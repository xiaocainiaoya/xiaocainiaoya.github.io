<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2023-07-17T03:12:59.421Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-statemachine入门</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-15T14:20:58.000Z</published>
    <updated>2023-07-17T03:12:59.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-statemachine入门"><a href="#spring-statemachine入门" class="headerlink" title="spring-statemachine入门"></a>spring-statemachine入门</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring-statemachine</code>是<code>spring</code>设计于处理状态的变化，以及定义状态之间的转换规则。</p><span id="more"></span><p><strong>状态机的基本组成</strong></p><p>状态机主要由4要素组成：</p><ul><li>现态：当前所处的状态。</li><li>条件：或者称为“事件”，在状态转换图中使用箭头标识，当满足某个条件（触发某个事件）之后，由一个状态转移到另一个状态。比如下图中“支付”这个箭头。</li><li>动作：表示由现态转换到次态之后，需要执行的动作，不是必须的，可以是转换转换后不执行任何动作。比如下图中从[待收货]转换到[已收货]是否设置某个动作。</li><li>次态：下一环状态。</li></ul><p>​    比如一个支付下单流程的状态转换图：</p><p><img src="https://s2.loli.net/2023/07/15/a71AErSKG2TLFNw.png" alt="状态装换图.png"></p><p>​    订单的开始状态为[待支付]，当用户支付之后状态流转为[已支付]，这个地方是个分支节点，当状态流转到[已支付]后，根据一些业务规则，将状态流转到[待收货]或者[待开票]，若是[待收货]，通过收货行为，使状态流转到[结束];若是[待开票]状态，通过投递行为，使状态流转到[结束]。</p><h2 id="Spring-stateMachine"><a href="#Spring-stateMachine" class="headerlink" title="Spring stateMachine"></a>Spring stateMachine</h2><p><code>Spring StateMachine</code>是一个基于 <code>Spring</code>框架的状态机框架，使用<code>Spring StateMachine</code>可以方便地在 <code>Java</code>应用中实现状态机功能，并可以与<code>Spring</code>框架的其他功能结合使用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><b>1.添加依赖</b></p><p>我这里使用的是<code>springboot</code>工程，最好先引入官方提供的<code>spring-statemachine-bom</code>，这样基本上不会出现与<code>spring framework</code>版本不对应，出现的一些无法解释的坑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>2.订单状态枚举类</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UNPAID(<span class="string">&quot;unpaid&quot;</span>,<span class="string">&quot;待支付&quot;</span>),</span><br><span class="line">    PAID(<span class="string">&quot;paid&quot;</span>,<span class="string">&quot;已支付&quot;</span>),</span><br><span class="line">    WAITING_FOR_RECEIVE(<span class="string">&quot;waitingForReceive&quot;</span>,<span class="string">&quot;待收货&quot;</span>),</span><br><span class="line">    DONE(<span class="string">&quot;done&quot;</span>,<span class="string">&quot;结束&quot;</span>),</span><br><span class="line">    INVOICE(<span class="string">&quot;invoice&quot;</span>, <span class="string">&quot;开票&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    StateEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StateEnum <span class="title">getByState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (StateEnum stateEnum : StateEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stateEnum.getType().equals(state)) &#123;</span><br><span class="line">                <span class="keyword">return</span> stateEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.事件枚举类</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EventEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PAY(<span class="string">&quot;pay&quot;</span>,<span class="string">&quot;支付&quot;</span>),</span><br><span class="line">    RECEIVE(<span class="string">&quot;receive&quot;</span>,<span class="string">&quot;收货&quot;</span>),</span><br><span class="line">    DELIVERY(<span class="string">&quot;delivery&quot;</span>,<span class="string">&quot;发货&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    EventEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.状态机配置</b></p><p>状态机配置类中包含状态配置、状态转换事件关系配置、监听器配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 这里最好手动设置name， 如果不设置, 默认使用stateMachineFactory这个名字, 由于这个类</span></span><br><span class="line"><span class="comment">// 需要注入到spring容器中, 如果需要创建两个不一样的状态机会出现重名的冲突。</span></span><br><span class="line"><span class="meta">@EnableStateMachineFactory(name = &quot;feeStateMachineFactory&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeeStateMachineConfig</span> <span class="keyword">extends</span> <span class="title">StateMachineConfigurerAdapter</span>&lt;<span class="title">StateEnum</span>, <span class="title">EventEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态: 初始状态、</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineStateConfigurer&lt;StateEnum, EventEnum&gt; states)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        states.withStates()</span><br><span class="line">                <span class="comment">// 初始状态</span></span><br><span class="line">                .initial(StateEnum.UNPAID)</span><br><span class="line">                <span class="comment">// 分支节点, 如果存在分支节点, 必须要在这里声明</span></span><br><span class="line">                .choice(StateEnum.PAID)</span><br><span class="line">                <span class="comment">// 状态的所有值</span></span><br><span class="line">                .states(EnumSet.allOf(StateEnum.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态机监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2023/7/14 16:04:34</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineConfigurationConfigurer&lt;StateEnum, EventEnum&gt; config)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        config.withConfiguration()</span><br><span class="line">                <span class="comment">// 设置全局监听器</span></span><br><span class="line">                .listener(listener())</span><br><span class="line">                <span class="comment">// 设置状态机的ID, 可以认为是状态机的名称，在通过StateMachineFactory.getStateMachine()需要通过这个名称获取</span></span><br><span class="line">                <span class="comment">// 在测试的过程中发现, 有些人写的文章里没有设置这个名称, 然后在使用StateMachineFactory.getStateMachine(machineId)</span></span><br><span class="line">                <span class="comment">// 中的machineId使用的是数据库中查出的订单ID, 这样的写法在不使用OnTransition相关监听注解是不会有问题，但是如果</span></span><br><span class="line">                <span class="comment">// 需要使用到@OnTransition相关注解就会导致无法进入到这个注解标记的方法中。</span></span><br><span class="line">                .machineId(<span class="string">&quot;stateMachine&quot;</span>)</span><br><span class="line">                .autoStartup(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态转换和事件的转换关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transitions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineTransitionConfigurer&lt;StateEnum, EventEnum&gt; transitions)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        transitions</span><br><span class="line">                .withExternal()</span><br><span class="line">                .source(StateEnum.UNPAID)</span><br><span class="line">                .target(StateEnum.PAID)</span><br><span class="line">                .event(EventEnum.PAY)</span><br><span class="line">                <span class="comment">// guard()守卫函数，状态转移后进入, 如果返回的是true, 才进入到action方法中。</span></span><br><span class="line">                .guard(<span class="keyword">new</span> Guard&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(StateContext&lt;StateEnum, EventEnum&gt; context)</span> </span>&#123;</span><br><span class="line">                        log.info(<span class="string">&quot;进入订单守卫函数&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.UNPAID.getValue(), StateEnum.PAID.getValue()))</span><br><span class="line">            .and()</span><br><span class="line">                .withExternal()</span><br><span class="line">                .source(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">                .target(StateEnum.DONE)</span><br><span class="line">                .event(EventEnum.RECEIVE)</span><br><span class="line">                .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.WAITING_FOR_RECEIVE.getValue(), StateEnum.DONE.getValue()))</span><br><span class="line">            .and()</span><br><span class="line">                <span class="comment">// 表示分支</span></span><br><span class="line">                .withChoice()</span><br><span class="line">                .source(StateEnum.PAID)</span><br><span class="line">                <span class="comment">// 类似于 if(first的第二个参数的方法如果是true)则进入到first第一个参数的状态，并进入first第三个参数的action</span></span><br><span class="line">                <span class="comment">// 如果first的第二个参数返回的是false，则进入到last的第一个参数状态，并进入到first第二个参数的atction</span></span><br><span class="line">                .first(StateEnum.INVOICE, ctx -&gt; (<span class="keyword">boolean</span>) Optional.ofNullable(ctx.getMessage().getHeaders().get(<span class="string">&quot;invoice&quot;</span>)).orElse(<span class="keyword">true</span>), ctx -&gt; log.info(<span class="string">&quot;进入发票分支&quot;</span>))</span><br><span class="line">                .last(StateEnum.WAITING_FOR_RECEIVE, ctx -&gt; log.info(<span class="string">&quot;进入收货分支&quot;</span>))</span><br><span class="line">            .and()</span><br><span class="line">                .withExternal()</span><br><span class="line">                .source(StateEnum.INVOICE)</span><br><span class="line">                .target(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">                .event(EventEnum.DELIVERY)</span><br><span class="line">                .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.INVOICE.getValue(), StateEnum.WAITING_FOR_RECEIVE.getValue()))</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StateMachineListener&lt;StateEnum, EventEnum&gt; <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StateMachineListenerAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当状态的转移在configure方法配置中时，会走到该方法。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;StateEnum, EventEnum&gt; transition)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;listener[&#123;&#125;]状态变更:&#123;&#125; -&gt; &#123;&#125;&quot;</span>, transition.getKind().name(),</span><br><span class="line">                    transition.getSource() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getSource().getId()),</span><br><span class="line">                    transition.getTarget() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getTarget().getId()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当发生的状态转移不在configure方法配置中时，会走到该方法，此处打印error日志，方便排查状态转移问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;EventEnum&gt; event)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;事件未收到: &#123;&#125;&quot;</span>, event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> Object <span class="title">ofNullableState</span><span class="params">(StateEnum s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.ofNullable(s)</span><br><span class="line">                    .map(StateEnum::getValue)</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>4.测试调用</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.sendEvent(MessageBuilder.withPayload(EventEnum.PAY)</span><br><span class="line">                    .setHeader(JSON_STR, JSON.toJSONString(feeOrder))</span><br><span class="line">                    .build())</span><br></pre></td></tr></table></figure><h3 id="使用注解方式配置监听器"><a href="#使用注解方式配置监听器" class="headerlink" title="使用注解方式配置监听器"></a>使用注解方式配置监听器</h3><p>​    前面说到，如果需要使用注解方式配置监听器，一定一定要注意<code>machineId</code>的赋值。因为可以通过多种方式来处理状态转移之后的监听，所以并不一定所有人在使用时都会使用这种方式，但是使用这种方式就是一定要注意<code>machineId</code>的赋值问题。(可以在定义配置时就设置<code>action</code>也可以达到状态转移后进入某个函数进行相关处理。)</p><p>​    <code>spring stateMachine</code>中设置的监听，这些监听都有设置对应的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateMachineListener</span>&lt;<span class="title">S</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(State&lt;S,E&gt; from, State&lt;S,E&gt; to)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateEntered</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateExited</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;E&gt; event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transitionStarted</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transitionEnded</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateMachineStarted</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateMachineStopped</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateMachineError</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine, Exception exception)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extendedStateChanged</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateContext</span><span class="params">(StateContext&lt;S, E&gt; stateContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过注解的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/7/15 09:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@WithStateMachine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnTransition(target = &quot;UNPAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@StatesOnTransition</span></span><br><span class="line">    <span class="meta">@OnTransition(source = &quot;UNPAID&quot;, target = &quot;PAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Message&lt;EventEnum&gt; obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取消息中的订单对象</span></span><br><span class="line">        <span class="comment">//Order order = (Order) message.getHeaders().get(&quot;order&quot;);</span></span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        <span class="comment">//order.setStates(States.WAITING_FOR_RECEIVE);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户支付完毕，状态机反馈信息：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>​    一般来说，我们的处理逻辑为从状态机工程中获取到一个状态机，但是不一定说每一台状态机都是从初始状态开始走，有可能订单目前处在某个状态，但是由于一些原因重启了服务，那么这是如果重新创建状态机那么状态需要从头开始走，这显然不符合逻辑，所以在获取到状态机之后，需要为这台状态机重新赋状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从状态机工厂获取一个状态机</span></span><br><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.stop();</span><br><span class="line">stateMachine.getStateMachineAccessor().doWithAllRegions(sma -&gt; &#123;</span><br><span class="line">    <span class="comment">//配置状态机拦截器，当状态发生转移时，会走到该拦截器中</span></span><br><span class="line">    sma.addStateMachineInterceptor(<span class="keyword">new</span> StateMachineInterceptorAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStateChange</span><span class="params">(State&lt;StateEnum, EventEnum&gt; state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Message&lt;EventEnum&gt; message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Transition&lt;StateEnum, EventEnum&gt; transition,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; stateMachine,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; rootStateMachine)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;preStateChange&quot;</span>);</span><br><span class="line">            FeeOrder result = JSON.parseObject(String.class.cast(message.getHeaders().get(JSON_STR)), FeeOrder.class);</span><br><span class="line">            <span class="comment">//更新状态机转移后的状态</span></span><br><span class="line">            result.setOrderStatus(state.getId().getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//将状态机的初始状态配置为DB中对应状态</span></span><br><span class="line">    sma.resetStateMachine(<span class="keyword">new</span> DefaultStateMachineContext&lt;&gt;(stateEnum, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;stateMachine&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动状态机</span></span><br><span class="line">stateMachine.start();</span><br></pre></td></tr></table></figure><p>​    尽管可以手动对状态机赋状态，但是这种方式也解决不了根本问题，以订单为例子，如果用户在发起创建订单之后，订单处在待支付状态，然后用户一直没有去支付，这时出现需要重启服务器的情况；或者如果部署了多个实例，某一台实例中状态机处在待支付状态，而用户去支付时请求走到了另一台服务器，这时在另一台服务器上状态走到了待开票，如果开票的请求又走到了原本处在待支付状态的服务器上呢？所以这里就变成必须与数据库中的订单状态实时校验？</p><p>所以这里引入的持久化。主要针对于故障恢复、可恢复性、长时间运行等情况。</p><p>持久化有多种方式，基于内存、基于<code>db</code>、基于<code>redis</code>、基于<code>MongoDB</code>等，这里以<code>redis</code>为例。</p><p><b>1.引入依赖</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>2.redis配置</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachinePersisterConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Redis持久化配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisStateMachinePersister&lt;StateEnum, EventEnum&gt; <span class="title">persister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt; repository</span><br><span class="line">            = <span class="keyword">new</span> RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt;(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisStateMachinePersister&lt;&gt;(<span class="keyword">new</span> RepositoryStateMachinePersist&lt;&gt;(repository));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.使用redis进行持久化</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sendEvent</span><span class="params">(Events changeEvent, Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      stateMachine.start();</span><br><span class="line">      <span class="comment">//尝试恢复状态机状态</span></span><br><span class="line">      stateMachineMemPersister.restore(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">      Message message = MessageBuilder.withPayload(changeEvent)</span><br><span class="line">              .setHeader(<span class="string">&quot;order&quot;</span>, order).build();</span><br><span class="line">      result = stateMachine.sendEvent(message);</span><br><span class="line">      <span class="comment">//持久化状态机状态</span></span><br><span class="line">      stateMachineMemPersister.persist(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;操作失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      stateMachine.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    <code>spring stateMachine</code>在简单实用之后感觉虽然在一定层度上对状态装换过程的代码编写风格进行了解耦，但是感觉由于<code>spring stateMachine</code>有点过于重量化，导致如果使用不当容易出现一些不可预判、出乎意料之外的问题。就比如之前提到的版本不对应监听注解失效的问题，在使用过程中它也不会报错，仅仅是始终无法进入到对应的注解中；还比如<code>choice</code>分支的问题、状态机不持久化带来的问题、若使用了持久化，持久化带来的问题等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring-statemachine入门&quot;&gt;&lt;a href=&quot;#spring-statemachine入门&quot; class=&quot;headerlink&quot; title=&quot;spring-statemachine入门&quot;&gt;&lt;/a&gt;spring-statemachine入门&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring-statemachine&lt;/code&gt;是&lt;code&gt;spring&lt;/code&gt;设计于处理状态的变化，以及定义状态之间的转换规则。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK9特性</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/</id>
    <published>2023-07-12T13:51:58.000Z</published>
    <updated>2023-07-12T02:38:17.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK9特性"><a href="#JDK9特性" class="headerlink" title="JDK9特性"></a>JDK9特性</h1><span id="more"></span><h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK9特性&quot;&gt;&lt;a href=&quot;#JDK9特性&quot; class=&quot;headerlink&quot; title=&quot;JDK9特性&quot;&gt;&lt;/a&gt;JDK9特性&lt;/h1&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Rancher入门（一）</title>
    <link href="http://xiaocainiaoya.github.io/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-06-12T13:51:58.000Z</published>
    <updated>2023-06-13T02:15:19.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rancher入门（一）"><a href="#Rancher入门（一）" class="headerlink" title="Rancher入门（一）"></a>Rancher入门（一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    公司内网的服务是通过<code>Rancher</code>进行编排，<code>Rancher</code>有<code>V1</code>和<code>V2</code>两个版本，都是提供容器调度与编排，在<code>V1</code>版本中可选不同的编排模式，比如<code>cattle</code>、<code>swarm</code>、<code>kubernetes</code>。所以<code>V1</code>时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于<code>k8s</code>后来发展势不可挡，所以<code>V2</code>版本诞生，移除了其他类型的编排工具，只剩下<code>k8s</code>，所以<code>Rancher</code>的底层是采用<code>k8s</code>编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个<code>k8s</code>集群等。</p><span id="more"></span><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>我这里是在<code>docker.hub</code>上搜索了一个<code>rancher/rancher</code>容器，直接在本机部署拉取这个容器。</p><blockquote><p>docker pull rancher/rancher</p></blockquote><p>启动这个容器：</p><blockquote><p> sudo docker run -d –restart=unless-stopped -p 80:80 -p 443:443 –privileged rancher/rancher</p></blockquote><ul><li><code>--restar</code>：表示指定容器的重启策略，可选值为<code>no</code>、<code>on-failure</code>、<code>always</code>、<code>unless-stopped</code><ul><li><code>no</code>：默认值，表示容器退出时，<code>docker</code>不自动重启容器</li><li><code>on-failure</code>：若容器的退出状态非0，则docker自动重启容器，还可以指定重启次数，若超过指定次数未能启动容器则放弃</li><li><code>always</code>：容器退出时总是重启</li><li><code>unless-stopped</code>：容器退出时总是重启，但不考虑<code>docker</code>守护进程启动时就已经停止的容器</li></ul></li><li><code>--privileged</code>：表示容器内的<code>root</code>拥有的权限，如果<code>=true</code>表示容器内的<code>root</code>拥有真正的<code>root</code>权限，否则容器内的<code>root</code>只是外部的一个普通用户权限，通过<code>--privileged</code>启动的容器，可以看到很多<code>host</code>宿主机上的设备，并且可以执行<code>mount</code>，甚至允许在这个容器中启动新的容器等等。(<code>rancher/rancher</code>这个镜像必须添加这个命令才可以启动)</li></ul><p>默认映射了<code>80</code>和<code>443</code>端口，通过<code>127.0.0.1:80</code>实际上是<code>127.0.0.1</code>就可以直接访问<code>rancher</code>。由于未使用授信证书，会有报警，忽略即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rancher入门（一）&quot;&gt;&lt;a href=&quot;#Rancher入门（一）&quot; class=&quot;headerlink&quot; title=&quot;Rancher入门（一）&quot;&gt;&lt;/a&gt;Rancher入门（一）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;​    公司内网的服务是通过&lt;code&gt;Rancher&lt;/code&gt;进行编排，&lt;code&gt;Rancher&lt;/code&gt;有&lt;code&gt;V1&lt;/code&gt;和&lt;code&gt;V2&lt;/code&gt;两个版本，都是提供容器调度与编排，在&lt;code&gt;V1&lt;/code&gt;版本中可选不同的编排模式，比如&lt;code&gt;cattle&lt;/code&gt;、&lt;code&gt;swarm&lt;/code&gt;、&lt;code&gt;kubernetes&lt;/code&gt;。所以&lt;code&gt;V1&lt;/code&gt;时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于&lt;code&gt;k8s&lt;/code&gt;后来发展势不可挡，所以&lt;code&gt;V2&lt;/code&gt;版本诞生，移除了其他类型的编排工具，只剩下&lt;code&gt;k8s&lt;/code&gt;，所以&lt;code&gt;Rancher&lt;/code&gt;的底层是采用&lt;code&gt;k8s&lt;/code&gt;编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个&lt;code&gt;k8s&lt;/code&gt;集群等。&lt;/p&gt;</summary>
    
    
    
    <category term="rancher" scheme="http://xiaocainiaoya.github.io/categories/rancher/"/>
    
    
    <category term="rancher" scheme="http://xiaocainiaoya.github.io/tags/rancher/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture任务编排</title>
    <link href="http://xiaocainiaoya.github.io/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
    <id>http://xiaocainiaoya.github.io/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/</id>
    <published>2023-06-02T13:51:58.000Z</published>
    <updated>2023-06-02T06:21:59.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture任务编排"><a href="#CompletableFuture任务编排" class="headerlink" title="CompletableFuture任务编排"></a>CompletableFuture任务编排</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    <code>CompletableFuture</code>是对<code>Future</code>的扩展，弥补了<code>Future</code>的局限性，同时又实现了对任务进行编排的能力。    </p><span id="more"></span><p>​    <code>CompletableFuture</code>实现于<code>Future</code>和<code>CompletionStage</code>，对于<code>Future</code>的扩展内容，都在<code>CompletionStage</code>接口中。在这个接口中定义了任务编排的方法，执行某个任务完成或者进行并行执行等操作的方法。</p><p><img src="https://s2.loli.net/2023/06/02/9GnaLSmQPoBFt3I.png" alt="CompletableFuture类图.png"></p><p>​    <code>CompletableFutrue</code>在对任务编排的基础上，结合<code>Futrue</code>的特性，做到可以将某个任务异步到其他线程执行，内部通过<code>Futrue</code>的阻塞相关接口来等待任务的完成，再执行编排的接下来任务。默认使用<code>ForkJoinPool</code>。</p><p><b>任务编排主要分为4大类</b></p><h3 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1.依赖关系"></a>1.依赖关系</h3><ul><li><code>thenApply()</code>：入参为以上一个任务的执行结果为入参的<code>Function</code>方法，也就是<code>thenApply()</code>中的<code>Function</code>方法的返回值是上一个任务执行结果的类型。</li><li><code>thenCompose()</code>：入参为以上一个任务的执行结果为<code>Function</code>方法的入参类型，以<code>CompletableFuture</code>为出参类型。也就是<code>thenCompose()</code>中的<code>Function</code>方法的返回值是<code>CompletableFuture</code>类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 结果转换，thenApply使用上一轮结果进行计算</span></span><br><span class="line">    <span class="comment">// thenApply 加不加async仅表示是否使用异步线程来完成任务(可指定线程池)</span></span><br><span class="line">    CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenApply(value -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenComposeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// thenCompose 与 thenApply 类似，但是thenCompose的返回值必须是CompletableFuture</span></span><br><span class="line">     <span class="comment">// thenCompose是将上一次计算的结果作为参数传进来，然后需要返回一个新的CompletableFuture</span></span><br><span class="line">     CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCompose(param -&gt; CompletableFuture.supplyAsync(() -&gt; param + <span class="string">&quot;d&quot;</span>));</span><br><span class="line">     System.out.println(result.join());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-合并关系"><a href="#2-合并关系" class="headerlink" title="2.合并关系"></a>2.合并关系</h3><p>合并A、B任务，当A、B任务完成之后执行C任务。</p><ul><li><code>thenCombine</code>：合并A、B任务，当A、B任务完成之后执行<code>thenCombine()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiFunction</code>方法，接收A、B任务的返回值作为入参，且有返回值。</li><li><code>thenAccepetBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>thenAccepetBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiConsumer</code>方法，接收A、B任务的返回值作为入参，且无返回值。</li><li><code>runAfterBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>runAfterBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>Runnable</code>，不接收参数，且无返回值。</li></ul><p>综上：其实三个方法的主要却别在于第二个参数所使用的的是<code>BiFunction</code>、<code>BiConsumer</code>、<code>Runnable</code>来控制是否需要接收前面任务的参数、是否需要有返回值。其他核心逻辑并无二至。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombineTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 联合</span></span><br><span class="line">     CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">1000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">         System.out.println(s1 + s2);</span><br><span class="line">         System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hij&quot;</span>;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.println(s1 + s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), () -&gt; &#123;</span><br><span class="line">        <span class="comment">//System.out.println(s1 + s2);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-并联关系"><a href="#3-并联关系" class="headerlink" title="3.并联关系"></a>3.并联关系</h3><p>A、B两个任务，只要有一个完成，就执行C任务。</p><ul><li><code>applyToEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>applyToEither()</code>的第二个参数是<code>Function</code>，表示使用前一个任务的返回值为入口参数，且有返回值。</li><li><code>acceptEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Consumer</code>，表示使用前一个任务的返回值为入口参数，无返回值。</li><li><code>runAfterEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Runnable</code>，表示AB任意一个任务完成后，就执行一个任务，这个任务无入参无返回值。</li></ul><p>综上：与<b>合并关系</b>其实差不多，三个方法上都是在对第二个函数式接口参数上做文章，主要为了用户在根据任务的参数需要和返回值需要选择特定的方法。</p><h3 id="4-并行关系"><a href="#4-并行关系" class="headerlink" title="4.并行关系"></a>4.并行关系</h3><p>多个任务时，多个任务都完成或者其中一个任务完成时，进行下一个任务的执行，返回的是新的<code>CompletableFuture</code>。</p><ul><li><code>allOf()</code>:当所有给定的<code>CompletableFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li><li><code>anyOf()</code>:当任何一个给定的<code>CompletablFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 只要有一个有结果就得到result, 但是存在一种情况，如果future1先完成，那么future2还是在执行，</span></span><br><span class="line">    <span class="comment">// 如果在future1执行完成后，future2执行完成前获取result的值，那么result的值就是future1的值</span></span><br><span class="line">    <span class="comment">// 获取值时如果都完成，那么由前往后取，也就是都完成的情况下，根据anyOf()方法参数定义的顺序获取。</span></span><br><span class="line">    CompletableFuture&lt;Object&gt; result = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 两个都完成了</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; result = CompletableFuture.allOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-结果处理"><a href="#5-结果处理" class="headerlink" title="5.结果处理"></a>5.结果处理</h3><p>当任务执行结束可以对任务执行的结果或者任务抛出的异常进行处理。</p><ul><li><p><code>whenComplete</code>:当任务完成时，将使用结果(或<code>null</code>)和此阶段的异常(或<code>null</code>)执行给定操作</p></li><li><p><code>exceptionally</code>:为了捕获任务中抛出的异常进行处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当某个任务完成之后，进行下一个任务</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="comment">// 上一个任务若有异常则这里的s=null, throwable=异常; 若正常执行完成则s=上一个任务的返回值, throwable=null</span></span><br><span class="line">    <span class="comment">// async表示使用可能会去使用其他线程如果使用同一线程池也可能被同一个线程执行</span></span><br><span class="line">    <span class="comment">// 不指定线程池的情况下使用的是ForkJoinPool.commonPool()</span></span><br><span class="line">    .whenComplete((s, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionallyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;).thenApply(result -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply接收到的参数 = &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常：&quot;</span> + throwable.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终返回的结果 = &quot;</span> + future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>​    在<code>CompletableFuture</code>中针对<b>每个方法</b>都定义了两个<code>xxxAsync</code>接口，以<code>whenComplete</code>方法为了，如下所示，两个<code>xxxAsync</code>接口的区别在于是否显示指定使用的线程池。如果不使用<code>xxxAsync</code>接口，则使用当前线程执行任务，如果使用<code>xxxAysnc</code>没有显示指定线程池，则使用默认的<code>ForkJoinPool</code>提供的线程池。但<code>ForkJoinPool</code>是公共线程池，如果所有的<code>CompletableFuture</code>都共享一个线程池，如果某一些任务执行较慢，会导致线程池中的所有线程阻塞，造成线程饥饿，从而影响整个系统的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在京东的开源框架<code>AsyncTool</code>，主要就是对<code>CompletableFuture</code>进行了组装和包装，使得任务的编排和回调在使用上变更更加方便。并对任务回调相关内容做了一个优化。比如在<code>CompletableFuture</code>中，如果你编排了多个任务，当前执行到那个任务，每一个任务的执行结果实际上是不知道的，只有等任务都执行完毕，最总汇总结果。<code>AysncTool</code>认为这种方式不是友好的，一个并行框架需要对每一步的执行有能进行监控，每一步无论执行成功与失败，都应该有一个回调，才算完整。比如在某些场景中，某些任务单元是需要被跳过不执行的，但是不执行的这个任务是不是也需要一个回调，进行类似于一些通知之类的动作？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CompletableFuture任务编排&quot;&gt;&lt;a href=&quot;#CompletableFuture任务编排&quot; class=&quot;headerlink&quot; title=&quot;CompletableFuture任务编排&quot;&gt;&lt;/a&gt;CompletableFuture任务编排&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;CompletableFuture&lt;/code&gt;是对&lt;code&gt;Future&lt;/code&gt;的扩展，弥补了&lt;code&gt;Future&lt;/code&gt;的局限性，同时又实现了对任务进行编排的能力。    &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>德鲁伊简单使用</title>
    <link href="http://xiaocainiaoya.github.io/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-11T14:13:58.000Z</published>
    <updated>2023-05-12T09:14:30.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="德鲁伊简单使用"><a href="#德鲁伊简单使用" class="headerlink" title="德鲁伊简单使用"></a>德鲁伊简单使用</h1><p>​    在翻阅项目底层代码时发现，在底层的<code>framework</code>模块中有引入<code>druid</code>监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下<code>druid</code>的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。</p><span id="more"></span><p><b>注：我使用的版本是<code>1.1.22</code>，如果不是这版本请绕道，避免引起不适，不同版本中修改了部分配置的前缀！！</b></p><h2 id="启用德鲁伊管理页"><a href="#启用德鲁伊管理页" class="headerlink" title="启用德鲁伊管理页"></a>启用德鲁伊管理页</h2><p>1.根据配置项加载这个管理页<code>bean</code>。前缀为<code>my.druid.monitor.enable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建德鲁伊数据源</span></span><br><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="title">druidServlet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-password:admin&#125;&quot;)</span> String password,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-username:admin&#125;&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.reset-enable:true&#125;&quot;)</span> String reset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.url-pattern:/druid/*&#125;&quot;)</span> String urlPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.allow:&#125;&quot;)</span> String allow,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.deny:&#125;&quot;)</span> String deny</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; reg = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">    reg.setServlet(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">    reg.addUrlMappings(urlPattern);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, reset);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, userName);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, password);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;allow&quot;</span>,deny );</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;deny&quot;</span>,allow);</span><br><span class="line">    <span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>yaml</code>或者<code>properties</code>配置文件中添加相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 忽略默认自动注入druid,避免走默认druid配置</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure</span></span><br><span class="line">  <span class="comment">#数据库连接池配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">        <span class="attr">allow:</span></span><br><span class="line">        <span class="attr">deny:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局druid参数，单独数据源配置为空取全局配置</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 声明默认的主数据源</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">druid:</span></span><br><span class="line">        <span class="comment"># 连接池的配置信息</span></span><br><span class="line">        <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">        <span class="attr">initial-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">        <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line">        <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">        <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">        <span class="attr">validation-query:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">        <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">        <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span></span><br></pre></td></tr></table></figure><p>到此在本地启动项目，访问<code>http://127.0.0.1:8064/xxxx/druid/login.html</code>进入管理页，登录之后，虽然进入了管理页，但是其实只是一个空壳，执行对应的<code>SQL</code>发现，并不会在监控页面上显示出来，后经过查询资料发现，这里的<code>filter</code>为空。</p><p><img src="https://s2.loli.net/2023/05/12/YQLoPJjbdrHqm3W.png" alt="druid中filter为空.png"></p><p>在配置文件中明明在<code>spring.datasource.druid.filters</code>设置了<code>stat,wall</code>等过滤器，但是实际上没有读到，排查发现，在<code>1.1.22</code>上，并不是这个配置，修改了配置前缀为<code>spring.datasource.druid.filter.stat.enabled</code></p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(FILTER_STAT_PREFIX)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = FILTER_STAT_PREFIX, name = &quot;enabled&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatFilter <span class="title">statFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 主要是为了创建这个filter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置后，在启动项目，在管理页上就显示出了执行的<code>SQL</code>语句。</p><h2 id="开发环境启用"><a href="#开发环境启用" class="headerlink" title="开发环境启用"></a>开发环境启用</h2><p>​    本以为到这里基本上已经万事大吉了，开发环境只需要复刻本地环境的配置即可。但是操作之后发现，在开发环境上访问<code>login.html</code>之后原本应该跳转到<code>druid/index.html</code>，但是<code>404</code>，看样子是<code>nginx</code>拦截处理了。</p><p>​    在<code>nginx</code>中，对于<code>/index.html</code>的路径直接转发到本地的某个文件夹中，所以修改<code>nginx.conf</code>相关配置信息，是的对<code>/druid/index.html</code>不进行这个拦截处理。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ (?!.*druid/index.html$).*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启<code>nginx</code>之后，发现还是有问题，观察发送的请求，在<code>login.html</code>提交表单之后，发起了一个<code>submitLogin</code>请求，如果用户名密码校验正确，会直接跳转到<code>druid/index.html</code>，但是这个<code>druid/index.html</code>的请求居然进行了<code>302</code>跳转，又跳回<code>druid/login.html</code>页面。通过和本地的工程发起的请求对比发现，在<code>submitLogin</code>登录之后会返回一个<code>JSESSIONID</code>的<code>cookies</code>，发起<code>druid/index.html</code>请求需要携带这个<code>cookies</code>值，但是在开发环境中不知道是<code>nginx</code>还是哪里给弄丢了，由于时间紧迫我没有细看在那个环节丢调了这个<code>cookies</code>值，我手动将这个<code>cookies</code>值打入浏览器的<code>cookies</code>中，正常访问。</p><h2 id="关闭广告"><a href="#关闭广告" class="headerlink" title="关闭广告"></a>关闭广告</h2><p>​    在开源项目若依中看到，感觉挺好玩的，便记录一下，用过<code>druid</code>管理页都知道，在面板的最下方有一个阿里的横幅广告，这个广告是请求服务器的<code>common.js</code>中会添加到页脚，请求公网的<code>banner</code>连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildFooter : function() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;&lt;a href=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner_click&quot; target=&quot;new&quot;&gt;&lt;img src=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner&quot;&gt;&lt;/a&gt;&lt;br/&gt;&#x27;</span> +</span><br><span class="line">              <span class="string">&#x27; powered by &lt;a href=&quot;https://github.com/alibaba/&quot; target=&quot;_blank&quot;&gt;Alibaba&lt;/a&gt; &amp; sandzhang &amp; &lt;a href=&quot;http://melin.iteye.com/&quot; target=&quot;_blank&quot;&gt;melin&lt;/a&gt; &amp; &lt;a href=&quot;https://github.com/shrekwang&quot; target=&quot;_blank&quot;&gt;shrek.wang&lt;/a&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br><span class="line">    $(document.body).append(html);</span><br></pre></td></tr></table></figure><p>​    所以思路上，通过对获取<code>common.js</code>进行拦截，并将这段页脚的<code>html</code>代码重写，即可达到关闭广告的目的。</p><p>1.设置一个过滤器，对<code>js/common.js</code>的请求进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DruidAdRemoveFilter 过滤器，过滤 common.js 的广告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; <span class="title">druidAdRemoveFilterFilter</span><span class="params">(DruidStatProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 druid web 监控页面的参数</span></span><br><span class="line">        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();</span><br><span class="line">        <span class="comment">// 提取 common.js 的配置路径</span></span><br><span class="line">        String pattern = config.getUrlPattern() != <span class="keyword">null</span> ? config.getUrlPattern() : <span class="string">&quot;/druid/*&quot;</span>;</span><br><span class="line">        String commonJsPattern = pattern.replaceAll(<span class="string">&quot;\\*&quot;</span>, <span class="string">&quot;js/common.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 DruidAdRemoveFilter Bean</span></span><br><span class="line">        FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; registrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> DruidAdRemoveFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.拦截过滤器中替换这段<code>html</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidAdRemoveFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * common.js 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_JS_ILE_PATH = <span class="string">&quot;support/http/resources/js/common.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="comment">// 重置缓冲区，响应头不会被重置</span></span><br><span class="line">        response.resetBuffer();</span><br><span class="line">        <span class="comment">// 获取 common.js</span></span><br><span class="line">        String text = Utils.readFromResource(COMMON_JS_ILE_PATH);</span><br><span class="line">        <span class="comment">// 正则替换 banner, 除去底部的广告信息</span></span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;&lt;a.*?banner\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;powered.*?shrek.wang&lt;/a&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        response.getWriter().write(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>替换之后的<code>html</code>变量值为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;&#x27;</span> +</span><br><span class="line">                      <span class="string">&#x27; &#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;德鲁伊简单使用&quot;&gt;&lt;a href=&quot;#德鲁伊简单使用&quot; class=&quot;headerlink&quot; title=&quot;德鲁伊简单使用&quot;&gt;&lt;/a&gt;德鲁伊简单使用&lt;/h1&gt;&lt;p&gt;​    在翻阅项目底层代码时发现，在底层的&lt;code&gt;framework&lt;/code&gt;模块中有引入&lt;code&gt;druid&lt;/code&gt;监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下&lt;code&gt;druid&lt;/code&gt;的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="druid" scheme="http://xiaocainiaoya.github.io/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>redis序列化配置</title>
    <link href="http://xiaocainiaoya.github.io/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://xiaocainiaoya.github.io/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-05T12:50:58.000Z</published>
    <updated>2023-05-05T08:42:19.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis序列化配置"><a href="#redis序列化配置" class="headerlink" title="redis序列化配置"></a>redis序列化配置</h1><blockquote><p>使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。</p></blockquote><span id="more"></span><h2 id="模板类RedisTemplate"><a href="#模板类RedisTemplate" class="headerlink" title="模板类RedisTemplate"></a>模板类RedisTemplate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplate</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">RedisAccessor</span> <span class="keyword">implements</span> <span class="title">RedisOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableTransactionSupport = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> exposeConnection = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableDefaultSerializer = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ClassLoader classLoader;</span><br><span class="line"><span class="comment">//序列化器</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> RedisSerializer&lt;String&gt; stringSerializer = RedisSerializer.string();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ScriptExecutor&lt;K&gt; scriptExecutor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常用数据结构操作类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ValueOperations&lt;K, V&gt; valueOps = <span class="keyword">new</span> DefaultValueOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListOperations&lt;K, V&gt; listOps = <span class="keyword">new</span> DefaultListOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SetOperations&lt;K, V&gt; setOps = <span class="keyword">new</span> DefaultSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StreamOperations&lt;K, ?, ?&gt; streamOps = <span class="keyword">new</span> DefaultStreamOperations&lt;&gt;(<span class="keyword">this</span>,</span><br><span class="line">ObjectHashMapper.getSharedInstance());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ZSetOperations&lt;K, V&gt; zSetOps = <span class="keyword">new</span> DefaultZSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GeoOperations&lt;K, V&gt; geoOps = <span class="keyword">new</span> DefaultGeoOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HyperLogLogOperations&lt;K, V&gt; hllOps = <span class="keyword">new</span> DefaultHyperLogLogOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClusterOperations&lt;K, V&gt; clusterOps = <span class="keyword">new</span> DefaultClusterOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有5个序列化器：</p><ul><li><code>keySerializer</code>：对存入<code>redis</code>中的<code>key</code>的序列化器</li><li><code>valueSerializer</code>：对存入<code>redis</code>中的<code>value</code>的序列化器</li><li><code>hashKeySerializer</code>：对以<code>hash</code>结构数据存入的<code>hashkey</code>序列化器</li><li><code>hashValueSerializer</code>：对以<code>hash</code>结构数据存入的<code>hashvalue</code>序列化器</li><li><code>stringSerializer</code>：字符串方式序列化器</li></ul><p>序列化器具体的实现：</p><ol><li><code>FastJsonRedisSerializer</code>由阿里巴巴的<code>fastjson</code>提供的转为<code>JSON</code>格式进行序列化。</li><li><code>Jackson2JsonRedisSerializer</code>在<code>spring</code>中已经集成，采用<code>Jackson</code>的方式转换为<code>JSON</code>格式进行序列化。</li><li><code>JdkSerializationRedisSerializer</code>jdk默认提供的序列化方式，如果是<code>POJO</code>需要实现<code>Serializable</code>接口。</li><li><code>StringRedisSerializer</code>字符方式序列化，如果是<code>POJO</code>，相当于调用了<code>toString</code>进行序列化。</li></ol><p><b>默认情况下使用的是<code>jdk</code>方式进行键和值的序列化，如果需要修改默认方式，在接入<code>spring</code>的情况下需要设置这些序列化器之后添加到<code>spring</code>容器中。你可以仅仅修改你想要修改的序列化器，其他的保持默认，模板类提供了一个后置接口。</b></p><p>它会逐个进行判断处理，如果某个序列化器为空，则设置对应的默认序列化器。所以一般在设置完成之后会调用一次这个后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</span><br><span class="line">classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableDefaultSerializer) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">keySerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">valueSerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">hashKeySerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">hashValueSerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h2><p>对<code>RedisTemplate</code>进行配置，设置<code>value</code>的序列化器为<code>jdk</code>提供的序列化器，<b><code>POJO</code>需要实现<code>Serializable</code>接口。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用jdk序列化方式进行序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式进行序列化之后，在<code>redis-cli</code>上查看时，默认获取的值会被转换为<b>十六进制</b>，导致在排查问题时可读性较差。</p><blockquote><p>\xAC\xED\x00\x05sr\x00\x1Ecn.com.xiaocainiaoya.vo.Person\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x04L\x00\x03aget\x00\x13Ljava/lang/Integer;L\x00\x06housest\x00\x10Ljava/util/List;L\x00\x08passwordt\x00\x12Ljava/lang/String;L\x00\x08userNameq\x00<del>\x00\x03xpsr\x00\x11java.lang.Integer\x12\xE2\xA0\xA4\xF7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xAC\x95\x1D\x0B\x94\xE0\x8B\x02\x00\x00xp\x00\x00\x00\x0Csr\x00\x13java.util.ArrayListx\x81\xD2\x1D\x99\xC7a\x9D\x03\x00\x01I\x00\x04sizexp\x00\x00\x00\x01w\x04\x00\x00\x00\x01sr\x00\x1Dcn.com.xiaocainiaoya.vo.House\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x02L\x00\x07addressq\x00</del>\x00\x03L\x00\x04areat\x00\x16Ljava/math/BigDecimal;xpt\x00\x06\xE5\x8C\x97\xE4\xBA\xACsr\x00\x14java.math.BigDecimalT\xC7\x15W\xF9\x81(O\x03\x00\x02I\x00\x05scaleL\x00\x06intValt\x00\x16Ljava/math/BigInteger;xq\x00<del>\x00\x06\x00\x00\x00\x01sr\x00\x14java.math.BigInteger\x8C\xFC\x9F\x1F\xA9;\xFB\x1D\x03\x00\x06I\x00\x08bitCountI\x00\x09bitLengthI\x00\x13firstNonzeroByteNumI\x00\x0ClowestSetBitI\x00\x06signum[\x00\x09magnitudet\x00\x02[Bxq\x00</del>\x00\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFE\x00\x00\x00\x01ur\x00\x02[B\xAC\xF3\x17\xF8\x06\x08T\xE0\x02\x00\x00xp\x00\x00\x00\x02\x03\xE9xxxt\x00\x03123t\x00\x03tom</p></blockquote><p>根据比对调用反序列化时的二进制流，发现这一串乱码中“\xAC”表示的十六进制，“\x05sr”中的“\x05”表示一个十六进制，“sr”需要按位解析为二进制，按这个逻辑进行解析之后，得到的结果就是反序列化字节流，所以根据这个逻辑就可以简单通过一段代码将这串乱码反序列化为原始对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String value = <span class="string">&quot;\\xAC\\xED\\x00\\x05t\\x00\\x18Pj/1x/ZLXkvm0q6bNZiOYw==&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] hexValues = value.split(<span class="string">&quot;\\\\x&quot;</span>);</span><br><span class="line">    <span class="comment">// 结果字节流长度，适当调整长度，如果类过大，可能长度不够会报数组长度越界</span></span><br><span class="line">    <span class="keyword">byte</span>[] resultValue = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> resultIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hexValues.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 切割之后可能出现首个或者末个是空串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isEmpty(hexValues[i]))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// AC/ED/00等表示为单个十六进制</span></span><br><span class="line">        <span class="keyword">if</span>(hexValues[i].length() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(hexValues[i], <span class="number">16</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 05t等认为前两位为十六进制，后面按字符逐个转换为字节</span></span><br><span class="line">            String str = hexValues[i];</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(str.substring(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 后面的按字符转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; str.length(); j++)&#123;</span><br><span class="line">                resultValue[resultIndex++] = (<span class="keyword">byte</span>) str.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对转换的字节流进行反序列化解析为对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> JdkSerializationRedisSerializer().deserialize(resultValue);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在排查问题时，可以尝试使用这种方式对乱码串进行解析，得到原始对象。(<b>前提是你的工程存在这个类！！</b>)</p><h2 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h2><p>字符序列化器，一般对于存入的<code>key</code>和非<code>POJO</code>都会采用这种方式进行序列化，在<code>redis-cli</code>上也能直观的看到对应的键和值是什么。</p><p>在<code>Spring</code>中已经提供了对键和值都采用字符序列化器的方式进行操作的模板类<code>StringRedisTemplate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setKeySerializer(RedisSerializer.string());</span><br><span class="line">setValueSerializer(RedisSerializer.string());</span><br><span class="line">setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> RedisSerializer&lt;String&gt; <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringRedisSerializer.UTF_8;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 设置为编码为UTF-8的字符序列化器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer UTF_8 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jackson2JsonRedisSerializer"><a href="#Jackson2JsonRedisSerializer" class="headerlink" title="Jackson2JsonRedisSerializer"></a>Jackson2JsonRedisSerializer</h2><p><code>jackson</code>机制进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>jackson</code>方式进行序列化之后的值，如下所示，对于复杂对象会表示它的类型，这种存储方式会导致占用的序列化串长度过长，占用一定的存储空间。</p><blockquote><p>[“cn.com.xiaocainiaoya.vo.Person”,{“userName”:”tom”,”password”:”123”,”age”:12,”houses”:[“java.util.ArrayList”,[[“cn.com.xiaocainiaoya.vo.House”,{“address”:”北京”,”area”:[“java.math.BigDecimal”,100.1]}]]]}]</p></blockquote><h2 id="FastJsonRedisSerializer"><a href="#FastJsonRedisSerializer" class="headerlink" title="FastJsonRedisSerializer"></a>FastJsonRedisSerializer</h2><p>阿里巴巴提供的<code>fastjson</code>序列化器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer = <span class="keyword">new</span> FastJsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        <span class="comment">// 全局开启AutoType，不建议使用</span></span><br><span class="line">        <span class="comment">// ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span></span><br><span class="line">        <span class="comment">// 建议使用这种方式，小范围指定白名单</span></span><br><span class="line">        <span class="comment">//ParserConfig.getGlobalInstance().addAccept(&quot;cn.com.xiaocainiao&quot;);</span></span><br><span class="line">        template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式生成的<code>JSON</code>串结果如下所示，对比<code>jackson</code>序列化器生成的结果串，发现复杂对象的所在类不会生成，减少一定的空间占用。</p><blockquote><p>{“age”:12,”houses”:[{“address”:”北京”,”area”:100.1}],”password”:”123”,”userName”:”tom”}</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis序列化配置&quot;&gt;&lt;a href=&quot;#redis序列化配置&quot; class=&quot;headerlink&quot; title=&quot;redis序列化配置&quot;&gt;&lt;/a&gt;redis序列化配置&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot部分功能浅析</title>
    <link href="http://xiaocainiaoya.github.io/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/</id>
    <published>2023-04-26T14:51:58.000Z</published>
    <updated>2023-04-28T02:10:47.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot部分功能浅析"><a href="#springboot部分功能浅析" class="headerlink" title="springboot部分功能浅析"></a>springboot部分功能浅析</h1><span id="more"></span><h2 id="1-绑定器"><a href="#1-绑定器" class="headerlink" title="1.绑定器"></a>1.绑定器</h2><p><code>org.springframework.boot.context.properties.bind.Binder</code>是<code>springboot</code>从<code>environment</code>对象中获取配置信息的绑定器，可以很方便的就获取到对应的配置值信息。</p><p>1.创建配置类(必须要提供<code>set</code>方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DtpProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.配置文件中的配置项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.dynamic.enabledBanner</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.dynamic.apollo.namespace</span>=<span class="string">aaa</span></span><br></pre></td></tr></table></figure><p>2.通过<code>Binder</code>获取配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binder.get(environment).bind(<span class="string">&quot;spring.dynamic&quot;</span>, Bindable.ofInstance(dtpProperties));</span><br></pre></td></tr></table></figure><h2 id="2-Import引入"><a href="#2-Import引入" class="headerlink" title="2.@Import引入"></a>2.@Import引入</h2><p>通过<code>@Import</code>引入将某些配置类或者扩展点接口添加到容器中。</p><p><b>示例：</b></p><p>1.创建一个注解<code>EnableMyConfig</code>，该注解使用<code>@Import</code>标记，并添加<code>MyConfigurationSelector.class</code>，这个类实现了<code>ImportSelector</code>顶层接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MyConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现<code>DeferredImportSelector#selectImports</code>接口，那么在<code>Spring</code>加载到这个引入类<code>MyConfigurationSelector</code>时就会将<code>MyBeanDefinitionRegistrar</code>类添加到<code>Spring</code>容器中，作用等同于为<code>MyBeanDefinitionRegistrar</code>添加<code>@Component</code>等自动注入注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;MyBeanDefinitionRegistrar.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.这个引入类一般以注册类居多，如果是配置类一般通过<code>@Component</code>或者<code>@Configuration</code>等注解就可自动注入，我这里的示例是一个注册类。实现于<code>ImportBeanDefinitionRegistrar</code>接口，<code>MyBeanDefinitionRegistrar</code>这个<code>spring</code>生命周期中会执行到<code>registerBeanDefinitions</code>，即为<code>MyProperties</code>类创建<code>BeanDefinition</code>对象，并将这个对象注入到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BeanDefinition对象构建器</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(DtpProperties.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注入属性键和属性值</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;enabledBanner&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里手动注册bean对象</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myProperties&quot;</span>, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：<code>@EnableMyConfig</code>注解需要标记到某个类上，且这个类在扫描范围之内才会生效，我曾经深深陷入于这个注解已经是在扫描范围之内，为什么需要标记到某个类上，扫描到这个注解后这个注解不是被<code>@Import</code>标记吗，难道不能直接获取到<code>@Import</code>中的值。实际上还是需要通过标记的这个类上拥有<code>@Component</code>等自动注入的注解。</b></p><p>整个过程大致为：由<code>Spring</code>容器MapperScan入口<code>refresh</code>方法 &rArr;执行容器中实现<code>BeanDefinitionRegistryPostProcessor</code>的<code>bean</code>对象&rArr;<code>ConfigurationClassPostProcessor</code>是对<code>BeanDefinitionRegistryPostProcessor</code>的实现，主要处理逻辑在这个类中。&rArr;之后会执行实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>，也就是这时会执行<code>MyBeanDefinitionRegistrar</code>这个自定义类，在这个自定义类中又注册了新的<code>BeanDefinition</code>&rArr;之后<code>Spring</code>容器会创建这个<code>Bean</code>对象。</p><p>综上：从<code>Spring</code>容器的角度来说，<code>MyBeanDefinitionRegistrar</code>是在<code>ConfigurationClassPostProcessor</code>执行时加载的，<code>MyProperties</code>是在<code>MyBeanDefinitionRegistrar</code>加载之后加载。</p><p>​    目前在<code>Spring</code>的生态中一般都是通过<code>@EnableXX</code>注解标记<code>@Import</code>注解来引入某些配置的方式，进行动态的引入某些配置类。比如<code>EnableScheduling</code>，只有将这个注解标记在扫描配置类之上，才会通过<code>@Import</code>引入配置<code>SchedulingConfiguration</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Import</code>也可以配合<code>ImportSelector</code>实现类，进行动态创建类。比如<code>MapperScan</code>。在<code>MapperScannerRegistrar</code>中动态的创建 <code>MapperScannerConfigurer</code>对象并注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置类加载"><a href="#3-配置类加载" class="headerlink" title="3.配置类加载"></a>3.配置类加载</h2><p><code>EnableConfigurationProperties</code>注解配合<code>ConfigurationProperties</code>注解进行使用。</p><p>假设说创建了一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个类没有标记<code>@Configuration</code>注解，那么这个容器中不会有这个类的<code>Bean</code>对象。</p><p>所以将此配置类添加到容器中有两种方式，一种是直接添加注入容器注解<code>@Configuration</code>。第二种是通过<code>@EnableConfigurationProperties</code>注解指向这个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRegistry <span class="title">myRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当加载<code>DtpBaseBeanConfiguration</code>这个类时，会读取到<code>EnableConfigurationProperties</code>注解，这里又是一个<code>@Import</code>的应用，引入了<code>EnableConfigurationPropertiesRegistrar</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnableConfigurationPropertiesRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">registerInfrastructureBeans(registry);</span><br><span class="line">registerMethodValidationExcludeFilter(registry);</span><br><span class="line">ConfigurationPropertiesBeanRegistrar beanRegistrar = <span class="keyword">new</span> ConfigurationPropertiesBeanRegistrar(registry);</span><br><span class="line">    <span class="comment">// 获取到指向的配置类(这里是MyProperties),这里会将MyProperties转换为</span></span><br><span class="line">    <span class="comment">// BeanDefinition对象注册到容器中, 等到根据BeanDefinition创建具体的bean</span></span><br><span class="line">    <span class="comment">// 对象的时候，会读取到ConfigurationProperties注解进行配置属性值的绑定</span></span><br><span class="line">getTypes(metadata).forEach(beanRegistrar::register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：这个<code>EnableConfigurationProperties</code>注解的作用仅仅是将某个配置类转换为<code>BeanDefinition</code>注册到<code>Spring</code>容器中，结合<code>@ConditionXXX</code>可以减少无用<code>bean</code>对象的创建。</b></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot部分功能浅析&quot;&gt;&lt;a href=&quot;#springboot部分功能浅析&quot; class=&quot;headerlink&quot; title=&quot;springboot部分功能浅析&quot;&gt;&lt;/a&gt;springboot部分功能浅析&lt;/h1&gt;</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>springboot的Spi机制</title>
    <link href="http://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/</id>
    <published>2023-04-10T14:51:58.000Z</published>
    <updated>2023-05-10T02:54:20.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot的Spi机制"><a href="#springboot的Spi机制" class="headerlink" title="springboot的Spi机制"></a>springboot的Spi机制</h1><p>​    在与<code>Springboot</code>打交道的过程中，应该大家对<code>starter</code>都不会陌生，<code>springboot</code>中的各种<code>starter</code>其实就是利用了<code>springboot</code>的<code>SPI</code>机制。</p><span id="more"></span><p>​    在<code>springboot</code>中，会默认扫描<code>Applicatoin</code>启用类及其子包里面的配置类<code>Bean</code>(比如标记<code>@Configuration</code>，<code>@Component</code>，<code>@Server</code>等)然后进行初始化，那么如果你是为别人提供二方包，三方包的库，如果你的需要加载的类路径跟他的不一样，那么根据<code>Springboot</code>的<code>bean</code>加载机制是不会加载到的。</p><p><b>主工程：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── Application.java</span><br></pre></td></tr></table></figure><p><b>二方库A：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure><p><b>二方库B：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure><p>这时只有<b>二方库A</b>可以正确加载<code>MybatisXmlReloadConfig</code>这个<code>bean</code>，因为它的路径在<b>主工程</b>的<code>Application</code>的包以及子包下，那么就出现所有的二方库、三方库都需要与主工程的类路径一致？</p><p>这里<code>Springboot</code>就提供了<code>Spi</code>的机制用来获取二方库，三方库中需要加载的<code>Bean</code>对象。</p><p><code>注意</code>：一定要确保二方库、三方库的类路径不在主工程<code>Application</code>下的情况，在考虑<code>SPI</code>逻辑，我之前就掉入一个陷阱，因为我的二方库的类路径与主工程一致，但是那个时候我的<code>spring.factories</code>指向的路径是错的，导致一度怀疑自己理解的<code>SPI</code>有出入。</p><p><b>二方库、三方库类路径与主工程启动类路径不一致的情况下！！！(再次强调！)</b>如果使得主工程可以加载到对应库中的<code>bean</code>对象。</p><ol><li><p>创建<code>META-INF/spring.factories</code>文件。这个文件中是<code>k-v</code>的结构，一个<code>key</code>对应多个逗号分隔的<code>value</code>。对于这个文件来说，可以配置的<code>key</code>有很多，比如有<code>EnableAutoConfiguration</code>，<code>ApplicationContextInitializer</code>，<code>ApplicationListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li><li><p>在主工程启动时，会加载<code>META-INF/spring.factories</code>文件，对这个文件内指向的<code>bean</code>对象进行逐个加载。</p></li></ol><p>主要源码在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：在<code>Springboot2.7</code>之后引入了新的<code>SPI</code>配置方式。</b></p><ol><li><p>创建<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件。这个文件的文件名是固定，文件内容是<code>value</code>，各个<code>value</code>之间通过回车分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bosssoft.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li></ol><p>主要源码同样是在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中进行了兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line"><span class="comment">// 兼容</span></span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="@AutoConfiguration"></a>@AutoConfiguration</h3><p>​    在<code>Springboot</code>中可以直接使用<code>@AutoConfiguration</code>来启用<code>SPI</code>机制，这是一个组合注解，通过<code>@AliasFor</code>注解将值传递给<code>@Configuration</code>、<code>@AutoConfigureBefore</code>、<code>@AutoConfigureAfter</code>三个注解。</p><p><b>注：使用这个注解需要配合<code>META-INF/spring</code>中设置<code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件中配置全限定类名。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = AutoConfigureBefore.class, attribute = &quot;value&quot;)</span></span><br><span class="line">Class&lt;?&gt;[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = AutoConfigureBefore.class, attribute = &quot;name&quot;)</span></span><br><span class="line">String[] beforeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = AutoConfigureAfter.class, attribute = &quot;value&quot;)</span></span><br><span class="line">Class&lt;?&gt;[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(annotation = AutoConfigureAfter.class, attribute = &quot;name&quot;)</span></span><br><span class="line">String[] afterName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cn.com.xiaocainiaoya.config.MyAutoConfiguration</span></span><br></pre></td></tr></table></figure><p><b>注：我之前进入一个误区，以为组合注解标记在某个类上就表明这个类拥有组合注解中的相关能力，其实这是错误的。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AutoConfiguration测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaocainiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/10 10:11:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AutoConfiguration()</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">house</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> House();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里我创建了类<code>MyAutoConfiguration</code>，标记了<code>@AutoConfiguration</code>注解，虽然这个注解是组合注解，也就是说实际上这个类也被<code>@AutoConfiguration</code>注解中的<code>@Configuration</code>标记，但是启动之后发现，在没有写<code>META-INF/spring</code>文件的情况下是不会加载，所以这里要解释一下，注解仅仅是标记了某个类，注解要起到什么作用取决于获取这个注解的动作的代码逻辑是如何。换句话说，标记了<code>@AutoConfiguration</code>实际上是可以具备<code>@Configuration</code>能力(不写<code>META-INF/spring</code>文件就可以被加载到容器中)，但是获取这个注解的处理端可以选择不赋予这种能力。<b>感觉还是没有说情况，文字表述不能很清楚的表达，上代码！</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当扫描到MyAutoConfiguration类需要进行容器化处理时肯定是需要进入某个处理器来进行处理</span></span><br><span class="line"><span class="comment">// 通过类对象来获取到对应标记的注解(这时其实只获取到@AutoConfiguration)</span></span><br><span class="line">Annotation[] annotations = MyAutoConfiguration.class.getAnnotations();</span><br><span class="line"><span class="comment">// 1.如果我的处理代码，仅仅是判断这个annotations中存不存在@Configuration来进行容器化，那么这个类就不会进行容器化。</span></span><br><span class="line"><span class="comment">// 2.如果我的处理代码，是如下代码，获取到当前类上的注解之后，逐个获取对应的组合注解中是否存在Configuration注解，再进行对应的处理，那么这个注解就会具备@Configuration的能力</span></span><br><span class="line"><span class="comment">// 所以在使用组合注解的情况下，主要是看处理注解的地方的判断方式，而不是组合注解上是否存在某注解！！</span></span><br><span class="line">Annotation[] annotations = MyAutoConfiguration.class.getAnnotations();</span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    Configuration configuration = annotation.annotationType().getAnnotation(Configuration.class);</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtils.isNotEmpty(configuration))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hutool中有提供方法可以快速获取组合注解中的注解</span></span><br><span class="line">Configuration[] candidates = AnnotationUtil.getCombinationAnnotations(field, Configuration.class);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot的Spi机制&quot;&gt;&lt;a href=&quot;#springboot的Spi机制&quot; class=&quot;headerlink&quot; title=&quot;springboot的Spi机制&quot;&gt;&lt;/a&gt;springboot的Spi机制&lt;/h1&gt;&lt;p&gt;​    在与&lt;code&gt;Springboot&lt;/code&gt;打交道的过程中，应该大家对&lt;code&gt;starter&lt;/code&gt;都不会陌生，&lt;code&gt;springboot&lt;/code&gt;中的各种&lt;code&gt;starter&lt;/code&gt;其实就是利用了&lt;code&gt;springboot&lt;/code&gt;的&lt;code&gt;SPI&lt;/code&gt;机制。&lt;/p&gt;</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用zip4j打包文件</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/</id>
    <published>2023-03-24T13:51:58.000Z</published>
    <updated>2023-03-27T09:37:54.099Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近接到需求需要为打包后的<code>zip</code>文件设置压缩密码，而我们之前使用的<code>ZipOutputStream</code>结合<code>hutool</code>的<code>NoiUtil</code>进行打包生成<code>zip</code>文件，但是<code>ZipOutputStream</code>没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问<code>chatGPT</code>)，它的回答是<code>Zip4j</code>。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Zip4j</code>是一个用于处理<code>ZIP</code>文件格式的<code>Java</code>库，它提供了一个易于使用的<code>API</code>，可以方便地创建、提取和修改<code>ZIP</code>文件，以及支持密码保护的ZIP文件。</p><p><code>Zip4j</code>的主要特点包括：</p><ol><li>支持标准<code>ZIP</code>文件格式以及<code>ZIP64</code>扩展格式，可以处理包含数百万文件的<code>ZIP</code>文件。</li><li>支持密码保护的<code>ZIP</code>文件，包括标准密码和<code>AES</code>加密密码。</li><li>支持<code>ZIP</code>文件的分卷（spanned）和自解压缩（self-extracting）功能。</li><li>支持<code>ZIP</code>文件的压缩级别、注释和<code>UTF-8</code>编码文件名等属性的设置。</li><li>提供了方便的<code>API</code>，可以方便地添加、提取和修改<code>ZIP</code>文件中的文件和文件夹，以及获取<code>ZIP</code>文件中的文件列表和属性信息。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我使用的是<code>2.1.6</code>版本，新版本对旧版本中的一些常量和接口有调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstDemo</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    List&lt;File&gt; fileToAdds = Arrays.asList(file1, file2);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    zipFile.addFiles(fileToAdds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    String filePath1 = <span class="string">&quot;/xxx/demo1.txt&quot;</span>;</span><br><span class="line">    String filePath2 = <span class="string">&quot;/xxx/demo2.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(filePath1);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(filePath2);</span><br><span class="line"></span><br><span class="line">    ZipDemo zipDemo = <span class="keyword">new</span> ZipDemo();</span><br><span class="line">    zipDemo.firstDemo(file1, file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>fileToAdds</code>列表打包为目标地址为<code>/xxx/result.zip</code>的压缩文件。这种写法是最简单的打包方式，将需要打包的源文件都打包在目标<code>zip</code>文件的顶层目录下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├─────── demo1.txt</span><br><span class="line">  └─────── demo2.txt</span><br></pre></td></tr></table></figure><p>但是有时候，甚至大部分时候都是需要将打包源文件进行分级(压缩包内文件夹)的方式进行打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├───── dir1</span><br><span class="line">  │       └─ demo1.txt</span><br><span class="line">  └───── demo2.txt</span><br></pre></td></tr></table></figure><p><b>1.设置目标<code>zip</code>文件内文件夹结构示例代码：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customInnerFilePath</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化压缩参数</span></span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 将设置的压缩参数作用在某个文件上</span></span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置文件夹加密：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptZip</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line">    zipParameters.setEncryptFiles(<span class="keyword">true</span>);</span><br><span class="line">    zipParameters.setEncryptionMethod(EncryptionMethod.AES);</span><br><span class="line">    zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：</b>上述代码中仅仅是对<code>file1</code>设置了<code>zipParameters</code>参数，也就是说现在有两个被打包文件，但是压缩参数只设置到了其中的一个文件上，打开压缩后的文件会发现，是需要解压密码才能解压，但是如果你有一些不需要解压可以查看<code>zip</code>包内部情况的工具可以发现，可以<code>file2</code>所对应的文件是无需密码就可以查看，也就是说，如果要对压缩包内所有文件在没有解压密码之前都不能访问，需要每个文件添加时设置<code>zipParameters</code>参数，设置为加密开启。</p><p><img src="https://s2.loli.net/2023/03/27/qbauo5fZCevzDUS.png" alt="zip文件内部分文件加密.png"></p><p>还有一点：踩过一个坑，由于我在打包文件的时候，可能出现某一个压缩包已经打包过了，但是业务上并不知道已经打包过了，所以会出现重复打包的情况，而我在针对重复打包的情况，会先将目标<code>zip</code>设置为一个空文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过java标准库中的方法，这时这个目标文件存在，但是内容被清除，结果是0B</span></span><br><span class="line">Files.newByteChannel(result, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE).close();</span><br></pre></td></tr></table></figure><p>但是这种情况下运行会报错：</p><blockquote><p>Zip file size less than minimum expected zip file size. Probably not a zip file or a corrupted zip file</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zip4jRaf.length() &lt; ENDHDR) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ZipException(<span class="string">&quot;Zip file size less than minimum expected zip file size. &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;Probably not a zip file or a corrupted zip file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思是目标文件是一个空文件，校验了目标文件头部的一个什么长度。没有细究这个问题，我的做法是改成直接删除旧文件，然后再生成文件。</p><p><b>3.打包分卷</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">zip</span><span class="params">(List&lt;String&gt; srcFiles, String destFile, <span class="keyword">long</span> fileSize)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(destFile);</span><br><span class="line">    List&lt;File&gt; filesToAdd = srcFiles.stream().map(File::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    ZipParameters parameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    parameters.setCompressionMethod(CompressionMethod.DEFLATE);</span><br><span class="line">    parameters.setCompressionLevel(CompressionLevel.NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未指定则设置为512KB</span></span><br><span class="line">    <span class="keyword">if</span>(fileSize==<span class="number">0</span>)&#123;</span><br><span class="line">        fileSize = <span class="number">65536</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置压缩分卷</span></span><br><span class="line">    zipFile.createSplitZipFile(filesToAdd, parameters, <span class="keyword">true</span>, fileSize);</span><br><span class="line">    <span class="keyword">return</span> zipFile.getSplitZipFiles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分卷生成的文件结构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标文件目录</span><br><span class="line">  ├─────── result.z01</span><br><span class="line">  └─────── result.z02</span><br></pre></td></tr></table></figure><p>这里会生成<code>.z</code>+<code>数字排列</code>的压缩包，要提取或打开这样的分卷<code>ZIP</code>文件，必须将所有的<code>ZIP</code>文件都放在同一个目录下。这种场景就可以用于大文件分卷为多个小文件后，传输小文件到目标地址。</p><p><b>4.提取</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> ZipException</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个ZipFile对象，用于打开要提取的ZIP文件</span></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置解压缩密码（如果需要）</span></span><br><span class="line">    <span class="keyword">if</span> (zipFile.isEncrypted()) &#123;</span><br><span class="line">        zipFile.setPassword(<span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.将所有文件都提取到当前目录下</span></span><br><span class="line">    zipFile.extractAll(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.仅提取一个文件</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;demo1.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.提取的这个文件不是在顶层目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/demo3.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.提取整个内部目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<code>Zip4j</code>是一个非常实用的<code>Java</code>库，可以帮助程序员方便地处理<code>ZIP</code>文件格式，节省大量的开发时间和工作量。还包含其他的一些，比如添加某个文件到<code>zip</code>文件中，修改<code>zip</code>中的某个文件等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近接到需求需要为打包后的&lt;code&gt;zip&lt;/code&gt;文件设置压缩密码，而我们之前使用的&lt;code&gt;ZipOutputStream&lt;/code&gt;结合&lt;code&gt;hutool&lt;/code&gt;的&lt;code&gt;NoiUtil&lt;/code&gt;进行打包生成&lt;code&gt;zip&lt;/code&gt;文件，但是&lt;code&gt;ZipOutputStream&lt;/code&gt;没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问&lt;code&gt;chatGPT&lt;/code&gt;)，它的回答是&lt;code&gt;Zip4j&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（六）---锁（第二弹）</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/</id>
    <published>2023-03-02T14:13:58.000Z</published>
    <updated>2023-03-03T07:31:25.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（六）—锁（第二弹）"><a href="#mysql45讲学习总结（六）—锁（第二弹）" class="headerlink" title="mysql45讲学习总结（六）—锁（第二弹）"></a>mysql45讲学习总结（六）—锁（第二弹）</h1><p>​    本篇主要为了记录间隙锁和<code>next-key lock</code>相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。</p><span id="more"></span><p>这里简单回顾一下：</p><p>表锁：如果查询条件中不包含索引字段，则是表锁。</p><p>行锁：行锁只能锁住行，跟行锁有冲突的是“另外一个行锁”</p><p>间隙锁：间隙锁是锁住两个值之间的空隙，跟间隙锁有冲突的是“往这个间隙插入一个记录”这个动作，所以某一个间隙可以被多个线程上间隙锁。</p><p><code>Next-Key Lock</code>是行锁和间隙锁的结合体。</p><p><b>无论任何锁的释放，都不是在执行完事务内的某条语句之后，是整个事务提交之后才会释放锁。</b></p><h2 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `USER_INFO` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_NAME` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`),</span><br><span class="line">  KEY `IDX_USER_ID` (`USER_ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br></pre></td></tr></table></figure><p>可以看到上面示例中有一张<code>USER_INFO</code>表，在<code>ID</code>上有主键索引，在<code>USER_ID</code>上有非唯一索引。这时有两个事务并发，事务1是删除，事务2是插入。</p><p><strong>分析一下上锁过程：</strong></p><p>因为<code>USER_ID</code>是有非唯一索引，那么对<code>USER_ID</code>索引上<code>Next-Key Lock</code>。(假设事务1比事务2快一点点到达)</p><ol><li>上锁的基本单位是<code>Next-Key Lock</code>，上<code>Next-Key Lock</code>为(前一个<code>USER_ID</code>, 10]，前开后闭。</li><li>由于<code>USER_ID</code>是非唯一索引，这时还需要向后扫描到第一个不等值才返回(不等于10)，但是由于目前这张表中的最大<code>USER_ID=10</code>，所以这时会变成<code>mysql</code>预设的最大值(+suprenum)。</li><li>所以最后锁的范围为(前一个formId， +suprenum)</li></ol><p><font color="red">在步骤2中，由于间隙锁需要锁住一个空间，但是在<code>USER_ID=10</code>之后没有其他数据，才会导致锁住了<code>USER_ID=10</code>之后的所有空间，这也不能理解，由于是非唯一索引，所以无法保证不会在<code>USER=10</code>之后再插入一条<code>USER_ID=10</code>的数据。</font></p><p>所以这个时候的事务2进来是就需要等待事务1提交事务之后才能进行数据插入。</p><p>可以自己通过脚本测试一下，验证结论是否正确。开两个<code>SQL</code>窗口，进行两个线程测试。</p><p>线程1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">-- 延迟 提交事务</span></span><br><span class="line"><span class="keyword">SELECT</span> sleep(<span class="number">10</span>) <span class="keyword">FROM</span> USER_INFO limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>线程2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h2 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h2><ol><li>原则1：加锁的基本单位就是<code>Next-Key Lock</code>，<code>Next-Key Lock</code>是前开后闭区间。</li><li>原则2：在加锁过程中访问到的对象(记录)才会被锁。</li><li>优化1：对唯一索引的等值查询，<code>Next-Key Lock</code>退化为行锁。</li><li>优化2：索引上的等值查询，从第一个满足等值条件的索引记录开始向右遍历到第一个不满足等值条件记录，并将第一个不满足等值条件记录上的<code>Next-Key Lock</code>退化为间隙锁</li></ol><p>下文通过这个脚本中的表和数据为例，进行加锁规则的一些解释。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这时对于主键索引来说，具有的值为<code>0、5、10、15、20、25</code>，以及7个间隙。</p><p><img src="https://s2.loli.net/2023/03/02/IqU9dRAu2c6VCYz.png" alt="间隙锁2.png"></p><h3 id="1-等值查询间隙锁"><a href="#1-等值查询间隙锁" class="headerlink" title="1.等值查询间隙锁"></a>1.等值查询间隙锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>update t set d=d+1 where id=7</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>Insert into t values(8, 8, 8)<br>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update set d=d+1 where id=10;<br/>(<font color='green'>Query OK</font>)</td><td>T3</td></tr></tbody></table><ol><li>在<code>T1</code>时刻，由于没有<code>id=7</code>这条记录，根据加锁规则，锁住<code>B</code>这个间隙，由于<code>Next-Key Lock</code>是前开后闭，所以锁住空间为<code>(5,10]</code></li><li><font color="red">若表中存在<code>id=7</code>这条记录，则根据优化1，锁住的仅仅为<code>id=7</code>这条记录。但是由于没有这条记录，故进入优化2的加锁规则。</font>根据优化2，等值查询<code>where id=7</code>向右遍历时，遇到的最后一个不满足等值条件的记录时，<code>Next-Key Lock</code>退化为间隙锁，所以<code>T1</code>时刻后最终加锁的范围为<code>(5,10)</code></li></ol><p>所以<code>T2</code>时刻的<code>SessionB</code>操作被阻塞，<code>T3</code>时刻的<code>SessionC</code>操作没有被阻塞。</p><h3 id="2-非唯一索引等值锁"><a href="#2-非唯一索引等值锁" class="headerlink" title="2.非唯一索引等值锁"></a>2.非唯一索引等值锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select id form t where c=5 lock in share mode;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where id=5;<br>(<font color='green'>Query OK</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(7, 7,7)<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li>根据原则1，加锁单位是<code>Next-Key Lock</code>,所以会给<code>(0,5]</code>上<code>Next-Key Lock</code>锁。</li><li>由于<code>c</code>是非唯一索引，当访问到<code>c=5</code>这条记录后不会停下来，会继续向后遍历，当遍历到<code>c=10</code>这条记录后停止，所以这时要对<code>(5,10]</code>上<code>Next-Key Lock</code>，但根据优化2，这时<code>Next-Key Lock</code>退化为间隙锁<code>(5,10)</code></li></ol><p>所以最终，在<code>T1</code>时刻，上锁的范围是<code>(0, 5]</code>的<code>Next-Key Lock</code>和<code>(5,10)</code>的间隙锁，故<code>T3</code>时刻，<code>SessionC</code>插入<code>c=7</code>的数据被阻塞。</p><p><font color="red">这里为什么<code>T2</code>时刻的<code>SessionB</code>执行成功？</font>这是因为加锁规则中的原则2，只有访问到的对象才会加锁，因为这条<code>SQL</code>采用的是索引覆盖，所以并不需要访问主键索引，所以也就没有对主键索引上锁，所以<code>sessionB</code>才会执行成功。</p><p><b>注意:<code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>不一样，<code>Mysql</code>这时认为接下来要更新数据，会顺便为主键索引上锁。</b>所以如果你要用<code>lock in share mode</code>来给行添加读锁避免数据被更新，就必须绕过覆盖索引的优化，在查询字段中添加索引中不存在的字段，让它必须进行一次回表。</p><h3 id="3-主键范围索引锁"><a href="#3-主键范围索引锁" class="headerlink" title="3.主键范围索引锁"></a>3.主键范围索引锁</h3><p>这两条<code>SQL</code>虽然在查询结果是一致的，但是它们的加锁规则不太一样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;=10 and id&lt;11 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(8, 8,8);<br>(<font color='green'>Query OK</font>)<br>insert into t values(13, 13,13);<br/>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update t set d=d+1 where id=15;<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li>开始执行时，从<code>id=10</code>开始查询，这里本来应该是<code>(5,10]</code>的<code>Next-Key Lock</code>，由于<code>id</code>是唯一索引，退化为行锁，这时只加了<code>id=10</code>这一行的行锁。</li><li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code>，这里要扫到<code>id=15</code>是正常的，只有扫到了这条记录，才会知道需不需要继续往后找。</li></ol><p><b>注意：</b><code>sessionA</code>的步骤一首次定位<code>id=10</code>是用等值查询来判断的，步骤二继续向右遍历用的是范围查询判断(范围查询并没有在两个优化中，所以这里的<code>(10, 15]</code>不会退化为间隙锁！！！这个要注意，优化只有在等值查询的时候才会发生，我在第一次看的时候当时也突然卡住，没有想明白为什么没有退化为间隙锁！)</p><h3 id="4-非唯一索引范围锁"><a href="#4-非唯一索引范围锁" class="headerlink" title="4.非唯一索引范围锁"></a>4.非唯一索引范围锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;=10 and c&lt;11 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(8, 8,8);<br>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update t set d=d+1 where c=15;<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><p>这个与案例3的区别在于通过字段<code>c</code>来进行查询，字段<code>c</code>是非唯一索引。</p><ol><li>根据<code>c=10</code>找到了<code>c=10</code>这条记录，所以添加对<code>(5,10]</code>添加<code>Next-Key Lock</code>，由于是非唯一索引，所以不会退化为间隙锁。</li><li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code></li></ol><p>综上：这里对索引<code>c</code>上了<code>(5,10]</code>和<code>(10, 15]</code>两个<code>Next-Key Lock</code>。</p><h3 id="5-唯一索引范围锁bug"><a href="#5-唯一索引范围锁bug" class="headerlink" title="5.唯一索引范围锁bug"></a>5.唯一索引范围锁bug</h3><p>在开头叙述的两个原则，两个优化的加锁原则之外，还有一个加锁<code>bug</code>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;10 and id&lt;=15 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where id=20;<br/>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(16, 16,16);<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><p><code>sessionA</code>是一个范围查询，根据原则1，这时为<code>(10,15]</code>上<code>Next-Key Lock</code>，并且<code>id</code>是唯一键，所以判断到<code>id=15</code>这一行就应该停止了，但实际上<code>InnoDB</code>会继续向后遍历到第一个不满足条件的行为止，也就是<code>id=20</code>这条记录，所以<code>(15,20]</code>也会上<code>Next-Key Lock</code>。所以这时<code>SessionB</code>和<code>SessionC</code>也会被锁住。</p><p>照理来说，扫描到<code>id=15</code>这行后，就可以不用继续往后查询了，但实际上<code>InnoDB</code>实际上还是这么做了。所以在<code>mysql 45讲</code>的作者认为这是一个<code>bug</code>。</p><h3 id="6-非唯一索引上存在等值的情况"><a href="#6-非唯一索引上存在等值的情况" class="headerlink" title="6.非唯一索引上存在等值的情况"></a>6.非唯一索引上存在等值的情况</h3><p>开头创建的表结构和数据中，没有存在索引<code>c</code>上有等值的数据，所以这里插入一条等值数据。</p><blockquote><p>insert into t values(30,10,30);</p></blockquote><p>执行之后，表中有两条<code>c=10</code>的数据。下图为索引<code>c</code>的间隙状态如下(上方是<code>c</code>，下方是主键)</p><p><img src="https://s2.loli.net/2023/03/02/FpGekvjcSrM7zCt.png" alt="非唯一索引间隙锁.png"></p><p>这时有两个<code>c=10</code>的记录，他们的主键<code>id</code>值不同（分别是<code>10</code>和<code>30</code>），但是这两个记录之间也是有间隙的。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>delete from t where c=10</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where c=15;<br/>(<font color='green'>Query OK</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(12, 12,12);<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li><code>sessionA</code>在遍历时先访问第一个<code>c=10</code>的记录，这时先对<code>(c=5,id=5)</code>到<code>(c=10,id=10)</code>这个<code>Next-Key Lock</code></li><li>继续向后遍历，直到碰到<code>(c=15,id=15)</code>这一行，遍历停止，根据优化2，这时一个等值查询，向右遍历第一个不满足条件的的行会退化为<code>(c=10,id=10) </code>到<code> (c=15,id=15)</code>的间隙锁。</li></ol><p>也就是说这个<code>delete</code>语句在索引<code>c</code>上的加锁范围就是下图中标记的区域，这里不包含两边的两条记录，是开区间，即<code> (c=5,id=5)</code> 和<code>(c=15,id=15)</code>这两行上都没有锁。<b>同时主键索引上锁(10,10,10) 和 (30,10,30) 两行,是行锁。</b></p><p><img src="https://s2.loli.net/2023/03/02/E5r6kSWTJDxpNQu.png" alt="非唯一索引间隙锁2.png"></p><h3 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h3><p>这个是对案例6的一个对照案例。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>delete from t where c=10 limit 2;</td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(12, 12, 12);<br/>(<font color='green'>Query OK</font>)</td><td>T2</td></tr></tbody></table><p>这个例子对比案例6的<code>sessionA</code>，仅在<code>delete</code>语句上加了<code>limit 2</code>，可能你会觉得数据库中<code>c=10</code>的记录只有两条，加不加<code>limit 2</code>删除的效果都是一样的，但是实际上加锁的访问有所不同。</p><p>这是因为，案例7的<code>delete</code>语句明确了<code>limit 2</code>的限制，因此在遍历到<code>(c=10, id=30)</code>这一行之后，就已经满足语句了，遍历就结束了。所以索引<code>c</code>的加锁范围就变成了<code>（c=5,id=5)</code>到<code>（c=10,id=30)</code>这个前开后闭区间。所以这时<code>T2</code>时刻的<code>sessionB</code>插入<code>c=12</code>是可以执行成功的。</p><p>所以这个例子对我们的实践是有指导意义的，<b>在删除数据的时候尽量加<code>limit</code>，</b>这样不仅可以控制删除的条数，也可以减少加锁的范围。</p><h3 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>select from t where c=10 lock in share mode;</td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where c=10;<br/>(<font color='green'>Query OK</font>)</td><td>T2</td></tr><tr><td>insert into t values(8, 8, 8)</td><td></td><td>T3</td></tr><tr><td></td><td>ERROR 1213:Deadlock found when trying to get lock; try restarting transaction</td><td>T4</td></tr></tbody></table><ol><li><code>session A </code>启动事务后执行查询语句加<code> lock in share mode</code>，在索引 <code>c </code>上加了<code> next-key lock(5,10]</code> 和间隙锁<code> (10,15)</code>；</li><li><code>session B </code>的<code> update</code> 语句也要在索引 <code>c </code>上加<code> next-key lock(5,10]</code> ，进入锁等待；</li><li>然后 <code>session A</code> 要再插入<code> (8,8,8)</code> 这一行，被<code>session B</code>的间隙锁锁住。由于出现了死锁，<code>InnoDB</code> 让 <code>session B </code>回滚。</li></ol><p>实际上步骤2中加<code>Next-Key Lock</code>是两步操作，分成间隙锁和行锁，在步骤2中加间隙锁是不会冲突，但是在加行锁的时候进入了等待，而T3时刻，<code>sessionA</code>插入数据需要等待<code>sessionB</code>释放间隙锁，所以出现了相互等待的情况，从而导致死锁。</p><p>虽然在分析<code>Next-Key Lock</code>表示间隙锁和行锁的结合，但是具体执行的时候要分为两段来执行。</p><h3 id="9-非唯一索引排序"><a href="#9-非唯一索引排序" class="headerlink" title="9.非唯一索引排序"></a>9.非唯一索引排序</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;=15 and c&lt;=20 order by c desc lock in share mode;</td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(6,6,6);<br/>(<font color='red'>blocked</font>)</td><td>T2</td></tr></tbody></table><ol><li>由于这里有<code>order by c desc</code>所以首先从<code>c=20</code>开始定位，所以首先加上间隙锁<code>(20, 25)</code>和<code>Next-Key Lock</code>锁<code>(15, 20]</code>。</li><li>在索引<code>c</code>向左遍历，需要扫描到<code>c=10</code>这条记录才会停止，所以<code>(5, 10]</code>。所以<code>sessionB</code>会阻塞。</li><li>在扫描的过程中，会对<code>c=10</code>，<code>c=15</code>，<code>c=20</code>这三行有数据，且查询字段是<code>select * </code>，需要进行回表，所以会在主键索引上上三个行锁。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（六）—锁（第二弹）&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（六）—锁（第二弹）&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（六）—锁（第二弹）&quot;&gt;&lt;/a&gt;mysql45讲学习总结（六）—锁（第二弹）&lt;/h1&gt;&lt;p&gt;​    本篇主要为了记录间隙锁和&lt;code&gt;next-key lock&lt;/code&gt;相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java的agent探针技术</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/02/java/java%E7%9A%84agent%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/02/java/java%E7%9A%84agent%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-02T13:51:58.000Z</published>
    <updated>2023-04-12T02:51:08.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java的agent探针技术"><a href="#java的agent探针技术" class="headerlink" title="java的agent探针技术"></a>java的agent探针技术</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>Java Agent</code>直译过来就是<code>java</code>代理或者有的地方叫做<code>java</code>探针。这个<code>jar</code>包不能独立运行，需要依附于目标<code>JVM</code>进程中。主要作用是通过对<code>JVM</code>进程进行代理，可以在目标<code>JVM</code>运行过程中获取到对应虚拟机中相关参数。</p><span id="more"></span><p>​    主要应用场景为：热部署、<code>IDEA</code>的<code>DEBUG</code>调试功能，<code>Arthas</code>线上诊断工具、性能监控等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>java Agent</code>有两个入口，两个入口的执行时机有所不同，一个是在目标应用启动之前，一个是在目标应用运行过程中。</p><p><b>目标应用刚启动时：</b></p><p>​    通过在目标应用的启动参数中添加<code>-javaagent:xxx/xxx/xxxAgent.jar</code>的方式启动，在执行目标应用的<code>main</code>方法之前会进入到<code>xxxAgent.jar</code>的<code>premain()</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个方法都存在的情况下，会进入这个方法，不会进入单个参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ premain方法，有一个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ premain方法，有一个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：这种方式是在目标应用要执行<code>main</code>方法，之前进入这个<code>premain</code>方法，也就是说这时<code>jvm</code>虚拟机中并没有加载过多的类。由于这种加载逻辑，导致在基本上在类加载之后就无法修改字节码，所以这种方式存的灵活性存在一定的限制。</b></p><p><b>目标应用运行过程中：</b></p><p>​    通过中间程序动态附着到目标<code>JVM</code>中的方式启动，所以中间程序就可以做到动态化，也就是达到某个条件之后就附着。</p><p><code>agent.jar</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个方法都存在的情况下，会进入这个方法，不会进入单个参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ agentmain方法 有两个入参 ------ agentArgs:&quot;</span> + agentArgs + <span class="string">&quot; inst:&quot;</span> + inst.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ agentmain方法 有两个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BridgeProject</code>（中间程序）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException </span>&#123;</span><br><span class="line">    VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(VirtualMachineDescriptor vmDescriptor : VirtualMachine.list())&#123;</span><br><span class="line">        <span class="keyword">if</span>(vmDescriptor.displayName().contains(<span class="string">&quot;XxxBootstrap&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入附着jvm&quot;</span>);</span><br><span class="line">            vm = VirtualMachine.attach(vmDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm.loadAgent(<span class="string">&quot;xxx/xxx/agent.jar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说拥有<code>XxxBootstrap</code>启动类的目标应用当前正处在运行状态，然后启动中间程序<code>BridgeProject#main</code>方法，它会获取<code>XxxBootstrap</code>对应的虚拟机之后，将<code>agent.jar</code>附着到该虚拟机上，这时就会进入到<code>agent.jar</code>包中的<code>agentmain</code>方法，就可以动态的进行一些处理。</p><p><code>Arthas</code>就是使用<code>agentmain</code>这种方式，它在首次使用的时候是仅下载这个中间程序<code>curl -O https://arthas.aliyun.com/arthas-boot.jar</code>，当通过<code>java -jar arthas-boot.jar</code>命令启动这个<code>springboot</code>程序之后，它会罗列当前环境中的虚拟机（如果你开多个应用，会有多个虚拟机）。当你选中某个应用之后，它会校验<code>arthasHome=~/.arthas/lib/</code>这个目录是否有<code>agent.jar</code>包，如果没有它会去下载<code>agent.jar</code>包，当然它的逻辑会更复杂，它不单单只有<code>agent.jar</code>包。也就是说实际上通过<code>curl</code>下载的<code>arthas-boot.jar</code>实际上是对上述中间程序的一个封装，做一些外围非核心逻辑的处理，当选中某个应用时，再去下载核心<code>agent.jar</code>包，进行探针修改字节码相关逻辑处理。</p><p><b><code>Instrumentation</code>相关接口:</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加一个Class文件的转换器，该转换器用于改变class二进制流的数据，</span></span><br><span class="line"><span class="comment"> * 参数canRetransform设置是否允许重新转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addTransformer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载之前，重新定义class文件，ClassDefinition表示一个类新的定义，</span></span><br><span class="line"><span class="comment"> * 如果在类加载之后，需要用retransformClasses方法重新定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redefineClasses(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类加载之后，重新定义class。事实上，该方法update了一个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retransformClasses();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加jar文件到BootstrapClassLoader中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendToBootstrapClassLoaderSearch();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加jar文件到system class loader。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendToSystemClassLoaderSearch();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加载的所有类数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getAllLoadedClasses();</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="1-打包"><a href="#1-打包" class="headerlink" title="1.打包"></a>1.打包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span> <span class="comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 添加 mplementation-*和Specification-*配置项--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addDefaultSpecificationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultSpecificationEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--指定premain方法所在的类--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.com.xiaocainiaoya.Agent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--添加这个即可--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.com.xiaocainiaoya.Agent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>descriptorRef</code>这是会将<code>pom</code>中的依赖打入到<code>agent.jar</code>包中，所以是否启动这个要取决于你的探针中需要的类库在目标程序中是否存在。比如我的目标程序中不存在<code>directory-watcher</code>依赖，但是<code>agent.jar</code>是需要这个依赖，所以我这里使用<code>descriptorRef</code>将这个依赖也打入到最终的<code>agent.jar</code>包中，如果不希望部分依赖打入到<code>agent.jar</code>包中(如果主工程中也存在这个依赖，会出现冲突的情况)，需要在<code>pom.xml</code>的依赖项中添加<code>&lt;scope&gt;</code>标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-tool-jar工具"><a href="#2-tool-jar工具" class="headerlink" title="2.tool.jar工具"></a>2.tool.jar工具</h3><p>其中<code>VirtualMachine</code>是<code>JDK</code>工具包下的类，如果系统环境变量没有配置，需要自己在<code>Maven</code>中引入本地文件。一般采用方案二时，动态附着需要使用到这些类。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.sun&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">    &lt;systemPath&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/lib/tools.jar&lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-ClassFileTransformer"><a href="#3-ClassFileTransformer" class="headerlink" title="3.ClassFileTransformer"></a>3.ClassFileTransformer</h3><p>通过实现这个类<code>ClassFileTransformer</code>，然后通过<code>Instrumentation</code>添加到类转换器中，即可对类进行动态修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inst.addTransformer(<span class="keyword">new</span> ProfilingTransformer());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java的agent探针技术&quot;&gt;&lt;a href=&quot;#java的agent探针技术&quot; class=&quot;headerlink&quot; title=&quot;java的agent探针技术&quot;&gt;&lt;/a&gt;java的agent探针技术&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;Java Agent&lt;/code&gt;直译过来就是&lt;code&gt;java&lt;/code&gt;代理或者有的地方叫做&lt;code&gt;java&lt;/code&gt;探针。这个&lt;code&gt;jar&lt;/code&gt;包不能独立运行，需要依附于目标&lt;code&gt;JVM&lt;/code&gt;进程中。主要作用是通过对&lt;code&gt;JVM&lt;/code&gt;进程进行代理，可以在目标&lt;code&gt;JVM&lt;/code&gt;运行过程中获取到对应虚拟机中相关参数。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>mybatis的MetaObject反射工具类</title>
    <link href="http://xiaocainiaoya.github.io/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-12-05T12:51:58.000Z</published>
    <updated>2022-12-05T14:30:58.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis的MetaObject反射工具类"><a href="#mybatis的MetaObject反射工具类" class="headerlink" title="mybatis的MetaObject反射工具类"></a>mybatis的MetaObject反射工具类</h1><p>​    <code>MetaObject</code>是<code>mybatis</code>中用于处理反射相关的工具类，通过<code>MetaObject</code>就可以进行获取和设置对象值。</p><span id="more"></span><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><b>简单类型：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Blog对象</span></span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">  <span class="comment">// 使用默认配置创建一个MetaObject对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">  <span class="comment">// 直接为Blog的id属性赋值</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>复杂类型：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    <span class="comment">// 为Bolg中的对象赋值，如果对象为空，会通过该对象的构造函数创建一个空对象</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;author.name&quot;</span>, <span class="string">&quot;tommy&quot;</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>集合类型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    List&lt;Comment&gt; commentList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 尽管设置了数组长度为5，以下调用还是报错，原因是set(index, value)方法中有判断</span></span><br><span class="line">    <span class="comment">// 若 index &gt;= size 则报越界，而size只有add(value)方法会进行叠加</span></span><br><span class="line">    <span class="comment">//commentList.set(0,new Comment());</span></span><br><span class="line">    commentList.add(<span class="keyword">new</span> Comment());</span><br><span class="line">    <span class="comment">// 1.如果是Object对象，为空时会通过构造函数进行创建，但是集合不能自动创建</span></span><br><span class="line">    <span class="comment">// 2.setValue的底层是调用集合的List.set(index, value)方法，不是List.add方法，所以要注意数组越界</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments&quot;</span>, commentList);</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments[0]&quot;</span>, <span class="keyword">new</span> Comment());</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;comments[0].user.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要由<code>MetaObject</code>、<code>ObjectWrapper</code>、<code>MetaClass</code>、<code>Reflector</code>构成。</p><p><img src="https://s2.loli.net/2022/12/05/MQDxLNbn4OgvKRw.png" alt="MetaObject.png"></p><h3 id="1-MetaObject"><a href="#1-MetaObject" class="headerlink" title="1.MetaObject"></a>1.MetaObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line">    <span class="comment">// 包装对象，根据不同对象的不同类型进行包装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同对象的不同对象进行包装</span></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完<code>MetaObject</code>之后，从<code>MetaObject</code>调用的<code>setValue</code>、<code>getValue</code>等属性操作方法实际上都委派给了<code>ObjectWrapper</code>进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="comment">// 如果存在下一层表达式，则创建下一层MetaObject</span></span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">        MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 通过创建的下一层的MetaObject对象，再次调用getValue，进入递归</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在下一层表达式，通过wrapper对象进行反射获取值</span></span><br><span class="line">        <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ObjectWrapper"><a href="#2-ObjectWrapper" class="headerlink" title="2.ObjectWrapper"></a>2.ObjectWrapper</h3><p><code>ObjectWrapper</code>是顶层接口，定义了<code>wrapper</code>包装原始对象的处理接口，如果原始对象是<code>Bean</code>对象那么具体的获取属性等操作在<code>BeanWrapper</code>，如果原始对象是<code>Map</code>则通过<code>MapWrapper</code>进行实现具体的属性操作，同理<code>List</code>则通过<code>CollectionWrapper</code>进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line">    </span><br><span class="line">    String[] getGetterNames();</span><br><span class="line">    </span><br><span class="line">    String[] getSetterNames();</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getSetterType(String name);</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getGetterType(String name);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanWrapper</code>和<code>MapWrapper</code>是继承于抽象类<code>BaseWrapper</code>，由抽象类继承顶层接口<code>ObjectWrapper</code>。<code>CollectionWrapper</code>是直接继承于顶层接口。这是因为如果原始对象是集合，它仅有<code>add</code>和<code>addAll</code>操作，其他接口均抛异常。</p><p><b>在BeanWrapper中解析表达式为词法分析器后进行属性操作</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以set方法为例，通过PropertyTokenizer词法分析器，对比如“comment[0].user.id”进行解析</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object collection = resolveCollection(prop, object);</span><br><span class="line">    setCollectionValue(prop, collection, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setBeanProperty(prop, object, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到对象的set方法</span></span><br><span class="line">        Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">        Object[] params = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射赋值</span></span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>PropertyTokenizer：词法分析器</b>，实现迭代器接口，通过<code>next()</code>方法解析下一层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里以 comments[0].user.id为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前层的名字: comments</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 若是集合则为comments[0]，否则indexedName和name值一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">    <span class="comment">// 表示下标: 若不是集合或者Map，则为空</span></span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="comment">// 表示子表达式: user.id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-MetaClass"><a href="#3-MetaClass" class="headerlink" title="3.MetaClass"></a>3.MetaClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reflector reflector;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">      <span class="comment">// 通过这个反射工厂来创建一个反射器</span></span><br><span class="line">      <span class="keyword">this</span>.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectorFactory</code>这个反射工厂的主要作用是对<code>Reflector</code>反射器进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultReflectorFactory</span> <span class="keyword">implements</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> classCacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">        <span class="comment">// 如果缓存中存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Reflector"><a href="#4-Reflector" class="headerlink" title="4.Reflector"></a>4.Reflector</h3><p>根据创建的<code>Class</code>对象，解析出这个类的所有<code>get</code>、<code>set</code>方法，构造函数，所有属性字段等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">      type = clazz;</span><br><span class="line">      addDefaultConstructor(clazz);</span><br><span class="line">      addGetMethods(clazz);</span><br><span class="line">      addSetMethods(clazz);</span><br><span class="line">      addFields(clazz);</span><br><span class="line">      readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">      writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">      <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis的MetaObject反射工具类&quot;&gt;&lt;a href=&quot;#mybatis的MetaObject反射工具类&quot; class=&quot;headerlink&quot; title=&quot;mybatis的MetaObject反射工具类&quot;&gt;&lt;/a&gt;mybatis的MetaObject反射工具类&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;MetaObject&lt;/code&gt;是&lt;code&gt;mybatis&lt;/code&gt;中用于处理反射相关的工具类，通过&lt;code&gt;MetaObject&lt;/code&gt;就可以进行获取和设置对象值。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis执行器</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/</id>
    <published>2022-11-22T14:13:58.000Z</published>
    <updated>2022-11-28T02:50:00.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis执行器"><a href="#mybatis执行器" class="headerlink" title="mybatis执行器"></a>mybatis执行器</h1><span id="more"></span><p>在<code>mybatis</code>中包含四大件是指<strong>：executor, statementHandler,parameterHandler，resultHandler对象</strong>。</p><p>它们都是sqlSession的底层类实现，本篇的重点是了解一下<code>executor</code>执行器的作用和一些原理。</p><p>在<code>mybatis</code>中有三类执行器：</p><ul><li>简单执行器：<code>SimpleExecutor</code>，是执行器的默认实现，继承了<code>BaseExecutor</code>抽象类，利用<code>StatementHandler</code>完成。每次调用执行方法都会构建一个<code>StatementHandler</code>，并预设参数，然后执行。</li><li>可重用执行器：<code>ReuseExecutor</code>，可重复使用<code>JDBC</code>中<code>Statement</code>，减少预编译次数。该执行器在执行<code>SQL</code>时会把<code>Statement</code>缓存起来，如果下次碰到相同的SQL，就会取出来使用。</li><li>批处理执行器：<code>BatchExecutor</code>，每次的执行操作 不会立即提交到数据库，而是把对应的<code>Statement</code>对象填充好参数之后暂存起来。调用<code>doFlushStatements</code>的时候一次性提交到数据库，可用于批处理插入的场景。</li></ul><p><img src="https://s2.loli.net/2022/11/22/meG7dva9NcRCg8U.png" alt="执行器.png"></p><p>执行器的顶层接口为<code>Executor</code>，它定义了数据修改、数据查询、缓存维护等基本功能，还有一些辅助的API接口，比如提交事务、回滚事务等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单列几个接口，还有一些没列出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象接口<code>BaseExecutor</code>实现<code>Executor</code>并提供一些通用能力，比如有一级缓存，获取连接等。比如针对查询来说，它实现了顶层接口的<code>query</code>方法，并实现一级缓存的相关逻辑，若缓存查询不同，通过<code>doQuery</code>方法，下放给具体实现子类，也就是说，子类只需要实现具体的<code>doQuery</code>方法。</p><p>在<code>mybatis</code>中有三种执行器，分别为简单执行器、可重用执行器、批处理执行器。在这种结构下，若希望添加一级缓存应该如何处理？可以在<code>BaseExecutor</code>上层抽象一层接口，这个抽象接口实现二级缓存的逻辑。但是<code>mybatis</code>不采用这种方式，它通过装饰者模式，构建<code>CachingExecutor</code>类实现于<code>Executor</code>接口，并将<code>Executor</code>作为他的一个属性，当自身的二级缓存获取不到值时，调用<code>delegate</code>的同名方法，进入具体的执行器中。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p><img src="https://s2.loli.net/2022/11/23/tVWrlBgjGM7L21F.png" alt="一级缓存.png"></p><p>​    一级缓存实际上就是一个<code>HashMap</code>，根据一些相关的参数信息生成一个<code>key</code>，结果集为值的<code>hashMap</code>。它的<code>CacheKey</code>的主要参数为<code>statementID</code>，<code>SQL</code>，执行参数等，所以有时候尽管是一模一样的<code>SQL</code>也不会命中<code>mybatis</code>的一级缓存。</p><p>​    <code>mybatis</code>的代码是极其精简的，这是仅是使用<code>HashMap</code>来存储一级缓存的内容，它甚至都不使用<code>concurrentHashMap</code>，这是因为<code>SqlSession</code>本身就不是线程安全的，对于<code>SqlSession</code>来说他需要创建一个执行器，执行器对应于一条<code>statementID</code>，如果出现并发，两个线程获取同一个<code>SqlSession</code>，那么就有可能导致执行器中绑定的<code>statementId</code>不一致，导致得到一级缓存的返回类型值不一样，从而报错。并且<code>SqlSession</code>获取对应的<code>JDBCConnection</code>连接同时得到事务，如果两个线程获取同一个线程，那么就表示两个线程拥有同一个事务，所以<code>SqlSession</code>不是线程安全了，在<code>Spring</code>中通过很多的手段去保证并发情况下<code>SqlSession</code>的线程安全。</p><p>​    所以一级缓存是与会话相关，如果会话被关闭，那么一级缓存就失效。</p><p><img src="https://s2.loli.net/2022/11/23/B5TGkf1XstumUOF.png" alt="一级缓存执行流程.png"></p><p>​    由<code>mybatis</code>生成对应的<code>mapper</code>的动态代理，在执行对应的<code>SQL</code>方法时，开启一个<code>SqlSession</code>会话，通过会话和相关信息开启一个执行器，在执行器中先调用<code>BaseExecutor#query()</code>，具体的一级缓存逻辑就是在<code>query()</code>方法中，如果一级缓存中获取不到，调用执行器实现子类的<code>doQuery()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserMapper mapper = context.getBean(UserMapper.class);</span><br><span class="line">        User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看一段结合<code>Spring</code>之后的缓存问题，测试结果为<code>false</code>，说明一级缓存没有生效，这是由于<code>Spring</code>在每次执行具体的调用时都自动进行了事务的提交，也就是说每执行一次<code>selectById</code>就会开启一次会话。所以很多人会说在<code>Spring</code>集成了<code>mybatis</code>之后，<code>mybatis</code>的一级缓存失效了。</p><p>​    那么如果就是想在<code>Spring</code>中使用<code>mybatis</code>的一级缓存。可以通过手动开启事务的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpringTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    DataSourceTransactionManager transactionManager = (DataSourceTransactionManager)context.getBean(<span class="string">&quot;txManager&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动开启事务</span></span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line"></span><br><span class="line">    User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Spring</code>中对<code>Mapper</code>做了一些动态代理的处理，通过<code>getBean()</code>获取到的<code>UserMapper</code>对象实际上已经是被<code>Spring</code>动态代理过的对象，</p><p><img src="https://s2.loli.net/2022/11/23/jzn7olaNiGMetWy.png" alt="spring结合mybatis会话.png"></p><ul><li><code>Mapper</code>：是被<code>spring</code>修改过的动态代理对象，做一些<code>statementID</code>相关预处理等操作。</li><li><code>SqlSessionTemplate</code>：它实现了<code>SqlSession</code>接口，并将数据库的相关操作，比如<code>query</code>、<code>update</code>、<code>insert</code>转发给具体的<code>sqlSession</code>。而它的能力为拦截之后获取对应的<code>sqlSession</code>会话对象。</li><li><code>SqlSessionFactory</code>：去创建对应的事务、执行器，然后返回<code>DefaultSqlSession</code>对象。</li></ul><p>那么现在来看一些<code>spring</code>使得<code>mybatis</code>一级缓存没有生效的具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略一些代码..</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个SqlSessionHolder，这个是存储在ThreadLocal对象中</span></span><br><span class="line"><span class="comment">// 也就是说它是跟线程绑定，与事务和线程绑定的原理对应上  </span></span><br><span class="line">SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里获取对应的session</span></span><br><span class="line">SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在<code>sessionHolder</code>处如果获取到对应的<code>session</code>则直接返回，如果获取不到则创建一个新的<code>session</code>,所以这里实际上事务决定了会话，如果事务被提交，则事务被删除，也就导致<code> session</code>会话被删除，如果一个事务一直不提交，那么在这个事务内的所有数据库操作就会触发一级缓存的相关逻辑。  </p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>​    二级缓存也称作是应用级缓存，与一级缓存不同的是它的作用范围是整个应用，而且可以跨线程调用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。由于二级缓存的作用范围是整个应用，所以需要为二级缓存考虑溢出淘汰的机制，而一级缓存的生命周期是一个会话，所以并没有特别为一级缓存考虑淘汰机制。</p><p>​    <img src="https://s2.loli.net/2022/11/24/w7NDM1HQ8ceiSYC.png" alt="二级缓存功能.png"></p><ul><li>过期清理：清理一些存放时间过久的数据，设置一个有效期，对超过有效期的缓存进行清理。</li><li>线程安全：二级缓存是跨线程使用的，所以需要考虑到线程安全的问题。</li><li>命中率统计：根据命中率统计来给用户提供反馈，告诉用户某次查询是否命中了缓存。</li></ul><p><img src="https://s2.loli.net/2022/11/24/ynvgEjMatCF6hHx.png" alt="二级缓存设计结构.png"></p><p>通过装饰者模式结合责任链的方式来实现二级缓存。每一种类型的缓存都是单一职责，当做完自己本身需要做的事情之后，就将需要缓存的相关参数等信息传递给责任链的下一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      这是缓存的顶层接口，非常简单，它通过接口屏蔽了复杂的底层调用，在使用的过程中，只需要通过这个接口<code>Cache</code>进行相关缓存的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache cache = configuration.getCache(<span class="string">&quot;cn.com.xiaocainiaoya.mapper.UserMapper&quot;</span>);</span><br><span class="line">    User user = Mock.newUser();</span><br><span class="line">    cache.putObject(<span class="string">&quot;cacheTest&quot;</span>, user);<span class="comment">// 设置缓存</span></span><br><span class="line">    cache.getObject(<span class="string">&quot;cacheTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/24/96SgDRdh4eLoFVQ.png" alt="二级缓存.png"></p><p>1.<code>chcheEnabled</code>：全局缓存开关，只要这个参数配置了<code>false</code>，整个二级缓存就关闭。</p><p>2.<code>useCache</code>：表示当前的<code>statement</code>要不要使用缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flushCache</code>：在查询时，将整个二级缓存清空。注意是整个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(flushCache = Options.FlushCachePolicy.TRUE)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectByid2在没有配置flushCache的情况下，也是命中不了缓存的。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询1</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    UserMapper mapper1 = session1.getMapper(UserMapper.class);</span><br><span class="line">    mapper1.selectByid2(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// flush cache清空</span></span><br><span class="line">    User user = mapper1.selectByid(<span class="number">10</span>); <span class="comment">//清空了，提交</span></span><br><span class="line">    </span><br><span class="line">    session1.commit();</span><br><span class="line">    <span class="comment">// 查询2</span></span><br><span class="line">    SqlSession session2 = factory.openSession();</span><br><span class="line">    UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line">    User use2 = mapper2.selectByid2(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>&lt;cache/&gt;</code>或<code>@CacheNamespace</code>是标记在<code>xml</code>文件或者对应的<code>mapper</code>文件，默认都是使用全限定类名作为缓存的命名空间，如果两个文件同时标记时会报错。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">&lt;cache/&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>5.在第四点中说到，对应的<code>mapper</code>文件和<code>xml</code>不能同时标记，那么如果就是想共用，那么就需要使用到缓存空间引用。<code>&lt;cache-ref/&gt;</code>或<code>CacheNamespaceRef</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">&lt;cache-ref namespace=<span class="string">&quot;cn.com.xiaocainiao.UserMapper&quot;</span> /&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>由于二级缓存是跨线程使用，所以需要在事务提交之后的数据库操作，才能命中缓存。</p><p><img src="https://s2.loli.net/2022/11/24/23OhkEWzlsTXw6j.png" alt="二级缓存脏读.png"></p><p>每一个会话都有一个事务缓存管理器，暂存区的个数取决于访问了多少个<code>mapper</code>。下方的缓存空间就是对应的<code>mapper</code>的缓存命名空间。会话一旦关闭，它所对应的事务缓存管理器就会被清理，从而导致暂存区数据被清理。在数据的操作过程，都是先操作暂存区，只有在事务提交或者事务回滚之后才会将暂存区数据提交到对应的缓存空间。</p><p>![image-20221127115857163](/Users/jiangjiamin/Library/Application Support/typora-user-images/image-20221127115857163.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个简单的代码，debug下暂存区的结构</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存的执行流程：</p><p><img src="https://s2.loli.net/2022/11/24/I4Ysoi9WlELVMK8.png" alt="二级缓存执行流程.png"></p><p>根据上图可知：查询是直接查询缓存空间，其他操作是对暂存区数据进行操作，当进行<code>commit</code>操作时将暂存区的操作数据添加到缓存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionalCache#commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出需要填充到二级缓存空间的数据，遍历进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis执行器&quot;&gt;&lt;a href=&quot;#mybatis执行器&quot; class=&quot;headerlink&quot; title=&quot;mybatis执行器&quot;&gt;&lt;/a&gt;mybatis执行器&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis处理器</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-11-22T14:13:58.000Z</published>
    <updated>2022-12-05T11:50:44.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis处理器"><a href="#mybatis处理器" class="headerlink" title="mybatis处理器"></a>mybatis处理器</h1><span id="more"></span><h2 id="一、statementHandler"><a href="#一、statementHandler" class="headerlink" title="一、statementHandler"></a>一、statementHandler</h2><p>​    <code>JDBC</code>处理器，基于<code>JDBC</code>构建<code>Statement</code>并设置参数，然后去执行具体的<code>SQL</code>语句，每调用会话当中一次<code>SQL</code>，都会有与之相对应且唯一的<code>Statement</code>实例。</p><p><img src="https://s2.loli.net/2022/11/28/OsSeqNWphfcyRGt.png" alt="statementHandler.png"></p><p><code>StatementHandler</code>为顶层接口，为<code>Statement</code>处理器相关实现设置标准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写操作</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读操作</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读游标</span></span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 辅助接口：获取动态语句</span></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 辅助接口：获取参数解析器</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseStatementHandler</code>抽取了具体子类的公共部分，比如有设置超时时间、设置获取行数等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseStatementHandler#prepare</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// BaseStatementHandler的抽象方法，由具体的子类来实现</span></span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      <span class="comment">// 根据子类返回的statement对象，来进行超时时间、获取行数的设置</span></span><br><span class="line">      setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法，由具体的子类实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>本篇中没有特殊说明都是以<code>PreparedStatementHandler</code>为例。具体的子类需要实现这个方法，使用<code>Conection</code>对象生成对应的<code>statement</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreparedStatementHandler#instantiateStatement</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">      <span class="comment">// 基于jdbc的connection#prepareStatement方法来创建PreparedStatement</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>StatementHandler执行流程：</strong></p><p><img src="https://s2.loli.net/2022/11/28/rmSGMb6WdnNoyu4.png" alt="statementHandler执行过程.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleExecutor#doQuery</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 1.通过Configuration对象创建StatementHandler对象</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 2.预处理</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 3.最后执行，对于PreparedStatement来说就是调用它的execute()方法。</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.通过<code>Configuration</code>对象创建<code>StatementHandler</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RoutingStatementHandler导航类来根据需要不同类型的statement进行创建</span></span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoutingStatementHandler#new()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.预处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的预处理接口来创建一个Statement对象</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 这里会调用参数解析器DefaultPrepareterHander来对statement对象的参数值(会经过类型转换等操作)</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后执行，对于<code>PreparedStatement</code>来说就是调用它的<code>execute()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// PreparedStatement的execute()方法。</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 执行完语句之后，使用结果集处理器对结果进行javabean的映射</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>BaseStatementHandler</code>将具体的<code>StatementHandler</code>中编写了具体子类的共性部分，实际上是由它来进行具体的<code>JDBC</code>抽象，创建它需要执行器、参数解析器、结果集处理器、动态语句等的参与。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BoundSql boundSql;</span><br></pre></td></tr></table></figure><h2 id="二、ParamenterHandler"><a href="#二、ParamenterHandler" class="headerlink" title="二、ParamenterHandler"></a>二、ParamenterHandler</h2><p>参数名称解析器<code>ParamNameResolver</code>。</p><p><b>单个参数：</b>默认不做任何处理，除非设置了<code>@Param</code></p><p><b>多个参数：</b></p><ol><li>根据参数声明的顺序将参数转换为<code>param1</code>、<code>param2</code>…</li><li>通过<code>@Param</code>指定变量名称</li><li>基于反射转换成变量名，如果不支持则根据声明的顺序转换成<code>arg0</code>、<code>arg1</code>…</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个参数情况下：</span></span><br><span class="line"><span class="comment"> *    args的值直接为这个参数的值 &#123;0, &quot;arg0&quot;&#125;</span></span><br><span class="line"><span class="comment"> * 多参数情况下：</span></span><br><span class="line"><span class="comment"> *    如果在mapper中对字段标记了<span class="doctag">@Param</span>注解并设置了对应的字段名称，则names的值为 &#123;&#123;0, &quot;field1&quot;&#125;, &#123;1, &quot;field2&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    如果没有标记<span class="doctag">@Param</span>注解，则names的值为&#123;&#123;0, &quot;arg0&quot;&#125;, &#123;1, &quot;arg1&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    所以这里仅仅是将字段名称和具体的参数值进行对应成param，实际的解析参数名的参数，在上层调用端。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// names 是一个SortMap</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果没有@Param注解，并且参数个数为1，直接返回原值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 直接将args参数中的值添加到param中</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认还会为参数根据声明的顺序设置param1， param2 ...</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不存在同名的情况下，可能有人字段名直接命名成paramX。</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">            param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所以如果不出现同名的情况，假设mapper接口设置了两个参数，那么这里返回有两份参数，</span></span><br><span class="line">        <span class="comment">// 一份要么是根据@Param解析规则，或者反射参数(启动参数) -parameters ,或者默认的arg0, arg1</span></span><br><span class="line">        <span class="comment">// 一份是param1， param2...</span></span><br><span class="line">        <span class="comment">// 要注意arg是从0下标开始，param是从1下标开始</span></span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以根据返回<code>param</code>不同的类型，使用的方式也有所不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是单个参数，那么这里的#&#123;userId&#125;,写什么都行，#&#123;param1&#125;, #&#123;arg0&#125;都可，实际上</span></span><br><span class="line"><span class="comment">// 根据就不校验名称，直接复制了</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的#&#123;name&#125;也可以写成#&#123;param1&#125;， 但是注意不能写#&#123;arg0&#125;， 因为#&#123;arg0&#125;已经变成@param</span></span><br><span class="line"><span class="comment">// 注解中的名称</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where name=#&#123;name&#125; or age=#&#123;user.age&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByNameOrAge</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;user&quot;)</span> User user)</span></span>;</span><br></pre></td></tr></table></figure><p>结合前文提到的<code>StatementHandler</code>执行流程时序图中，在<b>预处理</b>阶段，会<font color="red">为PrearedStatement设置参数</font>，来具体看一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以SimpleExecutor为例, 在调用doUpdate或者是doQuery方法创建StatementHandler之后，都会进行设置参数。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 创建statement</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 为statement设置参数</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreparedStatementHandler#parameterize</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 进入参数解析器，为statement设置参数</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就进入到了<code>ParameterHandler</code>的<code>setParameters</code>中，为创建的<code>preparedStatement</code>设置具体的参数。先来看一下<code>ParameterHandler</code>的接口，<code>ParameterHandler</code>是<code>mybatis</code>中的参数处理器，负责为<code>PreparedStatement</code>的<code>SQL</code>语句参数动态赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">// 读取参数</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 用于对PreparedStatement的参数赋值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只有一个实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个parameterObject就是前面说到通过ParameterNameSolver解析之后的对象</span></span><br><span class="line"><span class="comment">// 如果是单个参数，就是具体的值</span></span><br><span class="line"><span class="comment">// 如果是多个参数就是一个map对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getParameterObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parameterObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  <span class="comment">// parameterMappings是对具体执行语句的映射，将将要执行的语句映射成ParamterMapping对象，</span></span><br><span class="line">  <span class="comment">// 将具体需要填充的参数#&#123;&#125;解析出来，形成参数列表</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数化sql就需要进行参数设置，遍历这个参数列表，将参数设置到PreparedStatement中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="comment">// ParameterMode.OUT 存储过程的参数模式</span></span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        <span class="comment">// 声明value，最后就是将这个值设置到PreparedStatement中</span></span><br><span class="line">        Object value; </span><br><span class="line">        <span class="comment">// 获取执行语句声明的#&#123;&#125;中的参数变量名称</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; </span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 多个参数会走到这里，将map对象，转换成MetaObject对象，就可以直接通过字段名称来获取具体的值  </span></span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从parameterMapping获取TypeHandler类型转换器对象</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        <span class="comment">// 从TypeHandler类型转换器中获取对应的数据库类型</span></span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TypeHandler.setParameter实际上最后会调用到PreParedStatement.set*()方法，为要执行的语句绑定参数值</span></span><br><span class="line">          <span class="comment">// 比如说TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setBigDecimal(i, parameter);</span></span><br><span class="line">          <span class="comment">// TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setByte(i, parameter);</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>debugger</code>了解一下<code>ParameterMapping</code>中的内容： 主要是将<code>mybatis</code>在<code>SQL</code>或者是在实体上设置的一些配置进行映射，包含有字段名称、<code>javaType</code>数据类型、<code>jdbcType</code>数据库类型，<code>typeHandler</code>类型处理器等。</p><p><img src="https://s2.loli.net/2022/12/05/VkmnT5IjZgsGvP9.png" alt="parameterMapping.png"></p><h2 id="三、ResultHandler"><a href="#三、ResultHandler" class="headerlink" title="三、ResultHandler"></a>三、ResultHandler</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis处理器&quot;&gt;&lt;a href=&quot;#mybatis处理器&quot; class=&quot;headerlink&quot; title=&quot;mybatis处理器&quot;&gt;&lt;/a&gt;mybatis处理器&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis控制部分字段不打印</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/</id>
    <published>2022-11-13T14:13:58.000Z</published>
    <updated>2022-11-14T01:39:24.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis控制部分字段不打印"><a href="#mybatis控制部分字段不打印" class="headerlink" title="mybatis控制部分字段不打印"></a>mybatis控制部分字段不打印</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在<code>MySQL</code>的一些执行打印了<code>text</code>等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭<code>mybatis</code>的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为<code>text</code>等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。</p><span id="more"></span>    <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    具体的<code>mybatis</code>的几个核心组件执行流程这里不过多介绍，这里仅简单说明一条<code>SQL</code>的执行，是要先经过参数解析器，将具体的参数和数据类型解析处理，而后通过执行器，通过<code>Statement</code>或者是<code>PrepareStatement</code>等进行执行之后，再由结果集处理器进行结果映射相关逻辑。</p><p>​    在跟踪了一下<code>mybatis</code>的执行代码之后发现，日志的打印逻辑是在执行器<code>Executor</code>中，而数据类型相关的处理是在参数解析器中，也就是说如果想做到部分字段不打印，就需要在执行器中修改打印的逻辑。</p><p>我这边测试的是通过<code>PreparedStatement</code>方式进行插入数据，处理打印的类是<code>PreparedStatementLogger</code>的<code>invoke</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 打印数据在这里</span></span><br><span class="line">        debug(<span class="string">&quot;Parameters: &quot;</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... 省略很多无效代码</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用父类<code>BaseJdbcLogger</code>的<code>getParameterValueString</code>方法获取要打印的数据。可以看到这里就是直接将<code>columnValues</code>列表中的值进行拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">  <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      typeList.add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      typeList.add(objectValueString(value) + <span class="string">&quot;(&quot;</span> + value.getClass().getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">  <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，由于这个地方并没有提供扩展点，所以如果我想要打印的时候忽略某些类型的字段，我需要重写这个类，再有我需要在这里能获取到对应的数据类型，尝试之后发现，这个对象中主要是有一个<code>Map</code>对象，键是序号（填充最后执行<code>SQL</code>的序号），值就是对应要填充<code>SQL</code>的值。所以单纯的重写这个类型，获取不到对应的类型，也就无法进行类型的判断，所以需要外层这个类的地方，将执行<code>SQL</code>的类型信息传进来。</p><p><b>类型相关信息是解析到了<code>BoundSql</code>对象中。所以需要想方设法的将<code>BoundSql</code>对象传进来</b>，这个<code>PreparedStatementLogger</code>的创建和被调用并不是在同一个时间节点，也就是说将类型相关参数传进来有两种手段，一种是在<code>PreparedStatementLogger</code>创建的时候，跟着原本构造函数相关的参数带进来，另一种是在<code>invoke</code>方法在调用之前传进来。当然了根据尝试，否定了第一种方式，原因是创建这个对象的地方也没有类型相关信息。</p><p>后来发现在<code>PreparedStatementLogger#invoke</code>方法被调用之前是可以获取到<code>BoundSql</code>对象，调用的地方是<code>PreparedStatementHandler</code>的<code>update</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里是动态代理，通过这里进入到PreparedStatementLogger#invoke中</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只需要在这里做文章，将<code>BoundSql</code>对象传到<code>PreparedStatementLogger</code>中基本上就可以达到目的。</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p>1.将<code>PreparedStatementLogger</code>拷贝到应用的类路径下，并创建同名类路径<code>org.apache.ibatis.logging.jdbc.PreparedStatementLogger</code>类，然后添加一个属性字段<code>BoundSql</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BoundSql boundSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略很多代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同样，将<code>PreparedStatementHandler</code>拷贝到应用类路径下，并创建同名类路径<code>org.apache.ibatis.executor.statement.PreparedStatementHandler</code>，并在执行前设置<code>boundSql</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里获取到的是PreparedStatementLogger的动态代理对象，所以需要获取到被代理对象target</span></span><br><span class="line">  <span class="comment">// 然后判断被代理对象是否为PreparedStatementLogger，是的话就赋值boundSql</span></span><br><span class="line">  <span class="keyword">if</span> (Proxy.isProxyClass(statement.getClass())) &#123;</span><br><span class="line">    MetaObject metaObject = SystemMetaObject.forObject(statement);</span><br><span class="line">    Object target = metaObject.getValue(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> PreparedStatementLogger)&#123;</span><br><span class="line">      PreparedStatementLogger preparedStatementLogger = (PreparedStatementLogger) target;</span><br><span class="line">      preparedStatementLogger.boundSql = boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后在需要忽略日志打印的实体字段上标记能识别到<code>jdbcType</code>的注解，我这里用的是<code>tk.mybatis</code>，所以标记注解是<code>tk.mybatis.mapper.annotation.ColumnType</code>。如果用的是<code>mybatis-plus</code>应该是<code>com.baomidou.mybatisplus.annotation.TableField</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;GROUP_ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;PROJECT_ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="meta">@ColumnType(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="keyword">private</span> String extraInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的打印逻辑我这里就不去写了，附一张到这里的断点图，到这里已经能获取到字段的类型和字段的值。</p><p><img src="https://s2.loli.net/2022/11/14/Kp4nfxJ5MHWEekQ.png" alt="mybaits控制字段打印.png"></p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>​    这里通过自己定义了与<code>mybatis</code>中相关的包路径和同名类来达到替换第三方<code>jar</code>包中的同名对象。原理实际上就是<code>jdk</code>的类加载机制，采用的是双亲委派模型，如果一个类加载器收到了需要加载类的请求，它不会马上进行解析，而是把这个请求委派给父类去加载，每一个层级的类加载器都是入参，当最上层加载器无法解析之后，它才会一层一层往下委派。</p><p>​    比如<code>java.lang.Object</code>存放在<code>rt.jar</code>中，如果编写另一个<code>java.lang.Object</code>并放到<code>ClassPath</code>中，编译上是没有问题的，但是由于双亲委派模型，当获取<code>java.lang.Object</code>时会委派到最上级的启动类加载器，而类路径<code>ClassPath</code>是应用程序类加载器。</p><p>​    但是对于上面重写的两个类，使用到的都是应用程序类加载器，但是如果在在应用<code>ClassPath</code>下创建同名路径，那么编译之后，代码是在<code>classes</code>文件夹中，而第三方包是在<code>lib</code>文件夹中，这里加载类进行查找对应<code>.class</code>文件时也有一个优先级的关系，会优先获取<code>classes</code>中的<code>.class</code>文件。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;a href=&quot;#mybatis控制部分字段不打印&quot; class=&quot;headerlink&quot; title=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;/a&gt;mybatis控制部分字段不打印&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在&lt;code&gt;MySQL&lt;/code&gt;的一些执行打印了&lt;code&gt;text&lt;/code&gt;等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭&lt;code&gt;mybatis&lt;/code&gt;的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为&lt;code&gt;text&lt;/code&gt;等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>nacos简单入门</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-27T13:04:58.000Z</published>
    <updated>2022-10-28T02:42:43.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nacos入门"><a href="#nacos入门" class="headerlink" title="nacos入门"></a>nacos入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近闲来无事看到一篇关于<code>DynamicTp</code>动态可监控线程池框架，也去<code>DynamicTp</code>官网看了一下，发现原来跟<code>Hutool</code>出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中<code>apollo</code>已经使用比较多，所以这次想尝试一下使用<code>nacos</code>。<span id="more"></span></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>​    因为我使用的是<code>mac</code>，且安装了<code>docker</code>和<code>kitematic</code>，本以为只需要从容器仓库中拉一个<code>nacos</code>的镜像就大工告成，没想到，事情没有我想象的那么顺利，还是一波三折。</p><p>​    通过<code>kitematic</code>直接搜索<code>nacos</code>镜像，并下载启动。</p><p><img src="https://s2.loli.net/2022/10/27/DqZVrThs5FeLSip.png" alt="nacos部署.png"></p><p>启动后直接报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No DataSource set</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.DumpService.dumpOperate(DumpService.java:236)</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.ExternalDumpService.init(ExternalDumpService.java:52)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)</span><br><span class="line">... 53 common frames omitted</span><br></pre></td></tr></table></figure><p>看报错信息，大概率是数据连接的问题，到目前为止，容器是镜像下载之后直接启动的，我并没有配置数据库连接相关信息，到这里，我第一反应是将<code>nacos</code>的部分文件/文件夹挂载到宿主机，修改是也方便，但是对于容器的修改挂载点有点复杂，有的说去修改底层的那个<code>config.v2.json</code>文件，有的说通过<code>export</code>修改，不知道是我操作有问题还是怎么样，我尝试了之后是没有成功。后面我是将这个运行容器删掉，利用镜像重新启动一个容器，这时就可以指定对应的挂载卷，本来想把整个<code>/nacos</code>文件夹都挂载出来，但是指定之后，死活报错，某个文件找不到，启动失败，无奈只能走最下策，进入容器操作。</p><p>所以进入容器中，查看相关配置信息。</p><p>进入容器中定位到<code>/home/nacos/conf/application.properties</code>，不同容器应该会不太一样，但是大概率是在<code>~/nacos/conf</code>文件夹。</p><p>想将<code>conf</code>文件夹下的数据库脚本文件<code>shcema.sql</code>脚本，拿到数据库中执行之后，在修改<code>application.properties</code>文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">$&#123;SERVER_SERVLET_CONTEXTPATH:/nacos&#125;</span></span><br><span class="line"><span class="meta">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">$&#123;NACOS_APPLICATION_PORT:8848&#125;</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">$&#123;SPRING_DATASOURCE_PLATFORM:mysql&#125;</span></span><br><span class="line"><span class="meta">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="meta">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="meta">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">$&#123;MYSQL_DATABASE_NUM:1&#125;</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://$&#123;MYSQL_SERVICE_HOST:docker.for.mac.host.internal&#125;:$&#123;MYSQL_SERVICE_PORT:32786&#125;/$&#123;MYSQL_SERVICE_DB_NAME:nacos&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&#125;</span></span><br><span class="line"><span class="comment"># db.url.1=jdbc:mysql://$&#123;MYSQL_SERVICE_HOST&#125;:$&#123;MYSQL_SERVICE_PORT:3306&#125;/$&#123;MYSQL_SERVICE_DB_NAME&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&#125;</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">$&#123;MYSQL_SERVICE_USER:root&#125;</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">$&#123;MYSQL_SERVICE_PASSWORD:root&#125;</span></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">$&#123;NACOS_AUTH_SYSTEM_TYPE:nacos&#125;</span></span><br></pre></td></tr></table></figure><p>填写上数据库相关信息之后，重启还是报错，在这个地方磨了好久，一直想不明白为什么数据库连接不上。</p><p>这里主要原因是因为我的<code>mysql</code>数据库不是直接安装在本机上，也是通过<code>docker</code>容器部署，所以我最开始的时候通过<code>nacos</code>容器去<code>ping</code>连接<code>mysql</code>的容器，在<code>ping</code>通的情况下，我以为<code>nascos</code>容器通过<code>mysql</code>容器的<code>ip</code>可以直接访问到数据库。一直报错之后，使用<code>telnet</code>命令查看端口是否可访问时，报错了，才发现了问题。</p><p>按我理解，访问不到的原因可能是如果<code>ip</code>写的是<code>mysql</code>容器的<code>ip</code>，那么端口应该写哪个合适?是写容器对应开放的端口，还是写宿主机绑定的端口？我两种都尝试了一次，结果都是访问不到。所以将访问<code>ip</code>修改为访问宿主机<code>ip</code>+宿主机绑定<code>mysql</code>容器的端口，这种方式是可以访问到的。</p><p>这里必须安利一波<code>mac</code>上的<code>docker</code>和<code>kitematic</code>，基本上所有的类似组件，比如<code>rabbitmq</code>，<code>mysql</code>，<code>redis</code>，<code>jenkins</code>，<code>nexus3</code>等我都是通过容器化部署，只需要把对应的数据卷挂载到宿主机，保证重启是数据不丢失即可，好处当然多多，一是干净，二是简单。</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><blockquote><p>127.0.0.1:4567/nacos/index.html</p></blockquote><p><code>nacos</code>的默认账号和密码都是<code>nacos</code></p><p><img src="https://s2.loli.net/2022/10/27/IM5EVBWFh98iYw4.png" alt="nacos登录页.png"></p><p>在<code>nacos</code>中有命名空间和分组的概念，每一个命名空间中可以划分多个组，在<code>spring</code>配置文件中，可以指定需要拉取哪个命名空间下的那个组的配置。</p><p>通过『命名空间』创建<code>dev</code>、<code>test</code>命名空间之后，在『配置列表』会显示出对应的命名空间。</p><p><img src="https://s2.loli.net/2022/10/27/ymrj5ZHOnDb7cpo.png" alt="nacos配置列表.png"></p><h2 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h2><p>引入<code>nacos</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类启用<code>nacos</code>配置注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@NacosPropertySource(dataId = &quot;simple-dev-yaml&quot;, groupId = &quot;DEV_GROUP&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootSimpleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootSimpleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件添加<code>nacos</code>服务器访问地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nacos.config.server-addr</span>=<span class="string">127.0.0.1:4567</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NacosValue(value = &quot;$&#123;useLocalCache:false&#125;&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useLocalCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useLocalCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是想使用一下<code>nacos</code>，所以采用的都是最简单的写法，写死的方式指定了<code>dataId</code>和<code>groupId</code>，在实际的使用中一般都是使用配置文件来进行管理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nacos入门&quot;&gt;&lt;a href=&quot;#nacos入门&quot; class=&quot;headerlink&quot; title=&quot;nacos入门&quot;&gt;&lt;/a&gt;nacos入门&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近闲来无事看到一篇关于&lt;code&gt;DynamicTp&lt;/code&gt;动态可监控线程池框架，也去&lt;code&gt;DynamicTp&lt;/code&gt;官网看了一下，发现原来跟&lt;code&gt;Hutool&lt;/code&gt;出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中&lt;code&gt;apollo&lt;/code&gt;已经使用比较多，所以这次想尝试一下使用&lt;code&gt;nacos&lt;/code&gt;。</summary>
    
    
    
    <category term="nacos" scheme="http://xiaocainiaoya.github.io/categories/nacos/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatis-plus特性</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/</id>
    <published>2022-10-14T14:13:58.000Z</published>
    <updated>2023-06-28T09:31:47.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-plus特性"><a href="#mybatis-plus特性" class="headerlink" title="mybatis-plus特性"></a>mybatis-plus特性</h1><span id="more"></span><h2 id="1-字段类型转换器"><a href="#1-字段类型转换器" class="headerlink" title="1.字段类型转换器"></a>1.字段类型转换器</h2><p>如果出现实体字段类型与数据库类型不一致情况，比如实体是<code>String</code>但是数据库是<code>Date</code>，或者实体中是对象，而数据库中是<code>varchar</code>存储<code>json</code>；则可以通过字段类型转换器进行统一转换，无需业务层在每次存取时进行手段转换。</p><p><b>1.实体上设置转换器类型(设置之后，在通过基础接口的处理都会进行转换)</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里需要设置autoResultMap = true, 否则查询时不会将数据库中的json转换为对应实体</span></span><br><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">    <span class="comment">// 设置转换器的类型,这个是内置转换器,也可以自定义</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserExtraInfo userExtraInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.第一步骤中的设置仅导致通过内置接口的处理会进行转换，但是通过自定义XML的脚本语句不会进行转换。</b><br>法一：在<code>mapper</code>语句上通过<code>@Results</code>设置对应的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Results(value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;user_extra_info&quot;, property = &quot;userExtraInfo&quot;, typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：需要在<code>xml</code>文件中配置<code>resultMap</code>结果集，并在结果集映射中设置对应的类型转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.entity.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MOBILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deleteStatus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DELETE_STATUS&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userExtraInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;USER_EXTRA_INFO&quot;</span> <span class="attr">typeHandler</span> = <span class="string">&quot;com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testXmlSql&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-基础类扩展"><a href="#2-基础类扩展" class="headerlink" title="2.基础类扩展"></a>2.基础类扩展</h2><p>直接通过继承<code>mybatis-plus</code>提供的三层基础接口，可以直接具备一些数据操作能力，比如通过<code>deleteById</code>可以直接通过<code>id</code>删除记录，无需编写<code>SQL</code>语句。同时<code>mybatis-plus</code>还提供了对基础层的扩展，用户可自定义扩展点后，业务处理再继承于自定义的扩展点，使得系统应用具备自定义扩展底层接口的能力。<br><img src="https://s2.loli.net/2022/10/14/eropFI59y32lt4k.png" alt="mybatis-plus基础接口扩展.png"></p><p>上图中<code>userFacade</code>、<code>userService</code>、<code>userMapper</code>是业务层；<code>customerService&lt;User&gt;</code>、<code>CustomerServiceImpl</code>、<code>CustomerMapper</code>是自定义扩展层；<code>IService&lt;T&gt;</code>、<code>ServiceImpl</code>、<code>BaseMapper</code>是<code>mybatis-plus</code>的三次基础接口。</p><p><b>假设现在要扩展<code>Insert ignore</code>的插入语句</b></p><p><b>1.继承<code>AbstractMethod</code>编写具体<code>SQL</code>的拼写等处理：</b>可以参考原有的其他对<code>AbstractMethod</code>的实现，比如<code>com.baomidou.mybatisplus.core.injector.methods</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIgnore</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        CustomerSqlMethod sqlMethod = CustomerSqlMethod.INSERT_IGNORE_ONE;</span><br><span class="line">        String columnScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlColumnMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlPropertyMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(tableInfo.getKeyProperty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(sqlMethod.getMethod(), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, sqlMethod.getMethod(), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置自定义<code>SQL</code>注入器并注入到<code>Spring</code>容器：</b>将步骤一中创建的具体<code>SQL</code>执行器注入到<code>mybatis-plus</code>相应处理中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">iSqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomerSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.创建扩展的<code>mapper</code>层：</b>添加需要扩展的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>service</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>serviceImpl</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insertIgnore(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>5.到这里，业务层只要继承于扩展层，就具备了自定扩展的处理能力</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> <span class="keyword">extends</span> <span class="title">CustomerService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserExtraInfo userExtraInfo = UserExtraInfo.builder()</span><br><span class="line">                .address(<span class="string">&quot;北京市&quot;</span>)</span><br><span class="line">                .city(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                .id(<span class="string">&quot;12312311&quot;</span>)</span><br><span class="line">                .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                .mobile(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .deleteStatus(<span class="number">0</span>)</span><br><span class="line">                .userExtraInfo(userExtraInfo)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 这里就可以直接调用到扩展的接口</span></span><br><span class="line">        insertIgnore(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-逻辑删除"><a href="#3-逻辑删除" class="headerlink" title="3.逻辑删除"></a>3.逻辑删除</h2><p>只需要设置<code>@TableLogic</code>就具备了逻辑删除的能力，但是这仅限制与通过<code>mybatis-plus</code>的基础接口处理数据，如果是通过<code>xml</code>手写<code>SQL</code>是无法自动补充逻辑删除条件。</p><ul><li>插入语句不处理，也就是说默认值需要业务方插入或者通过数据库设置默认值来处理</li><li>查找、更新会追加查询条件</li><li>删除转为更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置逻辑删除字段</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-对第2点中的注入器分析"><a href="#4-对第2点中的注入器分析" class="headerlink" title="4.对第2点中的注入器分析"></a>4.对第2点中的注入器分析</h2><p>首先在<code>mybatis</code>对持久层进行解析时，需要对<code>xml</code>等进行解析，<code>mybatis-plus</code>对<code>mybatis</code>对<code>xml</code>解析进行了扩展，解析时会进入到<code>MybatisMapperAnnotationBuilder#parse</code>方法。每一个<code>XxxMapper</code>都会进入到这个解析方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个resource的值就是全限定路径，比如‘cn.com.xiaocainiaoya.user.UserMapper’</span></span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        String mapperName = type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.InterceptorIgnoreCache cache = InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="comment">// 因为UserMapper需要继承于或间接继承于mybatis-plus实现的通用BaseMapper接口</span></span><br><span class="line">        <span class="comment">// 所以这个methods得到的方法即UserMapper的所有方法(包含继承的上层接口的方法)</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这个地方主要是做缓存一类，默认情况下是不开启的</span></span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                SqlParserHelper.initSqlParserInfoCache(mapperName, method);</span><br><span class="line">                parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                <span class="comment">// TODO 使用 MybatisMethodResolver 而不是 MethodResolver</span></span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> MybatisMethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO 注入 CURD 动态 SQL , 放在在最后, because 可能会有人会用注解重写sql</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// https://github.com/baomidou/mybatis-plus/issues/3038</span></span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                <span class="comment">// 主要处理在这里</span></span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> InjectorResolver(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>parserInjector()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parserInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里在不扩展的情况下获取到的是DefaultSqlInjector，扩展之后就是扩展的实现类，比如在我的实现中是CustomerSqlInjector这个类</span></span><br><span class="line">    <span class="comment">// 注意在这个中：一定要获取super.getMethodList(mapperClass); 这是原本的通用方法的注入器，比如有selectById(id)、deleteById(id)</span></span><br><span class="line">    GlobalConfigUtils.getSqlInjector(configuration)</span><br><span class="line">    <span class="comment">// 进入注入器逻辑，这个方法的主要实现是在DefaultSqlInjector的父类AbstractSqlInjector中</span></span><br><span class="line">    .inspectInject(assistant, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>AbstractSqlInjector#inspectInject</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; modelClass = extractModelClass(mapperClass);</span><br><span class="line">    <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String className = mapperClass.toString();</span><br><span class="line">        Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">        <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">            <span class="comment">// 获取需要操作的方法列表，这个this.getMethodList()是模板方法，由子类实现，默认在DefaultSqlInjector中已经添加了17个通用方法，</span></span><br><span class="line">            <span class="comment">// 所以要求当需要自定义扩展时继承于DefaultSqlInjector类，并在getMethodList()实现中，先获取父类的getMethodList()，得到这17</span></span><br><span class="line">            <span class="comment">// 个通用方法之后，再添加自定义扩展的操作方法。</span></span><br><span class="line">            List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mapperRegistryCache.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的<code>CustomerSqlInjector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlInjector</span> <span class="keyword">extends</span> <span class="title">AbstractSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DefaultSqlInjector中的通用17个方法sql注入器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Insert(),</span><br><span class="line">            <span class="keyword">new</span> Delete(),</span><br><span class="line">            <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">            <span class="keyword">new</span> DeleteById(),</span><br><span class="line">            <span class="keyword">new</span> DeleteBatchByIds(),</span><br><span class="line">            <span class="keyword">new</span> Update(),</span><br><span class="line">            <span class="keyword">new</span> UpdateById(),</span><br><span class="line">            <span class="keyword">new</span> SelectById(),</span><br><span class="line">            <span class="keyword">new</span> SelectBatchByIds(),</span><br><span class="line">            <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">            <span class="keyword">new</span> SelectOne(),</span><br><span class="line">            <span class="keyword">new</span> SelectCount(),</span><br><span class="line">            <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">            <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">            <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">            <span class="keyword">new</span> SelectList(),</span><br><span class="line">            <span class="keyword">new</span> SelectPage()</span><br><span class="line">        ).collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面进入到具体注入器中，这里以<code>mybatis-plus</code>内置的一个但未启用的一个注入器<code>InsertBatchSomeColumn</code>为例。它是在<code>com.baomidou.mybatisplus.extension.injector.methods</code>目录下，这里内置了好几个未启用的注入器。<code>InsertBatchSomeColumn</code>是对批量插入的<code>SQL</code>注入器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertBatchSomeColumn</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段筛选条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Accessors(chain = true)</span></span><br><span class="line">    <span class="keyword">private</span> Predicate&lt;TableFieldInfo&gt; predicate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法的主要逻辑就是拼接出 </span></span><br><span class="line"><span class="comment">     * &lt;script&gt; INSERT INTO tableName (field1,field2,field3....) VALUES </span></span><br><span class="line"><span class="comment">     *  &lt;foreach collection=&quot;list&quot; item=&quot;et&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="comment">     *      (#&#123;et.field1&#125;,#&#123;et.field2&#125;,#&#123;et.field3&#125;....)</span></span><br><span class="line"><span class="comment">     *  &lt;/foreach&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/script&gt;</span></span><br><span class="line"><span class="comment">     * 动态的批量插入脚本语句，这里需要注意的一点是，对于在mysql中设置字段默认值的情况，由于在这个sql中会对空值的字段赋值null</span></span><br><span class="line"><span class="comment">     * 所以使用这种情况的批量插入会导致mysql默认值失效。如果在mysql中设置字段not null，则这种情况会报错。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;Duplicates&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        SqlMethod sqlMethod = SqlMethod.INSERT_ONE;</span><br><span class="line">        List&lt;TableFieldInfo&gt; fieldList = tableInfo.getFieldList();</span><br><span class="line">        String insertSqlColumn = tableInfo.getKeyInsertSqlColumn(<span class="keyword">false</span>) +</span><br><span class="line">            <span class="keyword">this</span>.filterTableFieldInfo(fieldList, predicate, TableFieldInfo::getInsertSqlColumn, EMPTY);</span><br><span class="line">        String columnScript = LEFT_BRACKET + insertSqlColumn.substring(<span class="number">0</span>, insertSqlColumn.length() - <span class="number">1</span>) + RIGHT_BRACKET;</span><br><span class="line">        String insertSqlProperty = tableInfo.getKeyInsertSqlProperty(ENTITY_DOT, <span class="keyword">false</span>) +</span><br><span class="line">            <span class="keyword">this</span>.filterTableFieldInfo(fieldList, predicate, i -&gt; i.getInsertSqlProperty(ENTITY_DOT), EMPTY);</span><br><span class="line">        insertSqlProperty = LEFT_BRACKET + insertSqlProperty.substring(<span class="number">0</span>, insertSqlProperty.length() - <span class="number">1</span>) + RIGHT_BRACKET;</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertForeach(insertSqlProperty, <span class="string">&quot;list&quot;</span>, <span class="keyword">null</span>, ENTITY, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (tableInfo.havePK()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(getMethod(sqlMethod), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后生成的模板SQL</span></span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="comment">// 绑定到对应的mapperId上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, getMethod(sqlMethod), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在扩展的CustomBaseMapper中需要与这个method通用，才会与这个注入器进行绑定。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">(SqlMethod sqlMethod)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义 mapper 方法名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;insertBatchSomeColumn&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis-plus特性&quot;&gt;&lt;a href=&quot;#mybatis-plus特性&quot; class=&quot;headerlink&quot; title=&quot;mybatis-plus特性&quot;&gt;&lt;/a&gt;mybatis-plus特性&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mysql问题汇总</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-10-11T14:13:58.000Z</published>
    <updated>2022-10-11T07:42:47.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL单表数据数据最大两千万？"><a href="#MySQL单表数据数据最大两千万？" class="headerlink" title="MySQL单表数据数据最大两千万？"></a>MySQL单表数据数据最大两千万？</h2><p>相比大家也有听说过<code>MySQL</code>单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。<span id="more"></span></p><p>其实这种说法的背后是索引高度的问题，<code>MySQL</code>索引内部使用的是<code>B+</code>树，叶子节点存具体的数据，非叶子节点是为了去叶子节点寻址。<code>MySQL</code>的数据是按页存储，每一页的大小是16k，读取的时候也是按页读取，也就是说就算你的语句里有<code>limit 1</code>，但是实际上也是将整页都加载到内存中。</p><p>这个16k大小的页包含有页头（页号，寻址指针等内容）、页尾（检验码等）、页目录（这一页内的数据目录，用于快速找到页内数据），剩下的空间就是存放具体的数据记录<code>record</code>。结合<code>B+</code>树的特性，非叶子节点内具体的数据记录<code>record</code>实际上存储的某一页的页号以及这一页的最小记录的<code>id</code>值。叶子节点内具体的数据记录<code>record</code>实际上存储的是行信息(再具体到存储的是行记录的多少内容，要看是什么索引)。</p><p>所以想查询某一行数据的主要过程：从索引的根往下找，先根据非叶子节点的<code>id</code>值匹配，匹配到对应的<code>id</code>值之后根据页号，找到对应的叶子节点，从而获取到整行数据。</p><p>当数据庞大时，树的叶子节点如果想要容纳所有数据就需要增加高度，高度越高，能容纳的数据量也就越大。同时也伴随着更多的磁盘io，一般3层索引树，会有3次磁盘io，并且是随机io。<br>这里有一个计算公式：<code>(x ^ (z-1)) * y</code></p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的<code>record</code>数量为<code>y</code></li><li><code>B+</code>树的层数为<code>z</code></li></ul><p><b>x的值：</b>主键假设是bigint（8Byte），而页号在源码里叫FIL_PAGE_OFFSET（4Byte），那么非叶子节点里的一条数据是12Byte左右，整个数据页16k， 页头页尾那部分数据全加起来大概128Byte，加上页目录毛估占1k吧。那剩下的15k除以12Byte，等于1280，也就是可以指向x=1280页。<br><b>y的值：</b>叶子节点和非叶子节点结构是一致的，这里也假设记录可用空间为15k，假设一行数据需要占用1k空间，那么叶子节点可用容纳15行的数据。</p><p>根据公式：<br>若z=2，则(1280 ^ (2-1)) * 15 ≈ 2w<br>若z=3，则(1280 ^ (3-1)) * 15 ≈ 2.5kw<br>这里的<code>2.5kw</code>也就是通常说的单表数据不要超过2kw的估值，如果高度再加一层，那么所能容纳的数据量就更加庞大。但是你有没有发现，我假设了单行数据的空间是1k，如果表字段不多，单行数据仅0.25k呢，那么这个计算结果就是1亿，也就是在三层高度的情况下，数据量也有可能达到1亿。</p><h2 id="随机IO-顺序IO"><a href="#随机IO-顺序IO" class="headerlink" title="随机IO/顺序IO"></a>随机IO/顺序IO</h2><p>顺序IO是指读写操作的访问地址连续。随机IO是指读写操作的时间连续，但访问的地址不连续。</p><h2 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h2><p>深度分页涉及到的问题通常是使用<code>limit offset, size</code>，对于<code>limit 10, 10</code>和<code>limit 10000, 10</code>，性能上前者是快于后者的，这是因为后者也是需要查出10000条数据，然后丢弃掉，再往后获取10条数据，也就是说前者总共获取了20条数据，后者获取了10010条数据。</p><p>这种情况其实是无解的，因为这是<code>MySQL</code>的内部逻辑，我们根本就触及不到，但是在一定条件下，可以通过一定的手段进行优化。假设有语句：</p><blockquote><p>select * from page order by id limit 10000, 10;</p></blockquote><p>这条查询语句还是有优化空间的，由于这里需要查询整行数据，也就导致了丢弃的10000行数据也去查询了整行数据，实际上这是没有必要的。<br>优化如下，虽然它也是会获取那丢弃的10000条数据，但是这10000条数据仅获取了id值，并没有获取整行数据，当行数据比较长时，还是会有一定的性能提升。</p><blockquote><p>select * from page  where id &gt;=(select id from page  order by id limit 10000, 1) order by id limit 10; </p></blockquote><p>再看在非主键索引上的操作：</p><blockquote><p>select * from page order by user_name  limit 10000, 10;</p></blockquote><p>这里由于是非主键索引，所以会对这丢弃的10000条数据都进行一次回表操作，影响性能。可以通过连接来优化，减少回表次数：</p><blockquote><p>select * from page t1, (select id from page order by user_name limit 10000, 10) t2  WHERE t1.id = t2.id;</p></blockquote><p>前面的优化实际上也都会查询丢弃的10000条数据，所以这里再怎么优化都是治标不治本的优化手段。所以只能通过一些特殊手段控制，比如百度、淘宝的搜索页只会固定页码，到一定页码之后就不允许往后页码查。再比如抖音这种这种滚动下只有翻页没有跳页，可以将当前页设置一个最小值，下一页在这个最小值的基础上查询。这也是同步大表时的一个手段。</p><p>如果同步一个大表，你使用的是<code>select * from tableName</code>，同步到异构系统，比如es等，因为数据量比较大，数据库无法一次性获取到所有数据而报错，如果仅仅通过<code>limit offset, size</code>就有可能出现深度分页的情况，所以一般来说可以通过<code>id</code>排序，将<code>id</code>对应的记录分块，当前块的最大<code>id</code>值，作为下一块<code>id</code>的查询条件。</p><blockquote><p>select * from tableName where id &gt; 上一块id的最大值 order by id limit 100</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;a href=&quot;#MySQL单表数据数据最大两千万？&quot; class=&quot;headerlink&quot; title=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;/a&gt;MySQL单表数据数据最大两千万？&lt;/h2&gt;&lt;p&gt;相比大家也有听说过&lt;code&gt;MySQL&lt;/code&gt;单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（五）---排序</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/</id>
    <published>2022-10-09T14:13:58.000Z</published>
    <updated>2022-10-09T08:50:06.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（五）—排序"><a href="#mysql45讲学习总结（五）—排序" class="headerlink" title="mysql45讲学习总结（五）—排序"></a>mysql45讲学习总结（五）—排序</h1><p>​<br>本篇记录<code>MySQL</code>在执行<code>order by</code>语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。</p><span id="more"></span><h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><blockquote><p>select name, age, address from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>使用<code>explain</code>分析该语句：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>bid_confirm_project</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4033</td><td>10</td><td>Using where; Using filesort</td></tr></tbody></table><p><code>Using filesort</code>：表示需要排序。<code>MySQL</code>会给每个线程分配一块<code>sort_buffer</code>内存空间用于排序。</p><p>假设在<code>name</code>上有索引排序流程：</p><ol><li>初始化<code>sort_buffer</code>空间，确定将用于存入字段<code>name</code>、<code>age</code>、<code>address</code>的值。</li><li>从索引<code>name</code>上找到第一个满足<code>xxx</code>条件的<code>id</code>。</li><li>根据这个<code>id</code>通过主键索引获取整行数据，将<code>name</code>、<code>age</code>、<code>address</code>的值存入到<code>sort_buffer</code>中。</li><li>从索引<code>name</code>取下一个记录的主键。</li><li>重复3,4步骤，直到从索引<code>name</code>取到的值不满足查询条件为止。</li><li>对<code>sort_buffer</code>空间的数据按照<code>age</code>进行排序。</li><li>返回结果集数据。</li></ol><p>​    <b>步骤6中按照<code>age</code>进行排序：这个可能在内存中完成，也有可能需要使用到外部排序。</b>这取决于排序所需要的内存空间大小和参数<code>sort_buffer_size</code>。如果需要排序的数据量小于<code>sort_buffer_size</code>则使用内存空间进行排序，如果需要排序的数量大于<code>sort_buffer_size</code>则需要使用磁盘临时文件辅助排序。</p><p>仅仅使用<code>explain</code>只能分析改语句是否需要排序，至于排序是在内存中排序还是在磁盘中排序就无法得知，需要使用其他手段。<b><code>MySQL</code>版本需要到5.6以上。</b></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开 optimizer_trace，只对本线程有效</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 OPTIMIZER_TRACE 输出 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`</span><br></pre></td></tr></table></figure><p>查询的结果是一个<code>json</code>结果：(<code>json</code>结果比较大，截取一段)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;filesort_summary&quot;: &#123;</span><br><span class="line">  &quot;rows&quot;: 4250,  </span><br><span class="line">  &quot;examined_rows&quot;: 4291, // 排序的行数</span><br><span class="line">  &quot;number_of_tmp_files&quot;: 11,   // 排序过程中使用的临时文件数，如果在内存中排序，则这个值为0</span><br><span class="line">  &quot;sort_buffer_size&quot;: 261696,  // 就是上面说的排序的空间大小，这个是可以通过命令调整</span><br><span class="line">  &quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>假设查询语句变为：</p><blockquote><p>select * from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>对比可知，仅仅是将查询结果的字段修改为了<code>*</code>，这时在步骤1中就需要为很多无需排序的字段开辟空间，那么就会造成<code>sort_buffer_size</code>空间中单行的数据比较长，那么<code>MySQL</code>会怎么做？</p><p>实际上当<code>MySQL</code>判断单行数据过长时，它会修改<code>sort_buffer_size</code>存放值的策略，之前全字段排序时<code>sort_buffer</code>存放的字段为<code>name</code>、<code>age</code>、<code>address</code>，而如果单行数据过长时，<code>sort_buffer</code>存储的字段就变成<code>id</code>、<code>age</code>，排序完成之后，通过主键<code>id</code>索引进行一次回表，也就是说比全字段排序多了一个步骤，在排序完成之后需要进行一次回表。</p><p>同时在刚刚的<code>optimizer_trace</code>的<code>json</code>中的<code>sort_mode</code>项中会标识出是否采用了<code>rowid</code>算法。通过参数<code>max_length_for_sort_data</code>控制单行数据长度。</p><p><b>全字段排序对比rowid排序</b></p><p>如果<code>MySQL</code>认为内存足够大，会优先选择<b>全字段排序</b>，如果认为排序内存太小，影响排序效率，则会采用<code>rowid</code>排序算法，这样排序过程中一次可以排多行，但是需要再回表取相关字段数据。</p><p>排序对于<code>MySQL</code>来说是一个成本比较高的操作，并不是所有的<code>order by</code>都需要排序操作，之所以需要排序操作，是因为查到的数据是无序的，所有才需要进行排序操作，但是在<code>MySQL</code>中有一种方式是天然排序的，那就是索引，可以通过创建对应索引，使得查询到的数据已经是有序，那么就无需在经过排序操作。这种情况下<code>explain</code>得到的结果中就没有<code>filesort</code>。</p><h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><blockquote><p>CREATE TABLE <code>words</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>word</code> varchar(64) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB;</p><p>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=0;<br>  while i&lt;10000 do<br>    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;</p><p>call idata();</p></blockquote><p>然后执行以下语句用于获取随机的前三个数据，这里的<code>order by rand()</code>，会对每一行的数据都生成一个随机值，然后根据这个随机值进行排序，最后取得前三行数据。</p><blockquote><p>select word from words order by rand() limit 3;</p></blockquote><p>使用<code>explain</code>命令执行结果如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>words</td><td>ALL</td><td></td><td></td><td></td><td></td><td>10304</td><td>Using temporary; Using filesort</td></tr></tbody></table><p><code>Using temporary</code>表示需要使用到临时表，这里是因为需要为每一行生成一个随机值进行排序，所以需要一个临时表存储生成的这个随机值。</p><p>对于内存临时表来说，会选用那种算法存放数据？是全字段索引的算法？还是<code>rowid</code>算法？。<br>答案是使用<code>rowid</code>算法，因为对内存临时表来说，回表只是简单的根据数据行的位置直接访问到数据，不会导致访问磁盘，所以这时采用的是<code>rowid</code>排序。</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p><b>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</b></p><h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>当需要到临时表的空间比较大时，超过了<code>tmp_table_size</code>的值，那么内存临时表会转换为磁盘临时表。<br>在磁盘临时表中还有一种优化算法：优先队列排序算法。对于这个查询语句，实际上只需要取值最小的3个值，但是如果使用归并排序的话，是将所有数据都排序了，所以实际上浪费了很大的计算量。所以这里<code>MySQL</code>提供了优先队列排序算法：<br>  先取3行数据构建一个堆，再取下一行数据，与这个堆的最大值进行比较，如果大则丢弃，如果小则替换，依次执行，知道扫描完整个表。</p><p>如果需要的空间大于<code>sort_buffer_size</code>则采用磁盘临时表，通过磁盘临时表进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（五）—排序&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;/a&gt;mysql45讲学习总结（五）—排序&lt;/h1&gt;&lt;p&gt;​&lt;br&gt;本篇记录&lt;code&gt;MySQL&lt;/code&gt;在执行&lt;code&gt;order by&lt;/code&gt;语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（四）---锁</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/</id>
    <published>2022-09-29T14:13:58.000Z</published>
    <updated>2023-03-01T03:14:56.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（四）—锁"><a href="#mysql45讲学习总结（四）—锁" class="headerlink" title="mysql45讲学习总结（四）—锁"></a>mysql45讲学习总结（四）—锁</h1><p>​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><span id="more"></span><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><ul><li><code>DML</code>：数据操纵语言(Data Manipulation Language)</li><li><code>DDL</code>：数据定义语言(Data Definition Language)</li><li><code>MDL</code>：元数据锁(meta data lock)</li></ul><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>​    全局锁顾名思义就是对整个数据库实例上锁，让整个数据库处于只读状态，<code>MySQL</code>提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock(FTWRL)</code>。使用这个命令之后，其他线程的数据更新语句<code>DML</code>(增删改)、数据定义语句<code>DDL</code>(建表、修改字段信息)和更新类事务的提交语句。</p><p>一般来说全局锁的使用场景就是全库的备份，使用<code>FTWRL</code>命令之后，使得整个库处于只读状态之后，进行数据备份。那么有两种情况，如果在主库进行备份，备份期间，主库处于业务停摆；如果在从库备份，从库无法执行主库过来的<code>binlog</code>，导致主从延迟。</p><p>那么有没有什么方式可以不影响业务？</p><p>先简单还原全库备份如果不上全局锁产生的问题：假设有两张表，一张账户余额表，一张用户课程表；事务内的操作顺序为余额表扣款，课程表添加一条课程记录。假设这个动作是在备份过程中执行，在余额表扣款之前，备份了余额表，在课程表添加记录之后，备份了课程表，导致在备份库中，余额表的金额是原值，课程表却新增了一条记录。从语义上简单说就是钱没有花，但是买到了课。</p><p>产生这个问题的原因主要是备份库得到的不是一个逻辑时间点，视图的逻辑是不一致的，所以备份的时候应该要拿到一个时间点的一致性视图。也就是在可重复读隔离级别看开启一个事务，那么在这个事务中的操作，对于每个表来说已经形成了”快照“，对这个”快照“进行备份，从而保证备份库数据逻辑正确。</p><p>官方自带的逻辑备份工具<code>mysqldump</code>，使用参数<code>--single-transaction</code>后备份数据会启动一个事务，来确保拿到的是一致性视图，但是要注意，这个参数需要存储引擎支持可重复读这个隔离级别。比如<code>MyISAM</code>不支持，那么只能使用<code>FTWRL</code>进行备份。</p><p>当然了还有人说可以使用<code>set global readonly = true</code>的方式让整个库处于只读的状态，但是这种做法存在两个致命的问题：</p><ul><li>使用<code>FTWRL</code>命令，当这个线程因为发生异常断开之后，会释放这个全局锁。</li><li>假设其他应用层框架通过这个<code>readonly</code>全局参数判断是否是主库，导致一些应用层逻辑出现问题。</li></ul><p>业务的更新不只是<b>增删改数据（<code>DML</code>)</b>，还有可能是加字段等<b>修改表结构的操作（<code>DDL</code>）</b>。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p><code>MySQL</code>里面的表级别锁有两种：表锁和元数据锁<code>MDL</code>。</p><h2 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h2><blockquote><p>表锁的语法是 lock tables … read/write</p></blockquote><p>与<code>FTWRL</code>类似，可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。</p><p><code>lock tables</code>命令除了会限制别的线程的读写之外，也会限制自身线程的数据访问权限：假设线程A中执行<code>lock tables t1 read, t2 write</code>那么其他线程的写<code>t1</code>、读写<code>t2</code>都会被阻塞。同时当线程A在执行<code>unlock tables</code>之前，自身线程只能执行读<code>t1</code>、读写<code>t2</code>，这时连写<code>t1</code>都不允许，自然不能访问其他表。</p><p>一般不使用<code>lock tables</code>来控制并发，这个锁的面积太大。</p><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>​    <code>MDL</code>不需要显示使用，在访问一个表的时候会自动加上，它的作用是保证读写的正确性，这是因为假设一个查询正在遍历表数据，突然另一个线程变更了表结构，那么查询线程获取到的数据结构跟原本对不上。</p><p>​    所以当对一个表做增删改操作时，加<code>DML</code>读锁，当要对表结构做变更时，加<code>DML</code>写锁。</p><ul><li>读锁之间不互斥，因此你可以多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，一个线程获取了读锁，另一个线程如果要获取写锁就需要进入等待。</li></ul><p>尽管这样还是可能会出现一些问题：</p><p>​    在给一个表添加字段、修改字段或者索引的处理，这些操作是需要全表扫描的。假设线程A获取了<code>DML</code>读锁，在对表进行查询操作，线程B想要获取<code>DML</code>写锁，进行修改表字段操作，这时由于线程A持有<code>DML</code>读锁，线程B阻塞进入等待，同时其他线程若想再查这个表数据，需要获取<code>DML</code>读锁，都会因为线程B而进入等待，如果这个表查询比较频繁，且很多客户端是有重试机制，也就是等待超时之后会重启一个<code>session</code>再次请求，那么这个库的线程很快就会满。<b>事务中的<code>DML</code>锁，在语句执行开始时申请，并不是在语句执行完成后就释放，而是在事务提交之后才释放。</b></p><p>所以一般情况下，首先要解决长事务，事务不提交会一直持有<code>DML</code>锁，或者将这个线程<code>kill</code>掉，但是对于热点表来说，可能<code>kill</code>不是那么有效果，可能刚<code>kill</code>掉，请求马上就又来了，所以只能通过为这个变更语句设置等待时间，如果在这个时间之内能获取到<code>DML</code>锁，就执行变更，如果获取不到，也不要阻塞业务，先放弃，之后在重复执行这个命令。</p><blockquote><p>ALTER TABLE tbl_name NOWAIT add column …</p><p>ALTER TABLE tbl_name WAIT N add column …</p></blockquote><h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>​    <code>MySQL</code>的行锁是各个引擎层自己实现，并不是所有存储引擎都支持行锁，比如<code>MyISAM</code>就不支持行锁，也就是锁它的并发控制只能使用表锁，这种颗粒度严重影响了业务并发度。</p><p>​    行锁就是针对于数据表中行记录的锁，锁的是主键索引，比如事务A更新了一行，这时候事务B也要更新同一行，那么事务B进入等待，如果事务B更新的不是同一行，那么事务B无需等待。</p><p><b>两阶段锁</b></p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;<br>update t set k=k+1 where id=1;<br>update t set k= k+1 where id=2;</td><td></td></tr><tr><td></td><td>Begin;<br>update t set k=k+2 wehre id=1;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这种情况下，事务A在执行两条更新语句之后，持有了这两条记录的行锁，但是事务A是在提交之后才会释放行锁，所以事务B的更新语句，要在事务A提交之后才能执行。</p><p><b>在<code>InnoDB</code>事务中，行锁是在执行语句的时候获取的，但并不是语句执行之后就释放，而是在这个事务提交之后才释放，这就是两阶段协议。</b></p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>间隙锁是用来解决幻读带来的问题，幻读是指事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</p><p>创建一个表，这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。</p><blockquote><p>CREATE TABLE <code>t</code> (<br><code>id</code> int(11) NOT NULL,<br><code>c</code> int(11) DEFAULT NULL,<br><code>d</code> int(11) DEFAULT NULL,<br>PRIMARY KEY (<code>id</code>),<br>KEY <code>c</code> (<code>c</code>)<br>) ENGINE=InnoDB;</p><p>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p></blockquote><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td></td><td>insert into t value(1, 1, 5)</td></tr><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p><code>sessionA</code>第一次查询的时候只返回一条记录，第二次查询的时候由于<code>sessionB</code>已经提交了，所以可以查到两条记录。</p><p>也就是说幻读指一个事务内的两次查询，后一次的查询看到了前一次查询没有看到的行。</p><p>仔细观察<code>sessionA</code>的查询语句，可以发现，<code>for update</code>命令加上之后，是当前读，当前读就是要读到已经提交的最新值，所以<code>sessionA</code>看到<code>sessionB</code>提交的结果看起来并没有什么问题。</p><p>但是，实际上这是有问题的，因为<code>sessionA</code>的第一个查询语句的语义是要锁住所有<code>d=5</code>的行，不允许其他事务进行写操作，如果将<code>sessionB</code>的语句修改为<code>update c=1 where d=5</code>，这时<code>sessionB</code>就会进入等待，等待<code>sessionA</code>提交之后释放锁。</p><p><b>锁的设计是为了在并发时保持数据的一致性，包括数据库内部数据状态的一致性，也包括了日志的一致性。</b></p><p>看下面的例子：</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from where d=5 for update;<br>update t set d=100 where d=5;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=5 where id=0;<br>update t set c=5 where id = 0;</td><td></td><td>T2</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T3</td></tr><tr><td></td><td></td><td>insert into t values(1,1,5);<br>update set c=5 where id=1;</td><td>T4</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T5</td></tr><tr><td>commit;</td><td></td><td></td><td>T6</td></tr></tbody></table><p>当执行完成之后数据库数据结果：</p><ol><li>经过T1之后，id=5这一行变成(5, 5, 100)，但是这个要在T6之后才正式提交。</li><li>经过T2之后，id=0这一行变成(0, 5, 5)</li><li>经过T4之后，表里对了一行(1, 5, 5)</li></ol><p>所以<code>binlog</code>中的语句大概是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure><p>如果使用这个<code>binlog</code>来备份或者是从库同步数据都会出现数据不一致的情况。</p><p>那么是什么导致了这个数据不一致？可以简单的认为是<code>sessionA</code>在T1时未锁住数据导致的，那么如果它在T1时刻锁住了所有扫描到的行又会怎么样？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure><p>可以看到，就算锁住了所有扫描行，阻塞了<code>sessionB</code>的执行，但是也无法锁住<code>sessionC</code>语句的执行，<b>换句话说就是即使是所有数据都上锁，也还是无法阻止新记录的插入。</b>这也就是为什么幻读需要单独拿出来说的原因。</p><p>所以产生幻读的原因是行锁只能锁住数据行，而新插入的数据是插入到数据行之间的间隙，因此为了解决幻读，<code>InnoDB</code>引入了间隙锁(<code>Gap Lock</code>)。</p><p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，在主键索引上这就产生了 7 个间隙。</p><p><img src="https://s2.loli.net/2022/10/12/DqFhULJ4MSvCWje.png" alt="间隙锁.png"></p><p>所以当执行<code>select * from t where d=5 for update</code>时，不止是给数据库中已有的6个记录上锁，同时也加上了7个间隙锁。这样就可以确保数据无法插入。也就是说在扫描行时不仅给行上锁，也给行两边的间隙上锁。</p><p>间隙锁的性质与之前碰到的锁性质有所不同。</p><p>比如行锁分为读写锁，读锁之间不冲突，读写、写写之间是冲突。而间隙锁，两个<code>session</code>可以同时对一个间隙上间隙锁，只要不插入数据就不会产生冲突。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin<br>select * from t where c=7 lock in share mode;</td><td></td></tr><tr><td></td><td>begin<br>select * from t where c=7 lock in share mode;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里的<code>sessionB</code>并不会阻塞，因为表中没有<code>c=7</code>这条记录，对于<code>sessionB</code>来说也是对(5,10)这个范围加间隙锁，它也<code>sessionA</code>锁住的范围是一致的，目标也是一致的，都是为了保护(5,10)这个范围不能插入数据。</p><p>间隙锁和行锁合称<code>next-key lock</code>，每个<code>next-key lock</code>是前开后闭区间。</p><p>当然了间隙锁的引入也会带来一些问题。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where id=5 for update;</td><td></td></tr><tr><td></td><td>select * from where id=5 for update;<br>insert into t values(5,1,5);</td></tr><tr><td>insert into t values(5,1,5);</td><td></td></tr></tbody></table><p>这个会带来死锁，原因是<code>sessionA</code>为(5,10)加上了间隙锁，<code>sessionB</code>也为(5, 10)加上了间隙锁，但是<code>sessionB</code>的插入语句需要等待<code>sessionA</code>释放间隙锁，<code>sessionA</code>的插入语句也在等待<code>sessionB</code>释放间隙锁，从而造成死锁。</p><p>间隙锁实际上是可重复读的隔离级别才会出现，如果隔离级别设置为读提交就不会产生幻读，也就不需要引入间隙锁。在读提交下，一般将日志格式设置为<code>row</code>来解决数据不一致的问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>行锁：对索引记录加锁。</li><li>间隙锁：锁住某个区间。(可以是两个索引记录之间，也可以是第一个索引之前或者最后一个索引之后的空间)</li><li>next-key锁：行锁和间隙锁的组合。</li></ul><p><b>如果检索条件不是索引的话会全表扫描，这时是表级锁。</b></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>如果需要删除一个表里前10000行数据，有一下三种方法可以做到：</p><ol><li>直接执行 <code>delete from T limit 10000</code>：单个语句占用时间过长，锁的时间比较长，而且大事务还会导致主从延迟。</li><li>在一个连接中循环执行20次<code>delete from T limit 500</code>：一般推荐这种方式。</li><li>在20个连接中同时执行<code>delete from T limit 500</code>：人为造成锁冲突。但是如果可以加上特定的条件，将这10000天然的分开，或者可以获取到主键<code>ID</code>，那么这种方式也不错。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（四）—锁&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;/a&gt;mysql45讲学习总结（四）—锁&lt;/h1&gt;&lt;p&gt;​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
