<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2022-12-05T14:30:58.284Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis的MetaObject反射工具类</title>
    <link href="http://xiaocainiaoya.github.io/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-12-05T12:51:58.000Z</published>
    <updated>2022-12-05T14:30:58.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis的MetaObject反射工具类"><a href="#mybatis的MetaObject反射工具类" class="headerlink" title="mybatis的MetaObject反射工具类"></a>mybatis的MetaObject反射工具类</h1><p>​    <code>MetaObject</code>是<code>mybatis</code>中用于处理反射相关的工具类，通过<code>MetaObject</code>就可以进行获取和设置对象值。</p><span id="more"></span><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><b>简单类型：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Blog对象</span></span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">  <span class="comment">// 使用默认配置创建一个MetaObject对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">  <span class="comment">// 直接为Blog的id属性赋值</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>复杂类型：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    <span class="comment">// 为Bolg中的对象赋值，如果对象为空，会通过该对象的构造函数创建一个空对象</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;author.name&quot;</span>, <span class="string">&quot;tommy&quot;</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>集合类型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    List&lt;Comment&gt; commentList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 尽管设置了数组长度为5，以下调用还是报错，原因是set(index, value)方法中有判断</span></span><br><span class="line">    <span class="comment">// 若 index &gt;= size 则报越界，而size只有add(value)方法会进行叠加</span></span><br><span class="line">    <span class="comment">//commentList.set(0,new Comment());</span></span><br><span class="line">    commentList.add(<span class="keyword">new</span> Comment());</span><br><span class="line">    <span class="comment">// 1.如果是Object对象，为空时会通过构造函数进行创建，但是集合不能自动创建</span></span><br><span class="line">    <span class="comment">// 2.setValue的底层是调用集合的List.set(index, value)方法，不是List.add方法，所以要注意数组越界</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments&quot;</span>, commentList);</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments[0]&quot;</span>, <span class="keyword">new</span> Comment());</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;comments[0].user.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要由<code>MetaObject</code>、<code>ObjectWrapper</code>、<code>MetaClass</code>、<code>Reflector</code>构成。</p><p><img src="https://s2.loli.net/2022/12/05/MQDxLNbn4OgvKRw.png" alt="MetaObject.png"></p><h3 id="1-MetaObject"><a href="#1-MetaObject" class="headerlink" title="1.MetaObject"></a>1.MetaObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line">    <span class="comment">// 包装对象，根据不同对象的不同类型进行包装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同对象的不同对象进行包装</span></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完<code>MetaObject</code>之后，从<code>MetaObject</code>调用的<code>setValue</code>、<code>getValue</code>等属性操作方法实际上都委派给了<code>ObjectWrapper</code>进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="comment">// 如果存在下一层表达式，则创建下一层MetaObject</span></span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">        MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 通过创建的下一层的MetaObject对象，再次调用getValue，进入递归</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在下一层表达式，通过wrapper对象进行反射获取值</span></span><br><span class="line">        <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ObjectWrapper"><a href="#2-ObjectWrapper" class="headerlink" title="2.ObjectWrapper"></a>2.ObjectWrapper</h3><p><code>ObjectWrapper</code>是顶层接口，定义了<code>wrapper</code>包装原始对象的处理接口，如果原始对象是<code>Bean</code>对象那么具体的获取属性等操作在<code>BeanWrapper</code>，如果原始对象是<code>Map</code>则通过<code>MapWrapper</code>进行实现具体的属性操作，同理<code>List</code>则通过<code>CollectionWrapper</code>进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line">    </span><br><span class="line">    String[] getGetterNames();</span><br><span class="line">    </span><br><span class="line">    String[] getSetterNames();</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getSetterType(String name);</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getGetterType(String name);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanWrapper</code>和<code>MapWrapper</code>是继承于抽象类<code>BaseWrapper</code>，由抽象类继承顶层接口<code>ObjectWrapper</code>。<code>CollectionWrapper</code>是直接继承于顶层接口。这是因为如果原始对象是集合，它仅有<code>add</code>和<code>addAll</code>操作，其他接口均抛异常。</p><p><b>在BeanWrapper中解析表达式为词法分析器后进行属性操作</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以set方法为例，通过PropertyTokenizer词法分析器，对比如“comment[0].user.id”进行解析</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object collection = resolveCollection(prop, object);</span><br><span class="line">    setCollectionValue(prop, collection, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setBeanProperty(prop, object, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到对象的set方法</span></span><br><span class="line">        Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">        Object[] params = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射赋值</span></span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>PropertyTokenizer：词法分析器</b>，实现迭代器接口，通过<code>next()</code>方法解析下一层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里以 comments[0].user.id为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前层的名字: comments</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 若是集合则为comments[0]，否则indexedName和name值一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">    <span class="comment">// 表示下标: 若不是集合或者Map，则为空</span></span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="comment">// 表示子表达式: user.id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-MetaClass"><a href="#3-MetaClass" class="headerlink" title="3.MetaClass"></a>3.MetaClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reflector reflector;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">      <span class="comment">// 通过这个反射工厂来创建一个反射器</span></span><br><span class="line">      <span class="keyword">this</span>.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectorFactory</code>这个反射工厂的主要作用是对<code>Reflector</code>反射器进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultReflectorFactory</span> <span class="keyword">implements</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> classCacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">        <span class="comment">// 如果缓存中存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Reflector"><a href="#4-Reflector" class="headerlink" title="4.Reflector"></a>4.Reflector</h3><p>根据创建的<code>Class</code>对象，解析出这个类的所有<code>get</code>、<code>set</code>方法，构造函数，所有属性字段等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">      type = clazz;</span><br><span class="line">      addDefaultConstructor(clazz);</span><br><span class="line">      addGetMethods(clazz);</span><br><span class="line">      addSetMethods(clazz);</span><br><span class="line">      addFields(clazz);</span><br><span class="line">      readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">      writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">      <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis的MetaObject反射工具类&quot;&gt;&lt;a href=&quot;#mybatis的MetaObject反射工具类&quot; class=&quot;headerlink&quot; title=&quot;mybatis的MetaObject反射工具类&quot;&gt;&lt;/a&gt;mybatis的MetaObject反射工具类&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;MetaObject&lt;/code&gt;是&lt;code&gt;mybatis&lt;/code&gt;中用于处理反射相关的工具类，通过&lt;code&gt;MetaObject&lt;/code&gt;就可以进行获取和设置对象值。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis执行器</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/</id>
    <published>2022-11-22T14:13:58.000Z</published>
    <updated>2022-11-28T02:50:00.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis执行器"><a href="#mybatis执行器" class="headerlink" title="mybatis执行器"></a>mybatis执行器</h1><span id="more"></span><p>在<code>mybatis</code>中包含四大件是指<strong>：executor, statementHandler,parameterHandler，resultHandler对象</strong>。</p><p>它们都是sqlSession的底层类实现，本篇的重点是了解一下<code>executor</code>执行器的作用和一些原理。</p><p>在<code>mybatis</code>中有三类执行器：</p><ul><li>简单执行器：<code>SimpleExecutor</code>，是执行器的默认实现，继承了<code>BaseExecutor</code>抽象类，利用<code>StatementHandler</code>完成。每次调用执行方法都会构建一个<code>StatementHandler</code>，并预设参数，然后执行。</li><li>可重用执行器：<code>ReuseExecutor</code>，可重复使用<code>JDBC</code>中<code>Statement</code>，减少预编译次数。该执行器在执行<code>SQL</code>时会把<code>Statement</code>缓存起来，如果下次碰到相同的SQL，就会取出来使用。</li><li>批处理执行器：<code>BatchExecutor</code>，每次的执行操作 不会立即提交到数据库，而是把对应的<code>Statement</code>对象填充好参数之后暂存起来。调用<code>doFlushStatements</code>的时候一次性提交到数据库，可用于批处理插入的场景。</li></ul><p><img src="https://s2.loli.net/2022/11/22/meG7dva9NcRCg8U.png" alt="执行器.png"></p><p>执行器的顶层接口为<code>Executor</code>，它定义了数据修改、数据查询、缓存维护等基本功能，还有一些辅助的API接口，比如提交事务、回滚事务等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单列几个接口，还有一些没列出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象接口<code>BaseExecutor</code>实现<code>Executor</code>并提供一些通用能力，比如有一级缓存，获取连接等。比如针对查询来说，它实现了顶层接口的<code>query</code>方法，并实现一级缓存的相关逻辑，若缓存查询不同，通过<code>doQuery</code>方法，下放给具体实现子类，也就是说，子类只需要实现具体的<code>doQuery</code>方法。</p><p>在<code>mybatis</code>中有三种执行器，分别为简单执行器、可重用执行器、批处理执行器。在这种结构下，若希望添加一级缓存应该如何处理？可以在<code>BaseExecutor</code>上层抽象一层接口，这个抽象接口实现二级缓存的逻辑。但是<code>mybatis</code>不采用这种方式，它通过装饰者模式，构建<code>CachingExecutor</code>类实现于<code>Executor</code>接口，并将<code>Executor</code>作为他的一个属性，当自身的二级缓存获取不到值时，调用<code>delegate</code>的同名方法，进入具体的执行器中。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p><img src="https://s2.loli.net/2022/11/23/tVWrlBgjGM7L21F.png" alt="一级缓存.png"></p><p>​    一级缓存实际上就是一个<code>HashMap</code>，根据一些相关的参数信息生成一个<code>key</code>，结果集为值的<code>hashMap</code>。它的<code>CacheKey</code>的主要参数为<code>statementID</code>，<code>SQL</code>，执行参数等，所以有时候尽管是一模一样的<code>SQL</code>也不会命中<code>mybatis</code>的一级缓存。</p><p>​    <code>mybatis</code>的代码是极其精简的，这是仅是使用<code>HashMap</code>来存储一级缓存的内容，它甚至都不使用<code>concurrentHashMap</code>，这是因为<code>SqlSession</code>本身就不是线程安全的，对于<code>SqlSession</code>来说他需要创建一个执行器，执行器对应于一条<code>statementID</code>，如果出现并发，两个线程获取同一个<code>SqlSession</code>，那么就有可能导致执行器中绑定的<code>statementId</code>不一致，导致得到一级缓存的返回类型值不一样，从而报错。并且<code>SqlSession</code>获取对应的<code>JDBCConnection</code>连接同时得到事务，如果两个线程获取同一个线程，那么就表示两个线程拥有同一个事务，所以<code>SqlSession</code>不是线程安全了，在<code>Spring</code>中通过很多的手段去保证并发情况下<code>SqlSession</code>的线程安全。</p><p>​    所以一级缓存是与会话相关，如果会话被关闭，那么一级缓存就失效。</p><p><img src="https://s2.loli.net/2022/11/23/B5TGkf1XstumUOF.png" alt="一级缓存执行流程.png"></p><p>​    由<code>mybatis</code>生成对应的<code>mapper</code>的动态代理，在执行对应的<code>SQL</code>方法时，开启一个<code>SqlSession</code>会话，通过会话和相关信息开启一个执行器，在执行器中先调用<code>BaseExecutor#query()</code>，具体的一级缓存逻辑就是在<code>query()</code>方法中，如果一级缓存中获取不到，调用执行器实现子类的<code>doQuery()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserMapper mapper = context.getBean(UserMapper.class);</span><br><span class="line">        User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看一段结合<code>Spring</code>之后的缓存问题，测试结果为<code>false</code>，说明一级缓存没有生效，这是由于<code>Spring</code>在每次执行具体的调用时都自动进行了事务的提交，也就是说每执行一次<code>selectById</code>就会开启一次会话。所以很多人会说在<code>Spring</code>集成了<code>mybatis</code>之后，<code>mybatis</code>的一级缓存失效了。</p><p>​    那么如果就是想在<code>Spring</code>中使用<code>mybatis</code>的一级缓存。可以通过手动开启事务的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpringTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    DataSourceTransactionManager transactionManager = (DataSourceTransactionManager)context.getBean(<span class="string">&quot;txManager&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动开启事务</span></span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line"></span><br><span class="line">    User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Spring</code>中对<code>Mapper</code>做了一些动态代理的处理，通过<code>getBean()</code>获取到的<code>UserMapper</code>对象实际上已经是被<code>Spring</code>动态代理过的对象，</p><p><img src="https://s2.loli.net/2022/11/23/jzn7olaNiGMetWy.png" alt="spring结合mybatis会话.png"></p><ul><li><code>Mapper</code>：是被<code>spring</code>修改过的动态代理对象，做一些<code>statementID</code>相关预处理等操作。</li><li><code>SqlSessionTemplate</code>：它实现了<code>SqlSession</code>接口，并将数据库的相关操作，比如<code>query</code>、<code>update</code>、<code>insert</code>转发给具体的<code>sqlSession</code>。而它的能力为拦截之后获取对应的<code>sqlSession</code>会话对象。</li><li><code>SqlSessionFactory</code>：去创建对应的事务、执行器，然后返回<code>DefaultSqlSession</code>对象。</li></ul><p>那么现在来看一些<code>spring</code>使得<code>mybatis</code>一级缓存没有生效的具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略一些代码..</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个SqlSessionHolder，这个是存储在ThreadLocal对象中</span></span><br><span class="line"><span class="comment">// 也就是说它是跟线程绑定，与事务和线程绑定的原理对应上  </span></span><br><span class="line">SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里获取对应的session</span></span><br><span class="line">SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在<code>sessionHolder</code>处如果获取到对应的<code>session</code>则直接返回，如果获取不到则创建一个新的<code>session</code>,所以这里实际上事务决定了会话，如果事务被提交，则事务被删除，也就导致<code> session</code>会话被删除，如果一个事务一直不提交，那么在这个事务内的所有数据库操作就会触发一级缓存的相关逻辑。  </p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>​    二级缓存也称作是应用级缓存，与一级缓存不同的是它的作用范围是整个应用，而且可以跨线程调用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。由于二级缓存的作用范围是整个应用，所以需要为二级缓存考虑溢出淘汰的机制，而一级缓存的生命周期是一个会话，所以并没有特别为一级缓存考虑淘汰机制。</p><p>​    <img src="https://s2.loli.net/2022/11/24/w7NDM1HQ8ceiSYC.png" alt="二级缓存功能.png"></p><ul><li>过期清理：清理一些存放时间过久的数据，设置一个有效期，对超过有效期的缓存进行清理。</li><li>线程安全：二级缓存是跨线程使用的，所以需要考虑到线程安全的问题。</li><li>命中率统计：根据命中率统计来给用户提供反馈，告诉用户某次查询是否命中了缓存。</li></ul><p><img src="https://s2.loli.net/2022/11/24/ynvgEjMatCF6hHx.png" alt="二级缓存设计结构.png"></p><p>通过装饰者模式结合责任链的方式来实现二级缓存。每一种类型的缓存都是单一职责，当做完自己本身需要做的事情之后，就将需要缓存的相关参数等信息传递给责任链的下一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      这是缓存的顶层接口，非常简单，它通过接口屏蔽了复杂的底层调用，在使用的过程中，只需要通过这个接口<code>Cache</code>进行相关缓存的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache cache = configuration.getCache(<span class="string">&quot;cn.com.xiaocainiaoya.mapper.UserMapper&quot;</span>);</span><br><span class="line">    User user = Mock.newUser();</span><br><span class="line">    cache.putObject(<span class="string">&quot;cacheTest&quot;</span>, user);<span class="comment">// 设置缓存</span></span><br><span class="line">    cache.getObject(<span class="string">&quot;cacheTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/24/96SgDRdh4eLoFVQ.png" alt="二级缓存.png"></p><p>1.<code>chcheEnabled</code>：全局缓存开关，只要这个参数配置了<code>false</code>，整个二级缓存就关闭。</p><p>2.<code>useCache</code>：表示当前的<code>statement</code>要不要使用缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flushCache</code>：在查询时，将整个二级缓存清空。注意是整个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(flushCache = Options.FlushCachePolicy.TRUE)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectByid2在没有配置flushCache的情况下，也是命中不了缓存的。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询1</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    UserMapper mapper1 = session1.getMapper(UserMapper.class);</span><br><span class="line">    mapper1.selectByid2(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// flush cache清空</span></span><br><span class="line">    User user = mapper1.selectByid(<span class="number">10</span>); <span class="comment">//清空了，提交</span></span><br><span class="line">    </span><br><span class="line">    session1.commit();</span><br><span class="line">    <span class="comment">// 查询2</span></span><br><span class="line">    SqlSession session2 = factory.openSession();</span><br><span class="line">    UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line">    User use2 = mapper2.selectByid2(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>&lt;cache/&gt;</code>或<code>@CacheNamespace</code>是标记在<code>xml</code>文件或者对应的<code>mapper</code>文件，默认都是使用全限定类名作为缓存的命名空间，如果两个文件同时标记时会报错。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">&lt;cache/&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>5.在第四点中说到，对应的<code>mapper</code>文件和<code>xml</code>不能同时标记，那么如果就是想共用，那么就需要使用到缓存空间引用。<code>&lt;cache-ref/&gt;</code>或<code>CacheNamespaceRef</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">&lt;cache-ref namespace=<span class="string">&quot;cn.com.xiaocainiao.UserMapper&quot;</span> /&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>由于二级缓存是跨线程使用，所以需要在事务提交之后的数据库操作，才能命中缓存。</p><p><img src="https://s2.loli.net/2022/11/24/23OhkEWzlsTXw6j.png" alt="二级缓存脏读.png"></p><p>每一个会话都有一个事务缓存管理器，暂存区的个数取决于访问了多少个<code>mapper</code>。下方的缓存空间就是对应的<code>mapper</code>的缓存命名空间。会话一旦关闭，它所对应的事务缓存管理器就会被清理，从而导致暂存区数据被清理。在数据的操作过程，都是先操作暂存区，只有在事务提交或者事务回滚之后才会将暂存区数据提交到对应的缓存空间。</p><p>![image-20221127115857163](/Users/jiangjiamin/Library/Application Support/typora-user-images/image-20221127115857163.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个简单的代码，debug下暂存区的结构</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存的执行流程：</p><p><img src="https://s2.loli.net/2022/11/24/I4Ysoi9WlELVMK8.png" alt="二级缓存执行流程.png"></p><p>根据上图可知：查询是直接查询缓存空间，其他操作是对暂存区数据进行操作，当进行<code>commit</code>操作时将暂存区的操作数据添加到缓存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionalCache#commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出需要填充到二级缓存空间的数据，遍历进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis执行器&quot;&gt;&lt;a href=&quot;#mybatis执行器&quot; class=&quot;headerlink&quot; title=&quot;mybatis执行器&quot;&gt;&lt;/a&gt;mybatis执行器&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis处理器</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-11-22T14:13:58.000Z</published>
    <updated>2022-12-05T11:50:44.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis处理器"><a href="#mybatis处理器" class="headerlink" title="mybatis处理器"></a>mybatis处理器</h1><span id="more"></span><h2 id="一、statementHandler"><a href="#一、statementHandler" class="headerlink" title="一、statementHandler"></a>一、statementHandler</h2><p>​    <code>JDBC</code>处理器，基于<code>JDBC</code>构建<code>Statement</code>并设置参数，然后去执行具体的<code>SQL</code>语句，每调用会话当中一次<code>SQL</code>，都会有与之相对应且唯一的<code>Statement</code>实例。</p><p><img src="https://s2.loli.net/2022/11/28/OsSeqNWphfcyRGt.png" alt="statementHandler.png"></p><p><code>StatementHandler</code>为顶层接口，为<code>Statement</code>处理器相关实现设置标准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写操作</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读操作</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读游标</span></span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 辅助接口：获取动态语句</span></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 辅助接口：获取参数解析器</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseStatementHandler</code>抽取了具体子类的公共部分，比如有设置超时时间、设置获取行数等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseStatementHandler#prepare</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// BaseStatementHandler的抽象方法，由具体的子类来实现</span></span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      <span class="comment">// 根据子类返回的statement对象，来进行超时时间、获取行数的设置</span></span><br><span class="line">      setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法，由具体的子类实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>本篇中没有特殊说明都是以<code>PreparedStatementHandler</code>为例。具体的子类需要实现这个方法，使用<code>Conection</code>对象生成对应的<code>statement</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreparedStatementHandler#instantiateStatement</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">      <span class="comment">// 基于jdbc的connection#prepareStatement方法来创建PreparedStatement</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>StatementHandler执行流程：</strong></p><p><img src="https://s2.loli.net/2022/11/28/rmSGMb6WdnNoyu4.png" alt="statementHandler执行过程.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleExecutor#doQuery</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 1.通过Configuration对象创建StatementHandler对象</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 2.预处理</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 3.最后执行，对于PreparedStatement来说就是调用它的execute()方法。</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.通过<code>Configuration</code>对象创建<code>StatementHandler</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RoutingStatementHandler导航类来根据需要不同类型的statement进行创建</span></span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoutingStatementHandler#new()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.预处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的预处理接口来创建一个Statement对象</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 这里会调用参数解析器DefaultPrepareterHander来对statement对象的参数值(会经过类型转换等操作)</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后执行，对于<code>PreparedStatement</code>来说就是调用它的<code>execute()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// PreparedStatement的execute()方法。</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 执行完语句之后，使用结果集处理器对结果进行javabean的映射</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>BaseStatementHandler</code>将具体的<code>StatementHandler</code>中编写了具体子类的共性部分，实际上是由它来进行具体的<code>JDBC</code>抽象，创建它需要执行器、参数解析器、结果集处理器、动态语句等的参与。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BoundSql boundSql;</span><br></pre></td></tr></table></figure><h2 id="二、ParamenterHandler"><a href="#二、ParamenterHandler" class="headerlink" title="二、ParamenterHandler"></a>二、ParamenterHandler</h2><p>参数名称解析器<code>ParamNameResolver</code>。</p><p><b>单个参数：</b>默认不做任何处理，除非设置了<code>@Param</code></p><p><b>多个参数：</b></p><ol><li>根据参数声明的顺序将参数转换为<code>param1</code>、<code>param2</code>…</li><li>通过<code>@Param</code>指定变量名称</li><li>基于反射转换成变量名，如果不支持则根据声明的顺序转换成<code>arg0</code>、<code>arg1</code>…</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个参数情况下：</span></span><br><span class="line"><span class="comment"> *    args的值直接为这个参数的值 &#123;0, &quot;arg0&quot;&#125;</span></span><br><span class="line"><span class="comment"> * 多参数情况下：</span></span><br><span class="line"><span class="comment"> *    如果在mapper中对字段标记了<span class="doctag">@Param</span>注解并设置了对应的字段名称，则names的值为 &#123;&#123;0, &quot;field1&quot;&#125;, &#123;1, &quot;field2&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    如果没有标记<span class="doctag">@Param</span>注解，则names的值为&#123;&#123;0, &quot;arg0&quot;&#125;, &#123;1, &quot;arg1&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    所以这里仅仅是将字段名称和具体的参数值进行对应成param，实际的解析参数名的参数，在上层调用端。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// names 是一个SortMap</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果没有@Param注解，并且参数个数为1，直接返回原值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 直接将args参数中的值添加到param中</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认还会为参数根据声明的顺序设置param1， param2 ...</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不存在同名的情况下，可能有人字段名直接命名成paramX。</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">            param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所以如果不出现同名的情况，假设mapper接口设置了两个参数，那么这里返回有两份参数，</span></span><br><span class="line">        <span class="comment">// 一份要么是根据@Param解析规则，或者反射参数(启动参数) -parameters ,或者默认的arg0, arg1</span></span><br><span class="line">        <span class="comment">// 一份是param1， param2...</span></span><br><span class="line">        <span class="comment">// 要注意arg是从0下标开始，param是从1下标开始</span></span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以根据返回<code>param</code>不同的类型，使用的方式也有所不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是单个参数，那么这里的#&#123;userId&#125;,写什么都行，#&#123;param1&#125;, #&#123;arg0&#125;都可，实际上</span></span><br><span class="line"><span class="comment">// 根据就不校验名称，直接复制了</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的#&#123;name&#125;也可以写成#&#123;param1&#125;， 但是注意不能写#&#123;arg0&#125;， 因为#&#123;arg0&#125;已经变成@param</span></span><br><span class="line"><span class="comment">// 注解中的名称</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where name=#&#123;name&#125; or age=#&#123;user.age&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByNameOrAge</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;user&quot;)</span> User user)</span></span>;</span><br></pre></td></tr></table></figure><p>结合前文提到的<code>StatementHandler</code>执行流程时序图中，在<b>预处理</b>阶段，会<font color="red">为PrearedStatement设置参数</font>，来具体看一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以SimpleExecutor为例, 在调用doUpdate或者是doQuery方法创建StatementHandler之后，都会进行设置参数。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 创建statement</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 为statement设置参数</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreparedStatementHandler#parameterize</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 进入参数解析器，为statement设置参数</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就进入到了<code>ParameterHandler</code>的<code>setParameters</code>中，为创建的<code>preparedStatement</code>设置具体的参数。先来看一下<code>ParameterHandler</code>的接口，<code>ParameterHandler</code>是<code>mybatis</code>中的参数处理器，负责为<code>PreparedStatement</code>的<code>SQL</code>语句参数动态赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">// 读取参数</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 用于对PreparedStatement的参数赋值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只有一个实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个parameterObject就是前面说到通过ParameterNameSolver解析之后的对象</span></span><br><span class="line"><span class="comment">// 如果是单个参数，就是具体的值</span></span><br><span class="line"><span class="comment">// 如果是多个参数就是一个map对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getParameterObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parameterObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  <span class="comment">// parameterMappings是对具体执行语句的映射，将将要执行的语句映射成ParamterMapping对象，</span></span><br><span class="line">  <span class="comment">// 将具体需要填充的参数#&#123;&#125;解析出来，形成参数列表</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数化sql就需要进行参数设置，遍历这个参数列表，将参数设置到PreparedStatement中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="comment">// ParameterMode.OUT 存储过程的参数模式</span></span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        <span class="comment">// 声明value，最后就是将这个值设置到PreparedStatement中</span></span><br><span class="line">        Object value; </span><br><span class="line">        <span class="comment">// 获取执行语句声明的#&#123;&#125;中的参数变量名称</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; </span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 多个参数会走到这里，将map对象，转换成MetaObject对象，就可以直接通过字段名称来获取具体的值  </span></span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从parameterMapping获取TypeHandler类型转换器对象</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        <span class="comment">// 从TypeHandler类型转换器中获取对应的数据库类型</span></span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TypeHandler.setParameter实际上最后会调用到PreParedStatement.set*()方法，为要执行的语句绑定参数值</span></span><br><span class="line">          <span class="comment">// 比如说TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setBigDecimal(i, parameter);</span></span><br><span class="line">          <span class="comment">// TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setByte(i, parameter);</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>debugger</code>了解一下<code>ParameterMapping</code>中的内容： 主要是将<code>mybatis</code>在<code>SQL</code>或者是在实体上设置的一些配置进行映射，包含有字段名称、<code>javaType</code>数据类型、<code>jdbcType</code>数据库类型，<code>typeHandler</code>类型处理器等。</p><p><img src="https://s2.loli.net/2022/12/05/VkmnT5IjZgsGvP9.png" alt="parameterMapping.png"></p><h2 id="三、ResultHandler"><a href="#三、ResultHandler" class="headerlink" title="三、ResultHandler"></a>三、ResultHandler</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis处理器&quot;&gt;&lt;a href=&quot;#mybatis处理器&quot; class=&quot;headerlink&quot; title=&quot;mybatis处理器&quot;&gt;&lt;/a&gt;mybatis处理器&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis控制部分字段不打印</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/</id>
    <published>2022-11-13T14:13:58.000Z</published>
    <updated>2022-11-14T01:39:24.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis控制部分字段不打印"><a href="#mybatis控制部分字段不打印" class="headerlink" title="mybatis控制部分字段不打印"></a>mybatis控制部分字段不打印</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在<code>MySQL</code>的一些执行打印了<code>text</code>等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭<code>mybatis</code>的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为<code>text</code>等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。</p><span id="more"></span>    <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    具体的<code>mybatis</code>的几个核心组件执行流程这里不过多介绍，这里仅简单说明一条<code>SQL</code>的执行，是要先经过参数解析器，将具体的参数和数据类型解析处理，而后通过执行器，通过<code>Statement</code>或者是<code>PrepareStatement</code>等进行执行之后，再由结果集处理器进行结果映射相关逻辑。</p><p>​    在跟踪了一下<code>mybatis</code>的执行代码之后发现，日志的打印逻辑是在执行器<code>Executor</code>中，而数据类型相关的处理是在参数解析器中，也就是说如果想做到部分字段不打印，就需要在执行器中修改打印的逻辑。</p><p>我这边测试的是通过<code>PreparedStatement</code>方式进行插入数据，处理打印的类是<code>PreparedStatementLogger</code>的<code>invoke</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 打印数据在这里</span></span><br><span class="line">        debug(<span class="string">&quot;Parameters: &quot;</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... 省略很多无效代码</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用父类<code>BaseJdbcLogger</code>的<code>getParameterValueString</code>方法获取要打印的数据。可以看到这里就是直接将<code>columnValues</code>列表中的值进行拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">  <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      typeList.add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      typeList.add(objectValueString(value) + <span class="string">&quot;(&quot;</span> + value.getClass().getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">  <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，由于这个地方并没有提供扩展点，所以如果我想要打印的时候忽略某些类型的字段，我需要重写这个类，再有我需要在这里能获取到对应的数据类型，尝试之后发现，这个对象中主要是有一个<code>Map</code>对象，键是序号（填充最后执行<code>SQL</code>的序号），值就是对应要填充<code>SQL</code>的值。所以单纯的重写这个类型，获取不到对应的类型，也就无法进行类型的判断，所以需要外层这个类的地方，将执行<code>SQL</code>的类型信息传进来。</p><p><b>类型相关信息是解析到了<code>BoundSql</code>对象中。所以需要想方设法的将<code>BoundSql</code>对象传进来</b>，这个<code>PreparedStatementLogger</code>的创建和被调用并不是在同一个时间节点，也就是说将类型相关参数传进来有两种手段，一种是在<code>PreparedStatementLogger</code>创建的时候，跟着原本构造函数相关的参数带进来，另一种是在<code>invoke</code>方法在调用之前传进来。当然了根据尝试，否定了第一种方式，原因是创建这个对象的地方也没有类型相关信息。</p><p>后来发现在<code>PreparedStatementLogger#invoke</code>方法被调用之前是可以获取到<code>BoundSql</code>对象，调用的地方是<code>PreparedStatementHandler</code>的<code>update</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里是动态代理，通过这里进入到PreparedStatementLogger#invoke中</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只需要在这里做文章，将<code>BoundSql</code>对象传到<code>PreparedStatementLogger</code>中基本上就可以达到目的。</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p>1.将<code>PreparedStatementLogger</code>拷贝到应用的类路径下，并创建同名类路径<code>org.apache.ibatis.logging.jdbc.PreparedStatementLogger</code>类，然后添加一个属性字段<code>BoundSql</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BoundSql boundSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略很多代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同样，将<code>PreparedStatementHandler</code>拷贝到应用类路径下，并创建同名类路径<code>org.apache.ibatis.executor.statement.PreparedStatementHandler</code>，并在执行前设置<code>boundSql</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里获取到的是PreparedStatementLogger的动态代理对象，所以需要获取到被代理对象target</span></span><br><span class="line">  <span class="comment">// 然后判断被代理对象是否为PreparedStatementLogger，是的话就赋值boundSql</span></span><br><span class="line">  <span class="keyword">if</span> (Proxy.isProxyClass(statement.getClass())) &#123;</span><br><span class="line">    MetaObject metaObject = SystemMetaObject.forObject(statement);</span><br><span class="line">    Object target = metaObject.getValue(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> PreparedStatementLogger)&#123;</span><br><span class="line">      PreparedStatementLogger preparedStatementLogger = (PreparedStatementLogger) target;</span><br><span class="line">      preparedStatementLogger.boundSql = boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后在需要忽略日志打印的实体字段上标记能识别到<code>jdbcType</code>的注解，我这里用的是<code>tk.mybatis</code>，所以标记注解是<code>tk.mybatis.mapper.annotation.ColumnType</code>。如果用的是<code>mybatis-plus</code>应该是<code>com.baomidou.mybatisplus.annotation.TableField</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;GROUP_ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;PROJECT_ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="meta">@ColumnType(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="keyword">private</span> String extraInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的打印逻辑我这里就不去写了，附一张到这里的断点图，到这里已经能获取到字段的类型和字段的值。</p><p><img src="https://s2.loli.net/2022/11/14/Kp4nfxJ5MHWEekQ.png" alt="mybaits控制字段打印.png"></p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>​    这里通过自己定义了与<code>mybatis</code>中相关的包路径和同名类来达到替换第三方<code>jar</code>包中的同名对象。原理实际上就是<code>jdk</code>的类加载机制，采用的是双亲委派模型，如果一个类加载器收到了需要加载类的请求，它不会马上进行解析，而是把这个请求委派给父类去加载，每一个层级的类加载器都是入参，当最上层加载器无法解析之后，它才会一层一层往下委派。</p><p>​    比如<code>java.lang.Object</code>存放在<code>rt.jar</code>中，如果编写另一个<code>java.lang.Object</code>并放到<code>ClassPath</code>中，编译上是没有问题的，但是由于双亲委派模型，当获取<code>java.lang.Object</code>时会委派到最上级的启动类加载器，而类路径<code>ClassPath</code>是应用程序类加载器。</p><p>​    但是对于上面重写的两个类，使用到的都是应用程序类加载器，但是如果在在应用<code>ClassPath</code>下创建同名路径，那么编译之后，代码是在<code>classes</code>文件夹中，而第三方包是在<code>lib</code>文件夹中，这里加载类进行查找对应<code>.class</code>文件时也有一个优先级的关系，会优先获取<code>classes</code>中的<code>.class</code>文件。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;a href=&quot;#mybatis控制部分字段不打印&quot; class=&quot;headerlink&quot; title=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;/a&gt;mybatis控制部分字段不打印&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在&lt;code&gt;MySQL&lt;/code&gt;的一些执行打印了&lt;code&gt;text&lt;/code&gt;等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭&lt;code&gt;mybatis&lt;/code&gt;的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为&lt;code&gt;text&lt;/code&gt;等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>nacos简单入门</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-27T13:04:58.000Z</published>
    <updated>2022-10-28T02:42:43.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nacos入门"><a href="#nacos入门" class="headerlink" title="nacos入门"></a>nacos入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近闲来无事看到一篇关于<code>DynamicTp</code>动态可监控线程池框架，也去<code>DynamicTp</code>官网看了一下，发现原来跟<code>Hutool</code>出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中<code>apollo</code>已经使用比较多，所以这次想尝试一下使用<code>nacos</code>。<span id="more"></span></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>​    因为我使用的是<code>mac</code>，且安装了<code>docker</code>和<code>kitematic</code>，本以为只需要从容器仓库中拉一个<code>nacos</code>的镜像就大工告成，没想到，事情没有我想象的那么顺利，还是一波三折。</p><p>​    通过<code>kitematic</code>直接搜索<code>nacos</code>镜像，并下载启动。</p><p><img src="https://s2.loli.net/2022/10/27/DqZVrThs5FeLSip.png" alt="nacos部署.png"></p><p>启动后直接报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No DataSource set</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.DumpService.dumpOperate(DumpService.java:236)</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.ExternalDumpService.init(ExternalDumpService.java:52)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)</span><br><span class="line">... 53 common frames omitted</span><br></pre></td></tr></table></figure><p>看报错信息，大概率是数据连接的问题，到目前为止，容器是镜像下载之后直接启动的，我并没有配置数据库连接相关信息，到这里，我第一反应是将<code>nacos</code>的部分文件/文件夹挂载到宿主机，修改是也方便，但是对于容器的修改挂载点有点复杂，有的说去修改底层的那个<code>config.v2.json</code>文件，有的说通过<code>export</code>修改，不知道是我操作有问题还是怎么样，我尝试了之后是没有成功。后面我是将这个运行容器删掉，利用镜像重新启动一个容器，这时就可以指定对应的挂载卷，本来想把整个<code>/nacos</code>文件夹都挂载出来，但是指定之后，死活报错，某个文件找不到，启动失败，无奈只能走最下策，进入容器操作。</p><p>所以进入容器中，查看相关配置信息。</p><p>进入容器中定位到<code>/home/nacos/conf/application.properties</code>，不同容器应该会不太一样，但是大概率是在<code>~/nacos/conf</code>文件夹。</p><p>想将<code>conf</code>文件夹下的数据库脚本文件<code>shcema.sql</code>脚本，拿到数据库中执行之后，在修改<code>application.properties</code>文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">$&#123;SERVER_SERVLET_CONTEXTPATH:/nacos&#125;</span></span><br><span class="line"><span class="meta">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">$&#123;NACOS_APPLICATION_PORT:8848&#125;</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">$&#123;SPRING_DATASOURCE_PLATFORM:mysql&#125;</span></span><br><span class="line"><span class="meta">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="meta">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="meta">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">$&#123;MYSQL_DATABASE_NUM:1&#125;</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://$&#123;MYSQL_SERVICE_HOST:docker.for.mac.host.internal&#125;:$&#123;MYSQL_SERVICE_PORT:32786&#125;/$&#123;MYSQL_SERVICE_DB_NAME:nacos&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&#125;</span></span><br><span class="line"><span class="comment"># db.url.1=jdbc:mysql://$&#123;MYSQL_SERVICE_HOST&#125;:$&#123;MYSQL_SERVICE_PORT:3306&#125;/$&#123;MYSQL_SERVICE_DB_NAME&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&#125;</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">$&#123;MYSQL_SERVICE_USER:root&#125;</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">$&#123;MYSQL_SERVICE_PASSWORD:root&#125;</span></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">$&#123;NACOS_AUTH_SYSTEM_TYPE:nacos&#125;</span></span><br></pre></td></tr></table></figure><p>填写上数据库相关信息之后，重启还是报错，在这个地方磨了好久，一直想不明白为什么数据库连接不上。</p><p>这里主要原因是因为我的<code>mysql</code>数据库不是直接安装在本机上，也是通过<code>docker</code>容器部署，所以我最开始的时候通过<code>nacos</code>容器去<code>ping</code>连接<code>mysql</code>的容器，在<code>ping</code>通的情况下，我以为<code>nascos</code>容器通过<code>mysql</code>容器的<code>ip</code>可以直接访问到数据库。一直报错之后，使用<code>telnet</code>命令查看端口是否可访问时，报错了，才发现了问题。</p><p>按我理解，访问不到的原因可能是如果<code>ip</code>写的是<code>mysql</code>容器的<code>ip</code>，那么端口应该写哪个合适?是写容器对应开放的端口，还是写宿主机绑定的端口？我两种都尝试了一次，结果都是访问不到。所以将访问<code>ip</code>修改为访问宿主机<code>ip</code>+宿主机绑定<code>mysql</code>容器的端口，这种方式是可以访问到的。</p><p>这里必须安利一波<code>mac</code>上的<code>docker</code>和<code>kitematic</code>，基本上所有的类似组件，比如<code>rabbitmq</code>，<code>mysql</code>，<code>redis</code>，<code>jenkins</code>，<code>nexus3</code>等我都是通过容器化部署，只需要把对应的数据卷挂载到宿主机，保证重启是数据不丢失即可，好处当然多多，一是干净，二是简单。</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><blockquote><p>127.0.0.1:4567/nacos/index.html</p></blockquote><p><code>nacos</code>的默认账号和密码都是<code>nacos</code></p><p><img src="https://s2.loli.net/2022/10/27/IM5EVBWFh98iYw4.png" alt="nacos登录页.png"></p><p>在<code>nacos</code>中有命名空间和分组的概念，每一个命名空间中可以划分多个组，在<code>spring</code>配置文件中，可以指定需要拉取哪个命名空间下的那个组的配置。</p><p>通过『命名空间』创建<code>dev</code>、<code>test</code>命名空间之后，在『配置列表』会显示出对应的命名空间。</p><p><img src="https://s2.loli.net/2022/10/27/ymrj5ZHOnDb7cpo.png" alt="nacos配置列表.png"></p><h2 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h2><p>引入<code>nacos</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类启用<code>nacos</code>配置注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@NacosPropertySource(dataId = &quot;simple-dev-yaml&quot;, groupId = &quot;DEV_GROUP&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootSimpleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootSimpleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件添加<code>nacos</code>服务器访问地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nacos.config.server-addr</span>=<span class="string">127.0.0.1:4567</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NacosValue(value = &quot;$&#123;useLocalCache:false&#125;&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useLocalCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useLocalCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是想使用一下<code>nacos</code>，所以采用的都是最简单的写法，写死的方式指定了<code>dataId</code>和<code>groupId</code>，在实际的使用中一般都是使用配置文件来进行管理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nacos入门&quot;&gt;&lt;a href=&quot;#nacos入门&quot; class=&quot;headerlink&quot; title=&quot;nacos入门&quot;&gt;&lt;/a&gt;nacos入门&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近闲来无事看到一篇关于&lt;code&gt;DynamicTp&lt;/code&gt;动态可监控线程池框架，也去&lt;code&gt;DynamicTp&lt;/code&gt;官网看了一下，发现原来跟&lt;code&gt;Hutool&lt;/code&gt;出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中&lt;code&gt;apollo&lt;/code&gt;已经使用比较多，所以这次想尝试一下使用&lt;code&gt;nacos&lt;/code&gt;。</summary>
    
    
    
    <category term="nacos" scheme="http://xiaocainiaoya.github.io/categories/nacos/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatis-plus特性</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/</id>
    <published>2022-10-14T14:13:58.000Z</published>
    <updated>2022-11-14T01:43:44.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-plus特性"><a href="#mybatis-plus特性" class="headerlink" title="mybatis-plus特性"></a>mybatis-plus特性</h1><span id="more"></span><h2 id="1-字段类型转换器"><a href="#1-字段类型转换器" class="headerlink" title="1.字段类型转换器"></a>1.字段类型转换器</h2><p>如果出现实体字段类型与数据库类型不一致情况，比如实体是<code>String</code>但是数据库是<code>Date</code>，或者实体中是对象，而数据库中是<code>varchar</code>存储<code>json</code>；则可以通过字段类型转换器进行统一转换，无需业务层在每次存取时进行手段转换。</p><p><b>1.实体上设置转换器类型(设置之后，在通过基础接口的处理都会进行转换)</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里需要设置autoResultMap = true, 否则查询时不会将数据库中的json转换为对应实体</span></span><br><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">    <span class="comment">// 设置转换器的类型,这个是内置转换器,也可以自定义</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserExtraInfo userExtraInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.第一步骤中的设置仅导致通过内置接口的处理会进行转换，但是通过自定义XML的脚本语句不会进行转换。</b><br>法一：在<code>mapper</code>语句上通过<code>@Results</code>设置对应的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Results(value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;user_extra_info&quot;, property = &quot;userExtraInfo&quot;, typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：需要在<code>xml</code>文件中配置<code>resultMap</code>结果集，并在结果集映射中设置对应的类型转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.entity.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MOBILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deleteStatus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DELETE_STATUS&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userExtraInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;USER_EXTRA_INFO&quot;</span> <span class="attr">typeHandler</span> = <span class="string">&quot;com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testXmlSql&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-基础类扩展"><a href="#2-基础类扩展" class="headerlink" title="2.基础类扩展"></a>2.基础类扩展</h2><p>直接通过继承<code>mybatis-plus</code>提供的三层基础接口，可以直接具备一些数据操作能力，比如通过<code>deleteById</code>可以直接通过<code>id</code>删除记录，无需编写<code>SQL</code>语句。同时<code>mybatis-plus</code>还提供了对基础层的扩展，用户可自定义扩展点后，业务处理再继承于自定义的扩展点，使得系统应用具备自定义扩展底层接口的能力。<br><img src="https://s2.loli.net/2022/10/14/eropFI59y32lt4k.png" alt="mybatis-plus基础接口扩展.png"></p><p>上图中<code>userFacade</code>、<code>userService</code>、<code>userMapper</code>是业务层；<code>customerService&lt;User&gt;</code>、<code>CustomerServiceImpl</code>、<code>CustomerMapper</code>是自定义扩展层；<code>IService&lt;T&gt;</code>、<code>ServiceImpl</code>、<code>BaseMapper</code>是<code>mybatis-plus</code>的三次基础接口。</p><p><b>假设现在要扩展<code>Insert ignore</code>的插入语句</b></p><p><b>1.继承<code>AbstractMethod</code>编写具体<code>SQL</code>的拼写等处理：</b>可以参考原有的其他对<code>AbstractMethod</code>的实现，比如<code>com.baomidou.mybatisplus.core.injector.methods</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIgnore</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        CustomerSqlMethod sqlMethod = CustomerSqlMethod.INSERT_IGNORE_ONE;</span><br><span class="line">        String columnScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlColumnMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlPropertyMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(tableInfo.getKeyProperty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(sqlMethod.getMethod(), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, sqlMethod.getMethod(), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置自定义<code>SQL</code>注入器并注入到<code>Spring</code>容器：</b>将步骤一中创建的具体<code>SQL</code>执行器注入到<code>mybatis-plus</code>相应处理中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">iSqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomerSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.创建扩展的<code>mapper</code>层：</b>添加需要扩展的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>service</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>serviceImpl</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insertIgnore(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>5.到这里，业务层只要继承于扩展层，就具备了自定扩展的处理能力</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> <span class="keyword">extends</span> <span class="title">CustomerService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserExtraInfo userExtraInfo = UserExtraInfo.builder()</span><br><span class="line">                .address(<span class="string">&quot;北京市&quot;</span>)</span><br><span class="line">                .city(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                .id(<span class="string">&quot;12312311&quot;</span>)</span><br><span class="line">                .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                .mobile(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .deleteStatus(<span class="number">0</span>)</span><br><span class="line">                .userExtraInfo(userExtraInfo)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 这里就可以直接调用到扩展的接口</span></span><br><span class="line">        insertIgnore(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-逻辑删除"><a href="#3-逻辑删除" class="headerlink" title="3.逻辑删除"></a>3.逻辑删除</h2><p>只需要设置<code>@TableLogic</code>就具备了逻辑删除的能力，但是这仅限制与通过<code>mybatis-plus</code>的基础接口处理数据，如果是通过<code>xml</code>手写<code>SQL</code>是无法自动补充逻辑删除条件。</p><ul><li>插入语句不处理，也就是说默认值需要业务方插入或者通过数据库设置默认值来处理</li><li>查找、更新会追加查询条件</li><li>删除转为更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置逻辑删除字段</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis-plus特性&quot;&gt;&lt;a href=&quot;#mybatis-plus特性&quot; class=&quot;headerlink&quot; title=&quot;mybatis-plus特性&quot;&gt;&lt;/a&gt;mybatis-plus特性&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mysql问题汇总</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-10-11T14:13:58.000Z</published>
    <updated>2022-10-11T07:42:47.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL单表数据数据最大两千万？"><a href="#MySQL单表数据数据最大两千万？" class="headerlink" title="MySQL单表数据数据最大两千万？"></a>MySQL单表数据数据最大两千万？</h2><p>相比大家也有听说过<code>MySQL</code>单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。<span id="more"></span></p><p>其实这种说法的背后是索引高度的问题，<code>MySQL</code>索引内部使用的是<code>B+</code>树，叶子节点存具体的数据，非叶子节点是为了去叶子节点寻址。<code>MySQL</code>的数据是按页存储，每一页的大小是16k，读取的时候也是按页读取，也就是说就算你的语句里有<code>limit 1</code>，但是实际上也是将整页都加载到内存中。</p><p>这个16k大小的页包含有页头（页号，寻址指针等内容）、页尾（检验码等）、页目录（这一页内的数据目录，用于快速找到页内数据），剩下的空间就是存放具体的数据记录<code>record</code>。结合<code>B+</code>树的特性，非叶子节点内具体的数据记录<code>record</code>实际上存储的某一页的页号以及这一页的最小记录的<code>id</code>值。叶子节点内具体的数据记录<code>record</code>实际上存储的是行信息(再具体到存储的是行记录的多少内容，要看是什么索引)。</p><p>所以想查询某一行数据的主要过程：从索引的根往下找，先根据非叶子节点的<code>id</code>值匹配，匹配到对应的<code>id</code>值之后根据页号，找到对应的叶子节点，从而获取到整行数据。</p><p>当数据庞大时，树的叶子节点如果想要容纳所有数据就需要增加高度，高度越高，能容纳的数据量也就越大。同时也伴随着更多的磁盘io，一般3层索引树，会有3次磁盘io，并且是随机io。<br>这里有一个计算公式：<code>(x ^ (z-1)) * y</code></p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的<code>record</code>数量为<code>y</code></li><li><code>B+</code>树的层数为<code>z</code></li></ul><p><b>x的值：</b>主键假设是bigint（8Byte），而页号在源码里叫FIL_PAGE_OFFSET（4Byte），那么非叶子节点里的一条数据是12Byte左右，整个数据页16k， 页头页尾那部分数据全加起来大概128Byte，加上页目录毛估占1k吧。那剩下的15k除以12Byte，等于1280，也就是可以指向x=1280页。<br><b>y的值：</b>叶子节点和非叶子节点结构是一致的，这里也假设记录可用空间为15k，假设一行数据需要占用1k空间，那么叶子节点可用容纳15行的数据。</p><p>根据公式：<br>若z=2，则(1280 ^ (2-1)) * 15 ≈ 2w<br>若z=3，则(1280 ^ (3-1)) * 15 ≈ 2.5kw<br>这里的<code>2.5kw</code>也就是通常说的单表数据不要超过2kw的估值，如果高度再加一层，那么所能容纳的数据量就更加庞大。但是你有没有发现，我假设了单行数据的空间是1k，如果表字段不多，单行数据仅0.25k呢，那么这个计算结果就是1亿，也就是在三层高度的情况下，数据量也有可能达到1亿。</p><h2 id="随机IO-顺序IO"><a href="#随机IO-顺序IO" class="headerlink" title="随机IO/顺序IO"></a>随机IO/顺序IO</h2><p>顺序IO是指读写操作的访问地址连续。随机IO是指读写操作的时间连续，但访问的地址不连续。</p><h2 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h2><p>深度分页涉及到的问题通常是使用<code>limit offset, size</code>，对于<code>limit 10, 10</code>和<code>limit 10000, 10</code>，性能上前者是快于后者的，这是因为后者也是需要查出10000条数据，然后丢弃掉，再往后获取10条数据，也就是说前者总共获取了20条数据，后者获取了10010条数据。</p><p>这种情况其实是无解的，因为这是<code>MySQL</code>的内部逻辑，我们根本就触及不到，但是在一定条件下，可以通过一定的手段进行优化。假设有语句：</p><blockquote><p>select * from page order by id limit 10000, 10;</p></blockquote><p>这条查询语句还是有优化空间的，由于这里需要查询整行数据，也就导致了丢弃的10000行数据也去查询了整行数据，实际上这是没有必要的。<br>优化如下，虽然它也是会获取那丢弃的10000条数据，但是这10000条数据仅获取了id值，并没有获取整行数据，当行数据比较长时，还是会有一定的性能提升。</p><blockquote><p>select * from page  where id &gt;=(select id from page  order by id limit 10000, 1) order by id limit 10; </p></blockquote><p>再看在非主键索引上的操作：</p><blockquote><p>select * from page order by user_name  limit 10000, 10;</p></blockquote><p>这里由于是非主键索引，所以会对这丢弃的10000条数据都进行一次回表操作，影响性能。可以通过连接来优化，减少回表次数：</p><blockquote><p>select * from page t1, (select id from page order by user_name limit 10000, 10) t2  WHERE t1.id = t2.id;</p></blockquote><p>前面的优化实际上也都会查询丢弃的10000条数据，所以这里再怎么优化都是治标不治本的优化手段。所以只能通过一些特殊手段控制，比如百度、淘宝的搜索页只会固定页码，到一定页码之后就不允许往后页码查。再比如抖音这种这种滚动下只有翻页没有跳页，可以将当前页设置一个最小值，下一页在这个最小值的基础上查询。这也是同步大表时的一个手段。</p><p>如果同步一个大表，你使用的是<code>select * from tableName</code>，同步到异构系统，比如es等，因为数据量比较大，数据库无法一次性获取到所有数据而报错，如果仅仅通过<code>limit offset, size</code>就有可能出现深度分页的情况，所以一般来说可以通过<code>id</code>排序，将<code>id</code>对应的记录分块，当前块的最大<code>id</code>值，作为下一块<code>id</code>的查询条件。</p><blockquote><p>select * from tableName where id &gt; 上一块id的最大值 order by id limit 100</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;a href=&quot;#MySQL单表数据数据最大两千万？&quot; class=&quot;headerlink&quot; title=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;/a&gt;MySQL单表数据数据最大两千万？&lt;/h2&gt;&lt;p&gt;相比大家也有听说过&lt;code&gt;MySQL&lt;/code&gt;单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（五）---排序</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/</id>
    <published>2022-10-09T14:13:58.000Z</published>
    <updated>2022-10-09T08:50:06.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（五）—排序"><a href="#mysql45讲学习总结（五）—排序" class="headerlink" title="mysql45讲学习总结（五）—排序"></a>mysql45讲学习总结（五）—排序</h1><p>​<br>本篇记录<code>MySQL</code>在执行<code>order by</code>语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。</p><span id="more"></span><h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><blockquote><p>select name, age, address from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>使用<code>explain</code>分析该语句：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>bid_confirm_project</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4033</td><td>10</td><td>Using where; Using filesort</td></tr></tbody></table><p><code>Using filesort</code>：表示需要排序。<code>MySQL</code>会给每个线程分配一块<code>sort_buffer</code>内存空间用于排序。</p><p>假设在<code>name</code>上有索引排序流程：</p><ol><li>初始化<code>sort_buffer</code>空间，确定将用于存入字段<code>name</code>、<code>age</code>、<code>address</code>的值。</li><li>从索引<code>name</code>上找到第一个满足<code>xxx</code>条件的<code>id</code>。</li><li>根据这个<code>id</code>通过主键索引获取整行数据，将<code>name</code>、<code>age</code>、<code>address</code>的值存入到<code>sort_buffer</code>中。</li><li>从索引<code>name</code>取下一个记录的主键。</li><li>重复3,4步骤，直到从索引<code>name</code>取到的值不满足查询条件为止。</li><li>对<code>sort_buffer</code>空间的数据按照<code>age</code>进行排序。</li><li>返回结果集数据。</li></ol><p>​    <b>步骤6中按照<code>age</code>进行排序：这个可能在内存中完成，也有可能需要使用到外部排序。</b>这取决于排序所需要的内存空间大小和参数<code>sort_buffer_size</code>。如果需要排序的数据量小于<code>sort_buffer_size</code>则使用内存空间进行排序，如果需要排序的数量大于<code>sort_buffer_size</code>则需要使用磁盘临时文件辅助排序。</p><p>仅仅使用<code>explain</code>只能分析改语句是否需要排序，至于排序是在内存中排序还是在磁盘中排序就无法得知，需要使用其他手段。<b><code>MySQL</code>版本需要到5.6以上。</b></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开 optimizer_trace，只对本线程有效</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 OPTIMIZER_TRACE 输出 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`</span><br></pre></td></tr></table></figure><p>查询的结果是一个<code>json</code>结果：(<code>json</code>结果比较大，截取一段)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;filesort_summary&quot;: &#123;</span><br><span class="line">  &quot;rows&quot;: 4250,  </span><br><span class="line">  &quot;examined_rows&quot;: 4291, // 排序的行数</span><br><span class="line">  &quot;number_of_tmp_files&quot;: 11,   // 排序过程中使用的临时文件数，如果在内存中排序，则这个值为0</span><br><span class="line">  &quot;sort_buffer_size&quot;: 261696,  // 就是上面说的排序的空间大小，这个是可以通过命令调整</span><br><span class="line">  &quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>假设查询语句变为：</p><blockquote><p>select * from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>对比可知，仅仅是将查询结果的字段修改为了<code>*</code>，这时在步骤1中就需要为很多无需排序的字段开辟空间，那么就会造成<code>sort_buffer_size</code>空间中单行的数据比较长，那么<code>MySQL</code>会怎么做？</p><p>实际上当<code>MySQL</code>判断单行数据过长时，它会修改<code>sort_buffer_size</code>存放值的策略，之前全字段排序时<code>sort_buffer</code>存放的字段为<code>name</code>、<code>age</code>、<code>address</code>，而如果单行数据过长时，<code>sort_buffer</code>存储的字段就变成<code>id</code>、<code>age</code>，排序完成之后，通过主键<code>id</code>索引进行一次回表，也就是说比全字段排序多了一个步骤，在排序完成之后需要进行一次回表。</p><p>同时在刚刚的<code>optimizer_trace</code>的<code>json</code>中的<code>sort_mode</code>项中会标识出是否采用了<code>rowid</code>算法。通过参数<code>max_length_for_sort_data</code>控制单行数据长度。</p><p><b>全字段排序对比rowid排序</b></p><p>如果<code>MySQL</code>认为内存足够大，会优先选择<b>全字段排序</b>，如果认为排序内存太小，影响排序效率，则会采用<code>rowid</code>排序算法，这样排序过程中一次可以排多行，但是需要再回表取相关字段数据。</p><p>排序对于<code>MySQL</code>来说是一个成本比较高的操作，并不是所有的<code>order by</code>都需要排序操作，之所以需要排序操作，是因为查到的数据是无序的，所有才需要进行排序操作，但是在<code>MySQL</code>中有一种方式是天然排序的，那就是索引，可以通过创建对应索引，使得查询到的数据已经是有序，那么就无需在经过排序操作。这种情况下<code>explain</code>得到的结果中就没有<code>filesort</code>。</p><h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><blockquote><p>CREATE TABLE <code>words</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>word</code> varchar(64) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB;</p><p>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=0;<br>  while i&lt;10000 do<br>    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;</p><p>call idata();</p></blockquote><p>然后执行以下语句用于获取随机的前三个数据，这里的<code>order by rand()</code>，会对每一行的数据都生成一个随机值，然后根据这个随机值进行排序，最后取得前三行数据。</p><blockquote><p>select word from words order by rand() limit 3;</p></blockquote><p>使用<code>explain</code>命令执行结果如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>words</td><td>ALL</td><td></td><td></td><td></td><td></td><td>10304</td><td>Using temporary; Using filesort</td></tr></tbody></table><p><code>Using temporary</code>表示需要使用到临时表，这里是因为需要为每一行生成一个随机值进行排序，所以需要一个临时表存储生成的这个随机值。</p><p>对于内存临时表来说，会选用那种算法存放数据？是全字段索引的算法？还是<code>rowid</code>算法？。<br>答案是使用<code>rowid</code>算法，因为对内存临时表来说，回表只是简单的根据数据行的位置直接访问到数据，不会导致访问磁盘，所以这时采用的是<code>rowid</code>排序。</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p><b>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</b></p><h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>当需要到临时表的空间比较大时，超过了<code>tmp_table_size</code>的值，那么内存临时表会转换为磁盘临时表。<br>在磁盘临时表中还有一种优化算法：优先队列排序算法。对于这个查询语句，实际上只需要取值最小的3个值，但是如果使用归并排序的话，是将所有数据都排序了，所以实际上浪费了很大的计算量。所以这里<code>MySQL</code>提供了优先队列排序算法：<br>  先取3行数据构建一个堆，再取下一行数据，与这个堆的最大值进行比较，如果大则丢弃，如果小则替换，依次执行，知道扫描完整个表。</p><p>如果需要的空间大于<code>sort_buffer_size</code>则采用磁盘临时表，通过磁盘临时表进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（五）—排序&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;/a&gt;mysql45讲学习总结（五）—排序&lt;/h1&gt;&lt;p&gt;​&lt;br&gt;本篇记录&lt;code&gt;MySQL&lt;/code&gt;在执行&lt;code&gt;order by&lt;/code&gt;语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（四）---锁</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/</id>
    <published>2022-09-29T14:13:58.000Z</published>
    <updated>2022-10-12T03:06:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（四）—锁"><a href="#mysql45讲学习总结（四）—锁" class="headerlink" title="mysql45讲学习总结（四）—锁"></a>mysql45讲学习总结（四）—锁</h1><p>​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><span id="more"></span><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><ul><li><code>DML</code>：数据操纵语言(Data Manipulation Language)</li><li><code>DDL</code>：数据定义语言(Data Definition Language)</li><li><code>MDL</code>：元数据锁(meta data lock)</li></ul><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>​    全局锁顾名思义就是对整个数据库实例上锁，让整个数据库处于只读状态，<code>MySQL</code>提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock(FTWRL)</code>。使用这个命令之后，其他线程的数据更新语句<code>DML</code>(增删改)、数据定义语句<code>DDL</code>(建表、修改字段信息)和更新类事务的提交语句。</p><p>一般来说全局锁的使用场景就是全库的备份，使用<code>FTWRL</code>命令之后，使得整个库处于只读状态之后，进行数据备份。那么有两种情况，如果在主库进行备份，备份期间，主库处于业务停摆；如果在从库备份，从库无法执行主库过来的<code>binlog</code>，导致主从延迟。</p><p>那么有没有什么方式可以不影响业务？</p><p>先简单还原全库备份如果不上全局锁产生的问题：假设有两张表，一张账户余额表，一张用户课程表；事务内的操作顺序为余额表扣款，课程表添加一条课程记录。假设这个动作是在备份过程中执行，在余额表扣款之前，备份了余额表，在课程表添加记录之后，备份了课程表，导致在备份库中，余额表的金额是原值，课程表却新增了一条记录。从语义上简单说就是钱没有花，但是买到了课。</p><p>产生这个问题的原因主要是备份库得到的不是一个逻辑时间点，视图的逻辑是不一致的，所以备份的时候应该要拿到一个时间点的一致性视图。也就是在可重复读隔离级别看开启一个事务，那么在这个事务中的操作，对于每个表来说已经形成了”快照“，对这个”快照“进行备份，从而保证备份库数据逻辑正确。</p><p>官方自带的逻辑备份工具<code>mysqldump</code>，使用参数<code>--single-transaction</code>后备份数据会启动一个事务，来确保拿到的是一致性视图，但是要注意，这个参数需要存储引擎支持可重复读这个隔离级别。比如<code>MyISAM</code>不支持，那么只能使用<code>FTWRL</code>进行备份。</p><p>当然了还有人说可以使用<code>set global readonly = true</code>的方式让整个库处于只读的状态，但是这种做法存在两个致命的问题：</p><ul><li>使用<code>FTWRL</code>命令，当这个线程因为发生异常断开之后，会释放这个全局锁。</li><li>假设其他应用层框架通过这个<code>readonly</code>全局参数判断是否是主库，导致一些应用层逻辑出现问题。</li></ul><p>业务的更新不只是<b>增删改数据（<code>DML</code>)</b>，还有可能是加字段等<b>修改表结构的操作（<code>DDL</code>）</b>。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p><code>MySQL</code>里面的表级别锁有两种：表锁和元数据锁<code>MDL</code>。</p><h2 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h2><blockquote><p>表锁的语法是 lock tables … read/write</p></blockquote><p>与<code>FTWRL</code>类似，可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。</p><p><code>lock tables</code>命令除了会限制别的线程的读写之外，也会限制自身线程的数据访问权限：假设线程A中执行<code>lock tables t1 read, t2 write</code>那么其他线程的写<code>t1</code>、读写<code>t2</code>都会被阻塞。同时当线程A在执行<code>unlock tables</code>之前，自身线程只能执行读<code>t1</code>、读写<code>t2</code>，这时连写<code>t1</code>都不允许，自然不能访问其他表。</p><p>一般不使用<code>lock tables</code>来控制并发，这个锁的面积太大。</p><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>​    <code>MDL</code>不需要显示使用，在访问一个表的时候会自动加上，它的作用是保证读写的正确性，这是因为假设一个查询正在遍历表数据，突然另一个线程变更了表结构，那么查询线程获取到的数据结构跟原本对不上。</p><p>​    所以当对一个表做增删改操作时，加<code>DML</code>读锁，当要对表结构做变更时，加<code>DML</code>写锁。</p><ul><li>读锁之间不互斥，因此你可以多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，一个线程获取了读锁，另一个线程如果要获取写锁就需要进入等待。</li></ul><p>尽管这样还是可能会出现一些问题：</p><p>​    在给一个表添加字段、修改字段或者索引的处理，这些操作是需要全表扫描的。假设线程A获取了<code>DML</code>读锁，在对表进行查询操作，线程B想要获取<code>DML</code>写锁，进行修改表字段操作，这时由于线程A持有<code>DML</code>读锁，线程B阻塞进入等待，同时其他线程若想再查这个表数据，需要获取<code>DML</code>读锁，都会因为线程B而进入等待，如果这个表查询比较频繁，且很多客户端是有重试机制，也就是等待超时之后会重启一个<code>session</code>再次请求，那么这个库的线程很快就会满。<b>事务中的<code>DML</code>锁，在语句执行开始时申请，并不是在语句执行完成后就释放，而是在事务提交之后才释放。</b></p><p>所以一般情况下，首先要解决长事务，事务不提交会一直持有<code>DML</code>锁，或者将这个线程<code>kill</code>掉，但是对于热点表来说，可能<code>kill</code>不是那么有效果，可能刚<code>kill</code>掉，请求马上就又来了，所以只能通过为这个变更语句设置等待时间，如果在这个时间之内能获取到<code>DML</code>锁，就执行变更，如果获取不到，也不要阻塞业务，先放弃，之后在重复执行这个命令。</p><blockquote><p>ALTER TABLE tbl_name NOWAIT add column …</p><p>ALTER TABLE tbl_name WAIT N add column …</p></blockquote><h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>​    <code>MySQL</code>的行锁是各个引擎层自己实现，并不是所有存储引擎都支持行锁，比如<code>MyISAM</code>就不支持行锁，也就是锁它的并发控制只能使用表锁，这种颗粒度严重影响了业务并发度。</p><p>​    行锁就是针对于数据表中行记录的锁，锁的是主键索引，比如事务A更新了一行，这时候事务B也要更新同一行，那么事务B进入等待，如果事务B更新的不是同一行，那么事务B无需等待。</p><p><b>两阶段锁</b></p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;<br>update t set k=k+1 where id=1;<br>update t set k= k+1 where id=2;</td><td></td></tr><tr><td></td><td>Begin;<br>update t set k=k+2 wehre id=1;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这种情况下，事务A在执行两条更新语句之后，持有了这两条记录的行锁，但是事务A是在提交之后才会释放行锁，所以事务B的更新语句，要在事务A提交之后才能执行。</p><p><b>在<code>InnoDB</code>事务中，行锁是在执行语句的时候获取的，但并不是语句执行之后就释放，而是在这个事务提交之后才释放，这就是两阶段协议。</b></p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>间隙锁是用来解决幻读带来的问题，幻读是指事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</p><p>创建一个表，这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。</p><blockquote><p>CREATE TABLE <code>t</code> (<br><code>id</code> int(11) NOT NULL,<br><code>c</code> int(11) DEFAULT NULL,<br><code>d</code> int(11) DEFAULT NULL,<br>PRIMARY KEY (<code>id</code>),<br>KEY <code>c</code> (<code>c</code>)<br>) ENGINE=InnoDB;</p><p>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p></blockquote><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td></td><td>insert into t value(1, 1, 5)</td></tr><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p><code>sessionA</code>第一次查询的时候只返回一条记录，第二次查询的时候由于<code>sessionB</code>已经提交了，所以可以查到两条记录。</p><p>也就是说幻读指一个事务内的两次查询，后一次的查询看到了前一次查询没有看到的行。</p><p>仔细观察<code>sessionA</code>的查询语句，可以发现，<code>for update</code>命令加上之后，是当前读，当前读就是要读到已经提交的最新值，所以<code>sessionA</code>看到<code>sessionB</code>提交的结果看起来并没有什么问题。</p><p>但是，实际上这是有问题的，因为<code>sessionA</code>的第一个查询语句的语义是要锁住所有<code>d=5</code>的行，不允许其他事务进行写操作，如果将<code>sessionB</code>的语句修改为<code>update c=1 where d=5</code>，这时<code>sessionB</code>就会进入等待，等待<code>sessionA</code>提交之后释放锁。</p><p><b>锁的设计是为了在并发时保持数据的一致性，包括数据库内部数据状态的一致性，也包括了日志的一致性。</b></p><p>看下面的例子：</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from where d=5 for update;<br>update t set d=100 where d=5;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=5 where id=0;<br>update t set c=5 where id = 0;</td><td></td><td>T2</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T3</td></tr><tr><td></td><td></td><td>insert into t values(1,1,5);<br>update set c=5 where id=1;</td><td>T4</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T5</td></tr><tr><td>commit;</td><td></td><td></td><td>T6</td></tr></tbody></table><p>当执行完成之后数据库数据结果：</p><ol><li>经过T1之后，id=5这一行变成(5, 5, 100)，但是这个要在T6之后才正式提交。</li><li>经过T2之后，id=0这一行变成(0, 5, 5)</li><li>经过T4之后，表里对了一行(1, 5, 5)</li></ol><p>所以<code>binlog</code>中的语句大概是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure><p>如果使用这个<code>binlog</code>来备份或者是从库同步数据都会出现数据不一致的情况。</p><p>那么是什么导致了这个数据不一致？可以简单的认为是<code>sessionA</code>在T1时未锁住数据导致的，那么如果它在T1时刻锁住了所有扫描到的行又会怎么样？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure><p>可以看到，就算锁住了所有扫描行，阻塞了<code>sessionB</code>的执行，但是也无法锁住<code>sessionC</code>语句的执行，<b>换句话说就是即使是所有数据都上锁，也还是无法阻止新记录的插入。</b>这也就是为什么幻读需要单独拿出来说的原因。</p><p>所以产生幻读的原因是行锁只能锁住数据行，而新插入的数据是插入到数据行之间的间隙，因此为了解决幻读，<code>InnoDB</code>引入了间隙锁(<code>Gap Lock</code>)。</p><p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，在主键索引上这就产生了 7 个间隙。</p><p><img src="https://s2.loli.net/2022/10/12/DqFhULJ4MSvCWje.png" alt="间隙锁.png"></p><p>所以当执行<code>select * from t where d=5 for update</code>时，不止是给数据库中已有的6个记录上锁，同时也加上了7个间隙锁。这样就可以确保数据无法插入。也就是说在扫描行时不仅给行上锁，也给行两边的间隙上锁。</p><p>间隙锁的性质与之前碰到的锁性质有所不同。</p><p>比如行锁分为读写锁，读锁之间不冲突，读写、写写之间是冲突。而间隙锁，两个<code>session</code>可以同时对一个间隙上间隙锁，只要不插入数据就不会产生冲突。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin<br>select * from t where c=7 lock in share mode;</td><td></td></tr><tr><td></td><td>begin<br>select * from t where c=7 lock in share mode;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里的<code>sessionB</code>并不会阻塞，因为对于<code>sessionB</code>来说也是对(0,5)这个范围加间隙锁，它也<code>sessionA</code>锁住的范围是一致的，目标也是一致的，都是为了保护(0,5)这个范围不能插入数据。</p><p>间隙锁和行锁合称<code>next-key lock</code>，每个<code>next-key lock</code>是前开后闭区间。</p><p>当然了间隙锁的引入也会带来一些问题。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where id=5 for update;</td><td></td></tr><tr><td></td><td>select * from where id=5 for update;<br>insert into t values(5,1,5);</td></tr><tr><td>insert into t values(5,1,5);</td><td></td></tr></tbody></table><p>这个会带来死锁，原因是<code>sessionA</code>为(5,10)加上了间隙锁，<code>sessionB</code>也为(5, 10)加上了间隙锁，但是<code>sessionB</code>的插入语句需要等待<code>sessionA</code>释放间隙锁，<code>sessionA</code>的插入语句也在等待<code>sessionB</code>释放间隙锁，从而造成死锁。</p><p>间隙锁实际上是可重复读的隔离级别才会出现，如果隔离级别设置为读提交就不会产生幻读，也就不需要引入间隙锁。在读提交下，一般将日志格式设置为<code>row</code>来解决数据不一致的问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>行锁：对索引记录加锁。</li><li>间隙锁：锁住某个区间。(可以是两个索引记录之间，也可以是第一个索引之前或者最后一个索引之后的空间)</li><li>next-key锁：行锁和间隙锁的组合。</li></ul><p><b>如果检索条件不是索引的话会全表扫描，这时是表级锁。</b></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>如果需要删除一个表里前10000行数据，有一下三种方法可以做到：</p><ol><li>直接执行 <code>delete from T limit 10000</code>：单个语句占用时间过长，锁的时间比较长，而且大事务还会导致主从延迟。</li><li>在一个连接中循环执行20次<code>delete from T limit 500</code>：一般推荐这种方式。</li><li>在20个连接中同时执行<code>delete from T limit 500</code>：人为造成锁冲突。但是如果可以加上特定的条件，将这10000天然的分开，或者可以获取到主键<code>ID</code>，那么这种方式也不错。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（四）—锁&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;/a&gt;mysql45讲学习总结（四）—锁&lt;/h1&gt;&lt;p&gt;​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（三）---事务</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-09-26T14:13:58.000Z</published>
    <updated>2022-09-29T02:51:11.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（三）—事务"><a href="#mysql45讲学习总结（三）—事务" class="headerlink" title="mysql45讲学习总结（三）—事务"></a>mysql45讲学习总结（三）—事务</h1><p>​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在<code>MySQL</code>中，事务支持是在引擎层实现的。<code>MySQL</code>是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如<code>MySQL</code>原生的<code>MyISAM</code>引擎就不支持事务，这也是<code>MyISAM</code>被<code>InnoDB</code>取代的重要原因之一。</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p><p>当数据库上有多个事务同时执行的时候，就可能出现：</p><ul><li>脏读（dirty read）：无效数据的读出，假设事务T1将某一值修改，这是事务T2读取到这一新值，但是事务T1由于某种原因回滚了新值，这就导致事务T2所读到的新值是无效的。</li><li>不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，在这个数据还没有结束时，另一个事务也访问了同一数据，那么第一个事务在两次读取数据之间由于第二个事务的修改，导致前后读取到的数据不一样，因此称为不可重复读，即原始读取不可重复。</li><li>幻读（phantom read）：事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</li></ul><p>对应的<code>SQL</code>标准事务隔离级别包括：</p><ul><li>读未提交（read uncommitted）：一个事务还没有提交时，它做的变更可以被其他事务看到。</li><li>读提交（read committed）：一个事务提交之后，它做的变更才能被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的；未提交的变更对其他事务也是不可见。</li><li>串行化（serializable ）：对同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写冲突时，后访问的事务需等待前访问事务释放锁，才可执行。</li></ul><p><b>例子</b></p><blockquote><p>create table T(c int) engine=InnoDB;</p><p>insert into T(c) values(1);</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>启动事务查询得到值1</td><td>启动事务</td></tr><tr><td></td><td>查询得到值1</td></tr><tr><td></td><td>将1改成2</td></tr><tr><td>查询得到值V1</td><td></td></tr><tr><td></td><td>提交事务B</td></tr><tr><td>查询得到值V2</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td>查询得到值V3</td><td></td></tr></tbody></table><p>不同隔离级别下V1，V2，V3的返回值：</p><ul><li>读未提交：V1=V2=V3=2（V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2）</li><li>读提交：V1=1，V2=V3=2（V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2）</li><li>可重复读：V1=V2=1，V3=2（V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的）</li><li>序列化：V1=V2=1，V3=2（在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2）</li></ul><p>在实现上，<code>MYSQL</code>引入视图的概念，访问的时候以视图的逻辑结果为准。</p><ul><li>读未提交：可以直接看到未提交事务的变更，不存在视图。</li><li>读提交：在每个<code>SQL</code>语句开始执行的时候创建视图。</li><li>可重复读：在事务启动时创建，整个事务存在期间都使用这个视图。</li><li>序列化：直接使用锁来控制并行访问，不存在视图。</li></ul><p><b>不同的隔离级别，数据库的行为有所不同，<code>Oracle</code>数据库的默认隔离级别是”读提交“，<code>MySQL</code>默认的隔离级别是可重复读，如果是将<code>Oracle</code>迁移到<code>MySql</code>的引用，为保证数据库隔离级别一致，可以将<code>MySQL</code>的隔离级别设置为”度提交“</b></p><blockquote><p>show variables like ‘transaction_isolation’</p><p>将参数transaction-isolation 的值设置成 READ-COMMITTED</p></blockquote><p><b>使用”可重复读“的场景</b></p><p>​    假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。        </p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>​    在<code>MYSQL</code>中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值通过一个个回滚操作，可以回到之前的旧值。</p><p>假设一个值从1&rarr;2&rarr;3&rarr;4，最后新值为4，那么在回滚日志和视图如下：</p><p><img src="https://s2.loli.net/2022/09/26/tM79KoGIlz4OVhA.png" alt="事务隔离回滚.png"></p><p>最新值为4，但是不同时刻启动的事务会产生不同的视图，在在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。 对于视图A来说，要想等到值为1，只需要将最新值依次执行回滚动作。所以即使现在有新事务将4改成5，这个事务对视图A，B，C对应的事务不会存在冲突。当系统中没有比回滚日志更早的视图时，这些回滚日志就会被删除。</p><p>所以尽量不要使用长事务，长事务意味着系统里会存在很老的事务视图，导致在这个事务提交之前，这个事务可能用到的回滚记录都必须被保留，也就造成了占用了大量的存储空间。</p><h1 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h1><ol><li>显示启动事务语句，<code>begin</code>或者<code>start transaction</code>，结束事务使用<code>commit</code>，回滚使用<code>rollback</code>。</li><li><code>set autocommit=0</code>，关闭这个线程的自动提交，意味着只要执行一个<code>select</code>事务都会启动，并且不会自动提交，只有到显示<code>commit</code>或者<code>rollback</code>或者断开连接。</li></ol><p>查询持续时间超过60s的事务：</p><blockquote><p>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p></blockquote><h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><blockquote><p>CREATE TABLE <code>t</code> (</p><p>  <code>id</code> int(11) NOT NULL,</p><p>  <code>k</code> int(11) DEFAULT NULL,</p><p>  PRIMARY KEY (<code>id</code>)</p><p>) ENGINE=InnoDB;</p><p>insert into t(id, k) values(1,1),(2,2);</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td></td><td>update t set k=k+1 where id = 1;</td></tr><tr><td></td><td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td><td></td></tr><tr><td>select k from t where id =1;<br/>commit;</td><td></td><td></td></tr><tr><td></td><td>commit;</td><td></td></tr></tbody></table><p><b>注意：</b><code>begin/start transaction</code>命令并不是一个事务的起点，在执行到他们之后的第一个操作<code>InnoDB</code>表的语句，事务才真正启动，若想马上启动则使用<code>start transaction with consistent snapshot</code>命令。</p><p>事务C没有显示的使用<code>begin/commit</code>，表示这个<code>update</code>语句本身是一个事务，语句在执行完成后会自动提交。</p><p>在上述三个事务中：事务A查到的k=1，事务B查到的k=3。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>​    在可重复读隔离级别下，事务在启动的时候就对整个数据库“拍了个快照”。当然了，这个“快照”不是简单理解为拷贝数据，而是通过逻辑手段进行处理。</p><p>​    在<code>InnoDB</code>里面每个事务都有一个唯一的事务<code>ID(transaction id)</code>，在事务开始时向事务组件申请，是严格按照申请顺序递增。</p><p>​    每一行数据都是有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并把这个数据版本上的<code>row trx_id</code>标记为这个事务<code>ID</code>，同时旧数据版本，通过<code>undo log</code>来拿到具体旧数据版本。</p><p>综上：每一行数据，其实可能有多个版本<code>row</code>，每个版本有自己的<code>row_trx_id</code>。</p><p><img src="https://s2.loli.net/2022/09/27/mcCoSq971UtjWpR.png" alt="MVCC例子.png"></p><p>上图就是一个记录被多个事务更新后的状态，虚线框中是一行数据的4个版本，V4是最新的版本；图中的U1，U2，U3就是<code>undo log</code>，但需要获取到前置版本数据时，就是通过<code>undo log</code>计算出来，比如需要V2的时候，就是通过V4依次执行U3，U2计算得出。(上图中的数据版本所对应的事务都是提交状态，避免有人理解为还能对事务id=15的事务进行回滚。)</p><p>所以，某一个事务在启动的时候，会声明：“在我启动时刻为准，如果一个数据版本是在我启动之前生成，我可见；如果是在我启动之后才生成，我不可见，我必须找它之前的我可见的版本；如果是自身事务版本，我也是可见”。</p><p><code>InnoDB</code>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃中”(启动还未提交)的所有事务<code>ID</code>。当一个事务启动时，这个数组中的元素就是“活跃中”事务和自身事务(顺序排列)。当判断数据版本可见性时，就通过这个数组来进行判断，比如一个事务的数组为<code>[7,8, 10]</code>（自身事务id=9）：</p><ul><li>查询某个数据版本的<code>row trx_id=10</code>，这就表示这个数据版本是在当前事务之后生成，故向前获取版本。</li><li>查询某个数据版本的<code>row trx_id=6</code>，比数组中最小的还小，表示是在事务启动前生成的，可见。</li><li>查询某个数据版本的<code>row trx_id=7</code>，落在这个数组中，表示这个版本事务还未提交，不可见。</li><li>查询某个数据版本的<code>row trx_id=8</code>，比数组中最小的大，但是不落在这个数组中，表示这个版本事务已提交，可见。</li></ul><p>根据上述结论，分析之前事务A的查询情况：</p><ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ol><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><p><img src="https://s2.loli.net/2022/09/27/iIohujG3qXvKedk.png" alt="MVCC事务A分析.png"></p><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p><p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>当事务 A 读事务时，由于它的视图数组是 [99,100]。读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id=101，比自身数组的最大值大，不可见</li><li>找到 (1,2) 的时候，判断出 row trx_id=102，比自身数组的最大值大，不可见</li><li>找到 (1,1) 的时候，它的 row trx_id=90，比自身数组的最小值小，可见</li></ul><p>综上：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p><b>但是上述实际上只是查询数据时的逻辑，可以将上述分析结果代入事务B，会发现按这种规则代入，事务B中的k值应该为1，而不是2，问题出在事务B在查询之前执行了一次更新操作。</b></p><p>这是因为事务B要去更新数据时，就不能是历史版本上更新了，否则事务C的更新就丢失了，所以事务B此时的更新操作是在事务C的基础上操作的。</p><p><b>当前读：更新数据都是先读后写，这个读，只能读当前的值。</b></p><p>实际上除了<code>update</code>语句，<code>select</code>语句如果加锁，也是当前读。</p><blockquote><p>select k from t where id=1 lock in share mode;  // 读锁（S 锁，共享锁）</p><p>select k from t where id=1 for update; // 写锁（X 锁，排他锁）</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td></td><td>start transaction with consistent snapshot;<br>update t set k=k+1 where id = 1;</td></tr><tr><td></td><td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td><td></td></tr><tr><td>select k from t where id =1;<br/>commit;</td><td></td><td>commit</td></tr><tr><td></td><td>commit;</td><td></td></tr></tbody></table><p>如果事务C并不是马上提交，而是在事务B执行更新动作之后提交，这时在事务C在执行更新操作时，是获取了这行数据的行锁，事务C在更新之后，事务B的更新操作需要去获取行锁，但是被事务C锁住，故事务B进入等待，直到事务C提交事务后，事务B获取到锁继续往下执行。</p><p>综上：可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（三）—事务&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（三）—事务&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（三）—事务&quot;&gt;&lt;/a&gt;mysql45讲学习总结（三）—事务&lt;/h1&gt;&lt;p&gt;​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在&lt;code&gt;MySQL&lt;/code&gt;中，事务支持是在引擎层实现的。&lt;code&gt;MySQL&lt;/code&gt;是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如&lt;code&gt;MySQL&lt;/code&gt;原生的&lt;code&gt;MyISAM&lt;/code&gt;引擎就不支持事务，这也是&lt;code&gt;MyISAM&lt;/code&gt;被&lt;code&gt;InnoDB&lt;/code&gt;取代的重要原因之一。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（一）---初试</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/</id>
    <published>2022-09-21T14:13:58.000Z</published>
    <updated>2022-09-29T02:51:46.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（一）—初试"><a href="#mysql45讲学习总结（一）—初试" class="headerlink" title="mysql45讲学习总结（一）—初试"></a>mysql45讲学习总结（一）—初试</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    感觉自身对于<code>MYSQL</code>的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说<code>MYSQL</code>45讲对<code>MYSQL</code>介绍比较细致，所以希望通过学习<code>MYSQL</code>45讲让自己的<code>MYSQL</code>形成知识网络。<span id="more"></span></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>​    下方为<code>MYSQL</code>的基本架构示意图，一个执行语句在不查询缓存的情况下，基本查询路径为：客户端&rarr;连接器 &rarr;分析器&rarr;优化器&rarr;执行器&rarr;存储引擎。对应过程：</p><ol><li>连接：连接管理模块，接收请求；连接进行和用户模块，验证通过；连接线程和客户端连接。</li><li>查询：（查询缓存）<ol><li>分析器：内建解析树，对其语法检查，<code>form</code>&rarr;<code>on</code>&rarr;<code>join</code>&rarr;<code>where</code>，检查权限，生成新的解析树，语义检查。</li><li>优化器：将解析树转换为执行计划，选择索引，并评估最优执行。</li><li>执行器：获取锁，打开表，通过<code>meta</code>数据，获取查询数据。</li></ol></li><li>返回结果：返回给连接进程，然后情况，等待新的请求。</li></ol><p><img src="https://s2.loli.net/2022/09/21/tsHEepgh6AIGyJZ.webp" alt="MySQL 的逻辑架构图.png"></p><p>总体来说<code>MYSQL</code>基本架构分为两个部分：</p><h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1.Server层"></a>1.Server层</h3><p><code>Server</code>层包含了很多执行组件，涵盖了<code>MYSQL</code>的大多数核心业务功能，以及所有的内置函数（聚合函数的处理），所有跨存储引擎的功能都是在这一层实现，比如存储过程、触发器、视图等。从图中可以看出所有存储引擎共用同一个<code>Server</code>层。</p><h4 id="1-1连接器"><a href="#1-1连接器" class="headerlink" title="1.1连接器"></a>1.1连接器</h4><p>当使用以下连接命令之后，连接器通过<code>TCP</code>与客户端建立连接、获取权限、维持和管理连接。</p><blockquote><p>mysql -h$ip -P$port -u$user -p</p></blockquote><p>通过以下命令可以查看每个连接的状态</p><blockquote><p>show processlist;</p></blockquote><table><thead><tr><th>Id</th><th>User</th><th>Host</th><th>db</th><th>Command</th><th>Time</th><th>State</th><th>Info</th></tr></thead><tbody><tr><td>5</td><td>root</td><td>172.17.0.1:40922</td><td>binlog_test</td><td>Query</td><td>0</td><td></td><td>show processlist</td></tr><tr><td>6</td><td>root</td><td>172.17.0.1:40926</td><td>binlog_test</td><td>Sleep</td><td>1237</td><td></td><td></td></tr></tbody></table><p><code>Command</code>列中存在一个<code>Sleep</code>，表示有一个连接处于空闲状态。</p><h4 id="1-2分析器"><a href="#1-2分析器" class="headerlink" title="1.2分析器"></a>1.2分析器</h4><p>分析器的主要作用是对接收到的<code>SQL</code>语句进行解析。</p><p>首先进行”词法分析“：识别收到的<code>SQL</code>语句中代表的是什么、识别出列<code>ID</code>，查询条件等。</p><p>其次进行”语法分析“：进行语法规则的校验，判断输入<code>SQL</code>是否满足<code>MYSQL</code>语法，若语法错误则会抛出<code>You have an error in your SQL syntax</code>。</p><h4 id="1-3查询缓存"><a href="#1-3查询缓存" class="headerlink" title="1.3查询缓存"></a>1.3查询缓存</h4><p>​    接收到的<code>SQL</code>在进入到分析器之前，会先进入到查询缓存组件，判断之前是否执行过该语句，如果执行过直接返回结果，若没有执行过则进入分析器。但是大多数的情况下，由于缓存失效的非常频繁，只要对一个表存在更新操作，这个表所对应的所有缓存都失效，导致对缓存的命中率比较低。</p><blockquote><p>query_cache_type设置为DEMAND表示开启，NO表示关闭</p></blockquote><p>或者也可以通过<code>SQL</code>中关键字<code>SQL_CACHE</code>指定：</p><blockquote><p>select SQL_CACHE * from T where ID=10；</p></blockquote><p>同时在<code>MYSQL  8.0</code>版本中移除了缓存模块。</p><h4 id="1-4优化器"><a href="#1-4优化器" class="headerlink" title="1.4优化器"></a>1.4优化器</h4><p>​    优化器接收到了经过了分析器的<code>SQL</code>，优化器的主要作用是对<code>SQL</code>进行优化、多表连接顺序、多索引时选择使用哪个索引等。同一个<code>SQL</code>语句，不同的连接顺序、索引选择虽然查询结果一致，但是执行效率上存在差异。</p><p>​    优化器的作用便是在同样查询结果的情况下，对<code>SQL</code>语句进行优化，尽可能提升语句的查询效率，但是也有可能经过优化器处理之后，反而导致执行时长变长。</p><h4 id="1-5执行器"><a href="#1-5执行器" class="headerlink" title="1.5执行器"></a>1.5执行器</h4><p>​    优化器执行之后，<code>SQL</code>语句的执行方案就确定下来，然后进入执行器，在开始执行之前，需判断登录用户对操作表有没有执行查询的权限，若没有权限则报错：</p><blockquote><p>ERROR 1142 (42000): SELECT command denied to user ‘b’@’localhost’ for table ‘T’</p></blockquote><p>比如查询语句为：</p><blockquote><p>select * from T where ID=10;</p></blockquote><p>表 <code>T</code> 中，<code>ID</code> 字段没有索引，在执行器中的执行流程为：</p><ol><li>调用<code>InnoDB</code>引擎接口取这个表的第一行，判断<code>ID</code>值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>如果<code>ID</code>字段存在索引，只是在第1步骤中使用的调用存储引擎的接口不一致。</p><p>在慢查询日志中会有一个<code>rows_examined</code>的字段，表示这个语句在执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟<code>rows_examined</code>并不是完全相同的。</p><h3 id="2-存储引擎层"><a href="#2-存储引擎层" class="headerlink" title="2.存储引擎层"></a>2.存储引擎层</h3><p>存储引擎层负责数据的存储和提取。其架构模式是插件式，支持<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>。默认情况下使用<code>InnoDB</code>，也就是说通过<code>create Table</code>创建表时，若没有明确指定存储情况，默认就会使用<code>InnoDB</code>。</p><ul><li>InnoDB：事务型数据库的首选存储引擎，支持书屋安全表<code>ACID</code>，支持行锁和外键，<code>InnoDB</code>是<code>MYSQL</code>的默认存储引擎。</li><li>MyISAM：基于<code>ISAM</code>存储引擎，并对其进行扩展，它是在<code>Web</code>、数据仓储和其他应用环境下最常使用的存储引擎之一，拥有较高的插入和查询速度，但不支持事务。</li><li>Memory：内存数据库，将表中的数据存储到内存中。</li></ul><h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><p>​    更新语句和查询语句在执行器之前经过的<code>Server</code>层组件是一样的(唯一不同的是更新语句会移除所操作表的查询缓存)。与查询流程不一样的是，更新流程还涉及到两个重要的日志模块<code>redo log</code>(重做日志)，<code>binlog</code>(归档日志)。</p><h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><p>​    在<code>MYSQL</code>45讲中，使用《孔乙己》中酒店掌柜的例子，粉板和账本指代<code>redo log</code>和磁盘。当有一个更新操作时先将记录写入到<code>redo log</code>中，并不是执行写入磁盘(这么做的话<code>IO</code>成本、查找成本太高)。而是在适当的时机将<code>redo log</code>的内容写入到磁盘中。</p><p>​    通过<code>redo log</code>和磁盘结合的方式进行数据记录，这个整合的过程，就是<code>MYSQL</code>的<code>WAL(Write-Ahead Logging)</code>技术，它的关键点就是先写日志，再写磁盘。</p><h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><p>​    <code>redo log</code>是<code>InnoDB</code>引擎特有的日志，<code>bin log</code>是<code>Server</code>层日志。</p><p>这两种日志的不同点：</p><ul><li><code>redo log</code>是<code>InnoDB</code>引擎特有的；<code>bin log</code>是<code>Server</code>层实现，所有存储引擎都可以使用。</li><li><code>redo log</code>记录的是物理日志，记录的是”在某一个数据页上做了什么修改“，<code>bin log</code>是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c 字段加 1 “。</li><li><code>redo log</code>是循环写，空间是固定(粉板)，当写满之后会覆盖掉以前的日志；<code>bin log</code>是可以追加写，当文件写入到一定大小后会根据规则生成新的日志文件，不会覆盖旧日志。</li></ul><blockquote><p>create table T(ID int primary key, c int);</p><p>update T set c=c+1 where ID=2;</p></blockquote><p><strong>两阶段提交的简单流程</strong></p><ol><li>执行器先通过存储引擎接口获取到<code>ID=2</code>这一行记录，如果<code>ID=2</code>这行记录的数据页在内存中，则直接从内存中获取后返回给执行器。否则需要先将磁盘中这一页数据加载到内存中，再返回。</li><li>执行器得到这一行数据后，对<code>c</code>列执行<code>+1</code>操作，再调用存储引擎接口，将结果写入到这行新数据中。</li><li>存储引擎将这行数据更新到内存中，之后将这个更新操作写入到<code>redo log</code>中，并标记状态为<code>prepare</code>，然后告知执行器可以进行提交<code>commit</code>操作。</li><li>执行器生成这个操作的<code>bin log</code>，并将<code>bin log</code>刷盘。</li><li>执行器调用存储引擎的提交事务接口，存储引擎将刚刚的<code>redo log</code>由<code>perpare</code>修改为<code>commit</code>状态。</li></ol><p>先说这样做的好处：实际上引入<code>redo log</code>的作用是希望<code>MYSQL</code>具备<code>crash-safe</code>(指服务器宕机重启后，能够保证已提交的事务仍然存在)。</p><p>若服务器宕机出现在以上的某个流程中：</p><ul><li>在第3步骤写入<code>redo log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是不完整的，直接回滚事务。</li><li>在第4步骤写入<code>bin log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是完整的，直接提交事务。</li><li>在第5步骤修改<code>redo log</code>状态为<code>commit</code>状态，显然直接提交这个事务。</li></ul><p><strong>若不使用两阶段提交：</strong></p><p>假设两个前提：</p><ul><li>数据在一定周期内进行全量备份，可以是一天一备，也可以是一周一备。</li><li>开启<code>bin log</code>。</li></ul><p>在这种情况下数据恢复到某一时间点的操作为：</p><ol><li>找到最近一次的全量备份，将这个备份恢复到临时库中。</li><li>从备份的时间点开始，将备份时间点之后的的<code>bin log</code>依次取出，在临时库进行重放到需要恢复的这一时刻。</li><li>这时在临时库就有被误删的数据，简单处理可以手动将数据从临时表取出，按需恢复到线上库。</li></ol><p>由于存在两个日志文件，所以就需要保证两个日志文件在<code>MYSQL</code>发生异常时，数据能保持一致。</p><ol><li>**先写<code>binlog</code>后写<code>redo log</code>**：假设在<code>binlog</code>写完之后，<code>MYSQL</code>发生异常，由于<code>redo log</code>还没有写，导致<code>MYSQL</code>重启后<code>binlog</code>存在某一个操作，而<code>redo log</code>中没有这一操作，若从库使用<code>binlog</code>重放，则导致从库会有这一操作，从而导致主从数据不一致。</li><li>**先写<code>redo log</code>再写<code>binlog</code>**：假设在<code>redo log</code>写完之后，<code>MYSQL</code>发生异常，由于<code>binlog</code>还没写，导致重启之后，通过<code>redo log</code>进行数据恢复，所以主库中是存在这一操作，但是由于<code>binlog</code>中没有写入，所以导致使用<code>binlog</code>重放时，从库丢失一个操作。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    <code>redo log</code>的主要作用是利用”粉板”和”账本”的配合，提高<code>MYSQL</code>的吞吐性能，降低<code>IO</code>成本、查找成本。<code>bin log</code>是<code>Server</code>层日志，它存在于<code>redo log</code>之前，<code>redo log</code>是在<code>InnoDB</code>存储引擎诞生时，由<code>innoDB</code>引擎自身携带，其他存储引擎是没有的。还有<code>redo log</code>是对一个日志文件进行循环写，到一定数据量之后会覆盖旧值，不持久保存，<code>binlog</code>才具备”归档“的能力。</p><p>故障恢复是使用<code>redo log</code>日志进行恢复。主从同步是使用<code>binlog</code>进行数据同步。</p><ul><li><code>innodb_flush_log_at_trx_commit</code>：设置为1时表示，表示每次事务的<code>redo log</code>都直接持久化到磁盘。建议设置为1，保证<code>MySQL</code>异常重启之后数据不丢失。</li><li><code>sync_binlog</code>：设置成1的时候，表示每次事务的<code>binlog</code>都持久化到磁盘。建议设置成1，这样可以保证 <code>MySQL</code>异常重启之后<code>binlog</code>不丢失。</li></ul><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（一）—初试&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（一）—初试&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（一）—初试&quot;&gt;&lt;/a&gt;mysql45讲学习总结（一）—初试&lt;/h1&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​    感觉自身对于&lt;code&gt;MYSQL&lt;/code&gt;的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说&lt;code&gt;MYSQL&lt;/code&gt;45讲对&lt;code&gt;MYSQL&lt;/code&gt;介绍比较细致，所以希望通过学习&lt;code&gt;MYSQL&lt;/code&gt;45讲让自己的&lt;code&gt;MYSQL&lt;/code&gt;形成知识网络。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（二）---索引</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/</id>
    <published>2022-09-21T14:13:58.000Z</published>
    <updated>2022-10-17T03:47:17.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（二）—索引"><a href="#mysql45讲学习总结（二）—索引" class="headerlink" title="mysql45讲学习总结（二）—索引"></a>mysql45讲学习总结（二）—索引</h1><p>​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><span id="more"></span><h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>​    索引实际上就像是字典的目录，当需要查询某个字时，通过目录可以快速定位到某一页，从而快速查找到所需要的数据，不必进行全局遍历，达到提高查询效率的目的，实现上一般都是通过设计某种的数据结构，简单介绍几个常用的数据结构。</p><ol><li>哈希表：一种以键值对存储数据的数据结构，类似于<code>Java</code>中的<code>HashMap</code>的实现（当然了<code>jdk8</code>之后是采用数组加红黑树的方式），数据结构为一个数组加链表（有的地方称拉链法），当添加某个值时计算出这个值的<code>HASH</code>值，然后插入到数组对应的链表尾部，这种数据结构对于添加和删除的效率是比较高的，只需要移动一个节点的引用。</li><li>有序数组（规则数组）：通过某种规则将数据存入到数组中，在查询时同样可以根据这种规则直接通过下标获取到数据，如果是有序数组，对于范围查询的效率也是比较高的。这种数据结构瓶颈在于扩容以及空间的使用率上，比如现在是有序数组，数组长度为10，假设现在仅有两个值1和50，那么50的这个值存放在哪个位置？如果将数组长度扩大50，空间利用率就极低。</li><li>二叉树：二叉树是课本中经典的数据结构了，同样在添加、删除节点时，需要进行平衡。</li></ol><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>​    <code>InnoDB</code>引擎中采用<code>B+</code>数索引模型，每一个索引都对应着一颗<code>B+</code>树。分为主键索引和非主键索引。</p><p>​    主键索引又称为聚簇索引，主键索引的叶子节点是整行数据。</p><p><img src="https://s2.loli.net/2022/07/29/Cdn3PoHR5vbi8Iy.png" alt="主键索引示意图.png"></p><p>​        非主键索引又称为二级索引，非主键索引的叶子节点的内容是主键的值。由下图可知，非主键索引的查询逻辑是通过非主键索引获取到要查询数据的主键，再通过主键索引获取到对应行数据，这个过程称为回表。</p><p><img src="https://s2.loli.net/2022/07/29/nI3Ay1ZM4bpQRs8.png" alt="非主键索引示意图.png"></p><h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><p>​    在<code>InnoDB</code>存储引擎中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。<code>InnoDB</code>使用的索引模型为<code>B+</code>树形索引模型，所以数据都是存储在<code>B+</code>树中。</p><p>每一个索引在<code>InnoDB</code>里面都对应着一颗<code>B+</code>树。</p><p>假设有一个表，<code>ID</code>为主键，且还有字段<code>k,name</code>，同时<code>k</code>字段上有索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表中有5条记录：(ID,K)&rarr; (100,1)、(200,2)、(300,3)、(500,5) 、 (600,6)</p><p>主键索引树和<code>k</code>字段索引树如下：(图中主键索引显示为[100, 200]在一页，[300, 500, 600]在一页)</p><p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p><p>由上图可知：</p><p>索引类型分为主键索引(聚簇索引)和非主键(二级索引)索引。</p><ul><li>主键索引的叶子节点存储的是一整行的记录。</li><li>非主键索引的叶子节点存储的是主键ID。</li></ul><p>某个查询语句使用主键索引和非主键索引的差别在于，非主键索引查询到树节点之后得到叶子节点上的主键<code>ID</code>之后，需要再通过主键索引树再查找一轮，得到主键<code>ID</code>对应的行数据，这个过程称为回表。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>​    根据第一小节中的常见的索引模型可知，索引之所以查询速度高，实际上是依赖于索引模型，也就是说在插入数据时，就需要根据索引模型相应的规则进行数据的存储。所以虽然添加索引的查询效率高，但索引的数量并不是越多越好，过多的索引会增加插入数据带来的成本。</p><p>以上方索引树的图为例：</p><ul><li>如果插入的新行<code>ID</code>值为700，则只需要在R5的记录后面插入一条新记录。</li><li>如果插入的新行<code>ID</code>值为400，则需要将500和600往后挪，空出位置。如果R5所在的数据页满了，则需要申请一个新的数据页，然后将部分数据挪过去，这个过程称为页分裂。</li><li>如果相邻两页数据由于删除了数据，导致利用率比较低，那么就会出现合并页，这个过程是页分裂的逆过程。</li></ul><h1 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h1><p>还是这个表为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"># 同时插入6条记录</span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p><p>执行查询语句：</p><blockquote><p>select * from T where k between 3 and 5</p></blockquote><p>执行流程：</p><ol><li>到非主键索引<code>k</code>上搜索<code>k=3</code>的树节点，得到主键<code>ID=100</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R3</code>。</li><li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=5</code>这个树节点，得到主键<code>ID=500</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R4</code>。</li><li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=6</code>这个树节点，不满足<code>where</code>条件，循环结束。</li></ol><p>在步骤1和步骤2都有回表的动作，这是因为需要查询的字段在非主键索引<code>k</code>上没有，那么有没有办法避免回表？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果将执行语句修改为：</p><blockquote><p>select ID from T where k between 3 and 5</p></blockquote><p>由于这时需要查询的字段<code>ID</code>，就是非主键索引<code>k</code>的叶子节点上能获取到的数据，所以就不需要进行回表的操作，也就达到了减少一次回表查询的动作，从而提升查询效率。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>所以为了不进行回表，就需要在数节点上存储的数据做文章，就需要通过联合索引。这里的<code>name_age</code>就是联合索引。</p><p>假设一个市民信息表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure><p>如果这时需要用市民的名称查询他的年龄：</p><blockquote><p>select age from tuser where name = “xxx”</p></blockquote><p>如果使用<code>name_age</code>索引，就不需要进行一次回表就可以查出想要的某个名称对应的年龄，当然了这里会出现多条记录的情况。</p><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>如果将这条查询语句换个查询条件，能否使用这个联合索引呢？</p><blockquote><p>select name from tuser where age = xx</p></blockquote><p><img src="https://s2.loli.net/2022/09/22/uneZG4Os8JbfMRS.jpg" alt="联合索引.jpeg"></p><p>由上图可以看出，联合索引是根据联合索引定义时字段的先后顺序进行排序，也就是这里先根据<code>name</code>排序，再根据<code>age</code>排序。</p><ul><li>当需求为查询所有名字为”张三“的人，可以快速定位到ID4，然后逐个遍历节点与<code>where</code>条件进行比对。</li><li>当需求为查询所有名字第一个字为”张”，查询语句为<code>where name like &#39;张%&#39;</code>，也会命中这个索引，查询到第一个符合条件的节点为ID3，然后逐个遍历节点与<code>where</code>条件进行比对。</li><li>当需求为查询年龄为20的人，就无法使用这个索引。对这个索引来说，是先对<code>name</code>进行排序，在<code>name</code>一致的情况下，对<code>age</code>排序。</li></ul><p>综上：查询条件中不一定要全部定义，只要满足最左前缀，就可以利用这个索引来加速检索。这个最左前缀可以是联合索引的最左<code>N</code>个字段，也可以是字符串索引的最左<code>M</code>个字符。</p><p><b>在建立联合索引的时候，如何安排索引内的字段顺序。</b></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<b>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</b></p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>如果查询语句的查询条件部分满足最左前缀原则呢？</p><p>以市民表的联合索引<code>(name, age)</code>为例</p><blockquote><p>select * from tuser where name like ‘张 %’ and age=10 and ismale=1;</p></blockquote><p>根据最左前缀的规则，这个语句在搜索树时，只能用到”张”，找到第一个满足条件的记录X，然后根据其他判断条件进行判断，就算只有这样，也是要比全表扫描效率高。</p><p>在<code>MYSQL5.6</code>之前，只能从记录X开始一个个回表，到主键索引上找出记录行，在对比字段值。</p><p>在<code>MYSQL5.6</code>之后，引入索引下推优化，可以在所有遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>无索引下推执行过程如下图所示：不会获取联合索引中<code>age</code>的值，在匹配”张“之后，逐个往后遍历，并进行回表取出对应行数据进行查询条件的判断。</p><p><img src="https://s2.loli.net/2022/09/22/Ik84FoZC3MHlWPV.jpg" alt="无索引下推.jpeg"></p><p>采用索引下推的执行过程如下图所示：在匹配”张“之后，会获取<code>age</code>的值与查询条件进行匹配，如果不匹配直接获取下一个节点。所以这里的年龄等于30和20的数据，获取到之后不会进行回表操作。</p><p><img src="https://s2.loli.net/2022/09/22/OzSdyGrlAkwEhUC.jpg" alt="有索引下推.jpeg"></p><h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>重建非主键索引：</p><blockquote><p>alter table T drop index k;</p><p>alter table T add index(k);</p></blockquote><p>重建主键索引：</p><blockquote><p>alter table T drop primary key;</p><p>alter table T add primary key(id);</p></blockquote><p>重建非主键索引的做法是合理的，可以达到省空间的目的；但是重建主键索引的过程是不合理的，不论是删除主键还是创建主键，都会将整个表重建，所以第一个语句其实可有可无，单纯执行第二个语句就会对表进行重建。再者可以使用<code>alter table T engine=InnoDB</code>对表进行重建。</p><p><b>表数据删除一半，表文件大小不变？</b></p><p>​    <code>InnoDB</code>表包含两个部分，表结构定义和数据。在<code>MYSQL8.0</code>之前，表结构是存储在以<code>.frm</code>为后缀的文件里。而<code>MYSQL8.0</code>则已经允许将把表结构定义放在系统数据表，实际上表结构定义占用的空间很小，所以占用空间的主要部分就是表数据。</p><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的：</p><ol><li>这个参数设置为<code>OFF</code>表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为<code>ON</code>表示的是，每个<code>InnoDB</code>表数据存储在一个以<code>.ibd</code>为后缀的文件中。</li></ol><p>从<code>MySQL 5.6.6</code>版本开始，它的默认值就是<code>ON</code>。一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>在<code>InnoDB</code>中，数据都是以<code>B+</code>树模型且按页存储，前面也有说到，在进行查询数据时，<code>MYSQL</code>是将数据的某一页或者某几页加载到内存中。假设要删除<code>A</code>页的<code>R4</code>这条记录，这里只会将这个空间标记为复用，但是占用的空间并没有减少，如果之后又在300~600间插入一条数据，那么会复用这个空间，所以有时候删除记录并不会减少表占用空间。</p><p><img src="https://s2.loli.net/2022/09/23/ARtpzfZ5Dg7G1O6.png" alt="索引数据页结构.png"></p><p>​    当然了，如果将300-600的数据行都删除，那么这整个<code>A</code>数据页就被标记复用，对应数据页的复用，比行的复用稍微灵活，比如上述中将500对应行删除之后，只能在插入300-600之间的数据可以复用这个空间，但是如果整个数据页被标记复用，这个时候如果需要使用新页，这个标记删除的数据页就可以被复用。如果相邻两个数据页的利用率比较低，<code>MYSQL</code>也会将这两个页的数据合并到一个页，将另一个页标记为复用。</p><p>​    所以如果使用<code>delete</code>删除整个表，结果就是这个表的所有数据页被标记为复用，但是占用的磁盘空间并不会减少；但是若使用<code>truncate</code>命令，相当于使用了<code>drop</code>和<code>create</code>命令的结合，单纯从这一方面看，<code>truncate</code>在删除整个表数据时会减少空间。(但是<code>truncate</code>不能加<code>where</code>条件，动作上是先删除表<code>drop</code>再<code>create</code>表，所以它是<code>DDL</code>命令)。</p><p>​    这里将这些标记为复用的空间称为”空洞“。新增、删除、修改(比如将300修改为800，则操作上是将300对应行标记复用，在插入800对应行)数据都会存在生成新的空洞的情况，比如新增一条数据，导致某个页进行了页分裂，但是由于页空间没有填满，造成了较大的空洞，如果空洞比较多，产生的现象就是删除部分数据，并不会导致磁盘空间的减少。所以如果在删除数据之后能将这些空洞去掉，就可以减少占用磁盘空间。</p><h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>​    假设已经存在了一个较多空洞的表<code>A</code>，可以通过创建一个同样的表<code>B</code>，按照主键递增的顺序将数据从<code>A</code>表中读出，再写入到表<code>B</code>中，由于表<code>B</code>是新建表，所以表<code>A</code>主键索引上的空洞在表<code>B</code>是不存在的。这时用表<code>B</code>替换表<code>A</code>，从结果上来看，起到了收缩表<code>A</code>的目的。</p><p>​    在<code>MYSQL</code>中已经存在这个命令，通过使用<code>alter table A engine=InnoDB</code>来重建表。实际上流程就是上述流程，只不过<code>MYSQL</code>将这些操作内置，你只需要通过这一个命令即可。</p><p>​    当然了，这个过程中最消耗资源的过程，就是将表<code>A</code>数据拷贝到表<code>B</code>的过程。但是在这个过程中，如果出现新数据需要写入到表<code>A</code>中，就有可能造成数据丢失，所以在这个过程中表<code>A</code>不能有更新。</p><p>在<code>MYSQL5.6</code>版本开始引入<code>Online DDL</code>，对这个操作流程进行优化。也就是在拷贝的过程中，通过记录一个<code>row log</code>，拷贝完成之后，将<code>row log</code>的操作应用到表<code>B</code>。由于这个优化之后，在表重建过程中，允许对表<code>A</code>做写操作，所以称为<code>Online DDL</code>。</p><p>​    这个<code>DDL</code>在<code>alter</code>启动的时候就获取了<code>DML</code>写锁，但是在真正拷贝数据时，就退化为读锁，这样是为了实现<code>Online</code>，<code>MDL</code>读锁不会阻塞写操作，至于为什么不直接释放锁，是因为要禁止其他线程同时做<code>DDL</code>。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件，对于大表来说，这个操作是很消耗<code>IO</code>和<code>CPU</code>资源，所以可以通过一些比较稳定的开源组件操作，比如<code>GitHub</code>开源的<code>gh-ost</code>。</p><p>据说100万行数据以下，可以使用<code>online ddl</code>超过百万可以使用<code>gh-ost</code></p><p>关于重建表的三个命令：</p><ul><li><code>alter table t engine = InnoDB</code>：在5.6版本之后，默认就是<code>Online DDL</code>的方式。</li><li><code>analyze table t</code>：这个命令实际上不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程加了<code>MDL</code>读锁。</li><li><code>optimize table t</code>：这个命令等于<code>recreate</code>+<code>analyze</code></li></ul><h1 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h1><p>使用唯一索引还是普通索引？这是分为查询过程和更新过程来分析两种索引之间的性能差别</p><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><blockquote><p>select id from T where k=5</p></blockquote><p>这个查询语句在索引树上查找的过程：先从<code>B+</code>树根开始按层搜索叶子节点。</p><ul><li>普通索引：查找到满足条件的第一个记录(5, 500)后，需要查找下一个记录，知道碰到第一个不满足的<code>k=5</code>条件的记录。</li><li>唯一索引：查找到满足条件的第一个记录(5, 500)后，由于唯一索引的特性，直接停止检索。</li></ul><p>所以对于查询语句来说，两种索引的性能差别几乎没有差别，由于<code>MYSQL</code>是按页读写数据，所以当找到<code>k=5</code>的记录时，它所在的数据页都在内存里，那么对于普通索引来说仅比唯一索引多做了一个判断而已，所以几乎忽略不计。</p><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><blockquote><p>change buffer：当需要更新一个数据页时，如果这个数据页在内存中，则直接更新这个数据页；如果这个数据页不在内存中，在不影响数据一致性的情况下，InnoDB会将这些更新动作缓存在 change buffer 中，这样就不需要从磁盘中读出这个数据页，当下次查询出这个数据页时，将数据页读入到内存中，然后先执行 change buffer 中与这个页相关的动作之后，再返回。(虽然这块缓存的名称叫 change buffer 实际上它是可以持久化数据，也就是说 change buffer 的数据也会被写入磁盘中。)</p><p>将 change buffer 的动作应用到操作页，得到最新的数据结果的过程称为 merge。除了访问数据页之外，后台会用定时线程会触发 merge、数据库正常关闭也会触发 merge。</p></blockquote><p>实际上唯一索引并不会用到 change buffer。这是因为唯一索引在更新时，需进行唯一性约束。而这个判断就使得必须将数据页读入内存才能判断，所以如果都已经将数据读入到内存中，那么直接更新内存中的值即可。</p><p>如果要插入一个新记录（4, 400）：</p><p>第一种情况，这个记录要更新的数据行在内存中。</p><ul><li>唯一索引：找到3到5之间的位置，判断到没有冲突，插入新记录。</li><li>普通索引：找到3到5之间的位置，插入新记录。</li></ul><p>普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>第二种情况，这个记录要更新的数据行不在内存中。</p><ul><li>唯一索引：需要将数据页读到内存中，判断没有冲突，插入新记录</li><li>普通索引：将动作插入到 change buffer。</li></ul><p>将数据从磁盘读入到内存中涉及随机IO的访问，是数据库里成本最高的操作之一。change buffer 减少了随机磁盘访问，所以对更新性能是很明显。</p><h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><p>​    在<code>MySQL</code>中一张表是可以创建多个索引，但是具体的<code>SQL</code>语句使用哪个索引来进行查询，是由<code>MySQL</code>来确定，有没有可能<code>MySQL</code>选到的索引不是最优解。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 创建<span class="number">10</span>w条数据: 从(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)，(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)，(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)直到(<span class="number">100000</span>,<span class="number">100000</span>,<span class="number">100000</span>)</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>现在来看一条<code>SQL</code>查询语句：</p><blockquote><p>select * from t where a between 10000 and 20000;</p></blockquote><p>这样查询语句会使用索引<code>a</code>来提高查询效率，用<code>explain</code>命令结果：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td>range</td><td>a</td><td>a</td><td>5</td><td></td><td>10000</td><td>Using where</td></tr></tbody></table><p>果然<code>key=a</code>表示使用了所以<code>a</code>，扫描了10000行数据。</p><p>再来：</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>Start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td>delete from t;<br>call idata();</td></tr><tr><td></td><td></td></tr><tr><td></td><td>explain select * from t where a between 10000 and 20000;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里表示<code>sessionA</code>开启一个事务后，<code>sessionB</code>把数据删了之后，再次调用写10w行数据的存储过程，再通过<code>explain</code>命令查询这条<code>SQL</code>语句的执行。</p><p>这时<code>sessionB</code>的查询语句就不会再选择索引<code>a</code>，但是如果这里使用<code>select * from t force index(a) where a between 10000 and 20000;</code>就会使用索引。</p><p>这个例子对应的就是我们平常不断的删除数据和新增数据的场景，在这种情况下<code>MySQL</code>可能会选错索引。</p><p>在<code>sessionB</code>中删除了所有数据，然后通过<code>call idata()</code>插入10w行数据，看上去这里重新插入了10w行数据，但是<code>sessionA</code>在<code>sessionB</code>删除之前就开启了事务且还没有提交，所以之前的10w行数据还不能删除，这就导致之前的每一行数据都有两个版本，旧版本是数据，新版本被标记<code>delete</code>。所以再重新插入10w行数据之后，索引<code>a</code>上就有两份10w行数据。</p><p>至于为什么会选错索引，实际上优化器在选择索引的时候，有很多判断维度：扫描行、是否使用临时表、是否排序等。这里主要是因为旧的10w行数据的存在，优化器认为需要扫描的行数比较多，索引没有命中索引。其实优化器在对扫描行的判断，是通过采样分析，也是一个预估的值。可以通过<code>analyze table t</code>来重新进行统计。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;geek&#96; (</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;d&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;a&#96;,&#96;b&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;),</span><br><span class="line">  KEY &#96;ca&#96; (&#96;c&#96;,&#96;a&#96;),</span><br><span class="line">  KEY &#96;cb&#96; (&#96;c&#96;,&#96;b&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表<code>geek</code>已经存在联合主键<code>(a, b)</code>，是不是只需要创建<code>(c)</code>索引包含了<code>(ca)</code>和<code>(cb)</code>的场景，为什么需要再创建<code>(ca)</code>和<code>(cb)</code>?</p><p>假设存在以下两条语句：</p><blockquote><p>select * from geek where c=N order by a limit 1;</p><p>select * from geek where c=N order by b limit 1;</p></blockquote><p>那么这时所有<code>ca</code>和索引<code>cb</code>有存在的必要吗？</p><p>假设表中记录为：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>d</td></tr><tr><td>1</td><td>3</td><td>2</td><td>d</td></tr><tr><td>1</td><td>4</td><td>3</td><td>d</td></tr><tr><td>2</td><td>1</td><td>3</td><td>d</td></tr><tr><td>2</td><td>2</td><td>2</td><td>d</td></tr><tr><td>2</td><td>3</td><td>4</td><td>d</td></tr></tbody></table><p>主键<code>a</code>和<code>b</code>的联合主键相当于对数据进行<code>order by a, b</code>。也就是先按<code>a</code>排序，再按<code>b</code>排序，<code>c</code>无序，这里没有使用到<code>d</code>。</p><p>索引<code>ca</code>的组织结果：逻辑上最后一列是<code>ab</code>的值，但是由于联合索引中已经存在了<code>a</code>，索引最后一列中只有<code>b</code>。<b>与索引<code>(c)</code>一致。</b></p><table><thead><tr><th>c</th><th>a</th><th>b(主键的b部分)</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>3</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>1</td><td>2</td></tr><tr><td>3</td><td>1</td><td>4</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>3</td></tr></tbody></table><p>索引<code>cb</code>的组织结果：同理，最后一列也只有<code>b</code>。</p><table><thead><tr><th>c</th><th>a</th><th>a(主键的a部分)</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>3</td><td>1</td></tr><tr><td>3</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>3</td><td>4</td><td>1</td></tr><tr><td>4</td><td>3</td><td>2</td></tr></tbody></table><p>综上：<code>ca</code>索引和<code>c</code>的数据组织结果一致，但<code>cb</code>不一致，若上述两条查询语句为高频语句，则<code>cb</code>可以保留。</p><h2 id="字符串添加索引"><a href="#字符串添加索引" class="headerlink" title="字符串添加索引"></a>字符串添加索引</h2><p>​    字符串字段存在一个问题，如果是热点字段使用比较频繁，在不加字段的情况下，就会出现一直全表扫描，那么如果为字符串字段添加索引？</p><p>如果你仅仅只想到直接为该字符串字段添加一个索引，那么只能说你只看到了问题的表面，因为为字符串字段添加索引需要考虑到这个字符串字段的长度问题，如果这个字符串长度比较长，那么这个索引需要占用的空间就会比较大。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是只取字段的部分长度作为索引：</p><blockquote><p>alter table SUser add index index2(email(6));</p></blockquote><p>设置<code>SUser</code>表的<code>email</code>字段的前6位作为索引。<br>假设表中有数据：</p><table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>xiaocainiaoya@foxmail</td></tr><tr><td>2</td><td>cainiao@foxmail</td></tr><tr><td>3</td><td>niao@foxmail</td></tr></tbody></table><p>那么如果根据<code>email</code>前六位来做为前缀索引就只需要匹配一次，回表一次后，将字段值与查询值再次匹配若匹配成功，则获取数据。<br>所以这种方式需要这个字段存储的值具备一定的规则，然后根据规则设置索引的长度，长度越长，区分度就越高，查询效率就越高，伴随着占用空间就越大。</p><p><b>注：前缀索引会破坏覆盖索引，如果仅查询索引上的字段，但是由于需要回表进行一次匹配（系统不知道这个字段值到底有没有被截断）。所以覆盖索引相关的优化可能就失效了。</b></p><h3 id="倒叙存储"><a href="#倒叙存储" class="headerlink" title="倒叙存储"></a>倒叙存储</h3><p>一些字段的规则比如身份证，身份证的前面6位表示地域位置，在查询时需要遍历的列就比较多，可以将身份证倒叙存储，也就是通过<code>reverse(idCard)</code>进行存储，再通过<code>index(idCard(6))</code>设置索引，减少遍历的行数。</p><h3 id="哈希字段"><a href="#哈希字段" class="headerlink" title="哈希字段"></a>哈希字段</h3><p>再设置一个哈希字段，比如创建身份证字段之后，再创建一个身份证的哈希字段，插入的时候计算身份证的哈希值填入，那么就可以为这个哈希字段添加索引，从而减少索引字段的长度，但是由于不同值经过哈希算法后可能会得到同一个值，所以存在一定的误差，在查询时还是要将身份证的原值加上。</p><blockquote><p>select field_list from t where id_card_crc=crc32(‘input_id_card_string’) and id_card=’input_id_card_string’</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>直接创建完整索引，这样可能比较占用空间；</p></li><li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p></li><li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p></li><li><p>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</p></li></ol><h2 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h2><p>如果在查询条件上添加聚合函数会导致索引失效，这是因为对索引字段进行聚合函数会破坏索引的有序性，导致优化器放弃走索引树的搜索功能，但是并不是说放弃了这个索引，因为如果遍历这个索引比遍历主键索引来的快，还是会使用这个索引，但是结果是使用了这个索引扫描的行也是全表的行数。</p><p>但是尽管有些聚合操作不破坏索引有序性，但是<code>MySQL</code>也不予支持，比如<code>where age + 1 = 1001</code>，不会改变索引的有序性，但是这时候也是扫描全表，要修改为<code>where age = 1001 - 1</code></p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>如果表中有一个<code>varchar</code>字段，但是查询语句是<code>where age = 10</code>，那么就涉及到类型的转换，<code>MySQL</code>采用的是字符串转换成数字的转换。也就是说<code>where age = 10</code>，需要将全表的数据都进行字符串转数字的转换，所以导致了索引失效。<br>如果换过来，表中有一个<code>int</code>字段，但是查询语句是<code>where age = &#39;10&#39;</code>,这个时候实际上是将这个<code>&#39;10&#39;</code>转为数字，在去表中匹配，这时就会命中索引。</p><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>假设有两个表有关联操作，但是关联字段的编码不一样，一个是<code>utf8mb4</code>，一个是<code>utf8</code>，因为<code>utf8mb4</code>是<code>utf8</code>的超集，在做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，是按“数据长度增加的方向”进行转换。</p><p>也就是说，实际上这个语句等同于下面这个写法: </p><blockquote><p>select * from trade_detail  where traideid USING utf8mb4 = $L2.tradeid.value;<br>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</p></blockquote><p>在这种情况下实际上就是需要判断谁是驱动表，谁是被驱动表，</p><blockquote><p>select * from trade_detail  where traideid = CONVERT($L2.tradeid.value USING utf8mb4);</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（二）—索引&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（二）—索引&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（二）—索引&quot;&gt;&lt;/a&gt;mysql45讲学习总结（二）—索引&lt;/h1&gt;&lt;p&gt;​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA插件开发</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2022-09-19T13:51:58.000Z</published>
    <updated>2022-09-22T01:47:29.721Z</updated>
    
    <content type="html"><![CDATA[<p>​    公司中提交<code>MYSQL</code>脚本有相应的规范，需要编写为<code>groovy</code>文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在<code>console</code>控制台上交互，使用上有点繁琐，偶然看到关于<code>IDEA</code>插件开发的博客，想着是否可以通过<code>IDEA</code>插件来写一个<code>UI</code>，生成逻辑直接使用原有代码移植过来。同时记录在开发<code>IntelliJ IDEA</code>插件过程中遇到的一些问题和踩到的一些坑。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>​    <code>IntelliJ IDEA</code>插件开发有两种方式，一种是直接引入<code>Plugin DevKit</code>，然后配置<code>IntelliJ Platform Plugin SDK</code>进行开发，另一种是使用<code>gradle</code>构建项目并引入<code>IDEA</code>插件开发包。使用<code>gradle</code>的好处是同时也可以引入一些其他的库进行使用。</p><p>​    在<code>IDEA 2021.3</code>以及之后的版本，开发需要使用<code>JDK 11</code>进行开发，在我开发的时候我本地也没有<code>JDK 11</code>(一台电脑可以支持多个版本的<code>JDK</code>，问题在于环境变量配置的是哪个版本而已。因为目前只有这里插件开发我才会用到<code>JDK 11</code>，所以没有将它添加到环境变量中，仅通过<code>IDEA</code>工具添加了<code>JDK</code>路径)。</p><p>​    我使用的是<code>gradle</code>的方式进行插件的开发。<code>gradle</code>导入之后，在<code>Libraries</code>下会有一个<code>com.jetbrains:ideaIC:2021.3</code>，这就是<code>IDEA</code>插件的开发包。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// IDEA的插件开发包</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;1.8.1&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// 设置阿里云maven仓库 </span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;cn.hutool:hutool-all:5.6.7&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.alibaba:fastjson:1.2.28&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-core:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-jul:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-slf4j-impl:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.25&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.9.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.9.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idea的使用版本</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    version = <span class="string">&#x27;2021.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">patchPluginXml &#123;</span><br><span class="line">    changeNotes = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Add change notes here.&lt;br&gt;</span></span><br><span class="line"><span class="string">      &lt;em&gt;most HTML tags may be used&lt;/em&gt;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gradle</code>中一些常用项：</p><p><code>intellij -&gt; runIde</code>：这时会新启动一个<code>IDEA</code>工具，可以进行调试插件。</p><p><code>intellij -&gt; buildPlugin</code>：构建插件，用来完成之后将代码打包成<code>.zip</code>。(路径为<code>build/distributions</code>)。</p><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p>点击<code>Help -&gt; Edit Custom Properties...</code>，添加以下配置后重启<code>IDEA</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">idea.is.internal</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>在<code>Tool</code>下会出现<code>Interal Actions</code>和<code>View PSI Structure...</code>按钮。</p><p><img src="https://s2.loli.net/2022/09/20/xouELJspl16qTnj.png" alt="ideaInternal.png"></p><p>参考面板：<code>Internal Actions -&gt; UI -&gt; Show Standard Panels</code>：会弹出一个<code>UI</code>面板，结合<code>UI Debug</code>就可以参考到对应的源码。</p><p><img src="https://s2.loli.net/2022/09/20/p46q5sldBj7Q3cn.png" alt="standPanel.png"></p><p>通过<code>Internal Actions -&gt;UI Debugger</code>可以监控在<code>IDEA</code>中鼠标操作对应的<code>Action</code>。比如创建一个类，在<code>UI Debugger</code>面板上可以看到一个<code>CreateClassAction</code>的类，就可以看到这个创建一个类的源码，如果功能类似甚至可以直接复用。</p><p>与<code>PSI</code>相关<code>API</code>目前占时没有使用，具体如果需要插件能实现在代码里根据某种规则生成内容，则就需要通过<code>PSI</code>相关内容进行处理。</p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idea-plugin</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">    └── main</span><br><span class="line">          └── resources</span><br><span class="line">          │     └── META-INF</span><br><span class="line">          │          └── plugin.xml</span><br><span class="line">          └── java</span><br><span class="line">              └── cn<span class="selector-class">.com</span>.xiaocainiao</span><br><span class="line">                       └── MyWindowFactory<span class="selector-class">.java</span>  </span><br></pre></td></tr></table></figure><h2 id="plugin-xml配置"><a href="#plugin-xml配置" class="headerlink" title="plugin.xml配置"></a>plugin.xml配置</h2><p>我使用的是<code>ToolWindowFactory</code>创建右侧窗体。若是创建<code>Action</code>，可以直接通过<code>New -&gt; Plugin DevKit -&gt; Action</code>进行创建，通过这种方式创建，会自动在<code>plugin.xml</code>文件中添加<code>&lt;action&gt;</code>的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>org.example.SecondIdeaPlugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SecondIdeaPlugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;xiaocainiaoya@foxmail.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://xxx.com&quot;</span>&gt;</span>bosssoft<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">        For simple and quick generation of SQL script files&lt;br&gt;</span><br><span class="line">        &lt;em&gt;Tools that are easy to use&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- please see https://plugins.jetbrains.com/docs/intellij/plugin-compatibility.html</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">toolWindow</span> <span class="attr">id</span>=<span class="string">&quot;generatorSQL&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">secondary</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">anchor</span>=<span class="string">&quot;right&quot;</span> <span class="attr">factoryClass</span>=<span class="string">&quot;cn.com.xiaocainiaoya.MyWindowFactory&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">toolWindow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>​    由于<code>IDEA</code>插件的<code>UI</code>采用的是<code>Swing</code>、<code>Awt</code>来进行窗体开发，当知道使用的是<code>Swing</code>一度想要放弃掉，确实是使用<code>Swing</code>是一件比较痛苦的事情。后借助于<code>IDEA</code>的<code>Swing UI Designer</code>功能通过拖拽简单组件的方式，硬着头皮画出了<code>UI</code>界面。</p><p><img src="https://s2.loli.net/2022/09/19/sTRPS3cQYnVABFD.png" alt="ideaSwing.png"></p><h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><h2 id="1-路径"><a href="#1-路径" class="headerlink" title="1.路径"></a>1.路径</h2><p>​    可能由于项目有别于常用的<code>java</code>项目、<code>spring</code>项目，所以在获取资源文件(<code>/resources/**</code>)时，总是感觉摸不着头脑。参考了一些其他博主写的<code>IDEA</code>插件项目，获取资源文件的方式，与<code>java</code>项目、<code>Spring</code>项目并无差别，但是我在获取资源文件时，一直提交获取不到资源文件，也有可能是<code>velocity</code>组件的问题。</p><p>​    原本使用<code>velocity</code>模板引擎来加载对应模板文件，但是一直报错获取不到对应资源文件之后，将这种动作修改为代码层获取到资源文件内容，在将模板内容提交给<code>velocity</code>模板引擎。</p><p>注：<code>velocity</code>组件和<code>groovy</code>库相关包在<code>com.jetbrains:ideaIC:20201.3</code>中已经存在，所以不能由自身再引入。</p><p>在调试开发过程中，<code>velocity</code>正常使用，但是打包成插件之后，通过插件的方式运行，一直报一个日志相关的异常。</p><p>添加<code>velocity.proerties</code>配置文件相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">runtime.log.logsystem.class</span>=<span class="string">org.apache.velocity.runtime.log.SimpleLog4JLogSystem</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.category</span>=<span class="string">velocity</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.logger</span>=<span class="string">velocity</span></span><br></pre></td></tr></table></figure><p>因为在调试过程的运行和实际插件方式运行是对应的相对路径是不一致的，所以在使用系统级有关的相对路径是需通过使用<code>com.intellij.openapi.application.PathManager</code>类来获取对应的路径：</p><p>比如使用<code>PathManager.getBinPath()</code>：</p><p>在调试运行获取到的路劲为：<code>/usr/local/Cellar/gradle/7.3.1/caches/modules-2/files-2.1/com.jetbrains.intellij.idea/ideaIC/2021.3/75777e10a0e2880bc02945066dda2480a696c3d9/ideaIC-2021.3/bin</code></p><p>在实际插件方式允许获取的路径为：<code>/Applications/IntelliJ IDEA.app/Contents/bin</code></p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://zhuanlan.zhihu.com/p/400059601" target="_blank">IntelliJ IDEA 插件开发指南</a></p><p><a href="https://plugins.jetbrains.com/docs/intellij/welcome.html" target="_blank">插件入门官网</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    公司中提交&lt;code&gt;MYSQL&lt;/code&gt;脚本有相应的规范，需要编写为&lt;code&gt;groovy&lt;/code&gt;文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在&lt;code&gt;console&lt;/code&gt;控制台上交互，使用上有点繁琐，偶然看到关于&lt;code&gt;IDEA&lt;/code&gt;插件开发的博客，想着是否可以通过&lt;code&gt;IDEA&lt;/code&gt;插件来写一个&lt;code&gt;UI&lt;/code&gt;，生成逻辑直接使用原有代码移植过来。同时记录在开发&lt;code&gt;IntelliJ IDEA&lt;/code&gt;插件过程中遇到的一些问题和踩到的一些坑。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="插件" scheme="http://xiaocainiaoya.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>markdown记录</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/</id>
    <published>2022-09-13T13:51:58.000Z</published>
    <updated>2022-09-27T09:19:50.493Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><table><thead><tr><th>符号</th><th>说明</th><th>编码(使用时移除’+’号)</th></tr></thead><tbody><tr><td>←</td><td>左箭头</td><td>&amp;+larr;</td></tr><tr><td>→</td><td>右箭头</td><td>&amp;+rarr;</td></tr><tr><td>↑</td><td>上箭头</td><td>&amp;+uarr;</td></tr><tr><td>↓</td><td>下箭头</td><td>&amp;+darr;</td></tr><tr><td>↔</td><td>水平箭头</td><td>&amp;+harr;</td></tr><tr><td>↕</td><td>竖直箭头</td><td>&amp;+varr;</td></tr><tr><td>⇐</td><td>双线左箭头</td><td>&amp;+lArr;</td></tr><tr><td>⇒</td><td>双线右箭头</td><td>&amp;+rArr;</td></tr><tr><td>⇑</td><td>双线上箭头</td><td>&amp;+uArr;</td></tr><tr><td>⇓</td><td>双线上箭头</td><td>&amp;+dArr;</td></tr><tr><td>⇔</td><td>双线水平双箭头</td><td>&amp;+hArr;</td></tr><tr><td>⇕</td><td>双线竖直箭头</td><td>&amp;+vArr;</td></tr></tbody></table><h1 id="跳转方式"><a href="#跳转方式" class="headerlink" title="跳转方式"></a>跳转方式</h1><p><strong>1.页内定位：</strong></p><ol><li>定义一个锚(id)：<code>&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</code></li><li>使用markdown语法：<code>[点击跳转](#jump)</code></li></ol><p><strong>2.重定向</strong></p><blockquote><p>[描述] (地址)</p></blockquote><p><strong>3.新标签页打开：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>显示字眼<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="表格内换行"><a href="#表格内换行" class="headerlink" title="表格内换行"></a>表格内换行</h1><p>使用<code>&lt;br&gt;</code></p><h1 id="黑体"><a href="#黑体" class="headerlink" title="黑体"></a>黑体</h1><p>部分<code>markdown</code>渲染器无法识别<code>****</code>，可以使用<code>&lt;b&gt;&lt;/b&gt;</code>的<code>html</code>标签来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;箭头&quot;&gt;&lt;a href=&quot;#箭头&quot; class=&quot;headerlink&quot; title=&quot;箭头&quot;&gt;&lt;/a&gt;箭头&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="markdown" scheme="http://xiaocainiaoya.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本基础</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-13T13:51:58.000Z</published>
    <updated>2022-09-22T01:47:37.209Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。</p></blockquote><span id="more"></span><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>最精简的<code>if</code>语句：<code>condition</code>是判断条件，<code>statement</code>判断条件为真时的执行语句。在<code>shell</code>脚本中不是通过大括号<code>&#123;&#125;</code>开标识代码的开始与结束。而是通过<code>fi</code>来闭合。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>也可以写成：当<code>condition</code>和<code>then</code>在同一行时，需要使用分号隔开，否则报语法错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition; <span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>结合<code>else</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statement2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>再结合<code>else if</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statementn</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>判断表达式：</p><blockquote><p>-e filename 如果 filename存在，则为真<br>-d filename 如果 filename为目录，则为真<br>-f filename 如果 filename为常规文件，则为真<br>-L filename 如果 filename为符号链接，则为真<br>-r filename 如果 filename可读，则为真<br>-w filename 如果 filename可写，则为真<br>-x filename 如果 filename可执行，则为真<br>-s filename 如果文件长度不为0，则为真<br>-h filename 如果文件是软链接，则为真<br>filename1 -nt filename2 如果 filename1比 filename2新，则为真。<br>filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</p></blockquote><p>整数变量表达式：</p><blockquote><p>-eq 等于<br>-ne 不等于<br>-gt 大于<br>-ge 大于等于<br>-lt 小于<br>-le 小于等于</p></blockquote><p>字符串变量表达式：</p><blockquote><p>If  [ $a = $b ]         如果string1等于string2，则为真<br>if  [ $string1 !=  $string2 ]  如果string1不等于string2，则为真<br>if  [ -n $string  ]       如果string 非空(非0），返回0(true)<br>if  [ -z $string  ]       如果string 为空，则为真<br>if  [ $sting ]          如果string 非空，返回0 (和-n类似) </p></blockquote><p>逻辑符号：</p><blockquote><p>逻辑非 !     if [ ! 表达式 ]<br>if [ ! -d $num ]         如果不存在目录$num</p><p>逻辑与 –a          条件表达式的并列(类似其他语言的<code>&amp;&amp;</code>)<br>if [ 表达式1  –a  表达式2 ]</p><p>  逻辑或 -o          条件表达式的或(类似其他语言的<code>||</code> )<br>if [ 表达式1  –o 表达式2 ]</p></blockquote><h4 id="2-循环"><a href="#2-循环" class="headerlink" title="2.循环"></a>2.循环</h4><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="shell" scheme="http://xiaocainiaoya.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Spock实践（一）</title>
    <link href="http://xiaocainiaoya.github.io/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-05T13:04:58.000Z</published>
    <updated>2022-08-05T09:24:23.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spock实践（一）"><a href="#Spock实践（一）" class="headerlink" title="Spock实践（一）"></a>Spock实践（一）</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在<code>Spring</code>体系中，常用的单元测试框架就是基于<code>PowerMock</code>或者<code>MockTo</code>等，由于这些框架依赖<code>Spring</code>容器，所以在编写过程需要频繁的启动<code>Spring</code>容器进行单元测试的测试，导致过程比较繁琐。<span id="more"></span></p><p>​    最近看到一篇美团的2021博客点击率<code>TOP10</code>中的一篇<a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">Spock单元测试框架介绍以及在美团优选的实践</a>，使用全新的<code>Spock</code>框架来进行单元测试，这个框架的好处，无需依赖<code>Spring</code>容器来进行单元测试，并且结合<code>groovy</code>动态语言的特点，提供了一些标签，并采用简单、通用、结构化的描述语言，让编写测试代码更加简洁、高效。具体细节参考美团的那篇技术博客。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><h4 id="对于dao层抽象"><a href="#对于dao层抽象" class="headerlink" title="对于dao层抽象"></a>对于dao层抽象</h4><p>​    在将这篇博客中的一些例子简单跑过之后，<code>Spock</code>确实在单元测试的编写上比较简单且直观，但是由于它不依赖于<code>Spring</code>容器，导致了原来<code>Spring</code>框架为我们封装的一些特性无法使用，比如在我们应用中，到处都是通过<code>tk.mybatis</code>或者<code>mybatis plus</code>的一些通过接口<code>api</code>来动态化<code>SQL</code>，而无需进行手动编写<code>SQL</code>。这些特性实际上是通过<code>Spring</code>容器中在创建特定<code>bean</code>对象时通过<code>spring</code>的扩展点进行处理的。在美团的那篇博客中也提到了如果想测试<code>dao</code>层，可以通过<code>MyBatis的SqlSession</code>启动<code>mapper</code>实例，但是这种方式仅仅获取到的是最基础的<code>ibatis</code>的代理对象，没有了<code>tk</code>或者是<code>mp</code>相关的增强。</p><p>​    由于目前只是想简单的引入<code>Spock</code>到某一个服务中，在实际的业务逻辑中，并不确定引入<code>Spock</code>对单元测试的编写是否会有提高，所以这里仅仅研究了如何在不依赖<code>spring</code>容器的情况下，伪造<code>tk.mybatis</code>查询时的<code>mapper</code>对象。</p><p>​    跟踪<code>Springbean</code>对象的创建过程，发现<code>tk.mybatis</code>主要是靠<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>(注意包路径，<code>ibatis</code>包下有一个同名类)来进行一些增强处理。所以创建一个工具类，专门用来获取对应的<code>mapper</code>代理对象。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用mapper工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * @date 2022/7/30 16:11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapperUtil</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MapperHelper mapperHelper = <span class="keyword">new</span> MapperHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config config = <span class="keyword">new</span> Config()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapperHelper.setConfig(config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">def</span> getMapper(Class clazz)&#123;</span><br><span class="line">        ClassLoader classLoader = MapperUtil.<span class="keyword">class</span>.getClassLoader()</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(classLoader.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟tk.mybatis相关创建过程</span></span><br><span class="line">        MapperFactoryBean mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean(clazz)</span><br><span class="line">        mapperFactoryBean.setSqlSessionFactory(sqlSessionFactory)</span><br><span class="line">        mapperFactoryBean.setMapperHelper(mapperHelper)</span><br><span class="line">        mapperFactoryBean.afterPropertiesSet()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperFactoryBean.getObject()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="H2内存数据库"><a href="#H2内存数据库" class="headerlink" title="H2内存数据库"></a>H2内存数据库</h4><p>​    在美团的这篇博客中，推荐使用<code>H2</code>数据库进行数据的隔离，在对<code>H2</code>进行一些了解后发现<code>H2</code>对<code>mysql</code>的一些语句并不支持，比如建表时的索引之类，所以需要修改原本的建表脚本，在进行一些字段迭代时，可能会比较繁琐。</p><p>通过直接使用<code>java.sql.Connection</code>对象来创建数据库连接，并执行建表语句。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AUTO_SERVER=TRUE 默认情况下只能单个连接，这个配置用来开启多个连接</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:h2:~/test;MODE=MySQL;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;AUTO_SERVER=TRUE</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>执行处理代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> executeSql(String sqlPath) &#123;</span><br><span class="line">    <span class="comment">// 执行sql文件</span></span><br><span class="line">    File sqlFile = <span class="keyword">new</span> File(sqlPath)</span><br><span class="line">    <span class="keyword">if</span>(!sqlFile.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;sql文件不存在&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Statement statement = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        statement = CONNECTION.createStatement();</span><br><span class="line">        <span class="keyword">boolean</span> success = statement.execute(sqlFile.text)</span><br><span class="line">        <span class="comment">// 这里有点不解，无论是脚本执行成功还是执行失败，这里好像返回的都是false</span></span><br><span class="line">        <span class="comment">// 目前不影响使用，没有进行深究</span></span><br><span class="line">        success ? println(<span class="string">&quot;执行sql文件成功&quot;</span>) : println(<span class="string">&quot;执行sql文件失败&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DbUnit的使用"><a href="#DbUnit的使用" class="headerlink" title="DbUnit的使用"></a>DbUnit的使用</h4><p>​    根据美团的这篇博客中，使用<code>DbUnit</code>来进行数据层数据的访问控制，也就是在初始化某个单元测试接口时进行的一些准备数据脚本的执行，</p><h5 id="基于xml脚本文件"><a href="#基于xml脚本文件" class="headerlink" title="基于xml脚本文件"></a>基于xml脚本文件</h5><p>​    在经过测试发现，<code>DbUnit</code>是通过<code>xml</code>文件来编写插入数据的脚本，这就导致写<code>xml</code>插入数据脚本文件也会花费一些工作量。以下为一个示例，假设要为某个接口准备几十条数据，估计准备数据的过程要疯，后期可以看看<code>DbUnit</code>有没有接口可以通过<code>SQL</code>转换为这个<code>xml</code>文件，或者自己实现一个接口，将<code>SQL</code>转换为<code>xml</code>文件来减少工作流。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataset</span>&gt;</span></span><br><span class="line">    &lt;gpfa_process_business</span><br><span class="line">            id=&quot;10007&quot;</span><br><span class="line">            test_id=&quot;1&quot;</span><br><span class="line">            name=&quot;2&quot;</span><br><span class="line">            value = &quot;1&quot;</span><br><span class="line">            mark = &quot;测试&quot;</span><br><span class="line">            create_time = &quot;2018-01-01&quot;</span><br><span class="line">            /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="基于csv脚本文件"><a href="#基于csv脚本文件" class="headerlink" title="基于csv脚本文件"></a>基于csv脚本文件</h5><p>​    <code>DbUnit</code>还支持通过<code>.csv</code>文件进行数据准备，但是比较繁琐的是它好像不能执行具体的文件，需要执行一个目录，并且目录下需要创建一个<code>table-ordering.txt</code>文件，内容为此目录下要执行的<code>csv</code>文件名称，同时<code>csv</code>文件的名称需与表名保持一致。</p><h4 id="自定义查询SQL语句"><a href="#自定义查询SQL语句" class="headerlink" title="自定义查询SQL语句"></a>自定义查询SQL语句</h4><p>​    对于在<code>xxxMapper.xml</code>文件中的查询语句，目前不知道因为什么原因，字段值无法赋值到实体上，需要通过<code>as</code>关键字将下划线字段别名为驼峰形式才可在实体中获取到，这个问题无疑是致命的，导致基本上所有的<code>mapper.xml</code>文件都无法进行单元测试。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spock实践（一）&quot;&gt;&lt;a href=&quot;#Spock实践（一）&quot; class=&quot;headerlink&quot; title=&quot;Spock实践（一）&quot;&gt;&lt;/a&gt;Spock实践（一）&lt;/h1&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在&lt;code&gt;Spring&lt;/code&gt;体系中，常用的单元测试框架就是基于&lt;code&gt;PowerMock&lt;/code&gt;或者&lt;code&gt;MockTo&lt;/code&gt;等，由于这些框架依赖&lt;code&gt;Spring&lt;/code&gt;容器，所以在编写过程需要频繁的启动&lt;code&gt;Spring&lt;/code&gt;容器进行单元测试的测试，导致过程比较繁琐。</summary>
    
    
    
    <category term="Spock" scheme="http://xiaocainiaoya.github.io/categories/Spock/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引优化</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-29T14:13:58.000Z</published>
    <updated>2022-10-17T09:11:42.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql索引优化"><a href="#mysql索引优化" class="headerlink" title="mysql索引优化"></a>mysql索引优化</h1><p>​    描述使用<code>explain</code>命令中的每列所代表的含义，以及出现某些慢查询时的一些优化。</p><span id="more"></span><p>通过<code>explain</code>命令可以知道<code>MySQL</code>是怎么执行语句，包括有关如何连接表以及连接表的顺序、扫描的行数、是否使用索引、排序使用的是内存排序还是磁盘排序等等。所以一般的语句优化手段都是通过<code>explain</code>来查询语句的处理过程，修改全表扫描的语句，优化查询效率。</p><p><img src="https://s2.loli.net/2022/10/17/mPcMZU9QsSJ5z7K.png" alt="简单expain示例.png"></p><p><b>上图是一个最简单的<code>explain select * from xxx</code>的执行结果，以下依次解释每一项的含义</b></p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>假设执行语句为<code>explain select * from words where id in (select id from words where word like &#39;aa%&#39;)</code><br>输出结果为:<br><img src="https://s2.loli.net/2022/10/17/5LAeJ2RofKDiMVS.png" alt="expain查询id示例.png"></p><p>这里的<code>id</code>值有两个1和2，实际上对于这条查询语句来说，是先执行了括号内的查询，在将括号内的结果赋予外层查询语句进行第二次查询，所以在<code>expian</code>结果有两条记录，id值越高越先执行，id值相同时从上往下执行。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>表示查询的类型：</p><ol><li><code>SIMPLE</code>: 简单语句，比如<code>select * from xxx </code>。</li><li><code>SUBQUERY</code>: 子查询</li><li><code>PRIMARY</code>: 主查询，最外层查询，表示最后一个到它</li><li><code>DERIVED</code>: 衍生表，查询语句中会生成新的表，比如<code>select * from words as t1, (select false) as t2</code></li><li><code>UNION</code>: 连接表</li><li><code>UNION RESULT</code>: 连接结果，一般与<code>UNION</code>配套出现</li></ol><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示某一个子查询使用到的表是什么，一般的查询语句直接就是某一个表，但是一些特殊处理，比如<code>select * from words as t1, (select false) as t2</code>这里的<code>table</code>就是空，因为它是临时生成的不是数据库中存在的表结构，再或者是使用<code>union</code>联合的时候，<code>select_type=UNION RESULT</code>的子查询是将两个查询结果联合，所以会标识是那两个id值所对应的查询进行联合<code>&lt;union id1, id2&gt;</code></p><p><img src="https://s2.loli.net/2022/10/17/7yjJrwtMZKVvqGh.png" alt="explain衍生表示例.png"></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type表示连接类型，查看索引执行情况的一个重要指标。以下性能从好到坏依次：<br><code>system  &gt; const &gt; eq_ref &gt; ref  &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p><ol><li><code>system</code>：这种类型要求数据库表中只有一条数据，是const类型的一个特例，一般情况下是不会出现的。</li><li><code>const</code>：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，速度非常快。</li><li><code>eq_ref</code>：常用于主键或唯一索引扫描，一般指使用主键的关联查询</li><li><code>ref</code>：常用于非主键和唯一索引扫描。</li><li><code>ref_or_null</code>：这种连接类型类似于ref，区别在于MySQL会额外搜索包含NULL值的行</li><li><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</li><li><code>unique_subquery</code>：类似于eq_ref，条件用了in子查询</li><li><code>index_subquery</code>：区别于unique_subquery，用于非唯一索引，可以返回重复值。</li><li><code>range</code>：常用于范围查询，比如：between … and 或 In 等操作，如果是这个类型需要注意，可能会因为数据量的原因导致索引失效</li><li><code>index</code>：全索引扫描</li><li><code>ALL</code>：全表扫描</li></ol><h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p><code>possible_key</code>这个一般来说用不上，意思就是理论上可能会使用到的索引，但是实际执行时可能会用不上，说了等于没说。<br><code>key</code>表示使用到的索引。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>使用的到的索引长度，<code>key_len</code>可以衡量索引的好坏，<code>key_len</code>越小，索引的效果越好，但是要注意如果索引是建立在一个字符串字段上，且字符串字段长度比较长，进行索引时可能会将字符串截断，也就是这一列的前n个字符参与索引。<br><code>MySQL innodb</code>引擎对于索引的长度是有限制的，最大为767字节，不同字符编码方式对应的字节数不一样，比如最常用的<code>utf8mb4</code>字符集是4字节字符集，767/4=191，所以在字符串上创建索引的前191字符才会参与索引。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列被使用了，如果是<code>where word = &#39;name&#39;</code>，那么显示的就是<code>const</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于<code>InnoDB</code>表，此数字是估计值，并非一定是个准确值，<code>InnoDB</code>的优化器也会通过需要扫描的行数来判断选择哪个索引。可以通过<code>analyze table t</code>命令，来重新统计索引信息。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>Using filesort</code>：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现。一般见于order by语句<br><code>Using index</code> ：表示是否用了覆盖索引。<br><code>Using temporary</code>： 表示是否使用了临时表,性能特别差，需要重点优化。一般多见于group by语句，或者union语句。<br><code>Using where</code> ： 表示使用了where条件过滤.<br><code>Using index condition</code>：MySQL5.6之后新增的索引下推。在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</p><h1 id="常用优化手段"><a href="#常用优化手段" class="headerlink" title="常用优化手段"></a>常用优化手段</h1><h3 id="1-in内容过多"><a href="#1-in内容过多" class="headerlink" title="1. in内容过多"></a>1. in内容过多</h3><p>使用<code>in</code>查询最好内容不要超过200个，因为<code>in</code>查询底层是通过<code>n*m</code>的方式去搜索，也就是每一个条件逐条遍历，默认临界值<code>eq_range_index_dive_limit=200</code>，如果超过这个值，可能会导致代价计算存在问题，从而导致<code>mySQL</code>选择的索引不准确。</p><h3 id="2-磁盘排序"><a href="#2-磁盘排序" class="headerlink" title="2. 磁盘排序"></a>2. 磁盘排序</h3><p>如果查询语句中存在<code>order by</code>但是<code>Extra</code>中没有<code>Using filesort</code>那么恭喜你，你的排序命中了索引，沿用了索引已然有序的特性直接查询出数据。但是实际情况并不是这么刚好，不命中索引的情况下，排序下的<code>Extra</code>的结果为<code>Using filesort</code>。排序分为全字段排序和<code>rowid</code>排序。至于是使用全字段排序和<code>rowid</code>排序主要影响因素是<code>max_length_for_sort_data</code>参数，当单行长度超过这个参数值时使用的就是<code>rowid</code>排序。<code>rowid</code>需要回表，查询性能比全字段查询差。</p><h3 id="3-不等号"><a href="#3-不等号" class="headerlink" title="3.不等号"></a>3.不等号</h3><p>查询使用不等号或者是<code>not in</code>这些时，索引形同虚设，这其实是被优化器处理了，因为优化器认为即便是走索引，还是需要扫描很多行，所以它觉得不划算，所以直接不走索引。还有<code>NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE</code>都会导致索引失效。</p><h3 id="4-group-by"><a href="#4-group-by" class="headerlink" title="4.group by"></a>4.group by</h3><blockquote><p>explain select wrod, num from words group by word</p></blockquote><p><img src="https://s2.loli.net/2022/10/17/2aLHIpAiF6oYWuN.png" alt="排序explain.png"><br>可以看到在<code>Extra</code>中有<code>Using filesort</code>和<code>Using temporary</code>，表示使用到了排序和临时表。<br><code>group by</code>的执行流程：</p><ol><li>创建内存临时表，表里设置字段<code>(word, num)</code></li><li>全表扫描<code>words</code>，依次取出<code>word</code>的值，判断临时表中是否有这个值，如果没有就插入<code>（word, 1）</code>，如果有就对这一行的<code>num</code>加一。</li><li>遍历完成后，再对<code>word</code>排序后返回结果。</li></ol><p><b>优化方式：</b>可以对<code>group by</code>后面的字段添加索引，提高步骤1的执行效率；使用<code>order by null</code>，既然默认是要排序，那么手动设置为不要排序，提高步骤3的执行效率。</p><h3 id="5-delete-in"><a href="#5-delete-in" class="headerlink" title="5. delete + in"></a>5. delete + in</h3><p><code>delete form xx where xx in (xx)</code>这个删除语句不会命中索引，但是<code>select * form xx where xx in (xx) </code>这个是会命中索引的，原因是对于这个查询语句实际上将<code>SQL</code>优化为可以命中索引的方式。</p><h3 id="6-asc和desc"><a href="#6-asc和desc" class="headerlink" title="6. asc和desc"></a>6. asc和desc</h3><p>如果出现<code>asc</code>和<code>desc</code>混用，也会导致索引失效。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql索引优化&quot;&gt;&lt;a href=&quot;#mysql索引优化&quot; class=&quot;headerlink&quot; title=&quot;mysql索引优化&quot;&gt;&lt;/a&gt;mysql索引优化&lt;/h1&gt;&lt;p&gt;​    描述使用&lt;code&gt;explain&lt;/code&gt;命令中的每列所代表的含义，以及出现某些慢查询时的一些优化。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>tk.mybaits动态表名</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/</id>
    <published>2022-07-27T14:13:58.000Z</published>
    <updated>2022-07-27T13:49:50.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits动态表名"><a href="#tk-mybaits动态表名" class="headerlink" title="tk.mybaits动态表名"></a>tk.mybaits动态表名</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以<code>ORDER_</code>开头。且一些二次开发的组件中也有使用<code>mysql</code>进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。 <span id="more"></span>    </p><h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>​    <code>tk.mybatis</code>的大致处理逻辑：</p><p><img src="https://s2.loli.net/2022/07/27/XcaJ5jdZ2omVnP1.png" alt="tk相关处理过程.png"></p><ol><li>扫描器会将所有被<code>@Mapper</code>标记的类通过<code>SpringBean</code>的创建对象流程中，然后创建相应的对象后，添加到<code>SpringBean</code>容器中。</li><li>将这个标记的类对象包装为<code>MapperFactoryBean</code>对象</li><li>待到创建<code>bean</code>流程的最后，也就是经过了初始化、后置处理器列表等扩展点的相关处理之后，通过包装对象<code>MapperFactoryBean#afterPropertiesSet()</code>进行<code>tk.mybatis</code>对象的二次处理。</li><li>通过这个后置方法，解析出这个<code>@Mapper</code>对象所对应的表实体的表名和其他一些在创建<code>SQL</code>所需要的配置信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在这个map中 实体类 =&gt; 表对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, EntityTable&gt; entityTableMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EntityTable&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>根据这个标记对象所继承的上层接口，逐个解析出对应的<code>SQL</code>语句。以下方代码为例，这里的上层接口<code>CommonMapper</code>继承于<code>Mapper</code>，而<code>Mapper</code>又继承于很多的上层接口，其中就有<code>selectOne</code>接口，那么在这一步就会根据第四步骤中解析出来的表信息和字段信息等，构建一个基于变量的<code>SQL</code>语句，如果业务层调用该方法时，仅将相关参数填充后就形成一条完整的<code>SQL</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxxMapper</span> <span class="keyword">extends</span> <span class="title">CommonMapper</span>&lt;<span class="title">XxxAttachment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">ExampleMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">RowBoundsMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">Marker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectOneMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = &quot;dynamicSQL&quot;)</span></span><br><span class="line">    <span class="function">T <span class="title">selectOne</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>​    根据以上的步骤，可以得出一个结论，如果想要动态（这个动态是指创建时动态，并不是指运行时动态）的修改表名，那么需要在第四步之后，第五步之前将<code>entityTableMap</code>中对应的表名修改为想要的表名。</p><p>​    根据<code>Springbean</code>创建对象的逻辑，在初始化后置方法之前，会经过后置处理器列表，所以可以通过模拟一个后置处理器列表，提前对<code>entityTableMap</code>相关信息进行解析并缓存。</p><p><code>MapperFactoryBean</code> 进行处理的主要逻辑：</p><ol><li><p>根据<code>XxxMapper</code>类获取到对应的表实体</p></li><li><p>通过<code>EntityHelper.initEntityNameMap()</code>方法解析出这个表实体的相关信息，并缓存。</p></li><li><p>将<code>XxxMapper.selectExample() </code>等等内置的通用接口解析为动态SQL语句，缓存在某个地方(这个我没有去找在哪里)</p></li></ol><p>综上：只要能在 第3步之前将<code>EntityHelper</code>中的这个缓存中的<code>EntityTable</code>的表名称修改为相应的值，就能实现将表名动态化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TablePrefixBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * tk.mybatis 在 MapperFactoryBean 进行相关的逻辑处理，所以通过BeanPostProcessor，在执行MapperFactoryBean.afterPropertiesSet()方法之前，</span></span><br><span class="line"><span class="comment">    * 进行一次预处理，将表相关信息通过EntityHelper.initEntityNameMap()方法提前添加到对应的entityTableMap&lt;Class, EntityTable&gt;缓存之后，</span></span><br><span class="line"><span class="comment">    * 然后马上将这个实体所对应的EntityTable的表名进行需要的业务处理。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/7/27 16:04:01</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.lang.Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean.getClass() != <span class="keyword">null</span> &amp;&amp; bean.getClass().toString().contains(<span class="string">&quot;tk.mybatis.spring.mapper.MapperFactoryBean&quot;</span>))&#123;</span><br><span class="line">            Class&lt;?&gt; mapperClass = ((MapperFactoryBean)bean).getMapperInterface();</span><br><span class="line">            Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) types[<span class="number">0</span>];</span><br><span class="line">            Class&lt;?&gt; returnType = (Class&lt;?&gt;)  parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取mapperHelper</span></span><br><span class="line">            MapperHelper mapperHelper = (MapperHelper) ReflectUtil.getFieldValue(bean, <span class="string">&quot;mapperHelper&quot;</span>);</span><br><span class="line">            <span class="comment">// 提前解析这个bean所对应的表实体的相关信息</span></span><br><span class="line">            EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否需要修改表名</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                EntityTable entityTable = EntityHelper.getEntityTable(returnType);</span><br><span class="line">                entityTable.setName(<span class="string">&quot;prefix&quot;</span> + entityTable.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码中的最后的判断语句可以根据相应的规则，比如说自定义一个注解，并且在注解中指定一个前缀的参数，标记在实体上，这里可以通过获取这个注解进行是否需要添加前缀的逻辑处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    实际上以上这种场景应该在真是情况中少之又少，一般情况下并不会说想要统一某个服务中的所有表名前缀，但是在解决的问题的过程中，其实对<code>springBean</code>创建实体的流程，以及<code>tk.mybatis</code>对实体解析的相关逻辑都大致的过了一遍，加强了框架中一些细节处理的印象，对于后续如果出现一些<code>bug</code>可以尽快的定位到问题。</p><p>​    实际上我并不是一下子就想到这么做，在想到这么做之前，我也经过了其他的尝试，比方说我最先想到的是通过写<code>mybatis</code>插件的方式，拦截出<code>BoundSql</code>具体的<code>SQL</code>语句，通过修改这个<code>SQL</code>语句达到目的，但是发现不同类型的<code>SQL</code>判断方式略有不同，操作难度大，所以一直往上层追溯，发现<code>BoundSql</code>中的语句是在<code>Bean</code>初始化过程就已经生成，后面才一点一点整理出上述步骤流程，从而找到下手的地方。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits动态表名&quot;&gt;&lt;a href=&quot;#tk-mybaits动态表名&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits动态表名&quot;&gt;&lt;/a&gt;tk.mybaits动态表名&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以&lt;code&gt;ORDER_&lt;/code&gt;开头。且一些二次开发的组件中也有使用&lt;code&gt;mysql&lt;/code&gt;进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>tk.mybaits和mybatisPlus兼容性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/</id>
    <published>2022-07-21T14:13:58.000Z</published>
    <updated>2022-07-22T03:29:40.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits和mybatisPlus兼容性"><a href="#tk-mybaits和mybatisPlus兼容性" class="headerlink" title="tk.mybaits和mybatisPlus兼容性"></a>tk.mybaits和mybatisPlus兼容性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    项目早期建设时底层采用了<code>tk.mybatis</code>方式来对数据访问层进行数据处理，而后再更新<code>Springboot</code>的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实<code>tk.mybatis</code>官网已经没有维护了）又在底层引入了<code>mybatisPlus</code>，所以新代码采用<code>mybatisPlus</code>编写，旧模块任然使用<code>tk.mybatis</code>编写。<span id="more"></span>    </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    今天同事在移植项目中的一个功能模块时，报了一个错<code>No qualifying bean of type &#39;com.xxxx&#39;..</code>。乍一看猜测大概是因为对应的<code>xxxMapper</code>接口文件没有被扫描到<code>Spring</code>容器中，导致<code>tk.mybatis</code>的表集合中没有该实体。排查发现，启动类中并没有显示使用<code>@MapperScan</code>指定扫描路径，果然，使用的是启动类及以下的包结构，由于是搬迁的功能模块，不想调整原来包结构，故使用<code>@MapperScan</code>来指定扫描路径。</p><p>​    在启动类上通过<code>@MapperScan</code>指定了扫描路径之后可以正常启动，但是在调用接口发现又报错了<strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>，如果对<code>tk.mybatis</code>比较熟悉就知道，这里是因为<code>tk.mybatis</code>会将所有的表信息都缓存到一个集合中，仔细检查了指定的路径，也没有发现问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    经过一段时间的排查，终于找到了原因，在这里记录下，避免以后又遇到同样的问题，以下仅为个人观点，可能存在理解错误，请带着批判的视角阅读。</p><p>​    原来是在<code>tk.mybatis</code>中也有一个同名的<code>tk.mybatis.spring.annotation.MapperScan</code>，若使用<code>org.mybatis.spring.annotation.MapperScan</code>是不会对扫描到的对象进行一些<code>tk.mybatis</code>相关的处理，所以直接将注解更换为前者，再次启动，又报出了新的错误：</p><p>定位进去发现就是<code>tk.mybatis</code>处理对应接口缓存的时候报了类型转换异常：</p><blockquote><p>Caused by: java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getEntityClass(MappedStatement ms) &#123;</span><br><span class="line">    String msId = ms.getId();</span><br><span class="line">    <span class="keyword">if</span> (entityClassMap.containsKey(msId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> entityClassMap.get(msId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; mapperClass = getMapperClass(msId);</span><br><span class="line">        Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType t = (ParameterizedType) type;</span><br><span class="line">                <span class="keyword">if</span> (t.getRawType() == <span class="keyword">this</span>.mapperClass || <span class="keyword">this</span>.mapperClass.isAssignableFrom((Class&lt;?&gt;) t.getRawType())) &#123;</span><br><span class="line">                    <span class="comment">// 报错报在这里</span></span><br><span class="line">                    Class&lt;?&gt; returnType = (Class&lt;?&gt;) t.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取该类型后，第一次对该类型进行初始化</span></span><br><span class="line">                    EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line">                    entityClassMap.put(msId, returnType);</span><br><span class="line">                    <span class="keyword">return</span> returnType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MapperException(<span class="string">&quot;无法获取 &quot;</span> + msId + <span class="string">&quot; 方法的泛型信息!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里直接下结论：</strong>报这个错的原因是因为指定扫描的路径范围太大了，导致扫描到了底层中的二次封装类<code>public interface CommonMapper&lt;T&gt; extends Mapper&lt;T&gt;</code>，结合以上代码不难发现，是取出了<code>T</code>泛型进行强转之后报错，所以只需要将扫描路径的范围缩小即可。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在最后发现问题之后，解决起来就很轻松了，但是在排查的过程中，就非常的痛苦。因为报错的这个地方并没有显式的指明是某个类强转失败，而项目中又存在<code>mybatisPlus</code>和<code>tk.mybatis</code>共存的情况，乍一看代码以为是兼容性的问题，因为对于这两种方式来说，数据访问层接口采用的是不同的继承接口。</p><p>一个是<code>tk.mybatis.mapper.common.Mapper</code><T>，一个是<code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code>，所以一看到这个类型转换异常，就误以为是因为需要通过<code>tk.mybatis</code>来解析的<code>xxxMapper</code>被<code>mybatisPlus</code>接管导致。</p><p>​    在排查跟踪源码的过程中，对<code>tk.mybatis</code>和<code>mybatisPlus</code>相关的一些处理有了进一步的了解，在此做了记录。</p><p><code>tk.mybatis</code>通过<code>tk.mybatis.spring.mapper.ClassPathMapperScanner</code>扫描器将对应的表实体收集到一个集合中，注意<code>mybatis</code>也有自己的扫描器<code>org.mybatis.spring.mapper.ClassPathMapperScanner</code>，也就是说在项目启动过程中，实际上是经过了两次的扫描，并且<code>tk.mybatis</code>的扫描器在<code>mybatis</code>的扫描器之前，至于是怎么插到<code>mybatis</code>之前的，猜测是通过<code>spring</code>的某个后置接口，这个与本篇主题无关，不进一步详解。</p><p>​    其实<code>tk.mybatis</code>的扫描器主要是将指定路径(默认是启动类所在包及子包)中被<code>@Mapper</code>标记的类，解析成<code>BeanDefinition</code>，添加到<code>Spring</code>对应集合中，用于后续将其实例化为具体的<code>bean</code>对象到容器中。这些的主要逻辑在这两个扫描器的父类<code>ClassPathBeanDefinitionScanner#doScan</code>。经过<code>tk.mybatis</code>扫描器处理后的表实体，同样也会在<code>mybatis</code>扫描器被作为候选对象<code>candidate</code>被扫描到。但它会从<code>Spring</code>中查询一次，查看是否存在该<code>BeanDefinition</code>，若存在则打印<code>Skipping MapperFactoryBean with name &#39;xxxMapper&#39; and &#39;com.xx.xxx....mapper.XxxMapper&#39; mapperInterface. Bean already defined with the same name!</code>，大概意思就是这个类已经存在<code>BeanDefinition</code>，当前处理跳过该类的处理，也就是说在指定路径下的实体表只会被这两个扫描器中的其中一个扫描并进行相关处理。</p><p>​    <code>tk.mybatis</code>扫描器中在创建<code>BeanDefinition</code>时，将它的<code>resolvedTargetType</code>和<code>beanClass</code>字段都标记为了<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>，而<code>mybatis</code>扫描器扫描器中这两个字段标记的是<code>org.mybatis.spring.mapper.MapperFactoryBean</code>，这就导致在真正实例化<code>Spring bean</code>对象时调用了不同的后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#invokeInitMethods</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最后会调用初始化的后置接口</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟踪下进入到不同的后置接口的调用方式，继承关系如下代码所示，从上面的代码中的最后调用<code>bean</code>对象的<code>afterPropertiesSet</code>方法，到下面代码中是由于二者的上层接口中<code>DaoSupport</code>实现了<code>InitializingBean</code>方法。且这个后置初始化方法中仅调用了<code>checkDaoConfig</code>和<code>initDao</code>方法，均由具体的子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tk.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoSupport</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, BeanInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">// Let abstract subclasses check their configuration.</span></span><br><span class="line">        checkDaoConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let concrete implementations initialize themselves.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initDao();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Initialization of DAO failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tk.mybatis.spring.mapper.MapperFactoryBean</code>具体的实现：核心的处理在这里，刚刚上文说到，<code>tk.mybatis</code>会将指定路径下的所有<code>@Mapper</code>类的<code>BeanDefinition</code>中的<code>resolvedTargetType</code>和<code>beanClass</code>都标记为<code>tk.MapperFactoryBean</code>，那么也就是说指定路径下的所有<code>@Mapper</code>都会被识别为是<code>tk.mybatis</code>的<code>mapper</code>？其实不是，这里有一个判断<code>mapperHelper.isExtendCommonMapper()</code>，这个判断的主要逻辑是获取这个<code>XxxMapper</code>接口及所有上层父类接口是否有<code>tk.mybatis.mapper.annotation.RegisterMapper</code>注解，如果没有，则不采用<code>tk.mybatis</code>的方式进行解析。到这，应该就可以解答前面提出的问题，所以如果需要用<code>mybatisPlus</code>，那么它的<code>XxxMapper</code>接口的所有上传父类接口必然不会存在<code>tk.RegisterMapper</code>注解，也就不会进行<code>tk.mybatis</code>相关的处理(<code>tk.mybatis</code>这里的处理是将表实体和<code>xxxMapper</code>接口的一些方法等信息缓存起来)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasMapper(<span class="keyword">this</span>.mapperInterface) &amp;&amp; mapperHelper != <span class="keyword">null</span> &amp;&amp; mapperHelper.isExtendCommonMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">        mapperHelper.processConfiguration(getSqlSession().getConfiguration(), <span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>No qualifying bean of type &#39;com.xxxx&#39;..</code>的实际原因是移植的功能模块类路径不落在默认扫描路径范围内（启动类所在的包及子包）</li><li><strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>是因为通过<code>org.mybatis.spring.annotation.MapperScan</code>指定了<code>mybatis</code>的扫描路径，但没有指定<code>tk.MapperScan</code>，导致<code>tk</code>的扫描器使用默认值(默认值为启动类所在的包及子包)，恰好移植的功能模块不属于启动类的包及子包中，所以移植功能中的所有<code>xxxMapper</code>都被解析为了<code>mybatis</code>类型(也就是前面说的<code>beanDefinition</code>中的那两个属性被赋值为了<code>mybatis</code>对应的类)，最后导致在初始化<code>bean</code>对象时，没有进入到<code>tk.mybaits</code>对应类的后置处理器，也就没有将这些表实体相关信息缓存，从而导致以上报错。</li><li>类型转换异常的报错，是因为指定<code>tk.MapperScan</code>设置扫描范围太大，导致扫描到了底层二次封装的抽象父类，导致在获取接口层参数获取到了泛型参数<code>T</code>，泛型参数以<code>T</code>进行类型转换为<code>Class</code>从而导致了报错。</li><li>在都不指定<code>@MapperScan</code>的情况下，二者扫描器的默认扫描路径都是启动类所在的包以及子包，当指定了<code>tk.@MapperScan</code>之后那么<code>tk.mybatis</code>的扫描路径变成了这个具体的指定路径，<code>mybatis</code>的扫描路径还是默认的启动类所在的包极其子包，也就是说两个扫描器的扫描路径是互不影响的、各自维护，这个很重要，如果不明白这个，在排查的过程中，会影响对问题的判断。</li><li>引入<code>tk.mybatis</code>一定会经过两次扫描器，一次是<code>tk.mybatis</code>的扫描器，一次是<code>mybatis</code>原生的扫描器，如果某个<code>mapper</code>对象被<code>tk.mybatis</code>扫描生成了<code>BeanDefinition</code>，<code>mybatis</code>的扫描器会跳过该类，同样的，某个<code>xxxMapper</code>若想使用<code>mybatisPlus</code>的方式进行数据访问层的处理，虽然它在扫描阶段被认为是以<code>tk.mybatis</code>的方式解析，但是在具体创建<code>spring bean</code>对象的时候，<code>kt.mybatis</code>的后置接口中有相应的逻辑判断(所有上层接口是否有标记<code>RegisterMapper</code>)，来控制是否进行相应处理。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits和mybatisPlus兼容性&quot;&gt;&lt;a href=&quot;#tk-mybaits和mybatisPlus兼容性&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits和mybatisPlus兼容性&quot;&gt;&lt;/a&gt;tk.mybaits和mybatisPlus兼容性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    项目早期建设时底层采用了&lt;code&gt;tk.mybatis&lt;/code&gt;方式来对数据访问层进行数据处理，而后再更新&lt;code&gt;Springboot&lt;/code&gt;的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实&lt;code&gt;tk.mybatis&lt;/code&gt;官网已经没有维护了）又在底层引入了&lt;code&gt;mybatisPlus&lt;/code&gt;，所以新代码采用&lt;code&gt;mybatisPlus&lt;/code&gt;编写，旧模块任然使用&lt;code&gt;tk.mybatis&lt;/code&gt;编写。</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>数据库和缓存双写一致性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-07-20T12:50:58.000Z</published>
    <updated>2022-07-20T08:42:46.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和缓存双写一致性"><a href="#数据库和缓存双写一致性" class="headerlink" title="数据库和缓存双写一致性"></a>数据库和缓存双写一致性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。<span id="more"></span></p><p><img src="https://s2.loli.net/2022/07/20/m6zT1AH2oZvSwa8.png" alt="双写一致性.png"></p><p>通常来说，常见的应用场景为：</p><ol><li>用户请求查询某些数据，先进入缓存查看是否存在</li><li>存在则直接返回数据</li><li>不存在则查数据库，查到则将数据添加一份到缓存中，再返回，使得下次查询可以直接从缓存中获取，从而提高系统的响应速度。</li></ol><h2 id="双写的四种场景"><a href="#双写的四种场景" class="headerlink" title="双写的四种场景"></a>双写的四种场景</h2><ol><li>先更新缓存，再更新数据库</li></ol><p>​    如果采用这种方式，极易产生数据不一致的情况。因为先更新缓存，如果因为某些原因出现数据写入失败，比如主键冲突、非空字段未填值、数据库宕机等等情况导致数据库写入失败，这时就出现了缓存中是新值，数据库中是旧值，造成了数据库和缓存数据不一致。</p><ol start="2"><li>先更新数据库，再更新缓存</li></ol><p>​    假设更新数据库的操作和更新缓存的操作在同一个事务中，那么更新数据库之后，再更新缓存，如果出现缓存更新失败，那么事务回滚，保证了数据的一致性。但由于数据库和缓存实际上都是采用远程链接的方式读写数据，所以一般来说只有在低并发的场景下，才会将二者放在同一个事务中，否则若写缓存过慢，直接导致数据库事务时间被拉长，而形成长事务。如果二者不在同一个事务中，若数据库更新数据成功，缓存中更新数据失败，就会导致数据的不一致。</p><p>​    假设在高并发场景下，且更新缓存和更新数据库不在同一个事务中执行。假设有两个写操作，当写操作A更新数据库之后，在将数据写入缓存的过程中出现网络拥堵等情况，这时写操作B，也更新了数据库，拿着更新之后的值，写入到缓存中，同时写操作A的网络不拥堵了，写操作A又更新了缓存，这时数据库中是写操作B的值，缓存中是写操作A的值，从而造成了数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/rq9LGBjQ4EfCvRh.png" alt="先更新数据库再更新缓存.png"></p><ol start="3"><li>先删除缓存，再更新数据库</li></ol><p>​    同样在高并发下，如果请求A在删除缓存之后，写入数据库之前的这段时间内，如果有请求B进行获取数据，这是它从缓存中获取不到，则从数据库中获取，由于这时A还未将数据写入到数据库中，请求B读到的是旧值，而请求B又将读到的旧值写入到缓存中，之后请求A又将新值写入到数据库中，造成了数据库和缓存数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/lZQImSBoycYAO5b.png" alt="先删缓存再写库.png"></p><p>可以通过<strong>缓存双删</strong>的方式解决这个问题，写操作A在写入数据库之后，再删除一次缓存，这时又有一个新的问题，如果写操作A在一更新数据库之后，就去删缓存，可能存在某些线程中已经获取了旧值，只不过还没写入到缓存中，也就是上图的步骤7和步骤8。所以一般是在更新数据库之后一段时间之后进行缓存删除，比如500ms。</p><ol start="4"><li>先更新数据库，再删除缓存</li></ol><p>​    同样假设有两个请求，一个读请求A，一个写请求B。</p><ul><li>当写请求B先到，在更新数据库的过程中或者更新数据库后还未删除缓存时，读请求到达，读取了缓存中的数据，然后写请求B再删除缓存，对于这种场景仅读请求A读取了一次旧值。</li><li>当读请求A先到，读取到了缓存中的数据，直接返回了，这时写请求B在更新数据库，再删除缓存，同样对于这种场景，仅读请求A读取了一次旧值。</li></ul><p>但是还是有一种场景下，会导致数据不一致，也就是缓存过期了。</p><p>也就是当写操作A到达，在更新数据时出现拥堵，这时读操作B来读取缓存，刚好缓存过期，则从数据库中获取到了旧值，同时写操作A更新了数据库，且删除了缓存，然后读操作B再将旧值写入到缓存中，造成数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/jD6v2BzV7gylqRE.png" alt="写库再删缓存.png"></p><p>但是一般来说认为要造成上述场景需要满足两个条件：</p><ol><li>缓存刚好过期了</li><li>读操作B从数据库读到数据之后，更新缓存的耗时比写操作A更新数据库+删除缓存的耗时长。(一般来说对缓存的操作耗时要远小于对数据的操作耗时)</li></ol><p><strong>综上，一般来说还是需要采用先更新数据库再删除缓存的策略。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实际上不论是方案3中的缓存双删还是方案4都存在一个问题，在二者操作不在同一个事务的前提下，如果删除缓存操作失败了，那么就会导致缓存和数据库数据不一致。</p><p>​    这时就需要引入重试机制，缓存删除失败之后进行重试。关于重试就可简单可复杂了，简单就是直接捕获异常进行重试操作，但这可能影响接口时效，也可以将设置专门线程池，将重试操作推给线程池，又或者引入一些任务调度或者是<code>MQ</code>的中间件来处理。在查资料的过程中，有看到有人说也可以通过订阅<code>mysql</code>的<code>binlog</code>，如果发现了更新数据请求，则删除对应的缓存，但是据我所知很多项目在生产环境甚至连<code>binlog</code>功能都没有开启[旺柴]。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库和缓存双写一致性&quot;&gt;&lt;a href=&quot;#数据库和缓存双写一致性&quot; class=&quot;headerlink&quot; title=&quot;数据库和缓存双写一致性&quot;&gt;&lt;/a&gt;数据库和缓存双写一致性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
