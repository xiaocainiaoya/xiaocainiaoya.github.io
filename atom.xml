<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2022-07-22T03:25:10.283Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tk.mybaits和mybatisPlus兼容性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/</id>
    <published>2022-07-21T14:13:58.000Z</published>
    <updated>2022-07-22T03:25:10.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits和mybatisPlus兼容性"><a href="#tk-mybaits和mybatisPlus兼容性" class="headerlink" title="tk.mybaits和mybatisPlus兼容性"></a>tk.mybaits和mybatisPlus兼容性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    项目早期建设时底层采用了<code>tk.mybatis</code>方式来对数据访问层进行数据处理，而后再更新<code>Springboot</code>的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实<code>tk.mybatis</code>官网已经没有维护了）又在底层引入了<code>mybatisPlus</code>，所以新代码采用<code>mybatisPlus</code>编写，旧模块任然使用<code>tk.mybatis</code>编写。<span id="more"></span>    </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    今天同事在移植项目中的一个功能模块时，报了一个错<code>No qualifying bean of type &#39;com.xxxx&#39;..</code>。乍一看猜测大概是因为对应的<code>xxxMapper</code>接口文件没有被扫描到<code>Spring</code>容器中，导致<code>tk.mybatis</code>的表集合中没有该实体。排查发现，启动类中并没有显示使用<code>@MapperScan</code>指定扫描路径，果然，使用的是启动类及以下的包结构，由于是搬迁的功能模块，不想调整原来包结构，故使用<code>@MapperScan</code>来指定扫描路径。</p><p>​    在启动类上通过<code>@MapperScan</code>指定了扫描路径之后可以正常启动，但是在调用接口发现又报错了<strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>，如果对<code>tk.mybatis</code>比较熟悉就知道，这里是因为<code>tk.mybatis</code>会将所有的表信息都缓存到一个集合中，仔细检查了指定的路径，也没有发现问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    经过一段时间的排查，终于找到了原因，在这里记录下，避免以后又遇到同样的问题，以下仅为个人观点，可能存在理解错误，请带着批判的视角阅读。</p><p>​    原来是在<code>tk.mybatis</code>中也有一个同名的<code>tk.mybatis.spring.annotation.MapperScan</code>，若使用<code>org.mybatis.spring.annotation.MapperScan</code>是不会对扫描到的对象进行一些<code>tk.mybatis</code>相关的处理，所以直接将注解更换为前者，再次启动，又报出了新的错误：</p><p>定位进去发现就是<code>tk.mybatis</code>处理对应接口缓存的时候报了类型转换异常：</p><blockquote><p>Caused by: java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getEntityClass(MappedStatement ms) &#123;</span><br><span class="line">    String msId = ms.getId();</span><br><span class="line">    <span class="keyword">if</span> (entityClassMap.containsKey(msId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> entityClassMap.get(msId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; mapperClass = getMapperClass(msId);</span><br><span class="line">        Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType t = (ParameterizedType) type;</span><br><span class="line">                <span class="keyword">if</span> (t.getRawType() == <span class="keyword">this</span>.mapperClass || <span class="keyword">this</span>.mapperClass.isAssignableFrom((Class&lt;?&gt;) t.getRawType())) &#123;</span><br><span class="line">                    <span class="comment">// 报错报在这里</span></span><br><span class="line">                    Class&lt;?&gt; returnType = (Class&lt;?&gt;) t.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取该类型后，第一次对该类型进行初始化</span></span><br><span class="line">                    EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line">                    entityClassMap.put(msId, returnType);</span><br><span class="line">                    <span class="keyword">return</span> returnType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MapperException(<span class="string">&quot;无法获取 &quot;</span> + msId + <span class="string">&quot; 方法的泛型信息!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里直接下结论：</strong>报这个错的原因是因为指定扫描的路径范围太大了，导致扫描到了底层中的二次封装类<code>public interface CommonMapper&lt;T&gt; extends Mapper&lt;T&gt;</code>，结合以上代码不难发现，是取出了<code>T</code>泛型进行强转之后报错，所以只需要将扫描路径的范围缩小即可。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在最后发现问题之后，解决起来就很轻松了，但是在排查的过程中，就非常的痛苦。因为报错的这个地方并没有显式的指明是某个类强转失败，而项目中又存在<code>mybatisPlus</code>和<code>tk.mybatis</code>共存的情况，乍一看代码以为是兼容性的问题，因为对于这两种方式来说，数据访问层接口采用的是不同的继承接口。</p><p>一个是<code>tk.mybatis.mapper.common.Mapper</code><T>，一个是<code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code>，所以一看到这个类型转换异常，就误以为是因为需要通过<code>tk.mybatis</code>来解析的<code>xxxMapper</code>被<code>mybatisPlus</code>接管导致。</p><p>​    在排查跟踪源码的过程中，对<code>tk.mybatis</code>和<code>mybatisPlus</code>相关的一些处理有了进一步的了解，在此做了记录。</p><p><code>tk.mybatis</code>通过<code>tk.mybatis.spring.mapper.ClassPathMapperScanner</code>扫描器将对应的表实体收集到一个集合中，注意<code>mybatis</code>也有自己的扫描器<code>org.mybatis.spring.mapper.ClassPathMapperScanner</code>，也就是说在项目启动过程中，实际上是经过了两次的扫描，并且<code>tk.mybatis</code>的扫描器在<code>mybatis</code>的扫描器之前，至于是怎么插到<code>mybatis</code>之前的，猜测是通过<code>spring</code>的某个后置接口，这个与本篇主题无关，不进一步详解。</p><p>​    其实<code>tk.mybatis</code>的扫描器主要是将指定路径(默认是启动类所在包及子包)中被<code>@Mapper</code>标记的类，解析成<code>BeanDefinition</code>，添加到<code>Spring</code>对应集合中，用于后续将其实例化为具体的<code>bean</code>对象到容器中。这些的主要逻辑在这两个扫描器的父类<code>ClassPathBeanDefinitionScanner#doScan</code>。经过<code>tk.mybatis</code>扫描器处理后的表实体，同样也会在<code>mybatis</code>扫描器被作为候选对象<code>candidate</code>被扫描到。但它会从<code>Spring</code>中查询一次，查看是否存在该<code>BeanDefinition</code>，若存在则打印<code>Skipping MapperFactoryBean with name &#39;xxxMapper&#39; and &#39;com.xx.xxx....mapper.XxxMapper&#39; mapperInterface. Bean already defined with the same name!</code>，大概意思就是这个类已经存在<code>BeanDefinition</code>，当前处理跳过该类的处理，也就是说在指定路径下的实体表只会被这两个扫描器中的其中一个扫描并进行相关处理。</p><p>​    <code>tk.mybatis</code>扫描器中在创建<code>BeanDefinition</code>时，将它的<code>resolvedTargetType</code>和<code>beanClass</code>字段都标记为了<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>，而<code>mybatis</code>扫描器扫描器中这两个字段标记的是<code>org.mybatis.spring.mapper.MapperFactoryBean</code>，这就导致在真正实例化<code>Spring bean</code>对象时调用了不同的后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#invokeInitMethods</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最后会调用初始化的后置接口</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟踪下进入到不同的后置接口的调用方式，继承关系如下代码所示，从上面的代码中的最后调用<code>bean</code>对象的<code>afterPropertiesSet</code>方法，到下面代码中是由于二者的上层接口中<code>DaoSupport</code>实现了<code>InitializingBean</code>方法。且这个后置初始化方法中仅调用了<code>checkDaoConfig</code>和<code>initDao</code>方法，均由具体的子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tk.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoSupport</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, BeanInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">// Let abstract subclasses check their configuration.</span></span><br><span class="line">        checkDaoConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let concrete implementations initialize themselves.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initDao();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Initialization of DAO failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tk.mybatis.spring.mapper.MapperFactoryBean</code>具体的实现：核心的处理在这里，刚刚上文说到，<code>tk.mybatis</code>会将指定路径下的所有<code>@Mapper</code>类的<code>BeanDefinition</code>中的<code>resolvedTargetType</code>和<code>beanClass</code>都标记为<code>tk.MapperFactoryBean</code>，那么也就是说指定路径下的所有<code>@Mapper</code>都会被识别为是<code>tk.mybatis</code>的<code>mapper</code>？其实不是，这里有一个判断<code>mapperHelper.isExtendCommonMapper()</code>，这个判断的主要逻辑是获取这个<code>XxxMapper</code>接口及所有上层父类接口是否有<code>tk.mybatis.mapper.annotation.RegisterMapper</code>注解，如果没有，则不采用<code>tk.mybatis</code>的方式进行解析。到这，应该就可以解答前面提出的问题，所以如果需要用<code>mybatisPlus</code>，那么它的<code>XxxMapper</code>接口的所有上传父类接口必然不会存在<code>tk.RegisterMapper</code>注解，也就不会进行<code>tk.mybatis</code>相关的处理(<code>tk.mybatis</code>这里的处理是将表实体和<code>xxxMapper</code>接口的一些方法等信息缓存起来)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasMapper(<span class="keyword">this</span>.mapperInterface) &amp;&amp; mapperHelper != <span class="keyword">null</span> &amp;&amp; mapperHelper.isExtendCommonMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">        mapperHelper.processConfiguration(getSqlSession().getConfiguration(), <span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>No qualifying bean of type &#39;com.xxxx&#39;..</code>的实际原因是移植的功能模块类路径不落在默认扫描路径范围内（启动类所在的包及子包）</li><li><strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>是因为通过<code>org.mybatis.spring.annotation.MapperScan</code>指定了<code>mybatis</code>的扫描路径，但没有指定<code>tk.MapperScan</code>，导致<code>tk</code>的扫描器使用默认值(默认值为启动类所在的包及子包)，恰好移植的功能模块不属于启动类的包及子包中，所以移植功能中的所有<code>xxxMapper</code>都被解析为了<code>mybatis</code>类型(也就是前面说的<code>beanDefinition</code>中的那两个属性被赋值为了<code>mybatis</code>对应的类)，最后导致在初始化<code>bean</code>对象时，没有进入到<code>tk.mybaits</code>对应类的后置处理器，也就没有将这些表实体相关信息缓存，从而导致以上报错。</li><li>类型转换异常的报错，是因为指定<code>tk.MapperScan</code>设置扫描范围太大，导致扫描到了底层二次封装的抽象父类，导致在获取接口层参数获取到了泛型参数<code>T</code>，泛型参数以<code>T</code>进行类型转换为<code>Class</code>从而导致了报错。</li><li>在都不指定<code>@MapperScan</code>的情况下，二者扫描器的默认扫描路径都是启动类所在的包以及子包，当指定了<code>tk.@MapperScan</code>之后那么<code>tk.mybatis</code>的扫描路径变成了这个具体的指定路径，<code>mybatis</code>的扫描路径还是默认的启动类所在的包极其子包，也就是说两个扫描器的扫描路径是互不影响的、各自维护，这个很重要，如果不明白这个，在排查的过程中，会影响对问题的判断。</li><li>引入<code>tk.mybatis</code>一定会经过两次扫描器，一次是<code>tk.mybatis</code>的扫描器，一次是<code>mybatis</code>原生的扫描器，如果某个<code>mapper</code>对象被<code>tk.mybatis</code>扫描生成了<code>BeanDefinition</code>，<code>mybatis</code>的扫描器会跳过该类，同样的，某个<code>xxxMapper</code>若想使用<code>mybatisPlus</code>的方式进行数据访问层的处理，虽然它在扫描阶段被认为是以<code>tk.mybatis</code>的方式解析，但是在具体创建<code>spring bean</code>对象的时候，<code>kt.mybatis</code>的后置接口中有相应的逻辑判断(所有上层接口是否有标记<code>RegisterMapper</code>)，来控制是否进行相应处理。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits和mybatisPlus兼容性&quot;&gt;&lt;a href=&quot;#tk-mybaits和mybatisPlus兼容性&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits和mybatisPlus兼容性&quot;&gt;&lt;/a&gt;tk.mybaits和mybatisPlus兼容性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    项目早期建设时底层采用了&lt;code&gt;tk.mybatis&lt;/code&gt;方式来对数据访问层进行数据处理，而后再更新&lt;code&gt;Springboot&lt;/code&gt;的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实&lt;code&gt;tk.mybatis&lt;/code&gt;官网已经没有维护了）又在底层引入了&lt;code&gt;mybatisPlus&lt;/code&gt;，所以新代码采用&lt;code&gt;mybatisPlus&lt;/code&gt;编写，旧模块任然使用&lt;code&gt;tk.mybatis&lt;/code&gt;编写。</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>数据库和缓存双写一致性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-07-20T12:50:58.000Z</published>
    <updated>2022-07-20T08:42:46.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和缓存双写一致性"><a href="#数据库和缓存双写一致性" class="headerlink" title="数据库和缓存双写一致性"></a>数据库和缓存双写一致性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。<span id="more"></span></p><p><img src="https://s2.loli.net/2022/07/20/m6zT1AH2oZvSwa8.png" alt="双写一致性.png"></p><p>通常来说，常见的应用场景为：</p><ol><li>用户请求查询某些数据，先进入缓存查看是否存在</li><li>存在则直接返回数据</li><li>不存在则查数据库，查到则将数据添加一份到缓存中，再返回，使得下次查询可以直接从缓存中获取，从而提高系统的响应速度。</li></ol><h2 id="双写的四种场景"><a href="#双写的四种场景" class="headerlink" title="双写的四种场景"></a>双写的四种场景</h2><ol><li>先更新缓存，再更新数据库</li></ol><p>​    如果采用这种方式，极易产生数据不一致的情况。因为先更新缓存，如果因为某些原因出现数据写入失败，比如主键冲突、非空字段未填值、数据库宕机等等情况导致数据库写入失败，这时就出现了缓存中是新值，数据库中是旧值，造成了数据库和缓存数据不一致。</p><ol start="2"><li>先更新数据库，再更新缓存</li></ol><p>​    假设更新数据库的操作和更新缓存的操作在同一个事务中，那么更新数据库之后，再更新缓存，如果出现缓存更新失败，那么事务回滚，保证了数据的一致性。但由于数据库和缓存实际上都是采用远程链接的方式读写数据，所以一般来说只有在低并发的场景下，才会将二者放在同一个事务中，否则若写缓存过慢，直接导致数据库事务时间被拉长，而形成长事务。如果二者不在同一个事务中，若数据库更新数据成功，缓存中更新数据失败，就会导致数据的不一致。</p><p>​    假设在高并发场景下，且更新缓存和更新数据库不在同一个事务中执行。假设有两个写操作，当写操作A更新数据库之后，在将数据写入缓存的过程中出现网络拥堵等情况，这时写操作B，也更新了数据库，拿着更新之后的值，写入到缓存中，同时写操作A的网络不拥堵了，写操作A又更新了缓存，这时数据库中是写操作B的值，缓存中是写操作A的值，从而造成了数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/rq9LGBjQ4EfCvRh.png" alt="先更新数据库再更新缓存.png"></p><ol start="3"><li>先删除缓存，再更新数据库</li></ol><p>​    同样在高并发下，如果请求A在删除缓存之后，写入数据库之前的这段时间内，如果有请求B进行获取数据，这是它从缓存中获取不到，则从数据库中获取，由于这时A还未将数据写入到数据库中，请求B读到的是旧值，而请求B又将读到的旧值写入到缓存中，之后请求A又将新值写入到数据库中，造成了数据库和缓存数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/lZQImSBoycYAO5b.png" alt="先删缓存再写库.png"></p><p>可以通过<strong>缓存双删</strong>的方式解决这个问题，写操作A在写入数据库之后，再删除一次缓存，这时又有一个新的问题，如果写操作A在一更新数据库之后，就去删缓存，可能存在某些线程中已经获取了旧值，只不过还没写入到缓存中，也就是上图的步骤7和步骤8。所以一般是在更新数据库之后一段时间之后进行缓存删除，比如500ms。</p><ol start="4"><li>先更新数据库，再删除缓存</li></ol><p>​    同样假设有两个请求，一个读请求A，一个写请求B。</p><ul><li>当写请求B先到，在更新数据库的过程中或者更新数据库后还未删除缓存时，读请求到达，读取了缓存中的数据，然后写请求B再删除缓存，对于这种场景仅读请求A读取了一次旧值。</li><li>当读请求A先到，读取到了缓存中的数据，直接返回了，这时写请求B在更新数据库，再删除缓存，同样对于这种场景，仅读请求A读取了一次旧值。</li></ul><p>但是还是有一种场景下，会导致数据不一致，也就是缓存过期了。</p><p>也就是当写操作A到达，在更新数据时出现拥堵，这时读操作B来读取缓存，刚好缓存过期，则从数据库中获取到了旧值，同时写操作A更新了数据库，且删除了缓存，然后读操作B再将旧值写入到缓存中，造成数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/jD6v2BzV7gylqRE.png" alt="写库再删缓存.png"></p><p>但是一般来说认为要造成上述场景需要满足两个条件：</p><ol><li>缓存刚好过期了</li><li>读操作B从数据库读到数据之后，更新缓存的耗时比写操作A更新数据库+删除缓存的耗时长。(一般来说对缓存的操作耗时要远小于对数据的操作耗时)</li></ol><p><strong>综上，一般来说还是需要采用先更新数据库再删除缓存的策略。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实际上不论是方案3中的缓存双删还是方案4都存在一个问题，在二者操作不在同一个事务的前提下，如果删除缓存操作失败了，那么就会导致缓存和数据库数据不一致。</p><p>​    这时就需要引入重试机制，缓存删除失败之后进行重试。关于重试就可简单可复杂了，简单就是直接捕获异常进行重试操作，但这可能影响接口时效，也可以将设置专门线程池，将重试操作推给线程池，又或者引入一些任务调度或者是<code>MQ</code>的中间件来处理。在查资料的过程中，有看到有人说也可以通过订阅<code>mysql</code>的<code>binlog</code>，如果发现了更新数据请求，则删除对应的缓存，但是据我所知很多项目在生产环境甚至连<code>binlog</code>功能都没有开启[旺柴]。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库和缓存双写一致性&quot;&gt;&lt;a href=&quot;#数据库和缓存双写一致性&quot; class=&quot;headerlink&quot; title=&quot;数据库和缓存双写一致性&quot;&gt;&lt;/a&gt;数据库和缓存双写一致性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志文件</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</id>
    <published>2022-07-14T14:13:58.000Z</published>
    <updated>2022-07-20T01:29:12.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql日志文件"><a href="#mysql日志文件" class="headerlink" title="mysql日志文件"></a>mysql日志文件</h1><p>​    <code>mysql</code>在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。<span id="more"></span></p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>​    错误日志<code>error_log</code>文件对<code>MYSQL</code>的启动、允许、关闭过程进行记录，在遇到问题时可以查看该文件进行问题的定位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>​    慢查询日志<code>slow log</code>文件，可以在<code>MYSQL</code>启动时设置一个阈值，将执行时间超过该值的<code>SQL</code>语句都记录到慢查询文件中，通过查看该文件中的<code>SQL</code>语句来对系统中的慢查询进行优化处理。</p><p>默认情况下，<code>MYSQL</code>不开启慢查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启慢查询日志</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span></span><br><span class="line"><span class="comment">-- 查看慢查询的时间，多久认为是慢SQL 大于long_query_time才会认为是慢查询</span></span><br><span class="line"><span class="comment">-- 5.1版本之后long_query_time的单位改为微秒，5.1之前是秒</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_slow_queries&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果与语句没有使用到索引，都认为是慢查询</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.6.5 版本之后才有的参数，用来表示每分钟允许记录的未使用索引的SQL次数</span></span><br><span class="line"><span class="comment">-- 默认值为0，表示没有限制；在生产环境下，若过多的SQL语句没有使用索引，会导致</span></span><br><span class="line"><span class="comment">-- 频繁的将SQL记录到slow log表中，消耗性能和占用资源</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_throttle_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.1 之后允许将慢查询SQL记录到TABLE中，便于开发者查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看记录的方式，默认是FILE</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_output&#x27;</span></span><br><span class="line"><span class="comment">-- 修改为TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;TABLE&#x27;</span></span><br><span class="line"><span class="comment">-- 通过MYSQL.slow_log 查看</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MYSQL.SLOW_LOG</span><br></pre></td></tr></table></figure><p>默认情况下<code>slow_log</code>表使用的是<code>CSV</code>引擎，如果数据量的情况下，查询效率可能不高，可以将<code>slow_log</code>表的引擎修改为<code>MyISAM</code>,并且对列<code>start_time</code>上添加索引来提交查询的效率。</p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志文件<code>bin log</code>记录对数据执行的所有操作，但不包含<code>select</code>等查询操作，因为本质上查询并不会对数据本身进行修改。</p><p>但非查询语句又对数据没有产生变化，这类还是会被记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 比如：数据库中并没有名为marry的数据</span></span><br><span class="line">update user_info <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;marry&#x27;</span></span><br></pre></td></tr></table></figure><p><code>bin log</code>的主要作用为：</p><ul><li>恢复：比如对某些数据进行<code>DELETE</code>操作，可以通过使用<code>mysqlbinlog</code>工具对<code>bin log</code>文件中的的某些事件的起止节点或者时间的起止进行数据的恢复。</li><li>复制：常用的场景为主从模式下，主节点通过将<code>bin log</code>文件传递给从节点，然后从节点通过读取<code>bin log</code>文件的数据保证主从数据一致性。</li><li>审计：通过<code>bin log</code>文件中的信息进行审计，判断是否有对数据库注入的攻击。</li></ul><p>默认情况下二进制文件<code>binlog</code>是关闭的，需要手动开启，逻辑上是存在一定的性能消耗，但是根据官方测试结果数据来看，开启仅消耗使得性能下降1%左右。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看binlog存放位置</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示缓存区大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_cache_size&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用了临时文件写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_disk_use&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用缓存区写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_use&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件中相应的配置参数</strong></p><ul><li><code>max_binlog_size</code>： 指定单个二进制文件的最大值。如果操作该值则产生新的二进制文件，<code>MYSQL5.0</code>之前默认值为<code>1.1G</code>，之后版本为<code>1G</code></li><li><code>binlog_cache_size</code>：在事务未提交的二进制日志会被记录到一个缓存区中，等到事务提交之后再写入到<code>binlog</code>中，缓存区默认大小为<code>32K</code>。且该参数是基于会话，也就是说当一个线程开启一个事务时，就会分配一个<code>binlog_cache_size</code>大小的缓存区。当事务中的记录容量超过该值时，<code>MySql</code>会将缓冲区中的日志写入到一个临时文件中。</li><li><code>sync_binlog</code>：默认情况下，并不是每次写的时候都将日志内容写入到磁盘中，所以当数据库发生宕机时，可能有部分缓存区的数据还未写入到磁盘中。<code>sync_binlog</code>这个参数就是用来控制写入到缓存多少次后将缓存中的日志数据同步到磁盘中。默认值为0</li><li><code> binlog_do-db</code>：表示需要写入那些库的日志</li><li> <code>binlog-ignore-db</code>：表示需要忽略那些库的日志</li></ul><p><strong>binlog_format</strong>：这个参数比较重要，单独罗列出来，表示记录到<code>binlog</code>日志的数据格式，在<code>MySql5.1</code>版本之后才有该参数。可选参数有：</p><ul><li><p><code>STATEMENT</code>：基于<code>SQL</code>语句记录。存在两个问题：</p><ul><li><p>如果主服务器使用了一些生成函数，比如<code>uuid</code>等，这时从服务器得到主服务器的<code>binlog</code>进行回放后会导致主从数据不一致。</p></li><li><p>由于<code>MySql</code>的<code>INnoDB</code>存储引擎的默认事务隔离级别是<code>RR(REPEATABLE READ)可重复读</code>。如果事务隔离级别不是<code>RR</code>,会出现一种情况是：</p><p>假设事务隔离级别为<code>RC</code>且有一个<code>user_info（id， name）</code>表和两个字段，且有两条数据<code>(1, &#39;tom&#39;), (2, &#39;marry&#39;)</code>，下表的两个事务执行之后的数据为<code>(3, &#39;tom&#39;), (2, &#39;tom&#39;)</code>，但是从服务器获取到的<code>binlog</code>中，由于事务B先提交，那么会先回放事务B的<code>SQL</code>语句，结果就变成了<code>(3, &#39;tom&#39;), (3, &#39;marry&#39;)</code>,从而导致主从数据不一致。所以有些人说<code>MySQL</code>为了避免这种情况，将事务的隔离级别默认设置为<code>RR</code>，但<code>Oracle</code>的默认事务隔离级别为<code>RC</code></p><table><thead><tr><th>顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>update T set id=3 where name=’tom’</td><td></td></tr><tr><td>2</td><td></td><td>Update T set name=’tom’ where name=’marry’</td></tr><tr><td>3</td><td></td><td>commit</td></tr><tr><td>4</td><td>commit</td><td></td></tr></tbody></table></li></ul></li><li><p><code>ROW</code>：不是简单的<code>SQL</code>语句，而是记录表所对应行数据的变化，也就是从某某修改为某某。假设<code>name=tom</code>的数据有1w条，那么采用<code>STATEMENT</code>仅记录一条<code>DELETE</code>语句，采用<code>ROW</code>则记录1w条日志记录，显然后者需要更大的磁盘空间。</p></li><li><p><code>MIXED</code>：混合模式，默认采用<code>STATEMENT</code>格式，指定一些情况使用<code>ROW</code>格式，比如使用了<code>uuid()</code>等生成函数，在<code>innodb</code>对表的数据进行增删改操作等等。</p></li></ul><p><strong>binlog的写入机制</strong></p><ol><li><code>binlog</code>的写入是利用事件触发执行机制，根据<code>binlog_format</code>格式和操作的类型触发<code>Log Event</code>事件。</li><li>将事务在执行过程中产生的所有<code>Log Event</code>写入到缓存区中，一个执行语句不一定都只对应一个<code>Log Event</code>，每个事务线程都有独立的缓存区。</li><li>事务提交后会将缓存区中的<code>Log Event</code>写入到<code>bin log</code>文件中。事务的写入是串行的方式，也就是说一个事务在写入的中间不会穿插其他事务的<code>Log Event</code>。</li></ol><h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><blockquote><p>重做日志redo log</p></blockquote><h3 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h3><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql日志文件&quot;&gt;&lt;a href=&quot;#mysql日志文件&quot; class=&quot;headerlink&quot; title=&quot;mysql日志文件&quot;&gt;&lt;/a&gt;mysql日志文件&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;mysql&lt;/code&gt;在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记(二)</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</id>
    <published>2022-07-12T13:39:58.000Z</published>
    <updated>2022-07-20T01:28:53.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习笔记-二"><a href="#redis学习笔记-二" class="headerlink" title="redis学习笔记(二)"></a>redis学习笔记(二)</h1><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>​    主从复制是将一台<code>redis</code>服务器设置为主服务器<code>master</code>，复制到其他多台从服务<code>slave</code>上，主服务器负责读写操作，从服务器只能读。<strong>数据的复制只能是主服务器到从服务器。</strong>当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。<strong>主从服务器之间通过心跳的机制检查服务器间的连接状态</strong><span id="more"></span></p><p><strong>主从服务之间的数据复制通过全量复制和部分复制。</strong></p><ol><li><p><strong>全量复制</strong> </p><p>​    分为两步操作：①主节点接收到从节点的全量复制命令，执行<code>gbsave</code>，在后台生成<code>RDB</code>文件，同时将此刻之后的写操作命令添加到复制缓冲区中。②将<code>RDB</code>文件发送给从节点，从节点先清除本身数据后加载<code>RDB</code>文件，然后在将主节点的复制缓冲区写命令依次执行。从而保证了从节点和主节点的数据一致。</p></li><li><p><strong>部分复制</strong></p><ul><li>复制偏移量：主从节点分别维护一个<code>offset</code>偏移量，主节点每次向从节点发送多少数据，修改<code>offset</code>偏移量值；同理，从节点每次从主节点接收多少数据，也会修改<code>offset</code>偏移量值。</li><li>复制积压缓冲区：主节点内部维护一个长度固定的<code>FIFO</code>队列作为复制积压缓冲区，默认大小是<code>1M</code>，在进行命令同步时，不仅会将写命令同步到从节点，同时会将写命令写入复制积压缓冲区，由于长度固定，写入比较早的命令会被挤出缓冲区，所以当主从的<code>offset</code>差距大于缓冲区长度时，无法进行部分复制，只能执行全量复制。</li><li>服务器运行<code>ID</code>(<code>runId</code>)：每个节点都有运行<code>ID</code>，运行<code>ID</code>在节点启动时自动生成，主节点会将自己的<code>runId</code>发送给从节点，从节点保存起来，出现从节点断线重连：①若若从节点中保存的主<code>runId</code>=主<code>runId</code>则之前同步过该主节点数据，会首先尝试部分复制。②若从节点中保存的主<code>runId</code>!=现主<code>runId</code>，则只能全量复制。</li></ul></li></ol><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>​    在主从复制模式下，若出现主服务器宕机，则需要运维人员手动修改从服务器为主服务器，不能良好的支持高可用。哨兵模式从出现就是为了解决这个问题，所以哨兵模式其实就是高可用的主从复制模式。可以由至少一个哨兵(哨兵可以集群)，监听任意多个主从服务器，当主服务器出现异常，导致宕机的时候，由哨兵投票将某个从服务器选举为主服务器，这样就可以保证主从服务之间的高可用。</p><blockquote><p>启动哨兵：redis-sentinel /path/to/sentinel.conf</p></blockquote><ul><li><code>Subjectively Down(SDOWN)</code>：主观下线，单个哨兵做出下线的判断。</li><li><code>Objectively Down(ODOWN)</code>：客观下线，多个哨兵实例对同一客户端做出下线判断。</li></ul><p><strong>客观下线只适用于主服务器，其他从服务器或者哨兵只会主观下线。哨兵在判定它们为下线前不需要进行协商，所以从服务器或者哨兵永远不会达到客观下线的条件。</strong>理论上，主观下线的作用就是当主服务器出现客观下线时，哨兵进行选举的从服务器不会从主观下线的从服务器中选举。</p><p><strong><code>redis</code>集群</strong></p><p>​    集群是为了解决单机<code>redis</code>容量有限的问题，将数据按一定的规则分配到多台机器中，也叫数据分片，集群不需要哨兵。</p><p>使用<code>redis</code>分片会遇到一个问题是如果将所有数据都均匀的分布到每一台服务器上，如果仅仅只通过<code>key</code>的哈希值取服务器数量的模有可能出现两个问题：</p><ul><li><p>大量的哈希碰撞导致大量数据存储在了某一台或者某几台服务器上。</p></li><li><p>当出现服务器增加一台或者减少一台时，需要迁移大量的数据。</p></li></ul><p><strong>解决方案</strong></p><p>采用一致性哈希算法进行处理。</p><p>如下图设置一个从0~2^32-1头尾相连的环。将目前集群中的服务器的<code>ip</code>进行哈希运算后对<code>2^23</code>进行取模后，得到结果一定落在这个环上的某个位置。</p><p><img src="https://s2.loli.net/2022/07/12/fb96c7TK3knjGdv.png" alt="一致性哈希图1.png"></p><p>假设现在集群中有三台服务器，分别进行<code>hash(ip)%2^23</code>运算之后，落在环上的位置，同时对一些需要存储在服务器中的数据进行<code>hash(key)%2^23</code>运算之后的值也会落在这个环上。根据顺时针，将对应的键归于某台服务器上，比如下图中<code>key1</code>落在<code>S1</code>服务器上，<code>key4</code>落在<code>S2</code>服务器上，<code>key2</code>和<code>key3</code>落在<code>S3</code>服务器上。</p><p><img src="https://s2.loli.net/2022/07/12/BujMksDNmw5Hx9z.png" alt="一致性哈希2.png"></p><p>假设这时需要添加一台服务器<code>S4</code>，那么只需要将<code>S4</code>在这个环上左侧部分的数据迁移到<code>S4</code>服务器上，其他服务器不需要进行迁移操作，删除服务器类似，所以不论是添加或者删除服务器，仅需要集群中的两台服务器进行迁移处理。</p><p><img src="https://s2.loli.net/2022/07/12/n8CoMD6u7KBAp2O.png" alt="一致性哈希3.png"></p><p>到这实际上已经解决了使用缓存集群进行分片在扩展和收缩时牵一发而动全身的数据迁移情况，但是在上面的例子中，服务的分布过于理想化，有可能出现一种场景是集群中就两台服务器，且两台服务器在这个环上距离非常靠近。业界称为<strong>数据倾斜</strong>：在存储集群中意思为大部分数据存储在少来服务器上，在计算集群中意思为大部分数据由少量服务器进行计算。</p><p>这里可以通过为服务器创建虚拟的节点，来扩大服务器在环上的分布，比如由每台服务器仅经过一次<code>hash(ip)%2^23</code>运算修改为<code>ip#1</code>、<code>ip#2</code>进行编号后在进行运算，使得一台服务器在环上存在多个节点，达到尽可能将数据均匀分布到各个服务器上的目的。</p><h4 id="缓冲穿透、击穿、雪崩"><a href="#缓冲穿透、击穿、雪崩" class="headerlink" title="缓冲穿透、击穿、雪崩"></a>缓冲穿透、击穿、雪崩</h4><p><strong>缓存穿透</strong>：当某一个<code>key</code>对应数据在缓存中不存在同时在持久层也不存在时，如果大量的请求涌入，会造成数据库的压力，这种现象称为缓存穿透。</p><p><strong>解决方案</strong></p><ul><li>布隆过滤器：将所有数据都打入布隆过滤器中，当通过布隆过滤器查询某个值时，若返回<code>false</code>则一定不存在该数据，若返回<code>true</code>则可能存在数据(有一定误判率)，进入<code>redis</code>查询，若没有命中，在进入持久层查询。</li><li>缓存空对象：这种做法比较粗暴，当出现数据查询不到时，将空对象缓存，一般会设置一个较短的缓存时间。</li></ul><p><strong>缓存击穿</strong>：当某一时刻，某一个<code>key</code>对应的缓存时间过期导致失效，如果大量的请求涌入，导致所有的请求都到持久层，会造成数据库压力，这种现象称为缓存击穿。</p><p><strong>解决方案</strong></p><ul><li>使用互斥锁：使用<code>mutex</code>，当缓存失效时，获取锁，在进入持久层，查询到数据后再添加到缓存中，也就是说若缓存中查询不到值，需要获取锁之后，才能进入持久层。</li></ul><p><strong>缓存雪崩</strong>：在某一个时刻，多个<code>key</code>对应的缓存时间过期，导致这些<code>key</code>全部失效，如果大量的请求涌入，导致所有的请求都到达持久层，会造成数据库压力，这种现象称为缓存雪崩。</p><p><strong>解决方案</strong></p><ul><li>缓存失效随机值，尽量避免多个<code>key</code>扎堆在同一时刻失效。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis学习笔记-二&quot;&gt;&lt;a href=&quot;#redis学习笔记-二&quot; class=&quot;headerlink&quot; title=&quot;redis学习笔记(二)&quot;&gt;&lt;/a&gt;redis学习笔记(二)&lt;/h1&gt;&lt;h4 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h4&gt;&lt;p&gt;​    主从复制是将一台&lt;code&gt;redis&lt;/code&gt;服务器设置为主服务器&lt;code&gt;master&lt;/code&gt;，复制到其他多台从服务&lt;code&gt;slave&lt;/code&gt;上，主服务器负责读写操作，从服务器只能读。&lt;strong&gt;数据的复制只能是主服务器到从服务器。&lt;/strong&gt;当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。&lt;strong&gt;主从服务器之间通过心跳的机制检查服务器间的连接状态&lt;/strong&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记(一)</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2022-07-12T12:50:58.000Z</published>
    <updated>2022-07-12T13:39:30.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis学习笔记-一"><a href="#redis学习笔记-一" class="headerlink" title="redis学习笔记(一)"></a>redis学习笔记(一)</h3><h4 id="一、非关系数据库"><a href="#一、非关系数据库" class="headerlink" title="一、非关系数据库"></a>一、非关系数据库</h4><blockquote><p><code>not only Sql</code>是非关系型数据库</p></blockquote><span id="more"></span><h5 id="1-NoSQL的特点"><a href="#1-NoSQL的特点" class="headerlink" title="1.NoSQL的特点"></a>1.NoSQL的特点</h5><ul><li><p>方便扩展（数据之间没有关系，很好扩展）</p></li><li><p>大数据高性能（8w写，11w读）</p></li><li><p>数据类型多样性（无需事先设计数据库，随取随用）</p></li></ul><h5 id="2-传统RDBMS和NoSQL"><a href="#2-传统RDBMS和NoSQL" class="headerlink" title="2.传统RDBMS和NoSQL"></a>2.传统RDBMS和NoSQL</h5><p>​    传统的<code>RDBMS</code>是结构化组织、建立在<code>SQL</code>语句之上，数据和数据间的关系存储在表中，严格的一致性，事务等。</p><p>​    非关系型数据库<code>NoSQL</code>是没有固定的查询语言，有列存储、键值对存储、图像数据库、文件存储，强调最终一致性，建立在<code>CAP</code>定理和<code>BASE</code>理论，具有高性能、高可用、高可扩。</p><blockquote><p>大数据时代的3V(海量Volume，多样Variety，实时Velocity)+3高(高并发、高可用、高性能)</p></blockquote><h5 id="3-四大分类"><a href="#3-四大分类" class="headerlink" title="3.四大分类"></a>3.四大分类</h5><ol><li><p><strong>KV键值对</strong></p><p>代表性的有<code>redis</code>、<code>memecache</code></p></li><li><p><strong>文档型数据库</strong></p><p><code>MongoDB</code>一个基于分布式文件存储的数据库，<code>C++</code>编写，主要用来处理大量的文档，是一个介于关系型数据库和非关系型数据库的中间产品，<code>MongoDB</code>是非关系型数据库中功能最丰富，最像关系型数据库的。</p></li><li><p><strong>列存储数据库</strong></p><ul><li><code>Hbase</code></li><li>分布式文件系统</li></ul></li><li><p><strong>图关系数据库</strong></p><ul><li>存储拓扑图关系，比如朋友圈社交网络、广告推荐！(<code>Neo4j、infoGrid</code>)</li></ul></li></ol><h4 id="二、redis简介"><a href="#二、redis简介" class="headerlink" title="二、redis简介"></a>二、redis简介</h4><p>​    <code>Redis</code>是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串<code>String</code>， 散列<code>hashes</code>， 列表<code>lists</code>， 集合<code>sets</code>， 有序集合<code>sorted sets</code>与范围查询， <code>bitmaps</code>， <code>hyperloglogs</code>和地理空间<code>geospatial</code>索引半径查询。<code>Redis</code> 内置了复制，<code>LUA</code>脚本，<code>LRU</code>驱动事件，事务<code>transactions</code>和不同级别的磁盘持久化<code>persistence</code>， 并通过<code>Redis</code>哨兵<code>Sentinel</code>和自动分区<code>Cluster</code>提供高可用性<code>high availability</code>。</p><blockquote><p><code>Redis</code> 官方发布效率8w写，11万读 （mysql在300w数据之后需要加索引）</p></blockquote><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><ol><li>内存存储、持久化，内存是断电即失，所以持久化很重要(<code>AOP</code>、<code>RDB</code>)</li><li>效率高可用用于高速缓存。</li><li>发布订阅系统。</li><li>地图信息分析。</li><li>计时器、计数器(浏览量、点赞数、发布数)</li></ol><h5 id="2-单线程"><a href="#2-单线程" class="headerlink" title="2. 单线程"></a>2. 单线程</h5><p><code>redis</code>是单线程，官方表示<code>redis</code>是基于内存操作，<code>CPU</code>不是<code>redis</code>性能瓶颈，<code>redis</code>的性能瓶颈是根据机器的内存和网络带宽。</p><p><strong>redis是单线程为什么还这么快?</strong></p><p>两个误区：高性能服务器一定是多线程？多线程一定比单线程效率高？</p><p>核心是：<code>redis</code>是将所有数据全部存放在内存中，所以使用单线程去操作效率就是最高的，减少了<code>CPU</code>上下文切换的时间，多线程会引发上下文切换，对于内存系统来说，如果没有上下文切换效率就是最高的。而且<code>redis</code>是基于<code>reactor</code>模型，使用的是<code>I/O</code>多路复用的<code>IO</code>模型。</p><p><strong><code>I/O</code>多路复用：</strong>在<code>I/O</code>多路复用模型中，最重要的函数调用就是<code>select</code>，该方法能同时监控多个文件描述符的可读可写情况，当其中某个文件描述符可读或可写时，<code>select</code>方法就会返回可读以及可写的文件描述符个数，<code>netty</code>的底层采用的也是<code>I/O</code>多路复用的模型。</p><h4 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h4><p>​    <code>redis</code>是内存数据库，如果不将内存中的数据保存在硬盘中，若出现断电或者宕机等情况，内存中保存的数据也会丢失。</p><h5 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h5><p>​    <code>RDB</code>全称是<code>Redis DataBase</code>，在指定的时间间隔内将内存中的数据集快照<code>Shapshot</code>写入磁盘，恢复时只需要将快照加载入内存即可，默认保存的文件名为<code>dump.rdb</code>。</p><p>​    <code>redis</code>会通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有内存数据写入到一个临时文件中，待持久化结束后，会替换掉上一次持久化好的文件。整个过程，主进程不进行任何<code>I/O</code>操作，确保了极高的性能。并且<code>.rdb</code>是二进制文件，比较轻量，灾难之后的恢复会快一些。</p><p><strong>两种方式</strong></p><ul><li><code>save</code>：阻塞主线程，使得主线程不能继续对外提供请求，若数据量小，将数据写入备份文件快，则没有多大影响，若数据量大，写入备份文件时间长，则写多长时间就会停机多长时间。</li><li><code>bgsave</code>：主线程<code>fork</code>子进程，子进程进行数据的备份，主进程在<code>fork</code>子进程时阻塞，之后不会阻塞，相比于<code>save</code>方式，阻塞时间可以忽略不计。</li></ul><p><strong><code>bgsave</code>的原理</strong></p><p>​    主进程在<code>fork()</code>子进程之后，内核把主进程所有的内存页的权限都设置为<code>read-only</code>，然后将子进程的地址空间指向主进程。所以这里两个进程共享了同一块内存空间，最极端的情况当子进程在备份数据时，主进程接收到写请求，这时由于内存页的权限是<code>read-only</code>，会触发页异常中断后，会将这个数据的内存页复制一份，并且主进程指向该内存页。所以可以得出，在某一个时间节点触发了<code>bgsave</code>，则它只会备份那个时间节点的数据，那个时间节点只有的写操作，它都无法处理到。从一般设计来说，缓存中都是使用频繁且读多写少的数据，所以这一机制并不会使得在备份时频繁带来内存页数据异常导致的性能问题。</p><h5 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h5><p>​    <code>AOF</code>全称是<code>Append only file</code>，以日志的形式来记录每个写操作(默认情况是关闭)，将<code>redis</code>执行过的所有写操作命令备份下来，会把写操作命令一直追加到文件中。恢复时，默认会读取<code>appendonly.aof</code>文件中的命令，逐个执行命令，使得数据恢复。</p><p>​    <code>redis</code>通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有<code>AOF</code>缓冲区的命令同步到<code>appendonly.aof</code>文件中。</p><p><strong><code>AOF</code>的配置项</strong></p><ul><li><code>appendonly on</code>：默认是关闭状态</li><li><code>appendfilename &quot;appendonly.aof&quot;</code>：默认的持久化文件名称</li><li><code>appendfsync always</code>：同步策略，有三种<code>always</code>(每次修改都会同步)，<code>everysec</code>(每秒同步一次)，<code>no</code>由操作系统控制同步，默认是<code>everysec</code></li></ul><p><strong><code>AOF</code>重写</strong></p><p>​    <code>AOF</code>重写会在保持最终数据一致的前提下，将一些多条命令，整合成一条命令来代替多条命令。<code>AOF</code>重写是通过子进程的方式进行，使用子进程不会阻塞父进程，使得父进程还是可以处理客户端请求，并且子进程可以继承父进程资源，并且这种继承采取<code>copy-on-write</code>的策略，所以<code>AOF</code>重写无需关心由于客户端写请求导致数据不一致问题。</p><p>​    <code>AOF</code>重写的写命令不仅要写入到<code>AOF</code>缓冲区，还会写入<code>AOF</code>重写缓冲区，写入原<code>AOF</code>缓冲区是为了避免若重写失败导致数据丢失；写入<code>AOF</code>重写缓冲区是为了子进程在进行<code>AOF</code>重写期间还是在继续处理命令请求。</p><p>​    子进程在重写完毕后会发送一个信号给父进程，父进程收到信号后，会将<code>AOF</code>重写缓冲区的所有内容写入到新的<code>AOF</code>文件中，并且采用原子操作覆盖现有<code>AOF</code>文件，完成新旧文件的替换。</p><p><strong>小结</strong></p><p>​    如果需要大规模恢复数据，且对数据恢复的完整性不是非常敏感，那么<code>RDB</code>比<code>AOF</code>方式更加有效，<code>RDB</code>的缺点是最后一次持久化可能会丢失一部分数据。若从安全性来说，<code>AOF</code>会比较高一点，<code>AOF</code>最多丢失1秒的数据(采用默认配置的话)，而<code>RDB</code>丢失上一次备份与宕机时间差之间的数据。在<code>redis</code>服务器开启<code>AOF</code>持久化功能时，会采用<code>AOF</code>文件来恢复数据，若没有开启<code>AOF</code>功能时，才会使用<code>RDB</code>来恢复数据。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;redis学习笔记-一&quot;&gt;&lt;a href=&quot;#redis学习笔记-一&quot; class=&quot;headerlink&quot; title=&quot;redis学习笔记(一)&quot;&gt;&lt;/a&gt;redis学习笔记(一)&lt;/h3&gt;&lt;h4 id=&quot;一、非关系数据库&quot;&gt;&lt;a href=&quot;#一、非关系数据库&quot; class=&quot;headerlink&quot; title=&quot;一、非关系数据库&quot;&gt;&lt;/a&gt;一、非关系数据库&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;not only Sql&lt;/code&gt;是非关系型数据库&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Springboot请求响应乱码</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/10/Spring/Springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%B9%B1%E7%A0%81/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/10/Spring/Springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%B9%B1%E7%A0%81/</id>
    <published>2022-07-10T03:37:20.000Z</published>
    <updated>2022-07-19T02:12:22.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot请求响应乱码"><a href="#Springboot请求响应乱码" class="headerlink" title="Springboot请求响应乱码"></a>Springboot请求响应乱码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在一个项目中出现了一个比较棘手的问题，情况是这样的：由于项目场景的需要，引入了公司技术架构部门在<code>activiti</code>工作流的基础上进行二次开发的工作流组件，使用该组件，需要实现几个获取岗位信息、人员信息相关的接口，工作流组件通过<code>restTemplate</code>调用这些接口来获取对应的人员、岗位信息用于工作流服务的节点信息显示，在开发过程中一切正常且部署到开发环境中调试过程中也是一切正常，但是当部署到测试环境后，发现接口出现乱码。</p><span id="more"></span><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>​    由于工作流服务采用的是<code>tomcat</code>方式部署，第一反应是修改<code>tomcat</code>中的相关配置文件<code>web.xml</code>和<code>server.xml</code>的相关配置，但是修改之后发现并无效果。又尝试在测试环境使用开发环境的正常使用的镜像，还是出现乱码，到这个时候真的是一点头绪都没有了，不知从何下手。在不断的排查过程中，发现仅仅是通过<code>restTemplate</code>请求业务服务的岗位信息、人员信息接口出现了乱码问题，其他接口并无异常。</p><p>​    而后发现开发环境和测试环境的通一个接口，响应时的<code>Content-Type</code>中，测试环境少了<code>charset=UTF-8</code>，马上使用<code>@RequestMapping</code>的<code>produces = &quot;application/json;charset=UTF-8&quot;</code>指定编码方式，经测试，正常解决乱码问题！！！</p><p><img src="https://s2.loli.net/2022/07/10/7YJc9hMUXdjStWg.png" alt="测试环境工作流请求返回.png"></p><p><img src="https://s2.loli.net/2022/07/10/PWksefL5D4HZN6a.png" alt="开发环境工作流返回.png"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>​    在解决这个乱码问题之后，其实还是很疑惑的，为什么在开发环境和测试环境出现了不同的<code>Content-Type</code>响应头信息，测试环境响应头中的<code>charset=UTF-8</code>为什么会消失？由于我们是采用指定了<code>@RequestMapping</code>注解的<code>produces</code>属性才解决问题，那么具体的情况还得从它入手，如果不指定值，那么它默认的处理逻辑是什么？</p><p>跟踪源码发现：在<code>HeaderContentNegotiationStrategy</code>进行了<code>api</code>媒体类型的相关处理，主要逻辑是获取请求头中的<code>accept</code>属性值，若为空，则指定<code>*/*</code>为结果值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MediaType&gt; <span class="title">resolveMediaTypes</span><span class="params">(NativeWebRequest request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取请求头中的accept属性</span></span><br><span class="line">    String[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT);</span><br><span class="line">    <span class="keyword">if</span> (headerValueArray == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若为空，则返回所有 -&gt; 实际值就是: */*</span></span><br><span class="line">        <span class="keyword">return</span> MEDIA_TYPE_ALL_LIST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; headerValues = Arrays.asList(headerValueArray);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues);</span><br><span class="line">        MediaType.sortBySpecificityAndQuality(mediaTypes);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(</span><br><span class="line">                <span class="string">&quot;Could not parse &#x27;Accept&#x27; header &quot;</span> + headerValues + <span class="string">&quot;: &quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着会进入<code>AbstractMessageConverterMethodProcessor#getProducibleMediaTypes</code>这个返回主要用于返回响应的媒体类型，主要会通过响应的返回值的数据类型根据具体的媒体转换器的<code>canWrite</code>方法来获取支持的媒体类型。</p><p>根据测试发现，如果在<code>accept</code>或者是<code>@RequestMapping</code>指定了<code>produces</code>属性值，那么这里直接获取到对应的值之后就返回了，而下面的通过默认的消息转换器中获取到的媒体类型都是不带具体的编码格式的，比如我的这个接口返回的主要就是<code>application/json</code>、<code>application/*+json</code>两种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;MediaType&gt; <span class="title">getProducibleMediaTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, Class&lt;?&gt; valueClass, <span class="meta">@Nullable</span> Type targetType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这里获取不到媒体的类型的情况下，进入下面的消息转换器获取，</span></span><br><span class="line">    <span class="comment">// 如果在@RequestMapping中指定了produces或者是原本请求头中的accept中指定了值，这里直接就是获取到指定的那个值    </span></span><br><span class="line">    Set&lt;MediaType&gt; mediaTypes =</span><br><span class="line">            (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(mediaTypes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(mediaTypes);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allSupportedMediaTypes.isEmpty()) &#123;</span><br><span class="line">        List&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">            <span class="comment">// 通过消息转换器获取响应结果支持的媒体类型</span></span><br><span class="line">            <span class="comment">// 比如接口的返回类型是List，则这里会获取到application/json、application/*+json</span></span><br><span class="line">            <span class="comment">// 返回类型是String，可能会有其他的媒体类型之类</span></span><br><span class="line">            <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter &amp;&amp; targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((GenericHttpMessageConverter&lt;?&gt;) converter).canWrite(targetType, valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    result.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (converter.canWrite(valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                result.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(MediaType.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    在我们公司其实研发也是获取不到开发环境、测试环境的服务器登录等相关权限，都是需要高数运维人员要操作什么，或者获取到对应的配置文件信息，然后进行更改，所以现在尽管知道了可能是请求头中的<code>accept</code>在测试环境中存在丢失的情况，也没有办法进入测试环境进行具体问题的排查，仅通过这一问题，对请求、响应的相关细节有了进一步的了解。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Springboot请求响应乱码&quot;&gt;&lt;a href=&quot;#Springboot请求响应乱码&quot; class=&quot;headerlink&quot; title=&quot;Springboot请求响应乱码&quot;&gt;&lt;/a&gt;Springboot请求响应乱码&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在一个项目中出现了一个比较棘手的问题，情况是这样的：由于项目场景的需要，引入了公司技术架构部门在&lt;code&gt;activiti&lt;/code&gt;工作流的基础上进行二次开发的工作流组件，使用该组件，需要实现几个获取岗位信息、人员信息相关的接口，工作流组件通过&lt;code&gt;restTemplate&lt;/code&gt;调用这些接口来获取对应的人员、岗位信息用于工作流服务的节点信息显示，在开发过程中一切正常且部署到开发环境中调试过程中也是一切正常，但是当部署到测试环境后，发现接口出现乱码。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="乱码" scheme="http://xiaocainiaoya.github.io/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>webService初试</title>
    <link href="http://xiaocainiaoya.github.io/2022/03/02/java/webservice%E5%88%9D%E8%AF%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/03/02/java/webservice%E5%88%9D%E8%AF%95/</id>
    <published>2022-03-02T13:51:58.000Z</published>
    <updated>2022-03-02T07:13:45.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webService初试"><a href="#webService初试" class="headerlink" title="webService初试"></a>webService初试</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近工作上需要将一些业务数据推送到各个门户网站，而各个门户网站上接收数据的方式不一样，有<code>webservice</code>和<code>http</code>两种方式，初次使用<code>webservice</code>，记录一下踩得一些坑。<span id="more"></span></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>​    使用<code>hutool</code>中的<code>SoapClient</code>配合<code>SoapUi</code>工具进行使用。</p><ol><li><p>使用<code>SoapUi</code>工具解析<code>WSDL</code>地址，得到这个地址提供的方法，再进入相应的方法，得到请求这个方法的<code>xml</code>结构。</p><p><img src="https://s2.loli.net/2022/03/02/BTNvykhem238QDE.png" alt="Snipaste_2022-03-02_14-40-27.png"></p><p>例子中: 这个<code>WSDL</code>提供了四个调用方法，然后点击<code>Request1</code>弹出右边部分。右边部分为对这个方法发起请求的<code>xml</code>结构，这时只需要通过<code>hutool</code>工具类<code>SoapClient</code>创建一个一致的<code>xml</code>请求结构后发起请求即可。</p><ol start="2"><li><p>直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SoapClient client = SoapClient.create(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    .setCharset(Charset.forName(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    .setMethod(<span class="string">&quot;调用的方法名&quot;</span>, <span class="string">&quot;命名空间&quot;</span>)</span><br><span class="line">    .setParam(<span class="string">&quot;参数名称&quot;</span>, <span class="string">&quot;参数值&quot;</span>);</span><br><span class="line">  <span class="comment">// 打印请求数据</span></span><br><span class="line">  log.info(<span class="string">&quot;webService请求: \n&#123;&#125;&quot;</span>, client.getMsgStr(<span class="keyword">false</span>));</span><br><span class="line">  client.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上就完成了<code>webService</code>的调用，使用上还是比较简单，主要是第一次使用<code>webService</code>，到处磕磕碰碰。</p></li></ol><p><strong>1.SoapUI解析错误</strong></p><p>部分门户使用<code>SoapUI</code>直接解析对应的<code>http://xxx/xxx.asmx?wsdl</code>地址，出现以下报错：</p><p><code>     Error loading [http://htgs.ccgp.gov.cn/GS8/services/Gs8WebService?wsdl]:     org.apache.xmlbeans.XmlException: org.apache.xmlbeans.XmlException: error:     The element type &quot;hr&quot; must be terminated by the matching end-tag </code>。</p><p>解决方案为通过浏览器进入这个地址，将这个页面中的内容保存为<code>xx.wsdl</code>文件，使用<code>SoapUI</code>加载这个文件。</p><p><strong>1. 使用postman调用</strong></p><p>在通过代码进行<code>webService</code>请求之前，实际上应该通过<code>SoapUI</code>发起请求，看是否能调用成功。(请求方式为上图右部分的绿色按钮)。但是有一个接口，由于使用<code>http://xx</code>地址解析失败后采用<code>xx.wsdl</code>文件的方式解析，这个接口一直不能发起请求。</p><p>解决方案为使用<code>postman</code>发起请求。设置头信息中<code>text/xml; charset=UTF-8</code>，然后<code>body</code>请求体中的参数修改为<code>raw</code>后选择<code>XML(text/xml)</code>后就可以发起对<code>webService</code>服务的请求。</p><p><strong>3.请求数据</strong></p><p>假设发起请求要携带的参数值为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user_name</span>&gt;</span>zanshang<span class="tag">&lt;/<span class="name">user_name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user_age</span>&gt;</span>15<span class="tag">&lt;/<span class="name">user_age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么实际上是需要将这个参数值填入到对应位置，实际发起的请求中是需要将<code>&lt;</code>和<code>&gt;</code>等字符进行编码化。<code>&amp;lt;</code>和<code>&amp;gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>body<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>user_name<span class="symbol">&amp;gt;</span>zanshang<span class="symbol">&amp;lt;</span>/user_name<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>user_age<span class="symbol">&amp;gt;</span>15<span class="symbol">&amp;lt;</span>/user_age<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>/body<span class="symbol">&amp;gt;</span></span><br></pre></td></tr></table></figure><p><strong>4.请求地址中?wsdl</strong></p><p>对<code>webService</code>的请求地址中是否需要<code>?wsdl</code>，就目前而言部分接口是需要，部分接口是不需要。这就使得调用是不知道需不需要带上，遇到过一个问题是这个接口实际上是不需要携带，但我在请求时携带了，然后请求返回的内容是这个访问地址的内容，还一直以为是请求的参数或者是姿势不对，排查了好久才找到问题。</p><p><strong>5.返回处理</strong></p><p>最让我觉得难受的是<code>webService</code>请求之后处理，因为对接了好几个门户网站，每个门户都返回一种不同的结构。情况非常多：</p><p><strong>异常情况：</strong>A门户的异常返回的是重定向页面的内容还包含了图片的<code>base64</code>串。B门户调用过于频繁也是返回一个重定向页面的内容。</p><p><strong>正常情况：</strong>A门户是在一种<code>xml</code>结构中的里层嵌入一个<code>json</code>串。B门户是在<code>xml</code>中用<code>![[DATA]]</code>的方式嵌入一个<code>xml</code>结构数据。然而AB门户的外层<code>xml</code>结构都不一致。</p><p>综上基本上每个门户的请求参数和返回都需要进行定制化，无法抽象出来达到通用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;webService初试&quot;&gt;&lt;a href=&quot;#webService初试&quot; class=&quot;headerlink&quot; title=&quot;webService初试&quot;&gt;&lt;/a&gt;webService初试&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近工作上需要将一些业务数据推送到各个门户网站，而各个门户网站上接收数据的方式不一样，有&lt;code&gt;webservice&lt;/code&gt;和&lt;code&gt;http&lt;/code&gt;两种方式，初次使用&lt;code&gt;webservice&lt;/code&gt;，记录一下踩得一些坑。</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>git记录</title>
    <link href="http://xiaocainiaoya.github.io/2022/01/10/git/git%E8%AE%B0%E5%BD%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/01/10/git/git%E8%AE%B0%E5%BD%95/</id>
    <published>2022-01-10T13:51:58.000Z</published>
    <updated>2022-01-10T12:24:35.881Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>旨在记录在使用<code>git</code>过程中出现的一些问题和使用上的一些操作记录、或者是<code>git</code>一些概念上的理解，防止重复踩坑。</p></blockquote><span id="more"></span><p><strong>1. 强制回滚远程<code>git</code>仓库的某个提交</strong><br>简单描述一下<code>git</code>的操作流程: </p><ol><li>工作区编写代码通过<code>add</code>命令添加到暂存区</li><li>暂存区通过<code>commit</code>命令添加到本地版本库</li><li>本地版本库通过<code>push</code>命令将本地代码推送到远程代码库</li></ol><p><code>git reset --soft HEAD^</code>  将本地仓库回滚为指定版本，且多余的提交回滚到暂存区</p><p><code>git reset --fixed HEAD^</code> 将本地仓库和暂存区回滚为指定版本</p><p><code>git reset --hard HEAD^</code> 将本地仓库、暂存区和工作区回滚为指定版本</p><p>强制回滚一个提交步骤:</p><ol><li>拉取需要修改的分支代码</li><li>通过<code>git reset --hard HEAD^</code>命令回滚一个提交</li><li>通过<code>git push --force</code>强制推送到远程代码库</li></ol><p><strong>2. 在<code>git</code>中<code>~</code>和<code>^</code>的区别</strong><br><code>HEAD^</code>, <code>HEAD^1</code>, <code>HEAD~</code>三个表达式都表示<code>HEAD</code>的父提交</p><p><code>HEAD^n</code>: 指的是<code>HEAD</code>的第<code>n</code>个父提交(有多个父提交的前提下[这里的父提交实际上是合并操作])<br><code>HEAD~n</code>: 指的是<code>HEAD</code>的第<code>n</code>个祖先提交(这里需要区分父提交和祖先提交的区别)，所以<code>HEAD~n=HEAD^^^(n个^)</code><br><img src="https://s2.loli.net/2022/01/10/q6iVtARvPXImlCZ.png" alt="git中^和~的区别.png"></p><p><strong>3. <code>log</code>和<code>reflog</code>的区别</strong></p><ul><li><code>reflog</code>: 可以查看所有分支的所有操作记录(包括已经删除的提交或者是重置的提交)</li><li><code>log</code>: 不能查看被删除的提交</li></ul><p>基于以上两个命令的区别<code>reflog</code>在一些场景下可以提供一些妙用。<br>比如:<br><strong>查看某个分支是基于那个分支迁出:</strong> <code>git reflog --date=local | grep &lt;分支名称&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输出信息</span><br><span class="line">077b02d HEAD@&#123;Fri Jan 7 17:03:26 2022&#125;: checkout: moving from 原分支名称 to 迁出后分支名称</span><br></pre></td></tr></table></figure><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#105;&#97;&#111;&#x63;&#97;&#105;&#110;&#105;&#97;&#111;&#121;&#x61;&#x40;&#102;&#x6f;&#x78;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#x78;&#105;&#97;&#111;&#x63;&#97;&#105;&#110;&#105;&#97;&#111;&#121;&#x61;&#x40;&#102;&#x6f;&#x78;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;旨在记录在使用&lt;code&gt;git&lt;/code&gt;过程中出现的一些问题和使用上的一些操作记录、或者是&lt;code&gt;git&lt;/code&gt;一些概念上的理解，防止重复踩坑。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Lock4j的锁代理浅析</title>
    <link href="http://xiaocainiaoya.github.io/2021/12/29/Spring/Lock4j%E7%9A%84%E9%94%81%E4%BB%A3%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2021/12/29/Spring/Lock4j%E7%9A%84%E9%94%81%E4%BB%A3%E7%90%86%E6%B5%85%E6%9E%90/</id>
    <published>2021-12-29T05:09:33.000Z</published>
    <updated>2021-12-29T06:18:06.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lock4j的锁代理浅析"><a href="#Lock4j的锁代理浅析" class="headerlink" title="Lock4j的锁代理浅析"></a>Lock4j的锁代理浅析</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>​    工作项目中使用<code>baomidou</code>的<code>lock4j</code>来进行分布式锁相关处理。在使用中还是出现了一些状况, 不得不稍微理解下<code>lock4j</code>中的一些基本设计思路和方式。<span id="more"></span></p><h3 id="二、基本知识"><a href="#二、基本知识" class="headerlink" title="二、基本知识"></a>二、基本知识</h3><p>​    在<code>Spring</code>中使用<code>AOP</code>实际上有好几种方式: 通过@AspectJ注解方式、通过<code>xml</code>配置文件方式、通过实现开放的一些抽象接口或者具体的实现方式。不论是使用哪种方式, 都需要指定出<code>AOP</code>中一些必备的结构。<br>这里简单描述下一些必需创建的结构:</p><ul><li>增强(<code>Advice</code>): 很多地方称为通知, 但实际上理解为增强更为准确. 用于表示具体的增强逻辑, 这里以日志前置增强为例, 前置增强顾名思义就是在某个逻辑之前添加保存日志的增强逻辑, 这里的日志保存逻辑即前置增强需要处理的逻辑, 所以前置增强的逻辑实际上就是一段处理逻辑代码, 和具体的目标逻辑之间没有关系. </li><li>切入点(<code>Pointcut</code>): 用于表示具体要切入的地方, 以上述前置增强为例, 在编写好日志增强的逻辑代码之后, 要应用到多少个地方, 也就是多少个地方需要添加这个日志前置增强, 这里就需要由切入点来标记具体需要切入的地方。</li><li>切面(<code>Aspect</code>): 切面可以简单理解为增强<code>Advice</code>和切入点<code>Pointcut</code>的组合.</li><li>目标对象(<code>Target Object</code>): 用于表示具体被增强的对象, 因为在<code>Spring</code>中是通过动态代理来实现切面处理, 故被增强对象就是目标对象.</li><li>代理对象(<code>AOP Proxy</code>): 用于表示将切面应用到目标对象而创建的代理对象。</li></ul><h3 id="三、浅析"><a href="#三、浅析" class="headerlink" title="三、浅析"></a>三、浅析</h3><p>​    在<code>lock4j</code>项目中, 大致的锁代理机制为创建一个基于<code>LockInterceptor</code>环绕增强的<code>Advice</code>和<code>@Lock4j</code>注解标记的切点<code>Pointcut</code>的<code>LockAnnotationAdvisor</code>切面。 </p><ol><li><p>环绕增强<code>Advice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LockTemplate lockTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockInterceptor</span><span class="params">(LockTemplate lockTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockTemplate = lockTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的环绕增强逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/12/29 11:31:23</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LockInfo lockInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Lock4j lock4j = invocation.getMethod().getAnnotation(Lock4j.class);</span><br><span class="line">            Lock4jConfig lock4JConfig = Lock4jConfig.builder().client(lock4j.client()).type(lock4j.type())</span><br><span class="line">                    .keys(lock4j.keys()).lockKeyBuilder(lock4j.keyBuilder()).acquireTimeout(lock4j.acquireTimeout())</span><br><span class="line">                    .expire(lock4j.expire()).lockFailureStrategy(lock4j.lockFailureStrategy()).build();</span><br><span class="line">            LockTemplate lockTemplateProxy = (LockTemplate) <span class="keyword">new</span> Lock4jProxyFactory(lockTemplate).getProxyInstance();</span><br><span class="line">            lockInfo = lockTemplateProxy.lock(invocation, lock4JConfig);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockInfo) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockInfo) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;[@Lock4j] releaseLock , current lockKey = &#123;&#125; &quot;</span>,lockInfo.getLockKey());</span><br><span class="line">                lockTemplate.releaseLock(lockInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切点<code>Pointcut</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记在方法上标记Lock4j注解的方法即为此aop的切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut = AnnotationMatchingPointcut.forMethodAnnotation(Lock4j.class);</span><br></pre></td></tr></table></figure></li><li><p>切面<code>LockAnnotationAdvisor</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记在方法上标记Lock4j注解的方法即为此aop的切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut = AnnotationMatchingPointcut.forMethodAnnotation(Lock4j.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockAnnotationAdvisor</span><span class="params">(<span class="meta">@NonNull</span> LockInterceptor lockInterceptor, <span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = lockInterceptor;</span><br><span class="line">        setOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pointcut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在增强中加入了bean工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/12/29</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advice <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) <span class="keyword">this</span>.advice).setBeanFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上就实现了若在方法上标记了<code>@Lock4j</code>注解就会进入到<code>LockInterceptor</code>的增强逻辑上进行具体的加锁逻辑。</strong><br>所以此实现采用的是<code>Advice</code>+<code>methodInterceptor</code>组合实现一个切面<code>Advisor</code>来实现<code>AOP</code>的逻辑。实际上此实现也可以通过<code>@Aspect</code>注解来实现, 在实际的工作过程中我感觉使用<code>@Aspect</code>注解的方式更为简单, 更容易让人理解。</p><p><strong>若在某个方法上同时使用<code>@Transactional</code>和<code>@Lock4j</code>那么锁对事物会不会有所影响？</strong><br>这边先下结论: 1.上锁 -&gt; 2.开启事务 -&gt; 3.执行逻辑 -&gt; 4.提交/回滚事务 -&gt; 5.释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里标记这个切面的order = HIGHEST_PRECEDENCE = Integer.MIN_VALUE;(最小值)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/12/29 11:44:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LockAnnotationAdvisor <span class="title">lockAnnotationAdvisor</span><span class="params">(LockInterceptor lockInterceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LockAnnotationAdvisor(lockInterceptor, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建锁切面对象时设置了<code>Order</code>排序号为最小值, 所以若在某个方法上同时使用<code>@Transactional</code>和<code>@Lock4j</code>, 在代理类的<code>advisors</code>列表中的第一个元素就是<code>LockAnnotationAdvisor</code>, 第二个元素才是事物处理增强。<br><img src="https://s2.loli.net/2021/12/29/8aKTRhwdom1Q37X.png" alt="锁代理.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Lock4j的锁代理浅析&quot;&gt;&lt;a href=&quot;#Lock4j的锁代理浅析&quot; class=&quot;headerlink&quot; title=&quot;Lock4j的锁代理浅析&quot;&gt;&lt;/a&gt;Lock4j的锁代理浅析&lt;/h2&gt;&lt;h3 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h3&gt;&lt;p&gt;​    工作项目中使用&lt;code&gt;baomidou&lt;/code&gt;的&lt;code&gt;lock4j&lt;/code&gt;来进行分布式锁相关处理。在使用中还是出现了一些状况, 不得不稍微理解下&lt;code&gt;lock4j&lt;/code&gt;中的一些基本设计思路和方式。</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Stream基本使用</title>
    <link href="http://xiaocainiaoya.github.io/2021/12/15/java/Stream%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/12/15/java/Stream%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-15T13:51:58.000Z</published>
    <updated>2021-12-15T08:04:27.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>​    <code>jdk8</code>中引入的函数式<code>lambda</code>表示式，同时引入了<code>Stream</code>流，这种流可以堆集合进行一些复杂查找、过滤、映射、规约等操作。一个<code>stream</code>是由三部分组成，<code>数据源流 -&gt;零个或多个中间操作 -&gt; 零个或一个终止操作</code>。中间操作是对数据的加工处理并且中间操作是懒<code>lazy</code>操作，并不会马上启动，需要等待终止操作允许到才会开始执行。<span id="more"></span></p><p><img src="https://s2.loli.net/2021/12/15/1SnxVPmy6G8sfth.png" alt="stream.png"></p><p><code>Stream</code>分为终端操作和中间操作。</p><ul><li>终端操作：也称为结束操作，即不能在继续处理数据。</li><li>中间操作：就是可以使用上一次处理的结果进行再次处理数据。</li></ul><p>终端操作又分为短路操作和非短路操作：</p><ul><li>短路操作：所有数据项不一定都需要处理完成即可结束。类似于<code>a || b</code>，这种判断语句只要某个数据项使得<code>a=true</code>即结束遍历。</li><li>非短路操作：所有数据项都需要遍历一遍方才结束。</li></ul><p>中间操作又分为有状态和无状态：</p><ul><li>有状态：表示改操作只有等待拿到所有元素后才能继续下去。</li><li>无状态：表示元素的处理不受其他元素的影响。</li></ul><p>比如：<code>sorted()</code>排序，需要获取到流中的所有元素后才能进行排序。而<code>filter()</code>只需要获取流中的一个元素就可以进行处理。</p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-终端操作"><a href="#2-1-终端操作" class="headerlink" title="2.1 终端操作"></a>2.1 终端操作</h3><h4 id="2-1-1-短路操作"><a href="#2-1-1-短路操作" class="headerlink" title="2.1.1 短路操作"></a>2.1.1 短路操作</h4><h5 id="2-1-1-1-匹配"><a href="#2-1-1-1-匹配" class="headerlink" title="2.1.1.1 匹配"></a>2.1.1.1 匹配</h5><p><strong>1.<code>find</code></strong></p><ul><li><p><code>findFirst</code>：获取数据流中的第一个元素</p></li><li><p><code>findAny</code> ：随机获取数据流中的一个元素(然而大部分情况下是返回第一个元素)</p></li></ul><p>通过<code>findFirst/findAny</code>返回的是一个<code>Optional&lt;T&gt;</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(list.stream().findFirst().get());</span><br><span class="line">    System.out.println(list.stream().findAny().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.<code>match</code></strong></p><ul><li><code>anyMatch</code>：数据流中仅有一个数据项满足<code>Predicate</code>即返回<code>true</code></li><li><code>allMatch</code>：数据流中所有数据项满足<code>Predicate</code>才返回<code>true</code></li><li><code>noneMatch</code>：数据流中所有数据项都不满足<code>Predicate</code>才返回<code>true</code></li></ul><p><strong>注意：</strong>当数据列表为空时, <code>allMatch</code>的返回值为<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(list.stream().anyMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(list.stream().allMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(list.stream().noneMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 特殊情况, 数据列表为空</span></span><br><span class="line">    List&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(items.stream().anyMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(items.stream().allMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(items.stream().noneMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-非短路操作"><a href="#2-1-2-非短路操作" class="headerlink" title="2.1.2 非短路操作"></a>2.1.2 非短路操作</h4><h5 id="2-1-2-1-遍历"><a href="#2-1-2-1-遍历" class="headerlink" title="2.1.2.1 遍历"></a>2.1.2.1 遍历</h5><ul><li> 在<code>stream.forEach</code>中不能使用<code>break</code>和<code>continue</code>关键字, 但<code>stream.forEach</code>中<code>return</code>和 <code>continue</code>达到的效果一致。</li><li> 在<code>parallelStream.forEachOrdered</code>可以使得结果有序, 但同时牺牲了并行流的好处。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().forEach(item -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(item % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(item);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.parallelStream().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.parallelStream().forEachOrdered(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-2-聚合"><a href="#2-1-2-2-聚合" class="headerlink" title="2.1.2.2 聚合"></a>2.1.2.2 聚合</h5><blockquote><p>max/min/count</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aggregation</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自然排序</span></span><br><span class="line">    System.out.println(list.stream().max(Integer::compareTo).get());</span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    Integer max = list.stream().max(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).get();</span><br><span class="line">    System.out.println(max);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.stream().min(Integer::compareTo).get());</span><br><span class="line"></span><br><span class="line">    System.out.println(list.stream().count());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-3-规约"><a href="#2-1-2-3-规约" class="headerlink" title="2.1.2.3 规约"></a>2.1.2.3 规约</h5><p><strong><code>reduce</code></strong></p><blockquote><p>规约: 将一个流通过一些计算/逻辑规约为一个值</p></blockquote><p>第三个参数一般使用不到, 用处是在使用并行流(<code>parallelStream</code>)时, 最终将所有并行流的数据进行规约。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;求和: &quot;</span> + list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b));</span><br><span class="line">    System.out.println(<span class="string">&quot;求积: &quot;</span> + list.stream().reduce(<span class="number">1</span>, (a, b) -&gt; a * b));</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值: &quot;</span> + list.stream().reduce((a, b) -&gt; a &gt; b ? a : b).get());</span><br><span class="line">    <span class="comment">// reduce三个参数的方法</span></span><br><span class="line">    <span class="comment">// 这种情况下会输出最大值, 在stream流下并不会调用第三个参数。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;stream最大值: &quot;</span> + list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a &gt; b ? a : b,  (a, b) -&gt; <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 这种情况输出结果为null, 因为在每个并行流中计算得到每个并行流中的最大值后, 通过第三个参数将并行流的结果合并。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;parallelStream最大值: &quot;</span> + list.parallelStream().reduce(<span class="number">0</span>, (a, b) -&gt; a &gt; b ? a : b,  (a, b) -&gt; <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-4-收集"><a href="#2-2-2-4-收集" class="headerlink" title="2.2.2.4 收集"></a>2.2.2.4 收集</h5><p><code>collect</code><br>在<code>stream</code>流中<code>collect</code>是功能最多的操作，可以将流中的数据收集为一个值或者一个集合。主要是依赖于<code>java.util.stream.Collectors</code>类内置的静态方法。</p><p><code>collect(Collector&lt;? super T, A, R&gt; collector)</code>中传入的是<code>Collector</code>对象, 主要使用为实现对象<code>java.util.stream.Collectors</code>。在<code>Collectors</code>中内置了很多具体收集的静态方法<br>而这些静态方法最终也都依赖于静态内部实现类<code>CollectorImpl&lt;T, A, R&gt;</code>。这里简单理解下<code>CollectorImpl&lt;T, A, R&gt;</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (T:输入元素类型, A:累加类型, R:最后返回的对象类型)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectorImpl</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 中间收集集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;A&gt; supplier;</span><br><span class="line">    <span class="comment">// 累加算法/收集算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiConsumer&lt;A, T&gt; accumulator;</span><br><span class="line">    <span class="comment">// 规约(主要针对并行流下规约每个流中的数据)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryOperator&lt;A&gt; combiner;</span><br><span class="line">    <span class="comment">// 结果操作(比如joining操作, 是先将数据收集到StringBuilder中, 最后通过</span></span><br><span class="line">    <span class="comment">// stringBuilder.toString返回结果, 这里finisher=StringBuilder:toString)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, R&gt; finisher;</span><br><span class="line">    <span class="comment">// 收集器特性, 有三个</span></span><br><span class="line">    <span class="comment">// UNORDERED: 规约结果不受流中元素的遍历和累加的顺序影响</span></span><br><span class="line">    <span class="comment">// CONCURRENT: 该收集器可以并行规约流</span></span><br><span class="line">    <span class="comment">// IDENTITY_FINISH: 表明finisher是一个恒等函数, 可以跳过(累加器的结果就是收集的最终结果)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Characteristics&gt; characteristics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举两个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入类型为T, 累加类型为?, 最后返回对象类型为List&lt;T&gt;。</span></span><br><span class="line"><span class="comment">// 假设调用为: students.stream().map(Student::getAge).collect(Collectors.toList())</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">        <span class="comment">// 创建一个中间收集容器</span></span><br><span class="line">        (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>,</span><br><span class="line">        <span class="comment">// 数据添加到容器中的算法/规则</span></span><br><span class="line">        List::add,</span><br><span class="line">        <span class="comment">// 并行流下的规约机制</span></span><br><span class="line">        (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">        <span class="comment">// 收集器特性</span></span><br><span class="line">        CH_ID</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            <span class="comment">// 新建了一个StringBuilder容器</span></span><br><span class="line">            StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">            <span class="comment">// 设置这个数据的添加规则</span></span><br><span class="line">            StringBuilder::append,</span><br><span class="line">            <span class="comment">// 并行流下的规约规则</span></span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            <span class="comment">// 最后的输出规则</span></span><br><span class="line">            StringBuilder::toString,</span><br><span class="line">            <span class="comment">// 收集器特性</span></span><br><span class="line">            CH_NOID</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>归集: 将流中的数据收集为集合(<code>List</code>、<code>Set</code>、<code>Map</code>)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student tom = Student.builder().age(<span class="number">19</span>).name(<span class="string">&quot;tom&quot;</span>).number(<span class="number">10</span>).build();</span><br><span class="line">    Student marry = Student.builder().age(<span class="number">12</span>).name(<span class="string">&quot;marry&quot;</span>).number(<span class="number">15</span>).build();</span><br><span class="line">    Student jack = Student.builder().age(<span class="number">12</span>).name(<span class="string">&quot;jack&quot;</span>).number(<span class="number">20</span>).build();</span><br><span class="line">    List&lt;Student&gt; students = ListUtil.of(tom, marry, jack);</span><br><span class="line">    System.out.println(<span class="string">&quot;======== collect ========&quot;</span>);</span><br><span class="line">    <span class="comment">// 归集</span></span><br><span class="line">    System.out.println(students.stream().map(Student::getAge).collect(Collectors.toList()));</span><br><span class="line">    System.out.println(students.stream().map(Student::getAge).collect(Collectors.toSet()));</span><br><span class="line">    <span class="comment">// Student类的number为key, Student对象为value的Map</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getNumber, p -&gt; p)));</span><br><span class="line">    <span class="comment">// Function.identity() 是 p -&gt; p 简单写法, 表示返回对象本身</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getNumber, Function.identity())));</span><br><span class="line">    <span class="comment">// Student类的age为key, Student类的name为value(由于marry和jack的age都是12, 所以在规约为map是出现一个key对应两个值, 这时由第三个参数来处理冲突键情况)</span></span><br><span class="line">    <span class="comment">// 这里简单处理: 重复时获取第一个键所对应的值。</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getAge, Student::getName, (key1, key2) -&gt; key2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>统计: 实际上就是聚合的那些操作(最大值、最小值、平均值、数量)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.counting()));</span><br><span class="line">System.out.println(students.stream().collect(Collectors.averagingInt(Student::getAge)));</span><br><span class="line">System.out.println(students.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compareTo)));</span><br><span class="line"><span class="comment">// 获取所有值, 返回IntSummaryStatistics对象(数量, 求和, 最小值, 平均值, 最大值)</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getAge)));</span><br></pre></td></tr></table></figure><ul><li>分组/分区: 分区是将流中的数据按照一定的规则分为两组数据(Map&lt;Boolean, List<Object>&gt;), 分组是将流中的数据按照一定的规则分成多组数据(Map&lt;String/Integer/…, List&lt;Object/String/Integer/…&gt;&gt;)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回键为boolean, 值为Student对象的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.partitioningBy(item -&gt; item.getAge() &gt; <span class="number">12</span>)));</span><br><span class="line"><span class="comment">// 返回键为student.age, 值为List&lt;Student&gt;的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getAge)));</span><br><span class="line"><span class="comment">// collectors.groupingBy的第二个参数表示下游收集器, 可以对上游收集到的value值进行处理。</span></span><br><span class="line"><span class="comment">// 返回键为student.age, 值为List&lt;String&gt; names 的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.mapping(Student::getName, Collectors.toList()))));</span><br><span class="line"><span class="comment">// 返回键为student.name, 值为相同name的年龄的平均值</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingInt(Student::getAge))));</span><br></pre></td></tr></table></figure><ul><li>连接: 将流中的数据通过某个分隔符、前缀字符串、后缀字符串进行连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接连接, 没有分隔符</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining()));</span><br><span class="line"><span class="comment">// 使用|分隔</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>)));</span><br><span class="line"><span class="comment">// 添加连接前缀和后缀</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>, <span class="string">&quot;name: [&quot;</span>, <span class="string">&quot;]&quot;</span>)));</span><br></pre></td></tr></table></figure><h3 id="2-2-中间操作"><a href="#2-2-中间操作" class="headerlink" title="2.2 中间操作"></a>2.2 中间操作</h3><h4 id="2-2-1-有状态"><a href="#2-2-1-有状态" class="headerlink" title="2.2.1 有状态"></a>2.2.1 有状态</h4><h5 id="2-2-1-1-排序"><a href="#2-2-1-1-排序" class="headerlink" title="2.2.1.1 排序"></a>2.2.1.1 排序</h5><p>自定义排序仅需要实现<code>Comparator</code>中的<code>compareTo</code>方法即可。实际上一些简单的排序在<code>Comparator</code>中都有静态实现，只需要通过<code>lambda</code>调用即可，比如降序排列<code>Comparator::reversOrder()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sorted</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认是升序排列</span></span><br><span class="line">    list.stream().sorted().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(Comparator.reverseOrder()).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(Integer::compareTo).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * o1 &gt; o2 返回大于0的数表示升序</span></span><br><span class="line"><span class="comment">            * o1 &lt; o2 返回大于0的数表示降序</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> o1</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> o2</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted(Comparator.comparing(Student::getAge)).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    <span class="comment">// 多次排序</span></span><br><span class="line">    list.stream().sorted(Comparator.comparing(Student::getNumber).thenComparing(Student::getAge)).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-2-去重"><a href="#2-2-1-2-去重" class="headerlink" title="2.2.1.2 去重"></a>2.2.1.2 去重</h5><p><strong><code>distinct</code></strong></p><p>通过流中元素的 <code>hashCode()</code> 和 <code>equals() </code>去除重复元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">distinct</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().distinct().forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-3-切片"><a href="#2-2-1-3-切片" class="headerlink" title="2.2.1.3 切片"></a>2.2.1.3 切片</h5><p><code>limit(n)</code>截取前<code>n</code>个元素，<code>skip(n)</code>跳过<code>n</code>个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">limitOrSkip</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().limit(<span class="number">5</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().skip(<span class="number">5</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-无状态"><a href="#2-2-2-无状态" class="headerlink" title="2.2.2 无状态"></a>2.2.2 无状态</h4><h5 id="2-2-2-1-映射"><a href="#2-2-2-1-映射" class="headerlink" title="2.2.2.1 映射"></a>2.2.2.1 映射</h5><p>可以将一个流中的元素按照一定的规则映射到另一个流中。</p><ul><li><code>map</code>：接收一个处理函数，这个函数会作用到每个元素上，并为处理后的结果生成一个新的流。</li><li><code>flatMap</code>：接收一个处理函数，这函数会将作用到每个元素上，<strong>并为每个处理后的元素生成一个流</strong>，然后把所有流合并为流。(也就是说处理之后得到的数据是一个流，且这个流中的每个元素也是流。)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().map(item -&gt; item + <span class="number">1</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    list.stream().map(Student::getAge).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在flatMap执行完成之后, 实际上是将一个流两个元素&#123;&quot;hello World!&quot;, &quot;how are you&quot;&#125; 分解为</span></span><br><span class="line">    <span class="comment">// 两个流: 分别为 &#123;&quot;hello&quot;, &quot;World!&quot;&#125; 和 &#123;&quot;how&quot;, &quot;are&quot;, &quot;you&quot;&#125; 两个流。</span></span><br><span class="line">    <span class="comment">// 在forEach操作是对这两个流分别执行forEach操作。</span></span><br><span class="line">    List&lt;String&gt; strs = ListUtil.of(<span class="string">&quot;hello World!&quot;</span>, <span class="string">&quot;how are you&quot;</span>);</span><br><span class="line">    strs.stream().flatMap(item -&gt; &#123;</span><br><span class="line">        <span class="comment">// 返回一个新流</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(item.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;).forEach(item -&gt; System.out.println(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为<code>debug</code>模式下<code>flatMap</code>执行完成之后的结果。</p><p><img src="https://s2.loli.net/2021/12/15/dgjItYFBTOJrAvC.png" alt="image-20211214204808262.png"></p><h4 id="2-2-2-2-过滤"><a href="#2-2-2-2-过滤" class="headerlink" title="2.2.2.2 过滤"></a>2.2.2.2 过滤</h4><p><code>filter</code></p><p>在实际的开发过程中比较常用的一个操作，接收一个函数，通过改函数判断是否需要过滤到元素。(一般情况下会配合映射<code>map</code>使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n======== filter ========&quot;</span>);</span><br><span class="line">    list.stream().filter(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-3-消费"><a href="#2-2-2-3-消费" class="headerlink" title="2.2.2.3 消费"></a>2.2.2.3 消费</h5><p><code>peek</code></p><p>主要是在<code>debug</code>中使用。</p><p>先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().peek(System.out::print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后发现并没有任何输出。回到开头的介绍中，<code>peek</code>属于中间操作，在运行到终止操作时，此中间操作是不会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.filter(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .peek(e -&gt; System.out.println(<span class="string">&quot;被2整除的数: &quot;</span> + item))</span><br><span class="line">        .map(item -&gt; item + <span class="number">1</span>)</span><br><span class="line">        .peek(item -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + item))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>被2整除的数: 2<br>结果: 3<br>被2整除的数: 4<br>结果: 5</p></blockquote><p>以上输出了流执行的中间过程，所以实际上流操作是在获取到一个元素后就会继续往下执行。</p><p>这里要注意：<code>peek(func)</code>接收的函数是一个<code>Consumer</code>，它是仅处理并不返回处理结果到流中。所以以下代码实际上执行也是没有效果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.peek(item -&gt; item + <span class="number">1</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;jdk8&lt;/code&gt;中引入的函数式&lt;code&gt;lambda&lt;/code&gt;表示式，同时引入了&lt;code&gt;Stream&lt;/code&gt;流，这种流可以堆集合进行一些复杂查找、过滤、映射、规约等操作。一个&lt;code&gt;stream&lt;/code&gt;是由三部分组成，&lt;code&gt;数据源流 -&amp;gt;零个或多个中间操作 -&amp;gt; 零个或一个终止操作&lt;/code&gt;。中间操作是对数据的加工处理并且中间操作是懒&lt;code&gt;lazy&lt;/code&gt;操作，并不会马上启动，需要等待终止操作允许到才会开始执行。</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Arthas的基本使用</title>
    <link href="http://xiaocainiaoya.github.io/2021/11/18/Springboot/Arthas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/11/18/Springboot/Arthas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-11-18T12:46:11.000Z</published>
    <updated>2021-11-18T12:26:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近正式环境出现一起事故，业务端经过一些列的业务逻辑之后，使用<code>wkhtmltopdf</code>工具进行<code>html</code>转换为<code>pdf</code>，但出现生成完成之后(正常结束，并未发生异常)业务端再次获取这个<code>pdf</code>文件时，出现文件不存在问题。<span id="more"></span></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>​    经过一系列的排查，最终锁定在<code>wkhtmltopdf</code>工具是否正常生成<code>pdf</code>文件，请看如下代码，这里通过<code>wkhtmltopdf</code>提供的工具类<code>pdf.saveAsDirect(ftpDir + &quot;/&quot; + path);</code>进行<code>pdf</code>的生成，但并未对返回的结果进行判断，所以猜测这里根本没有生成<code>pdf</code>文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadToPdfDirect</span><span class="params">(WrapperConfig config, String sourceString, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pdf pdf = <span class="keyword">new</span> Pdf(config);</span><br><span class="line">        pdf.setAllowMissingAssets();</span><br><span class="line">        pdf.addPageFromString(sourceString);</span><br><span class="line">        pdf.addParam(pageInfo);</span><br><span class="line">        pdf.saveAsDirect(ftpDir + <span class="string">&quot;/&quot;</span> + path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;wkHtmlToPdf发生异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 捕获到InterruptedException异常后恢复中断状态</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wkHtmlToPdf发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据猜测希望将代码修改为：(本想借助<code>Arthas</code>将代码修改以下代码，但由于线上一直产生数据，事故面积越来越大，来不及研究<code>Arthas</code>的使用，只能走繁琐的流程，进行发包替换正式环境的包)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadToPdfDirect</span><span class="params">(WrapperConfig config, String sourceString, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pdf pdf = <span class="keyword">new</span> Pdf(config);</span><br><span class="line">        pdf.setAllowMissingAssets();</span><br><span class="line">        pdf.addPageFromString(sourceString);</span><br><span class="line">        pdf.addParam(pageInfo);</span><br><span class="line">        <span class="comment">// 对生成的结果进行判断, 到底有没有生成对应文件</span></span><br><span class="line">        File file = pdf.saveAsDirect(ftpDir + <span class="string">&quot;/&quot;</span> + path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件生成失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;wkHtmlToPdf发生异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 捕获到InterruptedException异常后恢复中断状态</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wkHtmlToPdf发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>​    经过漫长的发版流程等待，等到正式环境替换包已经是大半夜。经过测试，确实是<code>pdf</code>文件未生成(如果会使用<code>Arthas</code>，这个时候应该就已经解决问题)。这里要说明下，到目前为止只知道这种方式会生成失败，至于在什么情况下生成失败就不得而知了，因为开发环境、测试环境、预发布环境都是正常生成。痛定思痛，决定学习一下<code>Arthas</code>的使用。</p><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><p>简单的使用流程：</p><ol><li><p>找到需要进行添加代码的类全路径后进行反编译到某个文件夹中。</p><blockquote><p>jad –source-only com.xxx.service.v3.xxxService &gt; /tmp/xxxService.java</p></blockquote><p>这里是由<code>.class</code>反编译为<code>.java</code>文件，所以阅读上没有那么友好，其实刚出现问题的时候就想到使用<code>Arthas</code>，但是被这个反编译出来的代码劝退了，反编译出来的代码甚至有指令重排，不太敢修改这个反编译文件。</p></li><li><p>修改这个反编译文件</p><blockquote><p>vim /tmp/UserController.java</p></blockquote><p>这里实际上是要先退出<code>arthas</code>，第一次使用的时候还以为<code>arthas</code>命令行可以直接操作文件，实际上应该退出<code>arthas</code>使用<code>linux</code>命令的方式进行文件修改。</p></li><li><p>查找这个类对应的类加载器</p><blockquote><p>sc -d *xxxService | grep classLoadHash</p><p>classLoadHash 6bc26251</p></blockquote><p>这里得到这个类的加载器的哈希值为<code>6bc26251</code></p></li><li><p>使用这个类加载器将修改后的文件编译为<code>.class</code>文件</p><blockquote><p>mc -c 6bc26251 /tmp/xxxService.java -d /tmp</p></blockquote><p>这时会在<code>/tmp</code>文件夹下生成一个以包结构为文件路径的<code>.class</code>文件。</p></li><li><p>进行热更新</p><blockquote><p>redefine /tmp/com/xxx/service/v3/xxxService.class</p></blockquote><p>当看到提示<code>redefine success, size: 1</code>说明替换成功，就可以进行具体的测试。</p></li></ol><p>以上这种方式，出现问题的概率极大，因为要修改反编译文件，且反编译文件好像进行了一些指令重排，导致阅读上比较困难，实际上以上的前四步骤就是为了得到修改之后的<code>.class</code>文件，那么实际上我们可以借助于<code>idea</code>进行处理。</p><ol><li>找到线上代码的标签，拉取修改文件分支。</li><li>检出这个分支，进行特定文件的修改后，直接使用<code>idea</code>工具进行文件的编译。这时就可以通过<code>target</code>文件夹获取到对应修改文件的<code>.class</code>文件。</li><li>将这个<code>.class</code>文件上传到对应服务器。</li><li>直接热更新这个文件。(也就是上述的第5步)</li></ol><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><ol><li>在某个接口的服务层添加一个日志打印信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequireFileVo <span class="title">getFiles</span><span class="params">(ParamVo ParamVo, Integer pageNum, Integer pageSize)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;pageSize:&#123;&#125;&quot;</span>, pageSize);</span><br><span class="line">        <span class="comment">// 以下为很复杂的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>通过<code>idea</code>对整个服务进行编译后，获取到该文件的<code>.class</code>文件。</p></li><li><p>上传到服务器中，由于服务是运行在<code>docker</code>中，所以上传到服务器后移动文件到<code>docker</code>与宿主机的挂载目录中。</p></li><li><p>从挂载目录移动到简单目录。(测试的时候使用的挂载目录路径比较长，就移动到简单一点的目录比如<code>/tmp</code>)</p></li><li><p>使用<code>redefine</code>命令后看到<code>redefine success, size: 1</code>表示成功</p></li><li><p>测试，通过<code>postman</code>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">30.491</span> [TraceId=92aeb19c3e8ce62b,SpanId=92aeb19c3e8ce62b,ParentSpanId=] [http-nio-<span class="number">20065</span>-exec-<span class="number">5</span>] INFO  c.b.g.b.s.v.s.xxxService-pageSize:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="其他基础功能"><a href="#其他基础功能" class="headerlink" title="其他基础功能"></a>其他基础功能</h2><ul><li><strong>reset</strong>：重置增强类，此命令会将<code>arthas</code>增强过的类都重置为增强之前的情况。</li><li><strong>quit</strong>：退出，<code>quit</code>只是退出<code>archas</code>的<code>session</code>，实际上目标进程<code>arthas server</code>还在运行中。</li><li><strong>stop</strong>：彻底退出<code>arthas</code>，使用此命令后，实际上会执行一次<code>reset</code>命令。</li></ul><p><strong>注意：</strong>要区别于<code>quit</code>和<code>stop</code>两个退出之间的区别。</p><blockquote><p> 通过线程<code>id</code>查看线程的具体信息，比如查看线程<code>id</code>为1的线程的具体信息：<code>thread 1</code></p></blockquote><p><strong>1.watch</strong>：查看类里面的某个方法的返回值和入参(实际上只能看参数类型, 是否有值, 并不能看值是多少)</p><blockquote><p>命令 + 类完全限定名 + 需要检测的方法 + 表达式 + (额外参数)</p><p>watch com.xxx.xxx.service.v3.xxxService  getFiles “{params, returnObj}” -x 2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">额外参数：</span><br><span class="line">-x 指定输出结果(默认为<span class="number">1</span>) 这里为<span class="number">2</span>层</span><br><span class="line">-b 表示在方法调用之前</span><br><span class="line">-e 表示在方法出异常时</span><br><span class="line">-s 表示在方法返回之后</span><br><span class="line">-f 表示在方法结束之后(正常返回和异常返回)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表达式核心变量列表：</span><br><span class="line">loader      本次调用类所在的 ClassLoader</span><br><span class="line">clazz       本次调用类的 Class 引用</span><br><span class="line">method      本次调用方法反射引用</span><br><span class="line">target      本次调用类的实例</span><br><span class="line">params      本次调用参数列表，这是一个数组，如果方法是无参方法则为空数组</span><br><span class="line">returnObj   本次调用返回的对象。当且仅当 isReturn==<span class="keyword">true</span> 成立时候有效，表明方法调用是以正常返回的方式结束。如果当前方法无返回值 <span class="keyword">void</span>，则值为 <span class="keyword">null</span></span><br><span class="line">throwExp    本次调用抛出的异常。当且仅当 isThrow==<span class="keyword">true</span> 成立时有效，表明方法调用是以抛出异常的方式结束。</span><br><span class="line">isBefore    辅助判断标记，当前的通知节点有可能是在方法一开始就通知，此时 isBefore==<span class="keyword">true</span> 成立，同时 isThrow==<span class="keyword">false</span> 和 isReturn==<span class="keyword">false</span>，因为在方法刚开始时，还无法确定方法调用将会如何结束。</span><br><span class="line">isThrow     辅助判断标记，当前的方法调用以抛异常的形式结束。</span><br><span class="line">isReturn    辅助判断标记，当前的方法调用以正常返回的形式结束。</span><br></pre></td></tr></table></figure><p><strong>2.trace</strong>：方法内部的调用路径，并输出方法路径上的每个节点耗时</p><blockquote><p>命令 + 类完全限定名 + 需要检测的方法</p><p>trace com.xxx.xxx.service.v3.xxxService  getFiles</p></blockquote><p><strong>3.heapdump</strong>：生成快照信息</p><blockquote><p>heapdump (–live) 生成文件路径/xxx.hprof</p></blockquote><p><strong>–live</strong>：只<code>dump</code>活着的对象</p><p>我是使用<code>jdk</code>自带的<code>jvisualvm</code>来打开<code>xx.hprof</code>文件进行分析。<code>jdk</code>自带的<code>jvisualvm</code>在<code>~/home/bin</code>目录下。顺便记录下<code>mac</code>系统查看<code>jdk home</code>所在位置的方式：执行<code>/usr/libexec/java_home -V</code></p><p><strong>4.sysprop</strong>：查看<code>Sysetm properties</code>信息</p><p>可以指定单个 </p><blockquote><p>sysprop @appId</p></blockquote><p>或者使用<code>grep</code>进行过滤</p><blockquote><p>sysprop | grep @appId </p></blockquote><p>再或者直接添加一个新的键值对</p><blockquote><p>sysprop timeout 50</p></blockquote><p><strong>5.sysenv</strong>：查看环境变量(使用上和<code>sysprop</code>一致)</p><p>注意：系统变量通过<code>System.getProperty()</code>，环境变量通过<code>System.getEnv()</code>。系统变量可以通过<code>-D</code>的方式在启动时添加，环境变量</p><p><strong>6.jvm</strong>：可以查看<code>jvm</code>虚拟机的一些信息</p><p><strong>7.sc</strong>：可以查看已经加载的类，如果类是接口，可以获取到已加载的所有实现类，通过<code>-d</code>参数可以打印类加载的具体信息。并且支持通配符查找类。</p><blockquote><p>sc -d xxx</p></blockquote><p><strong>8.sm</strong>：查找具体的函数</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文档地址[<a href="https://arthas.aliyun.com/doc/]">https://arthas.aliyun.com/doc/]</a></p><p>git地址(<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a>)</p><p>使用教程地址(<a href="https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&amp;id=arthas-advanced">https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&amp;id=arthas-advanced</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近正式环境出现一起事故，业务端经过一些列的业务逻辑之后，使用&lt;code&gt;wkhtmltopdf&lt;/code&gt;工具进行&lt;code&gt;html&lt;/code&gt;转换为&lt;code&gt;pdf&lt;/code&gt;，但出现生成完成之后(正常结束，并未发生异常)业务端再次获取这个&lt;code&gt;pdf&lt;/code&gt;文件时，出现文件不存在问题。</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
    <category term="工具" scheme="http://xiaocainiaoya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>springboot启动过程</title>
    <link href="http://xiaocainiaoya.github.io/2021/09/13/Springboot/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://xiaocainiaoya.github.io/2021/09/13/Springboot/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-09-13T14:51:58.000Z</published>
    <updated>2021-09-13T06:39:21.904Z</updated>
    
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>spring事件监听机制</title>
    <link href="http://xiaocainiaoya.github.io/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-12T05:09:33.000Z</published>
    <updated>2021-09-13T06:28:27.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring事件监听机制"><a href="#spring事件监听机制" class="headerlink" title="spring事件监听机制"></a>spring事件监听机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring</code>事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于<code>spring</code>容器进行事件的注册、发布、处理。</p><span id="more"></span><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1.创建一个类继承于顶层事件类<code>ApplicationEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendNotificationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SendNotificationVo sendNotificationVo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendNotificationEvent</span><span class="params">(ApplicationContext source, SendNotificationVo sendNotificationVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.sendNotificationVo = sendNotificationVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.监听到对应的事件后的业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.调用点发送具体的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上就是最简单的<code>spring</code>事件监听的使用。在具体的应用场景中，并不会这么简单的使用，因为若在业务逻辑上需要解耦，大部分还是希望是异步的方式进行事件的处理，然而在默认的情况下，这种模式是同步机制，也就是说待到具体的事件监听处理完成之后，才会继续执行调用点的业务逻辑。</p><h2 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h2><h3 id="1-广播器异步"><a href="#1-广播器异步" class="headerlink" title="1.广播器异步"></a>1.广播器异步</h3><p>​    在<code>spring</code>的事件监听机制中已经考虑到异步的情况，所以在事件发送器发送事件时，会判断是否存在广播器，当存在广播器时，会将具体的监听执行逻辑转移到广播器对应的线程池中。来跟踪一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        publishEvent((Object) event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体子类实现接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现在<code>AbstractApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取广播器, 并调用广播器对应的发送事件处理</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认仅有一个广播器的实现<code>SimpleApplicationEventMulticaster</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 获取对应的广播器线程池</span></span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="comment">// 获取这个event对应类型的所有监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="comment">// 若是配置了线程池, 则将监听任务转移到线程池中执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若是没有配置线程池, 执行执行监听任务, 所以在默认情况下与具体的业务逻辑是同步执行。</span></span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体事件监听的执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 具体执行监听逻辑</span></span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实际上就是ApplicationListener的onApplicationEvent方法</span></span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        String msg = ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">            Log logger = LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚上面介绍的最简单的使用方式中采用的<code>@EventListener</code>的方式来标记监听器的位置，实际上在初始化这个<code>bean</code>对象时，扫描到<code>@EventListener</code>后会将这个对应的方式转化为<code>ApplicationListenerMethodAdapter</code>类，该类中包含了<code>bean</code>名称、类名称、监听处理<code>method</code>等等，待到接收到事件时，通过反射调用对应的监听处理方法。</p><h3 id="2-Async注解异步"><a href="#2-Async注解异步" class="headerlink" title="2.@Async注解异步"></a>2.@Async注解异步</h3><p>​    虽然在事件发送器中内置了广播器线程池，但是若不进行配置，则它还是同步的方式执行，在它同步执行的基础上，若是利用<code>spring</code>的异步机制，也可以达到异步的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，在<code>spring</code>容器初始化时，扫描到这个<code>bean</code>对象并进行初始化时，会为这个<code>bean</code>创建一个代理类，由这个代理类来执行相应的异步逻辑。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>以上看似已经解决的异步的问题，但是在实际的使用过程中又发现如果事件发送点存在事务管理，就会导致事件中获取不到事件发送点的某些数据。(由于事件监听处理触发时，事件发送点还未提交事务。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪代码, 在事件监听的处理中, 通过id=123可能存在获取不到这条数据的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/09/12 13:54:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    mapper.insert(sendNotificationVo);</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是、但是、但是这种情况<code>spring</code>也考虑到了，<code>spring</code>监听机制中通过使用<code>@TransactionalEventListener</code></p><p>来解决这个问题。<code>@TransactionalEventListener</code>它的元注解为<code>@EventListener</code>，所以本质上也是个<code>@EventListener</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 事件触发阶段: 比如事务提交之前、事务提交之后等, 默认是在事务提交之后</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function">TransactionPhase <span class="title">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 若调用点无事务管理也触发, 默认情况下若调用点无事务接管, 该监听处理不会触发</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Alias for &#123;<span class="doctag">@link</span> #classes&#125;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The event classes that this listener handles.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚上面说到在<code>spring</code>扫描到对应的监听器处理<code>bean</code>时，会根据方法上标记的注解将监听器转换为对应的处理类。根据不同的两个注解<code>@TransactionalEventListener</code>和<code>EventListener</code>对应两个不同的生成监听类工厂<code>DefaultEventListenerFactory</code>和<code>TransactionalEventListenerFactory</code>，由它们来创建具体的监听处理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp; AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp; !isSpringContainerClass(targetType)) &#123;</span><br><span class="line">        Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从bean的class对象中找出含有@EventListener注解的方法, 存在Map&lt;Method, EventListener&gt;中</span></span><br><span class="line">            <span class="comment">// @TransactionListener方法也会被匹配, 因为它的元注解是@EventListener</span></span><br><span class="line">            annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">                            AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// An unresolvable type in a method signature, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Could not resolve methods for bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No @EventListener annotations found on bean class: &quot;</span> + targetType.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Non-empty set of methods</span></span><br><span class="line">            ConfigurableApplicationContext context = <span class="keyword">this</span>.applicationContext;</span><br><span class="line">            Assert.state(context != <span class="keyword">null</span>, <span class="string">&quot;No ApplicationContext set&quot;</span>);</span><br><span class="line">            List&lt;EventListenerFactory&gt; factories = <span class="keyword">this</span>.eventListenerFactories;</span><br><span class="line">            Assert.state(factories != <span class="keyword">null</span>, <span class="string">&quot;EventListenerFactory List not initialized&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取监听工厂, 这里有两个工厂:DefaultEventListenerFactory和TransactionalEventListenerFactory</span></span><br><span class="line">                <span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">                    <span class="comment">// 判断这个被标记的方法适配哪个工厂</span></span><br><span class="line">                    <span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line">                        Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                        <span class="comment">// 使用工厂创建对应的监听器对象</span></span><br><span class="line">                        ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                        <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">                            ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="keyword">this</span>.evaluator);</span><br><span class="line">                        &#125;</span><br><span class="line">                        context.addApplicationListener(applicationListener);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(annotatedMethods.size() + <span class="string">&quot; @EventListener methods processed on bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + annotatedMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这两个工厂生成出来的监听类，实际上是两个适配器，<code>ApplicationListenerMethodAdapter</code>和<code>ApplicationListenerMethodTransactionalAdapter</code>，由这两个适配器来执行相应的处理逻辑。这里要感叹下<code>spring</code>设计的精妙，一环扣一环，扩展性极强。</p><p>这里分析下<code>ApplicationListenerMethodTransactionalAdapter</code>中对应的监听触发方法<code>onApplicationEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// publish事件时: 创建一个TransactionSynchronization对象, 这个对象持有event</span></span><br><span class="line">        <span class="comment">// 创建TransactionSynchronizationEventAdapter</span></span><br><span class="line">        TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event);</span><br><span class="line">        <span class="comment">// 注册到事务管理器中</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Processing &quot;</span> + event + <span class="string">&quot; as a fallback execution on AFTER_ROLLBACK phase&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反射调用进行事件的处理</span></span><br><span class="line">        processEvent(event);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No transactional event execution at all</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No transaction is active - skipping &quot;</span> + event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为采用这种方式之后，就解决了对应的异步+调用点事务的问题。在测试中发现：若采用广播器实现异步，极大可能获取不到调用点事务内数据；而采用<code>@Async</code>实现异步百分百可以获取到调用点事务内数据。</p><p>简单跟踪发现：</p><ul><li>广播器方式实现异步，是将<code>onApplicationEvent</code>方法的触发丢入线程池。</li><li><code>@Async</code>方式实现异步，走下方<code>else</code>逻辑，在事件发送器中走同步逻辑，是直接执行<code>onApplicationEvent</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// invokeListener()返回最后的逻辑是去调用ApplicationListener.onApplicationEvent()</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的是否对<code>onApplicationEvent</code>方法执行执行起到了关键性的作用，因为在事务监听处理器适配器中会判断是否是否存在事务。第一种情况，由线程池内线程来执行该方法，这时事务是绑定在原线程上，所以会导致这个判断结果为<code>false</code>。第二种情况，由事件发送线程执行该方法，这时与事务在同一线程，则这个判断的结果为<code>true</code>，将对应的事件处理方法注册到事务管理器中，待到执行改事件监听处理方法时，是异步进行处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line"><span class="comment">// 省略以下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    整体使用下来，发现其中的道道还是很多的，这需要对所有的组合情况、问题情况、原理都掌握的情况下，否则随意组合，可能在某一场景下能达到需要的效果，但是就像是埋下了定时炸弹。当然了<code>spring</code>的事件监听机制毕竟只是基于内存，若对应的生产环境并没有升级停机钩子处理，或者是金丝雀升级等方式，需停机升级，有可能会导致部分监听未执行的情况，所以建议生产环境还是通过一些<code>mq</code>组件进行发布监听事件的处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring事件监听机制&quot;&gt;&lt;a href=&quot;#spring事件监听机制&quot; class=&quot;headerlink&quot; title=&quot;spring事件监听机制&quot;&gt;&lt;/a&gt;spring事件监听机制&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于&lt;code&gt;spring&lt;/code&gt;容器进行事件的注册、发布、处理。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-08-30T14:08:50.000Z</published>
    <updated>2021-08-30T14:55:43.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​    <code>spring</code>为了减少过多<code>xml</code>的配置，减轻开发者的配置负担，提供了通过注解的方式进行<code>bean</code>对象的加载。并且在单一注解的基础上增加了一些模式上的约定。</p><span id="more"></span><p>​    比如<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>，实际上它们的作用都是将标记的类生成对应的<code>bean</code>对象之后添加到<code>IOC</code>容器中，通过精细注解的方式，为注解带来一些语义。使得可以更直观的看出一些分层行为。再比如<code>springboot</code>中扩展了<code>spring</code>的<code>@Condition</code>注解，通过<code>@OnXXXConditon</code>的方式标记某个类是否需要进行加载到<code>IOC</code>容器。</p><h2 id="二、注解"><a href="#二、注解" class="headerlink" title="二、注解"></a>二、注解</h2><p>​    在注解上标记的注解称为元注解。比如在<code>@Service</code>注解之上标记<code>@Component</code>注解。使得<code>@Service</code>拥有将标记类加载为<code>Bean</code>对象后添加到<code>IOC</code>容器中的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment"> * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-AliasFor"><a href="#2-1-AliasFor" class="headerlink" title="2.1 AliasFor"></a>2.1 AliasFor</h3><p>别名注解，在注解创建时，有的时候为了加深语义以及向前兼容的原则，可以通过别名的方式进行创建新字段。比如以下例子，<code>value</code>和<code>path</code>互为别名。在日常使用中<code>path</code>更能体现访问路径的语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">  String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-使用"><a href="#2-1-1-使用" class="headerlink" title="2.1.1 使用"></a>2.1.1 使用</h4><p>​    在使用上基本上是标记两个注解属性互为别名，但若使用不当，仅在一方上标记为另一方的别名，这时实际上效果和互相标记一致，只是这样就降低了可读性，所以为了提高可读性和隐式别名带来的值覆盖，还是应该遵守规范，进行相互标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AliasFor</span> 别名注解测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/08/30 22:24:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AliaForAnnotation &#123;</span><br><span class="line">    <span class="meta">@AliasFor(value = &quot;path&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@AliasFor(value = &quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  AliaForAnnotation aliaForAnnotation = AnnotationUtils.getAnnotation(SpringMvcStart.class, AliaForAnnotation.class);</span><br><span class="line">  System.out.println(<span class="string">&quot;value:&quot;</span> + aliaForAnnotation.value());</span><br><span class="line">  System.out.println(<span class="string">&quot;path:&quot;</span> + aliaForAnnotation.path());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>spring</code>中除了在一个注解中相互标记互为注解之外，还可以对组合注解进行相互标记，同时别名具有传递性。</p><ol><li>显示标记：标记一个注解中的两个注解属性互为别名</li><li>隐式标记：<code>A</code>注解的<code>a</code>属性标记为<code>C</code>注解的<code>c</code>的别名，<code>B</code>注解的<code>b</code>属性标记为<code>C</code>注解的<code>c</code>的别名，那么可以得出<code>A</code>注解的<code>a</code>属性也是<code>B</code>注解的<code>b</code>属性的别名。</li></ol><p>在<code>PostMapping</code>注解中，<code>name</code>属性就是<code>RequestMapping</code>注解中<code>name</code>的别名，<code>value</code>属性就是<code>RequestMapping</code>注解中<code>value</code>的别名，所以当在声明<code>@PostMapping(value = &quot;/xx/x&quot;)</code>的时候，不论是直接获取<code>PostMapping</code>注解后获取<code>value</code>值，还是通过元注解获取<code>RequestMapping</code>后获取它的<code>value</code>值，都为<code>/xx/x</code>。在更为复杂的场景下，不会别名链有多长，若存在隐式标记都可能存在值的传递性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#name&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#value&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Conditional"><a href="#2-2-Conditional" class="headerlink" title="2.2 Conditional"></a>2.2 Conditional</h3><p>在<code>spring</code>中提供了条件注解<code>@Conditional</code>，用于判断在某种场景下是否需要加载某个类为<code>Bean</code>对象。在<code>springboot</code>中将其扩展之后，使用上更为方便。</p><h4 id="2-2-1-使用"><a href="#2-2-1-使用" class="headerlink" title="2.2.1 使用"></a>2.2.1 使用</h4><p>创建一个注解<code>ConditionalOnDev</code>，且使用<code>@Conditional</code>指定条件类为<code>DevCondition</code>。当<code>ConditionalOnEnviroment</code>配置类被加载，要创建<code>enviroment</code>对象之前，会进入条件类的<code>matches</code>方法，若该方法返回<code>true</code>则表示允许将这个<code>bean</code>对象添加到<code>IOC</code>容器中，反之不处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(DevCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnDev &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单演示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalOnEnviroment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnDev(value = &quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Environment <span class="title">enviroment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dev();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上示例，若对<code>springboot</code>有所了解，应该知道<code>springboot</code>中存在大量的<code>@OnXxxCondition</code>，它就是利用<code>spring</code>提供的条件控制注解的方式。比如在<code>springboot</code>中有<code>@OnBeanCondition</code>、<code>@OnClassCondition</code>、<code>@OnResourceCondition</code>等等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring注解&quot;&gt;&lt;a href=&quot;#Spring注解&quot; class=&quot;headerlink&quot; title=&quot;Spring注解&quot;&gt;&lt;/a&gt;Spring注解&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;为了减少过多&lt;code&gt;xml&lt;/code&gt;的配置，减轻开发者的配置负担，提供了通过注解的方式进行&lt;code&gt;bean&lt;/code&gt;对象的加载。并且在单一注解的基础上增加了一些模式上的约定。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>HandlerMethod</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/19/SpringMvc/Handler/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/19/SpringMvc/Handler/</id>
    <published>2021-08-19T13:24:33.000Z</published>
    <updated>2021-08-23T14:53:16.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMethod</code>是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMethod顶层接口"><a href="#1-HandlerMethod顶层接口" class="headerlink" title="1. HandlerMethod顶层接口"></a>1. HandlerMethod顶层接口</h4><p><img src="https://i.loli.net/2021/08/19/7ITf8eNah9YEn4c.png" alt="HandlerMethod类图.png"></p><p>​    <code>HandlerMethod</code>整体的结构比较简单，但是<code>HandlerMethod</code>并不是设计成接口，直接设计为类，主要用于封装对应的处理方法信息<code>method</code>和这个处理器方法所对应的类信息、这个方法上的所有注解信息等。而真正的处理器方法的处理交由子类<code>InvocableHandlerMethod</code>，这里类包含了参数解析器和参数名称解析器的处理，用于在真正方法调用前进行参数解析。最后底层实现类<code>ServletInvocableHandlerMethod</code>包含了返回值处理器链，用于处理执行处理器方法之后的返回值。</p><h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h4><p>​    在顶层类<code>HandlerMethod</code>中，主要的实现就是一些构造函数，为了应对不同场景下使用不同的参数对具体的的执行方法进行包装，比如记录具体执行方法的参数、对应的类、对应类的类型、<code>bean</code>工厂、桥接方法等。</p><p>​    在次顶层类<code>InvocableHandlerMethod</code>中，主要添加了参数解析器列表和参数名称解析器列表，用于在支持<code>support()=true</code>的情况下，对参数进行一些个性化处理。并且包含了具体执行方法的反射调用处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 参数处理</span></span><br><span class="line">    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际处理请求的方法</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体的执行方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行该方法</span></span><br><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">        String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(text, args), ex);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">        Throwable targetException = ex.getTargetException();</span><br><span class="line">        <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>ServletInvocableHandlerMethod</code>类中，主要的当处理器方法执行结束后，对返回值的进行一些定制化的特殊处理。<code>springmvc</code>在异步调用的处理上就是通过返回值处理器，当返回值类型为<code>Callable</code>时，进行一些特殊的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 选择具体的返回值处理器(获取首次匹配成功的返回值处理器)</span></span><br><span class="line">    <span class="comment">// 举个异步处理的方式Callable, 由CallableMethodReturnValueHandler进行处理</span></span><br><span class="line">    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体的执行逻辑</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>参数解析器和返回值处理器在获取时，是获取列表中第一个匹配成功的那个解析器或者处理器，也就是说如果希望定制化的解析器或者处理器被执行到，需要确保它所在的位置之前没有其他的解析器或者处理器会被命中。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerMethod&quot;&gt;&lt;a href=&quot;#HandlerMethod&quot; class=&quot;headerlink&quot; title=&quot;HandlerMethod&quot;&gt;&lt;/a&gt;HandlerMethod&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerMethod&lt;/code&gt;是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>HandlerAdapter</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/18/SpringMvc/HandlerAdapter/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/18/SpringMvc/HandlerAdapter/</id>
    <published>2021-08-18T14:12:53.000Z</published>
    <updated>2021-08-23T14:58:54.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerAdapter</code>是<code>Handler</code>的适配器，每种类型的<code>Handler</code>都对应一个<code>HandlerAdapter</code>。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在顶层接口<code>HandlerAdapter</code>的实现中，基本上都是直接具体的实现。</p><span id="more"></span><p><img src="https://i.loli.net/2021/08/18/PksoX39nvUDiZHB.png" alt="HandlerAdapter类图png.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HandlerAdapter 是否支持这个 Handler</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler the handler object to check</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 利用 Handler 处理请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment">  * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以<code>AbstractHandlerMethodAdapter</code>为例进行分析。这个抽象类也比较简答，仅仅是将顶层接口中的参数进行具象化，再调用本类的模板方法，供子类直接使用，所以子类就不需要在进行类型装换等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果handler是HandlerMethod, 直接强转后调用模板方法</span></span><br><span class="line">    <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">supportsInternal</span><span class="params">(HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 仅仅是强转了类型之后, 直接调用模板方法</span></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>具体实现<strong>RequestMappingHandlerAdapter</strong></p><p>​    <code>RequestMappingHandlerAdapter</code>是<code>HandlerAdapter</code>体系中最复杂的类，包含了具体<code>Handler</code>执行前后需要特殊处理或者是一些开放的扩展点的处理。比如有参数处理器、参数名称处理器、<code>HttpMessageConverter</code>、结果处理器等等。</p><p><strong>1.初始化</strong></p><p>​    <code>RequestMappingHandlerAdapter</code>的初始化分为两步，一步是在构造函数中进行默认<code>HttpMessageConvert</code>的添加，另一步是通过<code>afterPropertiesSet</code>进行一些全局处理的缓存和一些组件的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;&gt;());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        <span class="comment">// Ignore when no TransformerFactory implementation is available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化全局的三个变量modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line">    initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数解析器argumentResolvers参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getDefaultArgumentResolvers()中定义了一些常用的参数解析器，同时支持添加用户自定义参数解析器</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化initBinder式参数绑定器initBinderArgumentResolvers</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过getDefaultInitBinderArgumentResolvers()获取默认的解析器，同时支持添加用户自定义参数绑定器</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化返回值处理器returnValueHandlers</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过getDefaultReturnValueHandlers()方法获取返回值解析器，同时支持添加用户自定义返回值处理器</span></span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化全局的三个变量modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2021/08/18 10:12:25</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initControllerAdviceCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取带有@ControllerAdvice的所有类</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">        Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在@ModelAttribute注解, 但不存在@RequestMapping注解的方法</span></span><br><span class="line">        Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在@InitBinder注解的方法</span></span><br><span class="line">        Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是RequestBodyAdvice或者是ResponseBodyAdvice的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">            requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若在上述解析过程中存在实现类, 则添加到最前面, 所以在requestResponseBodyAdvice中, 自定义的优先级高于默认</span></span><br><span class="line">    <span class="keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.requestResponseBodyAdvice.addAll(<span class="number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.实际处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    <span class="comment">//判断是否支持当前request的方法，该方法在WebContentGenerator类中定义，通过内置的supportedMethods属性来进行判断</span></span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                <span class="comment">// 具体的执行方法</span></span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">            applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            prepareResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取创建WebDataBinder实例的工厂类，其中WebDataBinder类用于绑定request参数到JavaBean对象</span></span><br><span class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 获取@ModelAttribute的非@RequestMapping方法</span></span><br><span class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ServletInvocableHandlerMethod是继承于HandlerMethod, 这里相当于只是将handlerMethod中的属性值赋值给invocableMethod, 仅仅只做了包了一层</span></span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="comment">// 为ServletInvocableHandlerMethod中的一些数据赋值, 增加了参数解析、处理器方法调用、返回值解析等逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">//设置参数名称处理器</span></span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建模型和视图容器</span></span><br><span class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">        <span class="comment">// 设置FlashMap中的值</span></span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        <span class="comment">// 初始化模型</span></span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步处理相关代码</span></span><br><span class="line">        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            Object result = asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">                String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体的执行方法</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="comment">// 若是异步方式, 这里就直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建ModelAndView实例</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServletInvocableHandlerMethod</code>就是具体的<code>HandlerMethod</code>的实现，所以在最后通过<code>invocableMethod.invokeAndHandle(webRequest, mavContainer)</code>调用到具体的实现。以下基本上就是具体<code>Handler</code>的调用前最后一步了，返回执行结果之后，由结果处理器进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑(这里会先经过参数解析器的处理之后，再通过反射调用到具体的方法)</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里想简要说明一下异步调用的场景：<code>Servlet3.0</code>支持服务器异步操作，在<code>springmvc</code>中也添加了响应的支持。整个请求的过程与同步类似，只是在具体的<code>handler</code>调用之后，如果是异步方式，假设是使用<code>Callable</code>，则这里获取到的返回值处理器就是<code>CallableMethodReturnValueHandler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue;</span><br><span class="line">    <span class="comment">// 进入Callable方式异步处理逻辑</span></span><br><span class="line">    WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(<span class="keyword">final</span> WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Assert.notNull(webAsyncTask, <span class="string">&quot;WebAsyncTask must not be null&quot;</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">&quot;AsyncWebRequest must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    Long timeout = webAsyncTask.getTimeout();</span><br><span class="line">    <span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 设置异步线程池</span></span><br><span class="line"><span class="comment">      *   1. 默认情况下会创建DEFAULT_TASK_EXECUTOR -&gt; SimpleAsyncTaskExecutor线程池</span></span><br><span class="line"><span class="comment">      *   2. 一般来说, 在RequestMappingHandlerAdapter中, 创建的WebAsyncManager时会传入它的this.taskExecutor</span></span><br><span class="line"><span class="comment">      *      2.1 而RequestMappingHandlerAdapter也会创建一个默认的SimpleAsyncTaskExecutor(名称前缀为MvcAsync)</span></span><br><span class="line"><span class="comment">      *        2.1.1 但是在springmvc中, 初始化Bean RequestMappingHandlerAdapter时为它添加了单一线程池Executor.newSingleThreadExecutor</span></span><br><span class="line"><span class="comment">      *        2.1.2 但是在springboot中, 初始化Bean RequestMappingHandlerAdapter时为它添加了一个名为applicationTaskExecutor的线程池</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    AsyncTaskExecutor executor = webAsyncTask.getExecutor();</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskExecutor = executor;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        logExecutorWarning();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置拦截器</span></span><br><span class="line">    List&lt;CallableProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.add(webAsyncTask.getInterceptor());</span><br><span class="line">    interceptors.addAll(<span class="keyword">this</span>.callableInterceptors.values());</span><br><span class="line">    interceptors.add(timeoutCallableInterceptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取具体的callable</span></span><br><span class="line">    <span class="keyword">final</span> Callable&lt;?&gt; callable = webAsyncTask.getCallable();</span><br><span class="line">    <span class="comment">// 创建拦截器链对象, 拦截器链对象一般情况下都会包含拦截列表、具体执行对象以及具体执行到某个拦截器的下标值</span></span><br><span class="line">    <span class="keyword">final</span> CallableInterceptorChain interceptorChain = <span class="keyword">new</span> CallableInterceptorChain(interceptors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Async request timeout for &quot;</span> + formatRequestUri());</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = interceptorChain.triggerAfterTimeout(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">        <span class="keyword">if</span> (result != CallableProcessingInterceptor.RESULT_NONE) &#123;</span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置错误处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addErrorHandler(ex -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.errorHandlingInProgress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Async request error for &quot;</span> + formatRequestUri() + <span class="string">&quot;: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = interceptorChain.triggerAfterError(<span class="keyword">this</span>.asyncWebRequest, callable, ex);</span><br><span class="line">            result = (result != CallableProcessingInterceptor.RESULT_NONE ? result : ex);</span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置正常完成处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(() -&gt; interceptorChain.triggerAfterCompletion(<span class="keyword">this</span>.asyncWebRequest, callable));</span><br><span class="line"></span><br><span class="line">    interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">    <span class="comment">// 设置一些标志位为启动状态</span></span><br><span class="line">    startAsyncProcessing(processingContext);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将callable丢入线程池中</span></span><br><span class="line">        Future&lt;?&gt; future = <span class="keyword">this</span>.taskExecutor.submit(() -&gt; &#123;</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptorChain.applyPreProcess(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">                result = callable.call();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = ex;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, callable, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行完成之后进行结果的分发, 这个具体在不同容器有不同的实现(tomcat、undertow)</span></span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        interceptorChain.setTaskFuture(future);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        Object result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, callable, ex);</span><br><span class="line">        setConcurrentResultAndDispatch(result);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerAdapter&quot;&gt;&lt;a href=&quot;#HandlerAdapter&quot; class=&quot;headerlink&quot; title=&quot;HandlerAdapter&quot;&gt;&lt;/a&gt;HandlerAdapter&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerAdapter&lt;/code&gt;是&lt;code&gt;Handler&lt;/code&gt;的适配器，每种类型的&lt;code&gt;Handler&lt;/code&gt;都对应一个&lt;code&gt;HandlerAdapter&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;在顶层接口&lt;code&gt;HandlerAdapter&lt;/code&gt;的实现中，基本上都是直接具体的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>DispatcherServlet</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/DispatcherServlet/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/DispatcherServlet/</id>
    <published>2021-08-15T06:56:09.000Z</published>
    <updated>2021-08-23T14:53:23.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>DispatcherServlet</code>是一个<code>Servlet</code>，在<code>springmvc</code>中被称为前端控制器，根据请求的路径、类型等进行请求的分发。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>DispatcherServlet</code>类图</p><p><img src="https://i.loli.net/2021/08/15/OrjQ6AYMb7R2Pd1.png" alt="DispatcherServlet类图.png"></p><p>​    上图中的红色部分为<code>Servlet</code>接口，在<code>Springmvc</code>中实现并扩展了该<code>Servlet</code>接口。在我最早学<code>javaweb</code>开发时，并不是上来就使用各种<code>MVC</code>框架，而是从编写简单的<code>Servlet</code>开始，就是继承<code>HttpServlet</code>后，重写它的<code>service</code>方法。而<code>Springmvc</code>的设计同理，它也继承了<code>HttpServlet</code>并重写它的<code>service</code>方法，同时配置该<code>servlet</code>拦截所有的请求，从而实现了由<code>DispatcherServlet</code>来分发所有的请求。</p><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>​    因为<code>DispatcherServlet</code>实际上是一个<code>Servlet</code>，所以当配置它生效时它同时也就遵循<code>Servlet</code>的生命周期。在<code>Servlet</code>的生命周期有三个阶段：</p><ul><li><code>init()</code>：初始化请求</li><li><code>service()</code>：获取到请求后的业务处理以及跳转</li><li><code>distory()</code>：请求处理完成之后的销毁</li></ul><p>所以当<code>tomcat</code>容器(<code>servlet</code>容器)启动时，会触发<code>servlet</code>的初始化方法。<code>HttpServletBean</code>实现了该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际的处理在这, 由子类FrameworkServlet实现</span></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FrameworkServlet</code>的<code>initServletBean</code>方法，真正核心的地方在于<code>initWebApplicationContext()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Initializing Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化web容器上下文</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">                <span class="string">&quot;shown which may lead to unsafe logging of potentially sensitive data&quot;</span> :</span><br><span class="line">                <span class="string">&quot;masked to prevent unsafe logging of potentially sensitive data&quot;</span>;</span><br><span class="line">        logger.debug(<span class="string">&quot;enableLoggingRequestDetails=&#x27;&quot;</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                <span class="string">&quot;&#x27;: request parameters and headers will be &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Completed initialization in &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取由ContextLoaderListener初始化并注册在ServletContext中的根上下文，记为rootContext</span></span><br><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 2.如果webApplicationContext已经不为空，表示这个Servlet类是通过编程式注册到容器中的（Servlet 3.0+中的ServletContext.addServlet() ），</span></span><br><span class="line">    <span class="comment">// 上下文也由编程式传入。若这个传入的上下文还没被初始化，将rootContext上下文设置为它的父上下文，然后将其初始化，否则直接使用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.通过wac变量的引用是否为null，判断第2步中是否已经完成上下文的设置（即上下文是否已经用编程式方式传入），如果wac==null成立，说明该Servlet不是</span></span><br><span class="line">    <span class="comment">// 由编程式注册到容器中的。此时以contextAttribute属性的值为键，在ServletContext中查找上下文，查找得到，说明上下文已经以别的方式初始化并注册在contextAttribute下，直接使用。</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.检查wac变量的引用是否为null，如果wac==null成立，说明2、3两步中的上下文初始化策略都没成功，此时调用createWebApplicationContext(rootContext)，建立一个全新的以rootContext</span></span><br><span class="line">    <span class="comment">// 为父上下文的上下文，作为SpringMVC配置元素的容器上下文。大多数情况下我们所使用的上下文，就是这个新建的上下文。</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建成功之后会调用spring的refresh方法</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.以上三种初始化上下文的策略，都会回调onRefresh(ApplicationContext context)方法（回调的方式根据不同策略有不同），onRefresh方法在DispatcherServlet类中被覆写，</span></span><br><span class="line">    <span class="comment">// 以上面得到的上下文为依托，完成SpringMVC中默认实现类的初始化。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// onRefresh方法在DispatcherServlet类中被覆写，所以从这里可以知道先创建spring容器, 在springBean都创建成功之后, 再通过onRefresh方法进行DispatcherServlet的初始化。</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.最后，将这个上下文发布到ServletContext中，也就是将上下文以一个和Servlet类在web.xml中注册名字有关的值为键，设置为ServletContext的一个属性。你可以通过改变</span></span><br><span class="line">    <span class="comment">// publishContext的值来决定是否发布到ServletContext中，默认为true。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>onRefresh(wac)</code>方法，调用到子类<code>DispatcherServlet</code>具体的初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化DispatcherServlet策略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化DispatcherServlet策略(九大组件)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上传组件处理器</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 处理器映射器</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 处理器适配器</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">// 处理器异常整理器</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 视图处理器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-分发逻辑"><a href="#2-分发逻辑" class="headerlink" title="2. 分发逻辑"></a>2. 分发逻辑</h4><p><img src="https://i.loli.net/2021/08/15/Eh6UipmYNGXSPDo.png" alt="springmvc流程图.png"></p><ul><li>当客户端发起请求，请求进入<code>DispatcherServlet</code>，由它来进行处理器<code>Handler</code>的查找。</li><li>首先根据请求信息<code>HttpServletRequest</code>，遍历已注册的所有<code>handlerMappings</code>。返回的结构为<code>HandlerExecutionChain</code>，是包含了具体的处理器<code>handler</code>和拦截器<code>interceptor</code>的结构。</li><li>获取到<code>HandlerExcecutionChain</code>后，根据具体的处理器，遍历所有的<code>handlerAdapters</code>，返回支持的<code>HandlerAdapter</code>。</li><li>在获取到<code>HandlerAdapter</code>之后，执行具体的<code>handler</code>之前，会先遍历执行<code>HandlerExecutionChain</code>中的拦截器的前置拦截方法<code>preHandle()</code>，**若出现某个拦截器的前置方法执行后方法<code>false</code>，则直接从当前节点开始往前执行<code>afterCompletion()</code>**，执行完毕后直接终止请求。</li><li>根据<code>HandlerAdapter</code>处理器适配器执行具体的处理器<code>Handler</code>逻辑。</li><li>在执行完成具体的<code>handler</code>之后，会遍历执行<code>HandlerExecutionChain</code>中拦截器的<code>postHandle</code>方法。</li><li><code>Handler</code>执行完毕之后会返回<code>ModeAndView</code>。</li><li>执行正常的情况下，在渲染模板后，请求返回前，会遍历执行<code>HandlerExecutionChain</code>中拦截器的<code>afterCompletion</code>方法。</li></ul><h4 id="3-设置springmvc容器"><a href="#3-设置springmvc容器" class="headerlink" title="3.设置springmvc容器"></a>3.设置springmvc容器</h4><p>​    根据类图可知<code>DispatcherServlet</code>也是实现了<code>ApplicationContextAware</code>接口，而<code>xxxAware</code>接口，是在<code>springbean</code>初始化时的一个<code>postProcessBeforeInitialization</code>扩展点，由类<code>ApplicationContextAwareProcessor</code>去执行具体的逻辑，简单来说就是将<code>ApplicationContext</code>通过<code>setApplicationContext</code>的方法传递给正在初始化的这个<code>bean</code>。</p><p>​    在<code>springboot</code>中就是通过这个方法，将<code>spring</code>容器(<code>applicationContext</code>)传给<code>DispatcherServlet</code>，待到真正去执行<code>DispatcherServlet</code>的初始化方法时<code>this.applicationContext</code>就不为空，所以在<code>initWebApplicationContext()</code>方法中，就走第一个<code>if</code>的逻辑，这也是<code>springboot</code>最终不会产生父子容器的原因。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;DispatcherServlet&quot;&gt;&lt;a href=&quot;#DispatcherServlet&quot; class=&quot;headerlink&quot; title=&quot;DispatcherServlet&quot;&gt;&lt;/a&gt;DispatcherServlet&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;DispatcherServlet&lt;/code&gt;是一个&lt;code&gt;Servlet&lt;/code&gt;，在&lt;code&gt;springmvc&lt;/code&gt;中被称为前端控制器，根据请求的路径、类型等进行请求的分发。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>HandlerMapping</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/HandlerMapping/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/HandlerMapping/</id>
    <published>2021-08-15T06:56:09.000Z</published>
    <updated>2021-08-23T14:53:00.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMapping</code>处理器映射器，是<code>SpringMvc</code>的核心组件之一，用来根据请求的<code>request</code>信息查询对应的<code>Handler</code>，在<code>web</code>环境中，每个请求都需要一个对应的<code>Handler</code>来处理，所以当接收到一个请求，需要哪一个<code>Handler</code>来处理，<code>HandlerMapping</code>的作用就是找到处理的那个<code>Handler</code>。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMapping顶层接口"><a href="#1-HandlerMapping顶层接口" class="headerlink" title="1. HandlerMapping顶层接口"></a>1. HandlerMapping顶层接口</h4><p><img src="https://i.loli.net/2021/08/15/IObtEmouNveLT2y.png" alt="HandlerMapping类图.png"></p><p>以上为<code>HandlerMapping</code>的类图，在<code>HandlerMapping</code>接口中有一个公共的抽象类<code>AbstractHandlerMapping</code><br>所有的子孙都会继承它。该抽象类有两个子类<code>AbstractHandlerMethodMapping</code>表示基于方法的映射方法，这个方式就是我们日常使用的<code>Controller</code>的那种方式，<code>AbstractUrlHandlerMapping</code>表示根据<code>url</code>获取到对应的<code>Handler</code>。</p><p>这里分析一下公共抽象父类<strong>AbstractHandlerMapping</strong>。这个抽象类采用了模板方法的设计模式，编写了<code>HandlerMapping</code>的核心逻辑<code>getHandler()</code>方法，获取具体的<code>handler</code>由子类继承并实现<code>getHandlerInternal</code>方法，在获取到具体的<code>handler</code>之后，添加该请求匹配的拦截器列表，再返回<code>HandlerExecutionChain</code>结构，里面包含了具体的<code>handler</code>和拦截器列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法接口, 不同子类不同实现</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加匹配的拦截器</span></span><br><span class="line">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">        CorsConfiguration config = (<span class="keyword">this</span>.corsConfigurationSource != <span class="keyword">null</span> ? <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="keyword">null</span>);</span><br><span class="line">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">        config = (config != <span class="keyword">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里点一下初始化拦截器的方法。由于<code>AbstractHandlerMapping</code>间接继承于<code>ApplicationContextAware</code>接口，在<code>bean</code>初始化时会调用该接口进行<code>applicationContext</code>的赋值。而改方法中设置了一个模板方法接口，由具体子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationObjectSupport</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bean初始化时会调用这个接口(BeanPostProcessor)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2021/08/04 16:56:03</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">        <span class="comment">// Reset internal context state.</span></span><br><span class="line">        <span class="keyword">this</span>.applicationContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Initialize with passed-in context.</span></span><br><span class="line">        <span class="keyword">if</span> (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                    <span class="string">&quot;Invalid application context: needs to be of type [&quot;</span> + requiredContextClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = context;</span><br><span class="line">        <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">new</span> MessageSourceAccessor(context);</span><br><span class="line">        initApplicationContext(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Ignore reinitialization if same context passed in.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != context) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                    <span class="string">&quot;Cannot reinitialize with different application context: current one is [&quot;</span> +</span><br><span class="line">                    <span class="keyword">this</span>.applicationContext + <span class="string">&quot;], passed-in one is [&quot;</span> + context + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 扩展点, 由子类自行实现</span></span><br><span class="line">    initApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractHandlerMapping#initApplicationContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主要是初始化拦截器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Initializes the interceptors.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #extendInterceptors(java.util.List)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #initInterceptors()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 空实现。</span></span><br><span class="line">    <span class="comment">// 子类可重写此方法以注册额外的拦截器</span></span><br><span class="line">    extendInterceptors(<span class="keyword">this</span>.interceptors);</span><br><span class="line">    <span class="comment">// 从上下文中查询拦截器并添加到拦截器列表中</span></span><br><span class="line">    detectMappedInterceptors(<span class="keyword">this</span>.adaptedInterceptors);</span><br><span class="line">    <span class="comment">// 初始化拦截器</span></span><br><span class="line">    initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以下代码可以得出一个简单的结论，拦截器的作用范围实际上是在<code>Handler</code>执行的前后，而过滤器<code>Filter</code>作用的范围应该是在请求进入到<code>servlet</code>的前和执行完<code>servlet</code>逻辑之后，套在<code>springmvc</code>中，<code>Filter</code>的作用范围是在请求进入到<code>DispatcherServlet</code>之前和执行完<code>DispatcherServlet</code>之后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将自定义bean设置到适配拦截器中，bean需实现HandlerInterceptor或WebRequestInterceptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setInterceptors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #adaptInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.interceptors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.interceptors.size(); i++) &#123;</span><br><span class="line">            Object interceptor = <span class="keyword">this</span>.interceptors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Entry number &quot;</span> + i + <span class="string">&quot; in interceptors array is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-AbstractHandlerMethodMapping"><a href="#2-AbstractHandlerMethodMapping" class="headerlink" title="2. AbstractHandlerMethodMapping"></a>2. AbstractHandlerMethodMapping</h4><p>​    <code>AbstractHandlerMethodMapping</code>这个就是<code>RequestMappingHandlerMapping</code>的抽象顶层父类，这种映射方式就是我们日常开发的那种，将标记有<code>@Controller</code>的类中的每个标记有<code>@RequestMapping</code>的方法都抽象为一个对应的<code>HandlerMethod</code>。</p><p><strong>简单罗列一下使用到的类：</strong></p><ol><li><strong>HandlerMethod：</strong>在初始化<code>RequestMappingHandlerMapping</code>会将<code>spring</code>容器中标记有<code>@Controller</code>的类中的<code>@RequestMapping</code>的方法都封装为<code>HandlerMethod</code>实体，包含了<code>Handler</code>对应的方法以及<code>ControllerBean</code>，并提供一些访问参数、方法返回值、获取注解等方法。</li><li><strong>RequestMappingInfo：</strong>在<code>@Controller</code>类上标记的<code>@RequestMaping</code>或者是在方法上标记的<code>@RequestMapping</code>最终都会加载到<code>RequestMappingInfo</code>实体中。</li><li><strong>MappingRegistration：</strong>主要记录<code>RequestMappingInfo</code>与<code>HandlerMethod</code>关系</li><li><strong>MappingRegistry：</strong>一个注册表，它维护到处理程序方法的所有映射，公开执行查找的方法并提供并发访问。</li></ol><p><strong>AbstractHandlerMethodMapping</strong>分支的类图：</p><p><img src="https://i.loli.net/2021/08/17/fCx685RjaIJiYwK.png" alt="RequestMappingHandlerMapping类图.png"></p><p>图中红框中的三个类，分别依次继承，我们日常开发所使用的就是<code>RequestMappingHandlerMapping</code>。</p><h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h5><p>​    在<code>springbean</code>容器启动后，当初始化类<code>RequestMappingHandlerMapping</code>完成时，由于它间接实现了初始化的后置方法<code>InitializingBean</code>，所以会进入<code>afterPropertiesSet</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestMappingHandlerMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化RequestMappingInfo构建配置</span></span><br><span class="line">    <span class="keyword">this</span>.config = <span class="keyword">new</span> RequestMappingInfo.BuilderConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.config.setUrlPathHelper(getUrlPathHelper());</span><br><span class="line">    <span class="keyword">this</span>.config.setPathMatcher(getPathMatcher());</span><br><span class="line">    <span class="keyword">this</span>.config.setSuffixPatternMatch(useSuffixPatternMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setTrailingSlashMatch(useTrailingSlashMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法调用到父类的afterPropertiesSet, 从而调用到父类的initHandlerMethods方法(这个方法是完成映射的解析工作)</span></span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 后置初始化方法, 当这个Bean初始化完成之后调用, 获取容器中所有BeanDefinition</span></span><br><span class="line"><span class="comment"> * 中含有<span class="doctag">@RequestMapping</span>或者是<span class="doctag">@Controller</span>的Bean信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initHandlerMethods</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从容器中获取所有Bean的名称,默认只查找SpringMVC的IOC容器，不查找它的父容器Spring的IOC容器</span></span><br><span class="line">    <span class="comment">// 获取容器中所有Object.class类型的bean, 逐个遍历进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// 利用反射得到@ControllerBean中的Method并包装成HandlerMethod，然后放入注册表中</span></span><br><span class="line">            processCandidateBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCandidateBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 isHandler()方法由子类(RequestMappingHandlerMapping)实现，判断是否拥有 @Controller 注解或 @RequestMapping 注解</span></span><br><span class="line">    <span class="comment">// 这个isHandler()是个抽象接口, 由子类实现来控制是否进行接下来的注册。</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">        <span class="comment">// 利用反射得到@ControllerBean中的Method并包装成HandlerMethod，然后放入注册表中</span></span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来就是将具体的<code>@Controller</code>标记的类中的方法进行解析，满足条件的<code>method</code>封装为<code>HandlerMethod</code>后，添加到注册表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用反射得到 Bean 中的 Method 并包装成 HandlerMethod，然后放入 Map 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Look for handler methods in the specified handler bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据字符串获取到对应的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ? obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若是代理对象获取目标类型</span></span><br><span class="line">        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">        <span class="comment">// 收集要封装的接口信息, 键为method的引用, 值为RequestMethodInfo的引用</span></span><br><span class="line">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 根据 Method 和它的 @RequestMapping 注解，创建 RequestMappingInfo 对象。</span></span><br><span class="line">                        <span class="comment">// 这里的 T 就是 RequestMappingInfo，它封装了 @RequestMapping 信息</span></span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> + userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line">        methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">            Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">            <span class="comment">// 注册到mappingRegistry中</span></span><br><span class="line">            registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;Method, T&gt; <span class="title">selectMethods</span><span class="params">(Class&lt;?&gt; targetType, <span class="keyword">final</span> MetadataLookup&lt;T&gt; metadataLookup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集要封装的接口信息, 键为method的引用, 值为RequestMethodInfo的引用</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Method, T&gt; methodMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; handlerTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; specificHandlerType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非代理类</span></span><br><span class="line">    <span class="keyword">if</span> (!Proxy.isProxyClass(targetType)) &#123;</span><br><span class="line">        specificHandlerType = ClassUtils.getUserClass(targetType);</span><br><span class="line">        handlerTypes.add(specificHandlerType);</span><br><span class="line">    &#125;</span><br><span class="line">    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; currentHandlerType : handlerTypes) &#123;</span><br><span class="line">        <span class="comment">// specificHandlerType若为空表示其为代理类, 则取currentHandlerType</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetClass = (specificHandlerType != <span class="keyword">null</span> ? specificHandlerType : currentHandlerType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式接口: 遍历currentHandlerType的所有methods, 并执行第二个函数引用</span></span><br><span class="line">        ReflectionUtils.doWithMethods(currentHandlerType, method -&gt; &#123;</span><br><span class="line">            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line">            <span class="comment">// 获取@RequestMapping信息</span></span><br><span class="line">            T result = metadataLookup.inspect(specificMethod);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line">                <span class="keyword">if</span> (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    methodMap.put(specificMethod, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methodMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了两次的函数式接口，不同函数式接口可能看到这回有点吃力。第一个函数式接口的作用其实就是将某个<code>method</code>上标记的<code>@RequestMapping</code>信息和这个<code>method</code>所在类上标记的<code>@RequestMapping</code>信息拼接起来后包装为<code>RequestMappingInfo</code>后返回。第二个函数式接口的作用是将第一个函数式接口处理之后返回的<code>RequestMappingInfo</code>信息暂存到某个变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后将解析出来的所有RequestMappingInfo信息逐个遍历，通过调用以下方法，添加到注册表中。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Assert that the handler method is not a suspending one.</span></span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass())) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> ((parameterTypes.length &gt; <span class="number">0</span>) &amp;&amp; <span class="string">&quot;kotlin.coroutines.Continuation&quot;</span>.equals(parameterTypes[parameterTypes.length - <span class="number">1</span>].getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported suspending handler method detected: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化一个HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">        <span class="comment">// 校验是否已经存在这个handlerMethod</span></span><br><span class="line">        validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">        <span class="comment">// 添加到mappingLookup查找器中</span></span><br><span class="line">        <span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">        <span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">            addMappingName(name, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取跨域的配置</span></span><br><span class="line">        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">        <span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注册跨域配置</span></span><br><span class="line">            <span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * getHandlerInternal()方法是由AbstractHandlerMapping抽象类定义的模板方法，具体细节由</span></span><br><span class="line"><span class="comment"> * 子类实现，用于获取对应的HandlerMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前请求获取“查找路径”</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前请求最佳匹配的处理方法（即Controller类的方法中）</span></span><br><span class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体是通过该方法获取HandlerMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从MappingRegistry.urlLookup属性中，获取lookupPath对应的mapping集合</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取匹配的mapping，添加到matches列表</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配lookupPath的实例，则遍历所有的mapping，查找符合条件的mapping</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明存在符合条件的mapping</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 多个的情况</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//获取匹配条件的排序器，由抽象方法getMappingComparator()方法获取，该方法由子类实现</span></span><br><span class="line">          <span class="comment">// 这个排序规则也是个模板方法, 由子类实现, 由子类控制当出现多个匹配的mapping</span></span><br><span class="line">          <span class="comment">// 通过比较器排序后, 选择第一个为最匹配的mapping</span></span><br><span class="line">            Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">            matches.sort(comparator);</span><br><span class="line">            bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(matches.size() + <span class="string">&quot; matching mappings: &quot;</span> + matches);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                String uri = request.getRequestURI();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerMapping&quot;&gt;&lt;a href=&quot;#HandlerMapping&quot; class=&quot;headerlink&quot; title=&quot;HandlerMapping&quot;&gt;&lt;/a&gt;HandlerMapping&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerMapping&lt;/code&gt;处理器映射器，是&lt;code&gt;SpringMvc&lt;/code&gt;的核心组件之一，用来根据请求的&lt;code&gt;request&lt;/code&gt;信息查询对应的&lt;code&gt;Handler&lt;/code&gt;，在&lt;code&gt;web&lt;/code&gt;环境中，每个请求都需要一个对应的&lt;code&gt;Handler&lt;/code&gt;来处理，所以当接收到一个请求，需要哪一个&lt;code&gt;Handler&lt;/code&gt;来处理，&lt;code&gt;HandlerMapping&lt;/code&gt;的作用就是找到处理的那个&lt;code&gt;Handler&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>认识SpringMvc</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/09/SpringMvc/%E8%AE%A4%E8%AF%86SpringMvc/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/09/SpringMvc/%E8%AE%A4%E8%AF%86SpringMvc/</id>
    <published>2021-08-09T14:46:11.000Z</published>
    <updated>2021-08-23T14:53:31.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识SpringMvc"><a href="#认识SpringMvc" class="headerlink" title="认识SpringMvc"></a>认识SpringMvc</h3><h2 id="认识SpringMvc-1"><a href="#认识SpringMvc-1" class="headerlink" title="认识SpringMvc"></a>认识SpringMvc</h2><p>​    <code>SpringMvc</code>是基于<code>spring</code>在<code>web</code>领域进行开发的框架，使得业务开发者无需关心<code>Servlet</code>组件的逻辑处理，让业务开发者仅需要关心业务逻辑的处理。<span id="more"></span></p><p>​    由于在我较为整体的学习<code>SpringMvc</code>源码时，市面上已经比较倾向于前后端分离的开发模式，已经少有这种传统的<code>jsp</code>的模板结构的模式了。所以基本上只会记录从请求到前端控制器<code>DispatcherServlet</code>以及<code>HandlerMapping</code>、<code>HandlerAdapter</code>等的处理，并不会记录视图解析器等与视图相关内容。</p><!--more--><p><strong>以下先简单罗列后续会比较重点介绍的部分。</strong></p><ul><li><code>DispathcerServlet</code>：前端控制器，实际是它就是一个<code>servlet</code>。若你学过最原生的写法，不依赖于任何<code>mvc</code>框架，应该是继承一个<code>HttpServlet</code>后，重写它的<code>service</code>方法，然后再通过请求方式的不同等进行不同的路由跳转或者重定向等操作。实际上<code>DispatcherServlet</code>也以此为主要逻辑，它就是控制请求的分发。</li><li><code>Handler</code>：处理器(具体的业务逻辑)，在项目启动时会将<code>@Controller</code>中的一个个<code>@RequestMapping</code>方法都抽象为这个接口的结构。</li><li><code>HandlerMapping</code>：处理器映射器，当请求来临时，根据请求的<code>url</code>等结构，寻找具体的<code>Handler</code>。</li><li><code>HanderApdater</code>：处理器适配器，会将<code>Handler</code>包装为处理器适配器，从而支持多种类型的处理器，通过它根据适配的结构调用正在的处理器的业务逻辑方法，完成功能处理。</li></ul><h4 id="1-spring、springmvc、springboot间父子容器的问题？"><a href="#1-spring、springmvc、springboot间父子容器的问题？" class="headerlink" title="1. spring、springmvc、springboot间父子容器的问题？"></a>1. <strong>spring、springmvc、springboot间父子容器的问题？</strong></h4><p><strong>对于传统的<code>springmvc</code>项目而言，可以通过<code>web.xml</code>文件配置来配置</strong></p><ol><li><p>仅配置了<code>&lt;servlet&gt;</code>(<code>DispatcherServlet</code>)。这时在启动项目时，在对<code>DispatcherServlet</code>进行初始化时，调用父类<code>FrameworkServlet</code>的<code>initWebApplicationContext</code>方法，在该方法中的设置父容器，是获取不到<code>spring</code>容器的，所以这种情况下整个项目仅有<code>springmvc</code>容器。</p></li><li><p>若配置了<code>&lt;listener&gt;</code>(<code>ContextLoaderListener</code>)和<code>&lt;servlet&gt;</code>(<code>DispatcherServlet</code>)，这时项目启动时，先通过监听器加载<code>spring</code>容器，待完成<code>spring</code>容器加载后，才会通过<code>DispatcherServlet</code>进行<code>springmvc</code>容器的加载。(<strong>为什么在加载<code>spring</code>容器的过程中不会加载<code>DispatcherServlet</code>：</strong>这时<code>spring</code>并不会识别到<code>DispatcherServlet</code>)，在<code>springmvc</code>容器加载时，可以获取到<code>spring</code>容器，并设置为<code>springmvc</code>容器的父容器。</p></li><li><p>仅配置<code>&lt;listener&gt;</code>(<code>ContextLoaderListener</code>)，这种情况就没得说了，如果不加载<code>DispathcerServlet</code>那根本就不是<code>springmvc</code>项目。</p></li></ol><p><strong>注意：</strong>以上第二种情况，需特别注意若是使用中出现事务、或者<code>AOP</code>等处理，需保证父子容器中都有对应的处理。</p><p><strong><code>springboot</code>是如何处理<code>springmvc</code>中的父子容器问题？</strong></p><p>​    我认为<code>springmvc</code>的这种父子容器思想(子容器可以访问父容器，父容器不可访问子容器)，是可以有效的进行框架层级边界的划分，比如<code>service</code>层一般放在<code>spring</code>容器中，而<code>web</code>层(<code>controller/Action</code>)等放在<code>springmvc</code>容器中，所以如果需要跟换<code>web</code>层框架，比如将<code>springmvc</code>更换为<code>struct</code>，仅仅只需要将<code>spring-servlet.xml</code>文件替换为<code>struct</code>的配置文件即可。</p><p>​    在<code>springboot</code>中，并没有延续<code>springmvc</code>的这种父子容器思想，从设计结构来说，<code>DispatcherServlet</code>的父接口中有<code>ApplicationContextAware</code>接口，也就是说，如果在<code>spring</code>容器初始化过程中，将<code>DispatcherServlet</code>识别为<code>bean</code>，那么就会通过后置接口为<code>DispatcherServlet</code>设置容器，所以真正调用<code>DispatcherServlet</code>的初始化方法时，<code>this.webApplicationContext</code>已经通过后置接口赋值，就就不会重新创建一个新的容器，<code>springboot</code>就是通过这种方式，来控制整个上下文仅使用一个容器。</p><h4 id="2-springmvc和servlet之间的关系？"><a href="#2-springmvc和servlet之间的关系？" class="headerlink" title="2. springmvc和servlet之间的关系？"></a>2. springmvc和servlet之间的关系？</h4><p>​    <code>web</code>端开发实际上就是客户端和服务端进行交换数据，而交换数据的过程中不可避免的需要经过建立连接、传输数据、业务逻辑处理、返回数据、关闭连接的过程。而在日常开发过程中，业务开发者并不需要关心整个过程，业务开发者只需要关注业务逻辑处理这一环节。这是因为<code>tomcat</code>处理了这些动作。</p><p>在<code>springmvc</code>中，通过<code>web.xml</code>配置文件来配置<code>DispatcherServlet</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/spring/SpringMVC-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这里配置说明拦截了所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上<code>DispatcherServlet</code>就是一个<code>servlet</code>，这个配置文件配置了<code>DispathcerServlet</code>这个<code>Servlet</code>需要拦截的<code>url</code>地址，显然这个配置的是<code>/</code>，也就是入站的所有地址。也就是说当客户端发起请求时，先进入<code>tomcat</code>，由<code>tomcat</code>为其建立连接后将请求等信息传递给<code>DispatcherServlet</code>这个<code>servlet</code>。由这个<code>DispatcherServlet</code>来处理请求的分发，在<code>SpringMvc</code>中称它为前端控制器。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识SpringMvc&quot;&gt;&lt;a href=&quot;#认识SpringMvc&quot; class=&quot;headerlink&quot; title=&quot;认识SpringMvc&quot;&gt;&lt;/a&gt;认识SpringMvc&lt;/h3&gt;&lt;h2 id=&quot;认识SpringMvc-1&quot;&gt;&lt;a href=&quot;#认识SpringMvc-1&quot; class=&quot;headerlink&quot; title=&quot;认识SpringMvc&quot;&gt;&lt;/a&gt;认识SpringMvc&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;SpringMvc&lt;/code&gt;是基于&lt;code&gt;spring&lt;/code&gt;在&lt;code&gt;web&lt;/code&gt;领域进行开发的框架，使得业务开发者无需关心&lt;code&gt;Servlet&lt;/code&gt;组件的逻辑处理，让业务开发者仅需要关心业务逻辑的处理。</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactoryProcessor</title>
    <link href="http://xiaocainiaoya.github.io/2021/07/07/Spring/BeanFactoryProcessor/"/>
    <id>http://xiaocainiaoya.github.io/2021/07/07/Spring/BeanFactoryProcessor/</id>
    <published>2021-07-07T13:45:33.000Z</published>
    <updated>2021-08-23T14:55:54.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeanFactoryProcessor"><a href="#BeanFactoryProcessor" class="headerlink" title="BeanFactoryProcessor"></a>BeanFactoryProcessor</h1><p>​    <code>BeanFactoryPostProcessor</code>是<code>spring</code>中一个很重要的扩展点，它与<code>BeanPostProcessor</code>长相类似，触发点略有不同。<code>BeanFactoryPostProcessor</code>的作用时期是在所有<code>bean</code>实例化之前。所以它的作用是加载<code>BeanDefinition</code>。或者可以动态的修改或者是新增<code>BeanDefinition</code>。<span id="more"></span></p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><code>BeanFactoryPostProcessor</code>有一个扩展接口，这个扩展接口的方法会优先与<code>BeanFactoryPostProcessor</code>的方法执行。</p><p><img src="https://i.loli.net/2021/07/07/dU1jTIlg8Kr4YHs.png" alt="BeanFactoryPostProcessor类图.png"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>​    还是从<code>spring</code>的核心方法<code>refresh</code>入手。其中的<code>invokeBeanFactoryPostProcessors(beanFactory);</code>就是用来处理<code>BeanFactoryPostProcessor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// 准备刷新容器操作(设置一些状态位,监听器、事件器)</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// 实例化一个Bean工厂(DefaultListableBeanFactory)</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="comment">// 初始化BeanFactory, 进行一些属性的初始化赋值</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">        <span class="comment">// 空方法扩展点(springboot中有使用到)</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        <span class="comment">// 调用BeanFactoryPostProcessor ---&gt; (在这里执行!!!)</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">        <span class="comment">// 注册所有的BeanPostProcessor</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">        <span class="comment">// 国际化</span></span><br><span class="line">        initMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">        <span class="comment">// 初始化事件广播器</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">        <span class="comment">// 扩展点, 由子类实现</span></span><br><span class="line">        onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">        <span class="comment">// 注册事件监听器</span></span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        <span class="comment">// 实例化所有的非懒加载的单例对象</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        destroyBeans();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">        cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">        <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">        resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的处理方法在<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code>，源码处已有一些注释。这里简单描述一下整个流程。</p><p>第一步：参数中传递进来的 <code>beanFactoryPostProcessors</code>，由上述可知，这里可能是<code>BeanDefinitionRegistryPostProcessor</code>也可能是<code>BeanFactoryPostProcessor</code>的实现类。所以定义两个集合<code>regularPostProcessors</code>和<code>registryProcessors</code>用于将二者分离开。这里会执行参数中传递进来的<code>BeanDefinitionRegistryPostProcessor</code>类型的接口。(在<code>springboot</code>中，可以在启动类的启动方法中添加)</p><p>第二步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，挑选出包含实现了<code>PriorityOrdered</code>接口的类，根据特定的排序规则进行排序后逐一执行。(在默认的情况下，这里仅会获取到<code>ConfigurationClassPostProcessor</code>，这里类的作用是处理配置类，将配置类[也就是开发者标记<code>@Configuration</code>、<code>@Component</code>、<code>@ImportSelector</code>等等]添加到容器中。)</p><p>第三步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，挑选出包含实现了<code>Ordered</code>接口的类，过滤执行过<code>BeanDefinitionRegistryPostProcessor</code>(若某个接口同时实现<code>Ordered</code>和<code>PriorityOrdered</code>，则应该在第二步中执行)，根据特定的排序规则进行排序后逐一执行。</p><p>第四步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，过滤已经执行过的，将剩下未执行的所有类，根据特定的排序规则进行排序后逐一执行。(这里使用死循环的原因：可能出现套娃情况，某个<code>BeanDefinitionRegistryPostProcessor</code>的实现方法中又创建了一个新的<code>BeanDefinitionRegistryPostProcessor</code>。)</p><p><strong>以上便已经执行了容器中所有<code>BeanDefinitionRegistryPostProcessor</code>的扩展点。接下来就是执行<code>BeanFactoryPostPostProcessor</code>扩展点。</strong></p><p>第五步：执行上述所有步骤中的<code>BeanDefinitionRegistryPostProcessor</code>的<code>BeanFactoryPostProcessor</code>的实现接口。(就是扩展接口中的扩展方法已经都执行完了，在这个地方统一执行父接口中的实现方法。)</p><p>第六步：执行参数中传递进来的<code>beanFactoryPostProcessors</code>中仅实现<code>BeanFactoryPostProcessor</code>的实现接口。</p><p>第七步：(<code>BeanFactoryPostPostProcessor</code>的执行比较简单，用一步概括)，获取容器中所有实现了<code>BeanFactoryPostProcessor</code>的类，将它们分为三类<code>PriorityOrdered</code>、<code>Ordered</code>、和没有实现这两个接口的。然后分别根据排序规则进行排序后逐一执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行BeanFactoryPostProcessor扩展点</span></span><br><span class="line"><span class="comment"> * 1. 执行BeanDefinitionRegistryPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> * 1.1. 执行参数beanFactoryPostProcessors中是BeanDefinitionRegistryPostProcessor的实现类的扩展点</span></span><br><span class="line"><span class="comment"> * 1.2. 执行spring容器中的BeanDefinitionRegistryPostProcessor的实现且依次<span class="doctag">@PriorityOrdered</span>、<span class="doctag">@Ordered</span></span></span><br><span class="line"><span class="comment"> * 1.3. 执行容器中还存在BeanDefinitionRegistryPostProcessor实现但未加入已执行集合(registryProcessors)中的实现类</span></span><br><span class="line"><span class="comment"> *2. 执行BeanDefinitionPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> *2.1. 执行非直接实现BeanDefinitionRegistryPostProcessor集合(registryProcessors)的BeanFactoryPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> *2.2. 执行直接实现BeanFactoryPostProcessor集合(regularPostProcessors)的BeanFactoryPostProcessor的扩展点(这个集合中若存在</span></span><br><span class="line"><span class="comment"> *元素, 则是开发者通过调用参数携带进来, 在第一步骤执行是分离出来)</span></span><br><span class="line"><span class="comment"> *2.3. 执行spring容器中还未执行的BeanFactoryPostProcessor、顺序依次为<span class="doctag">@PriorityOrdered</span>、<span class="doctag">@Ordered</span>、最后是没有标记前者两注解的</span></span><br><span class="line"><span class="comment"> *BeanFactoryPostProcessor的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/09 10:05:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactoryPostProcessors 这个是自定义的beanFactoryPostProcessors, 默认是空的, 除非自己扩展</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line"><span class="comment">//处理过的BeanDefinitionRegistryPostProcessors类型的bean名字集合</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"><span class="comment">// 常规postProcessor(直接实现BeanFactoryPostProcessor的实现类)集合</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// registryProcessor(非直接实现BeanFactoryPostProcessor的实现类)且已经调用过扩展点的集合</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactoryPostProcessor是BeanDefinitionRegistryPostProcessor的父接口, 执行beanFactoryPostProcessors中的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">// 并将执行过后的BeanDefinitionRegistryPostProcessor放置在registryProcessors, 将未执行的BeanFactoryPostProcessor添加到regularPostProcessors</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"><span class="comment">// 调用BeanDefinitionRegistryPostProcessor扩展点</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 直接实现了BeanFactoryPostProcessor接口的实现</span></span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line"><span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line"><span class="comment">// 放内部的BeanDefinitionRegistryPostProcessor后置处理器</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 首先, 调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment">// (若没有改造或者二次开发过, 此处只会返回ConfigurationClassPostProcessor类</span></span><br><span class="line"><span class="comment">//  ConfigurationClassPostProcessor类的作用是加载配置类)</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 执行BeanDefinitionRegistryPostProcessors扩展点</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 其次, 调用仅实现了Ordered接口的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">// 过滤调用过的processedBean</span></span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 最后, 调用processedBeans中没有标记过的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment">// 这个while循环是由于可能出现套娃的情况: 比如A类实现了BeanDefinitionRegistryPostProcessor, 在调用A的</span></span><br><span class="line">    <span class="comment">//postProcessBeanDefinitionRegistry中又添加了一个BeanDefinitionRegistryPostProcessor类B。</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 不要在此处初始化 FactoryBeans：我们需要保留所有未初始化的常规bean，让 bean 工厂后处理器应用于它们！</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>​    从<code>spring</code>的生命周期看<code>BeanFactoryPostProcessor</code>的执行时机就是在<code>BeanPostProcessor</code>注册之前，甚至可以说是在大部分的<code>bean</code>注入之前。但若大量使用<code>BeanFactoryPostProcessor</code>进行扩展，若有重叠区域，则需考虑执行的先后顺序。比如后期的扩展是否需要控制新的<code>BeanFactoryPostProcessor</code>要在旧<code>BeanFactoryPostProcessor</code>之前或者之后？这个执行顺序是一个很容易忽略的<strong>关键点</strong>(自定义的<code>BeanFactoryPostProcessor</code>可以通过实现<code>Order</code>接口控制执行顺序)</p><p><strong>实例1</strong></p><p>​    可以通过<code>BeanDefinitionRegistryPostProcessor</code>修改<code>BeanDefinition</code>，比如在业务场景中有非常多的地方使用的是名称注入的方式，现要让这个名称注入容器中的类由新类，替换旧类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 替换class</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 获取扫描路径下的旧类 </span></span><br><span class="line">      BeanDefinition beanDefinition = registry.getBeanDefinition(<span class="string">&quot;roomService&quot;</span>);</span><br><span class="line">      <span class="comment">// 使其指向新类</span></span><br><span class="line">      beanDefinition.setBeanClassName(<span class="string">&quot;cn.com.xiaocainiaoya.service.NewRoomService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例2</strong></p><p>​    <code>springframwork</code>的扫描工作中比较核心的类<code>ConfigurationClassPostProcessor</code>，这个类的作用就是扫描配置类，扫描指定路径下的各种配置注解<code>@Configuration</code>、<code>Component</code>、<code>ComponentScan</code>等等。将这些类解析后添加到<code>BeanDefinition</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从注册表中的配置类派生进一步的 bean 定义。简单说根据BeanDefinition将配置类添加到spring容器中</span></span><br><span class="line"><span class="comment"> * 1. 完成扫描</span></span><br><span class="line"><span class="comment"> * 2. 对配置类的定义, 完成对配置类的标记</span></span><br><span class="line"><span class="comment"> * 3. 对import的处理</span></span><br><span class="line"><span class="comment"> * 3.1 ImportSelector(在springboot中自动装配典型使用)</span></span><br><span class="line"><span class="comment"> * 3.2 ImportBeanDefinitionRegistrar(在mybatis中典型使用)</span></span><br><span class="line"><span class="comment"> * 3.3 普通类</span></span><br><span class="line"><span class="comment"> * 3.3.1 没有任何特殊注解</span></span><br><span class="line"><span class="comment"> * 3.3.2 加了Import</span></span><br><span class="line"><span class="comment"> * 3.4 ImportResource</span></span><br><span class="line"><span class="comment"> * 4. <span class="doctag">@Bean</span>的处理</span></span><br><span class="line"><span class="comment"> * 5. 接口当中的<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> * 6. <span class="doctag">@PropertySource</span>的处理</span></span><br><span class="line"><span class="comment"> * 7. 内部类的处理</span></span><br><span class="line"><span class="comment"> * 8. 父类的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Derive further bean definitions from the configuration classes in the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 生成一个id，放置后面再重复执行</span></span><br><span class="line"><span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若重复执行  就抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此registry里的BeanDefinition收集动作，已经做了  避免再重复收集此registry</span></span><br><span class="line"><span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据配置类，收集到所有的bd信息,并且做出mark标注：是Full模式还是Lite模式</span></span><br><span class="line">processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>​    <code>BeanFactoryPostProcessor</code>算是<code>spring</code>给予开发者很高的权限去处理<code>BeanDefinitions</code>，但使用的过程中还需遵守<code>spring</code>的规范，不可将<code>bean</code>实例化，即不可在<code>BeanFactoryPostProcessor</code>中触发<code>bean</code>实例化的操作。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">// 这个getBeansOfType调用会触发getBean方法，会导致Bean提前注入，而在生命周期的这个节点</span></span><br><span class="line">      <span class="comment">// 自动注入的BeanPostProcessor还没有注入，还不会作用在bean的创建过程中，所以会导致</span></span><br><span class="line">      <span class="comment">// RoomService的属性注入会失效。</span></span><br><span class="line">      Map&lt;String, RoomService&gt; map = beanFactory.getBeansOfType(RoomService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以，在<code>BeanFactoryPostProcessor</code>的使用中切记要确保不会触发<code>Bean</code>的提前实例化。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BeanFactoryProcessor&quot;&gt;&lt;a href=&quot;#BeanFactoryProcessor&quot; class=&quot;headerlink&quot; title=&quot;BeanFactoryProcessor&quot;&gt;&lt;/a&gt;BeanFactoryProcessor&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;是&lt;code&gt;spring&lt;/code&gt;中一个很重要的扩展点，它与&lt;code&gt;BeanPostProcessor&lt;/code&gt;长相类似，触发点略有不同。&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的作用时期是在所有&lt;code&gt;bean&lt;/code&gt;实例化之前。所以它的作用是加载&lt;code&gt;BeanDefinition&lt;/code&gt;。或者可以动态的修改或者是新增&lt;code&gt;BeanDefinition&lt;/code&gt;。</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
</feed>
