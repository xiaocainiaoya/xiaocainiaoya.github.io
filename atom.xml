<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2025-09-18T02:47:18.778Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shardingsphere与mybatisflex冲突</title>
    <link href="http://xiaocainiaoya.github.io/2025/09/18/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shardingsphere%E4%B8%8Emybatisflex%E5%86%B2%E7%AA%81/"/>
    <id>http://xiaocainiaoya.github.io/2025/09/18/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shardingsphere%E4%B8%8Emybatisflex%E5%86%B2%E7%AA%81/</id>
    <published>2025-09-18T13:51:58.000Z</published>
    <updated>2025-09-18T02:47:18.778Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近在看shardingsphere分表相关实现，做了一个示例，将shardingsphere引入到之前一直用的以springboot3为基础的ruoyi-flex项目，引入之后，启动一直报一个错误。</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>Caused by: java.lang.NullPointerException: Properties <code>strategy</code> can not be null when uses class based sharding strategy.<br>    at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:1010)<br>    at org.apache.shardingsphere.sharding.algorithm.sharding.classbased.ClassBasedShardingAlgorithm.getStrategy(ClassBasedShardingAlgorithm.java:66)<br>    at org.apache.shardingsphere.sharding.algorithm.sharding.classbased.ClassBasedShardingAlgorithm.init(ClassBasedShardingAlgorithm.java:59)<br>    at org.apache.shardingsphere.infra.util.spi.type.typed.TypedSPIRegistry.findRegisteredService(TypedSPIRegistry.java:66)<br>    at org.apache.shardingsphere.infra.util.spi.type.typed.TypedSPIRegistry.getRegisteredService(TypedSPIRegistry.java:113)<br>    at org.apache.shardingsphere.infra.config.algorithm.ShardingSphereAlgorithmFactory.createAlgorithm(ShardingSphereAlgorithmFactory.java:40)<br>    at org.apache.shardingsphere.sharding.factory.ShardingAlgorithmFactory.newInstance(ShardingAlgorithmFactory.java:45)<br>    at org.apache.shardingsphere.sharding.rule.ShardingRule.lambda$new$0(ShardingRule.java:120)<br>    at java.base/java.util.LinkedHashMap.forEach(LinkedHashMap.java:986)<br>    at org.apache.shardingsphere.sharding.rule.ShardingRule.<init>(ShardingRule.java:120)<br>    at org.apache.shardingsphere.sharding.rule.builder.ShardingRuleBuilder.build(ShardingRuleBuilder.java:41)<br>    at org.apache.shardingsphere.sharding.rule.builder.ShardingRuleBuilder.build(ShardingRuleBuilder.java:35)<br>    at org.apache.shardingsphere.infra.rule.builder.database.DatabaseRulesBuilder.build(DatabaseRulesBuilder.java:58)<br>    at org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabase.create(ShardingSphereDatabase.java:87)<br>    at org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabasesFactory.createGenericDatabases(ShardingSphereDatabasesFactory.java:81)<br>    at org.apache.shardingsphere.infra.metadata.database.ShardingSphereDatabasesFactory.create(ShardingSphereDatabasesFactory.java:69)<br>    at org.apache.shardingsphere.mode.metadata.MetaDataContextsFactory.create(MetaDataContextsFactory.java:91)<br>    at org.apache.shardingsphere.mode.metadata.MetaDataContextsFactory.create(MetaDataContextsFactory.java:69)<br>    at org.apache.shardingsphere.mode.manager.standalone.StandaloneContextManagerBuilder.build(StandaloneContextManagerBuilder.java:49)<br>    at org.apache.shardingsphere.driver.jdbc.core.datasource.ShardingSphereDataSource.createContextManager(ShardingSphereDataSource.java:76)<br>    at org.apache.shardingsphere.driver.jdbc.core.datasource.ShardingSphereDataSource.<init>(ShardingSphereDataSource.java:64)<br>    at org.apache.shardingsphere.driver.api.ShardingSphereDataSourceFactory.createDataSource(ShardingSphereDataSourceFactory.java:93)<br>    at org.apache.shardingsphere.spring.boot.ShardingSphereAutoConfiguration.shardingSphereDataSource(ShardingSphereAutoConfiguration.java:91)<br>    at org.apache.shardingsphere.spring.boot.ShardingSphereAutoConfiguration$$SpringCGLIB$$0.CGLIB$shardingSphereDataSource$3(<generated>)<br>    at org.apache.shardingsphere.spring.boot.ShardingSphereAutoConfiguration$$SpringCGLIB$$FastClass$$1.invoke(<generated>)<br>    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:258)<br>    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:331)<br>    at org.apache.shardingsphere.spring.boot.ShardingSphereAutoConfiguration$$SpringCGLIB$$0.shardingSphereDataSource(<generated>)<br>    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)<br>    at java.base/java.lang.reflect.Method.invoke(Method.java:580)<br>    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:140)<br>    … 44 common frames omitted</p></blockquote><p>断点打在报错点之后，向上跟踪堆栈后发现，是由于创建<code>shardingsphereDataSource</code>时取用的<code>ruleConfiguration</code>中无法获取到strategy。从断点可知，几乎所有字段都是空值。</p><p><img src="https://s2.loli.net/2025/09/18/qD5chBotZEkHdva.png" alt="shardingsphere.png"></p><p>所以近一步就去排查为什么参数<code>ObjectProvider&lt;List&lt;RuleConfiguration&gt;&gt; rules</code>里的这些参数为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional(LocalRulesCondition.class)</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">shardingSphereDataSource</span><span class="params">(<span class="keyword">final</span> ObjectProvider&lt;List&lt;RuleConfiguration&gt;&gt; rules, <span class="keyword">final</span> ObjectProvider&lt;ModeConfiguration&gt; modeConfig)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Collection&lt;RuleConfiguration&gt; ruleConfigs = Optional.ofNullable(rules.getIfAvailable()).orElseGet(Collections::emptyList);</span><br><span class="line">    <span class="keyword">return</span> ShardingSphereDataSourceFactory.createDataSource(databaseName, modeConfig.getIfAvailable(), dataSourceMap, ruleConfigs, props.getProps());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪<code>shardingsphereDataSource</code>的bean创建流程，发现这块确实的数据是通过注入对象<code>shardingRuleConfiguration</code>中获得，所以再次跟踪<code>shardingRuleConfiguration</code>的bean创建流程。</p><p>它的初始化方法在：<code>ShardingRuleSpringBootConfiguration</code>配置类中，这里通过<code>ObjectProvider</code>注入了<code>Map&lt;String, ShardingAlgorithm&gt;</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RuleConfiguration <span class="title">shardingRuleConfiguration</span><span class="params">(<span class="keyword">final</span> ObjectProvider&lt;Map&lt;String, ShardingAlgorithm&gt;&gt; shardingAlgorithmProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">final</span> ObjectProvider&lt;Map&lt;String, KeyGenerateAlgorithm&gt;&gt; keyGenerateAlgorithmProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">final</span> ObjectProvider&lt;Map&lt;String, ShardingAuditAlgorithm&gt;&gt; shardingAuditAlgorithmProvider)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, ShardingAlgorithm&gt; shardingAlgorithmMap = Optional.ofNullable(shardingAlgorithmProvider.getIfAvailable()).orElse(Collections.emptyMap());</span><br><span class="line">    Map&lt;String, KeyGenerateAlgorithm&gt; keyGenerateAlgorithmMap = Optional.ofNullable(keyGenerateAlgorithmProvider.getIfAvailable()).orElse(Collections.emptyMap());</span><br><span class="line">    Map&lt;String, ShardingAuditAlgorithm&gt; shardingAuditAlgorithmMap = Optional.ofNullable(shardingAuditAlgorithmProvider.getIfAvailable()).orElse(Collections.emptyMap());</span><br><span class="line">    AlgorithmProvidedShardingRuleConfiguration result = swapper.swapToObject(yamlConfig.getSharding());</span><br><span class="line">    result.setShardingAlgorithms(shardingAlgorithmMap);</span><br><span class="line">    result.setKeyGenerators(keyGenerateAlgorithmMap);</span><br><span class="line">    result.setAuditors(shardingAuditAlgorithmMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>org.springframework.beans.factory.ObjectProvider</code> 是 Spring 框架提供的一个功能接口，主要用于<strong>依赖注入时的灵活获取 Bean</strong>，它是对传统 <code>BeanFactory.getBean()</code> 方法的增强，提供了更安全、更便捷的 Bean 查找和注入方式。如果获取不到，它会返回null，不会抛异常<strong>NoSuchBeanDefinitionException</strong></p></blockquote><p>进入<code>shardingAlgorithmProvider.getIfAvailable()</code>方法，实际上它也是springbean的创建流程，它尝试获取在spring容器中的<code>ShardingAlgorithm</code>的实现类，通过断点跟踪发现，这里从容器中获取到的<code>shardingAlgorithm</code>对象的相关参数就是空的。</p><p>到这里，简单复个盘：</p><p>报错的原因是创建<code>shardingsphereDataSource</code>时，其中的<code>algorithm</code>相关参数为空&rarr; 跟踪<code>shardingRuleConfiguration</code>，发现是从<code>ObjectProvider&lt;Map&lt;String, ShardingAlgorithm&gt;&gt;</code>来的 &rarr;跟踪<code>shardingAlgorithmProvider.getIfAvailable()</code>发现，这时从容器中获取到的<code>ShardingAlgorithm</code>实现就是空的。</p><p>所以现在就变成了新的问题：为什么从容器中获取到的<code>ShardingAlgorithm</code>对象，值都是空的？</p><p>创建一个新的工程，不包含<code>mybatis-flex</code>，观察<code>ShardingAlgorithm</code>的创建流程，通过跟踪发现，<code>ShardingAlgorithm</code>对象的值的填充时机，是在后置接口<code>ShardingAlgorithmProvidedBeanRegistry</code>中，当<code>ShardingAlgorithmProvidedBeanRegistry</code>后置接口方法触发时，才会将相关配置项的值填充到<code>ShardingAlgorithm</code>对象中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(<span class="keyword">final</span> String prefix, <span class="keyword">final</span> Class&lt;T&gt; algorithmClass, <span class="keyword">final</span> BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PropertyUtil.containPropertyPrefix(environment, prefix)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; parameterMap = PropertyUtil.handle(environment, prefix, Map.class);</span><br><span class="line">    Collection&lt;String&gt; algorithmNames = parameterMap.keySet().stream().map(key -&gt; key.contains(POINT) ? key.substring(<span class="number">0</span>, key.indexOf(POINT)) : key).collect(Collectors.toSet());</span><br><span class="line">    Map&lt;String, AlgorithmConfiguration&gt; algorithmConfigs = createAlgorithmConfigurations(prefix, algorithmNames);</span><br><span class="line">    ShardingSphereServiceLoader.register(algorithmClass);</span><br><span class="line">    <span class="comment">// 把相关配置项填充到当前对象中</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, AlgorithmConfiguration&gt; entry : algorithmConfigs.entrySet()) &#123;</span><br><span class="line">        AlgorithmConfiguration algorithmConfig = entry.getValue();</span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(ShardingSphereAlgorithmFactory.createAlgorithm(algorithmConfig, algorithmClass).getClass());</span><br><span class="line">        registry.registerBeanDefinition(entry.getKey(), builder.getBeanDefinition());</span><br><span class="line">        propsMap.put(entry.getKey(), algorithmConfig.getProps());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以跟踪原工程的<code>PostProcessorRegistrationDelegate</code>类，观察后置处理接口的执行情况，果然发现了一个不一样的后置处理器<code>JobRegistryBeanPostProcessor</code>，这个后置处理器在<code>ShardingAlgorithmProvidedBeanRegistry</code>之前，也就是说，一个bean会先经过<code>job</code>的这个后置处理，再经过<code>shardingAlgorithm</code>后置处理器。</p><p>继续跟踪<code>JobRegistryBeanPostProcessor</code>，在注册<code>JobRegistryBeanPostProcessor</code>置后置处理器列表中时，触发了它的初始化类<code>BatchAutoConfiguration#SpringBootBatchConfiguration</code>，而它的参数中包含了<code>DataSource dataSource</code>。</p><p>综上：因为<code>JobRegistryBeanPostProcessor</code>比<code>ShardingAlgorithmProvidedBeanRegistry</code>在后置处理器列表靠前，导致<code>JobRegistryBeanPostProcessor</code>先进入初始化流程，而它需要<code>dataSource</code>，则进入了<code>dataSource</code>的初始化流程，而<code>dataSource</code>的初始化会触发到<code>shardingsphereDataSource</code>初始化，而<code>shardingsphereDataSource</code>初始化会获取<code>ShardingAlgorithm</code>，这时因为<code>ShardingAlgorithmProvidedBeanRegistry</code>还没执行，导致相关值还没填充，导致报错。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>查询相关文档发现，官方貌似也发现存在这个问题，<code>JobRegistryBeanPostProcessor</code>注入的时机过早会导致一些问题，所以官方注明了替代方案<code>JobRegistrySmartInitializingSingleton</code></p><p>但是在工程里，<code>JobRegistryBeanPostProcessor</code>是在<code>spring-batch-core</code>包中的类<code>DefaultBatchConfiguration</code>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobRegistryBeanPostProcessor <span class="title">jobRegistryBeanPostProcessor</span><span class="params">()</span> <span class="keyword">throws</span> BatchConfigurationException </span>&#123;</span><br><span class="line">JobRegistryBeanPostProcessor jobRegistryBeanPostProcessor = <span class="keyword">new</span> JobRegistryBeanPostProcessor();</span><br><span class="line">jobRegistryBeanPostProcessor.setJobRegistry(jobRegistry());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">jobRegistryBeanPostProcessor.afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> jobRegistryBeanPostProcessor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BatchConfigurationException(<span class="string">&quot;Unable to configure the default job registry BeanPostProcessor&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，解决方案就是覆盖这个类，并对这部分代码注释，不声明<code>JobRegistryBeanPostProcessor</code>这个bean，同事声明替代方案<code>JobRegistrySmartInitializingSingleton</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注册JobRegistrySmartInitializingSingleton（关键：不使用JobRegistryBeanPostProcessor）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobRegistrySmartInitializingSingleton <span class="title">jobRegistrySmartInitializingSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化并设置参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JobRegistrySmartInitializingSingleton(jobRegistry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近在看shardingsphere分表相关实现，做了一个示例，将shardingsphere引入到之前一直用的以springboot3为基础的ruoyi-flex项目，引入之后，启动一直报一个错误。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>springboot3的aot实践</title>
    <link href="http://xiaocainiaoya.github.io/2025/09/12/Springboot/springboot3%E7%9A%84aot%E5%AE%9E%E8%B7%B5/"/>
    <id>http://xiaocainiaoya.github.io/2025/09/12/Springboot/springboot3%E7%9A%84aot%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-09-12T13:51:58.000Z</published>
    <updated>2025-09-12T06:17:09.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot3的aot实践"><a href="#springboot3的aot实践" class="headerlink" title="springboot3的aot实践"></a>springboot3的aot实践</h1><blockquote><p>AOT 如何进行优化</p></blockquote><p>AOT（Ahead-Of-Time）优化是从Spring Framework 6开始引入的一个新特性，用于提升应用的启动性能和运行时效率。</p><p>可以简单理解为 ：在编译阶段就把以往一些运行时的数据编译成静态代码，减少运行时开销，从而加快启动速度并降低内存使用。<span id="more"></span></p><p><strong>比如核心功能有：</strong></p><ul><li><strong>Bean 定义预解析</strong>：编译期解析 <code>@Configuration</code> 类、<code>@Bean</code> 方法，生成静态化的 Bean 定义元数据，避免运行时扫描。</li><li><strong>条件注解预处理</strong>：提前评估 <code>@Conditional</code> 条件是否生效，直接生成符合条件的配置，减少运行时判断。</li><li><strong>反射元数据生成</strong>：自动识别需要反射访问的类 / 方法，生成 <code>reflect-config.json</code> 等文件，供 GraalVM 原生编译使用。（当需要将引用编译为原生镜像时，AOT与GraalVM深度绑定，但若不需要编译为原生镜像，可以不使用GraalVM，仅仅使用AOT也可能有一定启动时间的提升）</li><li><strong>资源访问优化</strong>：提前收集应用所需的资源文件（如 <code>application.properties</code>），生成资源索引，避免运行时遍历目录。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>我在实践的时候不是新建一个空白工程，是直接使用gitee的ruoyi-flex的<code>https://gitee.com/dataprince/ruoyi-flex</code>。</p><p>这个工程已经是springboot3的版本，它的配置上没有使用aot相关配置，或者说部分配置没有配置为aot编译可运行状态。</p><p>1.顶层POM里要声明说用的打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-compiler-plugin.verison&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.therapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>therapi-runtime-javadoc-scribe<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;therapi-runtime-javadoc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.linpeilie<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-plus-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-mapstruct-binding<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapstruct-plus.lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mybatis-flex<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-flex-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-flex.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arg</span>&gt;</span>-parameters<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.主引用需要使用到<code>spring-boot-maven-plugin</code>打包插件(这个process-aot可以不配，通过使用mvn命令启动aot)，AOT主要是作用在主应用上，所以在主应用打包为AOT前，其他子模块都需要打包完成（普通jar包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process-aot<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.比如这个工程内还有一些其他模块（ruoyi-common，ruoyi-extra，ruoyi-modules），这些模块要能打成普通jar包，所以这里对这三个大模块的POM设置跳过<code>spring-boot-maven-plugin</code>打包（因为顶层的POM里设置了<code>maven-compiler-plugin</code>插件，所以当跳过spring-boot打包插件，那么打出的包就是普通jar包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.打包命令</p><p>有的地方的教使用<code>spring-boot:process-aot</code>，但是我自己测试，命令会报错。</p><p>以下是我添加到jenkins中构建的命令，执行过程依次为：</p><p>清理 -》各个模块打包 -》打到本地仓库 -》使用springboot3的aot打包</p><blockquote><p>mvn clean package  install org.springframework.boot:spring-boot-maven-plugin:3.2.5:process-aot</p></blockquote><p>最终打包出来的包里就会有很对静态编译的内容，并且模块代码都被打入结果包中：</p><p>左侧为不使用AOT打包，右侧为使用AOT打包。</p><p><img src="https://s2.loli.net/2025/09/12/rgEXSVAYs9QCGwk.png" alt="image-20250912112459443.png"></p><p>如果是本地使用IDEA打包，可以使用右侧maven图标-》主引用模块下 -》Plugins -》spring-boot -》spring-boot:process-aot</p><p>注：这个工程有使用到BOM(版本清单)，我自己在测试的时候，是对这个BOM模块install到本地仓库</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot3的aot实践&quot;&gt;&lt;a href=&quot;#springboot3的aot实践&quot; class=&quot;headerlink&quot; title=&quot;springboot3的aot实践&quot;&gt;&lt;/a&gt;springboot3的aot实践&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;AOT 如何进行优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AOT（Ahead-Of-Time）优化是从Spring Framework 6开始引入的一个新特性，用于提升应用的启动性能和运行时效率。&lt;/p&gt;
&lt;p&gt;可以简单理解为 ：在编译阶段就把以往一些运行时的数据编译成静态代码，减少运行时开销，从而加快启动速度并降低内存使用。</summary>
    
    
    
    <category term="springboot3" scheme="http://xiaocainiaoya.github.io/categories/springboot3/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springboot3" scheme="http://xiaocainiaoya.github.io/tags/springboot3/"/>
    
  </entry>
  
  <entry>
    <title>shardingsphere初识</title>
    <link href="http://xiaocainiaoya.github.io/2025/09/02/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shardingsphere/"/>
    <id>http://xiaocainiaoya.github.io/2025/09/02/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shardingsphere/</id>
    <published>2025-09-02T06:13:58.000Z</published>
    <updated>2025-09-12T06:18:02.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shardingsphere"><a href="#shardingsphere" class="headerlink" title="shardingsphere"></a>shardingsphere</h1><p>[TOC]</p><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><blockquote><p>Springboot 3.2.5+ mybatis-flex 1.9.4 + jdk21+ shardingsphere-jdbc-core-spring-boot-starter(5.2.1)</p></blockquote><h2 id="2-引入maven依赖"><a href="#2-引入maven依赖" class="headerlink" title="2. 引入maven依赖"></a>2. 引入maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="3-设置分片配置"><a href="#3-设置分片配置" class="headerlink" title="3. 设置分片配置"></a>3. 设置分片配置</h2><ul><li><p>application-dev.yml：引入application-sharding.yml配置文件，并屏蔽mybatis-flex的数据源设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">classpath:application-sharding.yml</span>  <span class="comment"># 引入ShardingSphere分片配置</span></span><br></pre></td></tr></table></figure></li><li><p>application-sharding.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds1</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://192.168.8.1:10086/ruoyi-flex?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8&amp;autoReconnect=true&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">          <span class="attr">minimum-idle:</span> <span class="string">$&#123;spring.datasource.hikari.minimum-idle&#125;</span></span><br><span class="line">          <span class="attr">maximum-pool-size:</span> <span class="string">$&#123;spring.datasource.hikari.maximum-pool-size&#125;</span></span><br><span class="line">          <span class="attr">connection-timeout:</span> <span class="string">$&#123;spring.datasource.hikari.connectionTimeout&#125;</span></span><br><span class="line">          <span class="attr">idle-timeout:</span> <span class="string">$&#123;spring.datasource.hikari.idleTimeout&#125;</span></span><br><span class="line">          <span class="attr">max-lifetime:</span> <span class="string">$&#123;spring.datasource.hikari.maxLifetime&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分片规则配置</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">sharding:</span></span><br><span class="line">        <span class="comment"># 分片表配置</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">version_code_change_record:</span></span><br><span class="line">            <span class="comment"># 实际数据节点 - 3张分片表：00、01、02</span></span><br><span class="line">            <span class="attr">actual-data-nodes:</span> <span class="string">ds1.version_code_change_record0$-&gt;&#123;0..2&#125;</span></span><br><span class="line">            <span class="comment"># 分表策略</span></span><br><span class="line">            <span class="attr">table-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">version_id</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">version-id-mod-algorithm</span></span><br><span class="line">            <span class="comment"># 主键生成策略</span></span><br><span class="line">            <span class="attr">key-generate-strategy:</span></span><br><span class="line">              <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">              <span class="attr">key-generator-name:</span> <span class="string">snowflake</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分片算法配置</span></span><br><span class="line">        <span class="attr">sharding-algorithms:</span></span><br><span class="line">          <span class="attr">version-id-mod-algorithm:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">MOD</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">sharding-count:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主键生成算法配置</span></span><br><span class="line">        <span class="attr">key-generators:</span></span><br><span class="line">          <span class="attr">snowflake:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">worker-id:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 属性配置</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="comment"># 是否开启SQL显示，建议开发环境开启，生产环境关闭</span></span><br><span class="line">      <span class="attr">sql-show:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">sql-simple:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 是否检查表元数据，生产环境建议关闭以提升启动性能</span></span><br><span class="line">      <span class="attr">check-table-metadata-enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 是否检查重复表，开发阶段开启</span></span><br><span class="line">      <span class="attr">check-duplicate-table-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="4-自定义分片算法"><a href="#4-自定义分片算法" class="headerlink" title="4.自定义分片算法"></a>4.自定义分片算法</h2><p>一般采用基因法对分片键进行一定的”潜规则“设置，使得某一类型的数据能到达统一固定分片上，比如如果用订单表的用户id做分片键，对用户id做基因法操作，使得这个用户的所有订单都到达同一个分片。</p><p>再通过分片查询逻辑实现<code>ComplexKeysShardingAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenComplexTableAlgorithm</span> <span class="keyword">implements</span> <span class="title">ComplexKeysShardingAlgorithm</span>&lt;<span class="title">Comparable</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String VERSION_ID = <span class="string">&quot;version_id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String VERSION_FLOW_NUM = <span class="string">&quot;version_flow_num&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> shardingCount = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ComplexKeysShardingValue&lt;Comparable&lt;?&gt;&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Collection&lt;Comparable&lt;?&gt;&gt;&gt; columnNameAndShardingValuesMap = shardingValue.getColumnNameAndShardingValuesMap();</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(availableTargetNames.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(MapUtils.isNotEmpty(columnNameAndShardingValuesMap))&#123;</span><br><span class="line">            <span class="comment">// 获取用户ID</span></span><br><span class="line">            Collection&lt;Comparable&lt;?&gt;&gt; versionIdCollection = columnNameAndShardingValuesMap.get(VERSION_ID);</span><br><span class="line">            <span class="comment">//用户分片</span></span><br><span class="line">            <span class="keyword">if</span>(CollectionUtils.isNotEmpty(versionIdCollection))&#123;</span><br><span class="line">                versionIdCollection.stream().findFirst().ifPresent(comparable -&gt; &#123;</span><br><span class="line">                    <span class="keyword">long</span> tableNameSuffix = (Long) comparable % shardingCount;</span><br><span class="line">                    result.add(shardingValue.getLogicTableName() + <span class="string">&quot;_&quot;</span> + tableNameSuffix);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Collection&lt;Comparable&lt;?&gt;&gt; orderSnCollection = columnNameAndShardingValuesMap.get(VERSION_FLOW_NUM);</span><br><span class="line">                orderSnCollection.stream().findFirst().ifPresent(comparable -&gt; &#123;</span><br><span class="line">                    String orderSn = String.valueOf(comparable);</span><br><span class="line">                    <span class="comment">//获取用户基因</span></span><br><span class="line">                    String substring = orderSn.substring(Math.max(<span class="number">0</span>, orderSn.length() - <span class="number">6</span>));</span><br><span class="line">                    <span class="keyword">long</span> tableNameSuffix = Long.parseLong(substring) % shardingCount;</span><br><span class="line">                    result.add(shardingValue.getLogicTableName() + <span class="string">&quot;_&quot;</span> + tableNameSuffix);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.props = props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><ul><li><p>所有 ShardingSphere 配置都嵌套在该节点下，包含三大核心模块：datasources（数据源）、rules（功能规则）、props（全局属性）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line"><span class="attr">props:</span></span><br></pre></td></tr></table></figure></li><li><p>rules：功能规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">rules:</span> <span class="comment"># 功能规则</span></span><br><span class="line"><span class="attr">sharding:</span></span><br><span class="line">        <span class="comment"># 分片表配置</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">version_code_change_record:</span> <span class="comment"># 要分片的表名</span></span><br><span class="line">        <span class="attr">actual-data-node:</span> <span class="string">ds1.version_code_change_record0$-&gt;&#123;0..2&#125;</span> <span class="comment"># 实际的数据节点</span></span><br><span class="line">        <span class="attr">database-strategy:</span> <span class="comment"># 分库策略</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">table-strategy:</span> <span class="comment"># 分表策略</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><ul><li><p>标准策略：<code>standard</code>：基于单一字段（分片键）进行分片，是最常用的策略。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tables:</span></span><br><span class="line">  <span class="attr">t_order:</span></span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">ds0.t_order_$&#123;0..1&#125;,</span> <span class="string">ds1.t_order_$&#123;0..1&#125;</span>  <span class="comment"># 物理表分布</span></span><br><span class="line">    <span class="attr">table-strategy:</span></span><br><span class="line">      <span class="attr">standard:</span>  <span class="comment"># 标准策略</span></span><br><span class="line">        <span class="attr">sharding-column:</span> <span class="string">order_id</span>  <span class="comment"># 分片键：订单ID</span></span><br><span class="line">        <span class="attr">sharding-algorithm-name:</span> <span class="string">order_table_inline</span>  <span class="comment"># 关联算法</span></span><br><span class="line"><span class="attr">sharding-algorithms:</span></span><br><span class="line">  <span class="attr">order_table_inline:</span>  <span class="comment"># 算法定义</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">INLINE</span>  <span class="comment"># 内联表达式算法</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">algorithm-expression:</span> <span class="string">t_order_$&#123;order_id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span>  <span class="comment"># 计算逻辑：order_id取模2</span></span><br></pre></td></tr></table></figure></li><li><p>复合策略：<code>complex</code>：基于<strong>多个字段联合分片</strong>（如同时按 <code>user_id</code> 和 <code>order_id</code> 分片），适合复杂业务场景。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tables:</span></span><br><span class="line">  <span class="attr">t_order:</span></span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">ds0.t_order_$&#123;0..3&#125;,</span> <span class="string">ds1.t_order_$&#123;0..3&#125;</span>  <span class="comment"># 4个物理表</span></span><br><span class="line">    <span class="attr">table-strategy:</span></span><br><span class="line">      <span class="attr">complex:</span>  <span class="comment"># 复合策略</span></span><br><span class="line">        <span class="attr">sharding-columns:</span> <span class="string">user_id,order_id</span>  <span class="comment"># 多个分片键</span></span><br><span class="line">        <span class="attr">sharding-algorithm-name:</span> <span class="string">order_table_complex</span>  <span class="comment"># 关联复合算法</span></span><br><span class="line"><span class="attr">sharding-algorithms:</span></span><br><span class="line">  <span class="attr">order_table_complex:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">CLASS_BASED</span>  <span class="comment"># 基于自定义类的算法</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">strategy:</span> <span class="string">STANDARD</span></span><br><span class="line">      <span class="attr">algorithm-class-name:</span> <span class="string">com.example.sharding.OrderTableComplexAlgorithm</span>  <span class="comment"># 自定义算法类</span></span><br></pre></td></tr></table></figure></li><li><p>hint策略：<code>hint</code>：不依赖 SQL 中的字段，而是通过<strong>代码手动指定分片值</strong>（如强制路由到某个物理表）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tables:</span></span><br><span class="line">  <span class="attr">t_order:</span></span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">ds0.t_order_$&#123;0..1&#125;</span></span><br><span class="line">    <span class="attr">table-strategy:</span></span><br><span class="line">      <span class="attr">hint:</span>  <span class="comment"># Hint策略</span></span><br><span class="line">        <span class="attr">sharding-algorithm-name:</span> <span class="string">order_table_hint</span>  <span class="comment"># 关联Hint算法</span></span><br><span class="line"><span class="attr">sharding-algorithms:</span></span><br><span class="line">  <span class="attr">order_table_hint:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">HINT_INLINE</span>  <span class="comment"># Hint内联算法</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">algorithm-expression:</span> <span class="string">t_order_$&#123;value&#125;</span>  <span class="comment"># value由代码传入</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动指定分片值为0，路由到t_order_0</span></span><br><span class="line">HintManager hintManager = HintManager.getInstance();</span><br><span class="line">hintManager.addTableShardingValue(<span class="string">&quot;t_order&quot;</span>, <span class="number">0</span>);  <span class="comment">// 指定逻辑表和分片值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行SQL时，ShardingSphere会根据Hint值路由</span></span><br><span class="line">Order order = orderMapper.selectById(<span class="number">1001L</span>);</span><br><span class="line">hintManager.close();  <span class="comment">// 用完关闭</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>内联策略：<code>inline</code></p></li><li><p>不分片策略：<code>none</code></p></li></ul></li></ul><h2 id="5-遇到的问题"><a href="#5-遇到的问题" class="headerlink" title="5. 遇到的问题"></a>5. 遇到的问题</h2><ol><li><p>如果工程中没有使用<code>@MapperScan</code>，若使用<code>@MapperScan</code>需制定到具体的<code>mapper</code>实现(<code>com.ruoyi.**.mapper</code>)，否则会出现某个类被多次扫描，多次生成bean实例。</p></li><li><p><code>snakeyaml</code>版本不兼容问题</p></li></ol><p><code>shardingsphere-jdbc-core-spring-boot-starter 5.2.1</code>版本与<code>snakeyaml 3.2</code>不兼容，需要使用<code>snakeyaml 1.33</code>，但<code>snakeyaml 1.33</code>与<code>springboot 3.2.5</code>不兼容。</p><p>所以，强行使用<code>snakeyaml 1.33</code>，并覆盖<code>TagInspector</code>、<code>UnTrustedTagInspector</code>、<code>LoaderOptions</code>三个类。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;shardingsphere&quot;&gt;&lt;a href=&quot;#shardingsphere&quot; class=&quot;headerlink&quot; title=&quot;shardingsphere&quot;&gt;&lt;/a&gt;shardingsphere&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1. 环境&quot;&gt;&lt;/a&gt;1. 环境&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Springboot 3.2.5+ mybatis-flex 1.9.4 + jdk21+ shardingsphere-jdbc-core-spring-boot-starter(5.2.1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-引入maven依赖&quot;&gt;&lt;a href=&quot;#2-引入maven依赖&quot; class=&quot;headerlink&quot; title=&quot;2. 引入maven依赖&quot;&gt;&lt;/a&gt;2. 引入maven依赖&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.shardingsphere&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;shardingsphere-jdbc-core-spring-boot-starter&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.2.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="shardingsphere" scheme="http://xiaocainiaoya.github.io/categories/shardingsphere/"/>
    
    
    <category term="shardingsphere" scheme="http://xiaocainiaoya.github.io/tags/shardingsphere/"/>
    
    <category term="分表" scheme="http://xiaocainiaoya.github.io/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>dubbo的Spi机制</title>
    <link href="http://xiaocainiaoya.github.io/2024/09/21/Springboot/dubbo%E7%9A%84spi%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2024/09/21/Springboot/dubbo%E7%9A%84spi%E6%9C%BA%E5%88%B6/</id>
    <published>2024-09-21T06:13:58.000Z</published>
    <updated>2024-09-26T11:14:35.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dubbo的Spi机制"><a href="#dubbo的Spi机制" class="headerlink" title="dubbo的Spi机制"></a>dubbo的Spi机制</h1><p>结合之前说到的<a href="https://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/" target="_blank">springboot的Spi机制</a>本篇将简单介绍一下<code>Doubbo</code>的SPI机制，<code>Dobbo</code>没有使用<code>jdk</code>的这套<code>SPI</code>机制，而是自己实现了一套，提供了一些更灵活、更易于使用的方式。</p><span id="more"></span><p>​    简单回顾下，SPI全称（Service Provider Interface）是一种服务发现机制，本质上是将接口的实现类的全限定类名写在配置文件中，并由类加载器读取配置文件，这样可以在运行时，动态为接口替换实现类，所以一般用这种方式来为服务提供扩展能力。</p><h2 id="JDK的服务发现spi机制"><a href="#JDK的服务发现spi机制" class="headerlink" title="JDK的服务发现spi机制"></a>JDK的服务发现spi机制</h2><p>JDK 的 SPI 规范规定：</p><ul><li><code>接口名</code>：可随意定义</li><li><code>实现类名</code>：可随意定义</li><li><code>提供者配置文件路径</code>： 其查找的目录为 META-INF/services</li><li><code>提供者配置文件名称</code>：接口的全限定性类名，没有扩展名。</li><li><code>提供者配置文件内容</code>：该接口的所有实现类的全限类性类名写入到该文件中，一个类名占一行</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建配置文件（META-INF/services/cn.com.xiaocainiaoya.spi.jdk.CarService），然后在配置文件中配置接口的实现类的全限定类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cn.com.xiaocainiaoya.spi.jdk.ElectricCarServiceImpl</span><br><span class="line">cn.com.xiaocainiaoya.spi.jdk.TankCarServiceImpl</span><br></pre></td></tr></table></figure><p>模拟客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ServiceLoader.load()方法获取到配置文件中的实现类</span></span><br><span class="line">        ServiceLoader&lt;CarService&gt; loader = ServiceLoader.load(CarService.class);</span><br><span class="line">        Iterator&lt;CarService&gt; it = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            CarService service = it.next();</span><br><span class="line">            service.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElectricCarServiceImpl run</span><br><span class="line">TankCarServiceImpl run</span><br></pre></td></tr></table></figure><p>这种方式有几个问题：</p><ul><li>获取实现类的方式不够灵活，只能通过<code>loader.iterator()</code>迭代器的方式来获取实现类，然后遍历判定当前要使用的实现类，假设说可以以键值对的方式来获取实现类，那么可以增加一定的便利。</li><li>不能按需加载，比如某个接口在配置文件中配置的实现类有很多，但是实际在运行过程中只需要其中的小几个，虽然ServiceLoader做了延迟载入，但是获取实现类的手段只能通过遍历来获取，基本上实现类都得加载并实例化。</li><li>ServiceLoader类的实例是线程不安全。</li></ul><h2 id="Dubbo的服务发现机制SPI"><a href="#Dubbo的服务发现机制SPI" class="headerlink" title="Dubbo的服务发现机制SPI"></a>Dubbo的服务发现机制SPI</h2><p>Dobbo没有使用<code>Java</code>的这套SPI机制，而是自己实现了一套功能更加强大的SPI机制，Dubbo的SPI是通过<code>ExtensionLoader</code>类来进行实现类加载。</p><p>先来简单理解一下Dubbo这套SPI机制中的一些概念：</p><p><b>接口名：</b>可以随意定义，但接口必须被<code>@SPI 注解修饰</code></p><p><b>实现类名：</b> 在接口名前添加一个用于表示自身功能的“标识前辍”字符串</p><p><b>提供者配置文件路径：</b>在依次查找的目录为</p><ul><li>META-INF/dubbo/internal</li><li>META-INF/dubbo</li><li>META-INF/services</li></ul><p><b>提供者配置文件名称：</b>接口的全限定性类名，无需扩展名</p><p><b>提供者配置文件内容：</b> 文件的内容为 <code>key=value 形式</code>， value 为该接口的实现类的全限类性类名， key 可以随意，但一般为该实现类的“标识前辍”（首字母小写）。一个类名占一行。</p><p><b>提供者加载： </b>ExtensionLoader 类相当于 JDK SPI 中的 ServiceLoader 类，用于加载提供者配置文件中所有的实现类，并创建相应的实例。</p><p>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接使用 setter() 方法注入其他扩展点 ，也可 以对扩展点使用 Wrapper 类进行功能增强。</p><p><b>一些名词解释：</b></p><ul><li>普通扩展类：就是接口的具体的实现类（对应JDK的SPI中的具体的实现类）</li><li>Adaptive类：自适应扩展类，就是类似于在普通扩展类上再包一层，客户端获取到这个自适应扩展类，通过这个扩展类调用定义的扩展接口，它会根据一定的规则（自适应扩展类的接口的参数需要有com.alibaba.dubbo.common.URL）来路由到对应的实现类中。</li><li>Wrapper类：包装类，对普通扩展类的包装机制，可以对扩展类的SPI接口方法进行增强，一个SPI可以包含多个Wrapper。</li><li>Activate类：激活类，激活扩展类，可以通过指定的条件来一下子把需要的扩展类激活（因为Dubbo这套机制是按需加载，也就使用到时再进行加载，但是有些场景，可能一下子就要把某一些规则「比如做了分组，要把某个组的类一下子都加载」的类进行加载）</li></ul><h3 id="普通扩展类"><a href="#普通扩展类" class="headerlink" title="普通扩展类"></a>普通扩展类</h3><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>META-INF/services/cn.com.xiaocainiaoya.spi.dubbo.CarService</code>文件，并添加配置:</p><p><b>注：</b>这里与<code>JDK</code>的SPI稍有不同，这是是自定为每个接口实现定义了一个key。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">electric</span>=<span class="string">cn.com.xiaocainiaoya.spi.dubbo.ElectricCarServiceImpl</span></span><br><span class="line"><span class="attr">tank</span>=<span class="string">cn.com.xiaocainiaoya.spi.dubbo.TankCarServiceImpl</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到用于加载Order类型扩展类实例的extensionLoader实例</span></span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        <span class="comment">// 这里只会获取到electric这个key指向的实例，它也只会加载这个实例，达到了按需加载的效果</span></span><br><span class="line">        CarService car = loader.getExtension(<span class="string">&quot;electric&quot;</span>);</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自适应扩展类Adaptive"><a href="#自适应扩展类Adaptive" class="headerlink" title="自适应扩展类Adaptive"></a>自适应扩展类Adaptive</h3><p>自适应扩展<code>@Adaptive</code>注解可以标记在类上，也可以标记在方法上。</p><h4 id="1-标记在类上"><a href="#1-标记在类上" class="headerlink" title="1.标记在类上"></a>1.标记在类上</h4><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记在类上</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String defaultName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定要加载扩展类的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">(String defaultName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = defaultName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        CarService carService;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(defaultName)) &#123;</span><br><span class="line">            <span class="comment">// 加载SPI默认名称的扩展类</span></span><br><span class="line">            carService = loader.getDefaultExtension();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加载指定名称的扩展类</span></span><br><span class="line">            carService = loader.getExtension(defaultName);</span><br><span class="line">        &#125;</span><br><span class="line">        carService.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><p>注意一个<code>@SPI</code>接口只能有一个标记<code>@Adaptive</code>在类上的实现，所以在有这个要求的情况下，这个类的在下面配置文件中的<code>key</code>就显得无关紧要，这里是叫<code>adaptive</code>，你可以叫其他名字。</p><p>那么假设某个接口有两个标记了<code>@Adaptive</code>类，并且两个类都写在了下方的配置文件中会怎么样？</p><p>在<code>ExtensionLoader#loadFile()</code>方法中逐行扫描这些配置文件时，会发现某个<code>@SPI</code>接口有两个<code>@Adaptive</code>的实现类，后一个扫描到时会中断，之后它的做法是把异常信息保存在<code>Map&lt;String, IllegalStateException&gt; exceptions</code>，并不会使得程序都中断。也就是说假设有两个<code>@Apdative</code>的情况下，最终加载的是靠前的那个实现。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">electric</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.ElectricCarServiceImpl</span><br><span class="line"><span class="attr">tank</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.TankCarServiceImpl</span><br><span class="line"><span class="attr">adaptive</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.AdaptiveCarServiceImpl</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        CarService carService = loader.getAdaptiveExtension();</span><br><span class="line">        ((AdaptiveCarServiceImpl)carService).setDefaultName(<span class="string">&quot;tank&quot;</span>);</span><br><span class="line">        carService.display();</span><br><span class="line">        <span class="comment">// 这里要注意，自适应扩展类不属于直接扩展类!!!!</span></span><br><span class="line">        Set&lt;String&gt; supportedExtensions = loader.getSupportedExtensions();</span><br><span class="line">        System.out.println(supportedExtensions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TankCarServiceImpl display</span><br><span class="line">[electric, tank]</span><br></pre></td></tr></table></figure><h4 id="2-标记在方法上"><a href="#2-标记在方法上" class="headerlink" title="2.标记在方法上"></a>2.标记在方法上</h4><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>@Adaptive</code>标记在方法上时，会通过<code>javassist</code>为该接口生成一个动态类<code>CarService$Adaptive</code>，这个自动生成的代理类的主要作用是根据<code>URL</code>这个类来传入路由规则，使得此类可以根据这个路由规则，找到具体的实现类。(这个类是动态生成的，这就导致了不能通过IDE打断点之类的方式进行调试)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.com.xiaocainiaoya.spi.dubbo.adaptive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarService</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">cn</span>.<span class="title">com</span>.<span class="title">xiaocainiaoya</span>.<span class="title">spi</span>.<span class="title">dubbo</span>.<span class="title">adaptive</span>.<span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;method public abstract void cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.CarService.display() of interface cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService is not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;car.service&quot;</span>, <span class="string">&quot;electric&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension(cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;.CarService) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([car.service])&quot;</span>);</span><br><span class="line">        cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService extension = (cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService) </span><br><span class="line">                ExtensionLoader.getExtensionLoader(cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService.class).getExtension(extName);</span><br><span class="line">        extension.run(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到用于加载Order类型扩展类实例的extensionLoader实例</span></span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        <span class="comment">// 获取自适应扩展类，它是一个代理类</span></span><br><span class="line">        CarService car = loader.getAdaptiveExtension();</span><br><span class="line">        <span class="comment">// 不传参数，它会去查找@SPI(&quot;car&quot;) 注解，获取默认值</span></span><br><span class="line">        URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        car.run(url);</span><br><span class="line">        <span class="comment">// 传参，注意这里的参数名要和@SPI的接口名把驼峰转换为点号分隔作为参数名</span></span><br><span class="line">        URL url2 = URL.valueOf(<span class="string">&quot;xxx?car.service=tank&quot;</span>);</span><br><span class="line">        car.run(url2);</span><br><span class="line">        <span class="comment">// 这里是不能调用display方法，它不是自适应扩展类的方法，根据动态生成的类CarService$Adaptive可以看出来，</span></span><br><span class="line">        <span class="comment">// display方法的实现里直接抛出了UnsupportedOperationException异常</span></span><br><span class="line">        car.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElectricCarServiceImpl run</span><br><span class="line">TankCarServiceImpl run</span><br></pre></td></tr></table></figure><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h4><p>​    对比两种对于<code>@Adaptive</code>标记的位置的不同，可以发现，其实标记在类上，就是需要自己去实现路由规则，由自己来控制怎么找到自己需要的实现类；标记在接口上，是<code>Dubbo</code>通过做了一层高度抽象，配合<code>URL</code>类和根据<code>javassist</code>动态生成自适应扩展类，来路由到具体需要使用到的实现类。</p><h3 id="包装机制Wrapper"><a href="#包装机制Wrapper" class="headerlink" title="包装机制Wrapper"></a>包装机制Wrapper</h3><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarServiceWrapper</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarService carService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarServiceWrapper</span><span class="params">(CarService carService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carService = carService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper display before&quot;</span>);</span><br><span class="line">        carService.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper display after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper run before&quot;</span>);</span><br><span class="line">        carService.run(url);</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper run after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarServiceWrapper2</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarService carService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarServiceWrapper2</span><span class="params">(CarService carService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carService = carService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 display before&quot;</span>);</span><br><span class="line">        carService.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 display after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 run before&quot;</span>);</span><br><span class="line">        carService.run(url);</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 run after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">electric</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.ElectricCarServiceImpl</span><br><span class="line"><span class="attr">tank</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.TankCarServiceImpl</span><br><span class="line"><span class="attr">wrapper</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarServiceWrapper</span><br><span class="line"><span class="attr">wrapper2</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarServiceWrapper2</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到用于加载Order类型扩展类实例的extensionLoader实例</span></span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        <span class="comment">// 获取自适应扩展类，它是一个代理类</span></span><br><span class="line">        CarService car = loader.getAdaptiveExtension();</span><br><span class="line">        <span class="comment">// 不传参数，它会去查找@SPI(&quot;car&quot;) 注解，获取默认值</span></span><br><span class="line">        URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        car.run(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CarServiceWrapper2 run before</span><br><span class="line">CarServiceWrapper run before</span><br><span class="line">ElectricCarServiceImpl run</span><br><span class="line">CarServiceWrapper run after</span><br><span class="line">CarServiceWrapper2 run after</span><br></pre></td></tr></table></figure><h3 id="激活机制Activate"><a href="#激活机制Activate" class="headerlink" title="激活机制Activate"></a>激活机制Activate</h3><p>用于直接激活扩展类，通过一定的规则（分组）等方式，一下子激活符合条件的扩展类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line"></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>before()</code>和<code>after()</code>已经过时。</p><ul><li>group：分组名称，根据组名称来激活一些类（是一个大范围，指定到一个集体）</li><li>value：指定一个名称，可以不根据分组，直接根据名称来激活（一个小范围，直接指定到个体）</li><li>order：排序号，序号越小，优先级越高，默认值为0。</li></ul><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><p>3个具体实现类，其中<code>HybridCarServiceImpl</code>既属于<code>tankGroup</code>，也属于<code>electricGroup</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &quot;electricGroup&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate(group = &#123;&quot;tankGroup&quot;, &quot;electricGroup&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HybridCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HybridCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HybridCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate(group = &quot;tankGroup&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">electric</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.ElectricCarServiceImpl</span><br><span class="line"><span class="attr">tank</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.TankCarServiceImpl</span><br><span class="line"><span class="attr">hybrid</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.HybridCarServiceImpl</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">    URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活整个组，返回整个组的实现类列表</span></span><br><span class="line">    List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活整个组，但是只会返回第二个参数指定的实现类</span></span><br><span class="line">    List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;tank&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活整个组，但是只会返回URL对象中的参数key的实现类</span></span><br><span class="line">    URL url = URL.valueOf(<span class="string">&quot;xxx?tank=true&quot;</span>);</span><br><span class="line">    List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 综上：其实不论是为了获取那些实现类，实际上都是激活了（加载了）整个组的实现类 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CarService carService : tankServices) &#123;</span><br><span class="line">        carService.run(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TankCarServiceImpl run</span><br><span class="line">HybridCarServiceImpl run</span><br></pre></td></tr></table></figure><p><b>注：</b>我在<code>@Activate</code>中只有指定了<code>group</code>值，并没有指定<code>value</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经过我的测试，如果我的@Activate是这样声明：</span></span><br><span class="line"><span class="meta">@Activate(group = &quot;tankGroup&quot;, value = &quot;tank&quot;)</span></span><br><span class="line"><span class="meta">@Activate(group = &#123;&quot;tankGroup&quot;, &quot;electricGroup&quot;&#125;, value = &quot;hybrid&quot;)</span></span><br><span class="line"><span class="meta">@Activate(group = &quot;electricGroup&quot; , value = &quot;electric&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行后输出的结果是空的，是一个实现类都获取不到的，我看有些博客是说这个语句的后两个参数是或的关系</span></span><br><span class="line"><span class="comment">// 经过我的测试，并不是这样。我的dobbo版本是2.6.0。</span></span><br><span class="line">List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这种方式获取tankGroup中value值为tank的实现类</span></span><br><span class="line">URL url = URL.valueOf(<span class="string">&quot;xxx?service.car=tank&quot;</span>);</span><br><span class="line">List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;service.car&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h2><p>根据前面提到的特性，我们需要通过一个类，来自动查找具体实现类，这个类就是<code>ExtensionLoader</code>（在<code>jdk</code>中是通过<code>ServiceLoader</code>）。</p><p>这是一个静态方法，通过这个方法获取<code>ExtensionLoader</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;Car&gt; loader = ExtensionLoader.getExtensionLoader(Car.class);</span><br></pre></td></tr></table></figure><p>先从缓存中获取，如果获取不到，则创建一个新的<code>ExtensionLoader</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EXTENSION_LOADERS中获取，如果获取不到则创建一个</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下这个类的构建函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前加载类的类型</span></span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="comment">// 判断当前需要创建的类是不是ExtensionFactory类型，ExtensionFactory是dubbo内置的一个@SPI接口</span></span><br><span class="line">    <span class="comment">// 它的具体实现类有SpiExtensionFactory和SpringExtensionFactory，它的自适应扩展类是AdaptiveExtensionFactory（@Adaptive标记在类上）</span></span><br><span class="line">    <span class="comment">// 看下这个语句，如果type不是ExtensionFactory，那么ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</span></span><br><span class="line">    <span class="comment">// 也就是，除了它自己，其他类型的ExtensionLoader实例的objectFactory(对象创建工厂)都是ExtensionFactory这个类的自适应扩展类</span></span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExtensionFactory</code>的两个实现：从以下可以看出，这是为了兼容<code>spring</code>，加载具体实现类可以从<code>spring</code>上下文中获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从spring容器中获取bean</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(name)) &#123;</span><br><span class="line">                Object bean = context.getBean(name);</span><br><span class="line">                <span class="keyword">if</span> (type.isInstance(bean)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) bean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到<code>ExtensionLoader</code>实例之后，就可以执行上文中介绍的一些特性功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接获取对应key指向的实现类</span></span><br><span class="line">CarService car = loader.getExtension(<span class="string">&quot;electric&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自适应扩展类，通过自适应扩展类来路由到具体实现类的具体方法</span></span><br><span class="line">CarService car = loader.getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接激活所有符合条件的扩展类</span></span><br><span class="line">loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br></pre></td></tr></table></figure><p>具体实现类的获取过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 这个实际不用管，其实就是直接读默认的实现</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检测锁用来防止并发冲突，在ExtensionLoader中大量使用</span></span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建实现类</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建扩展类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getExtensionClasses()主要的作用是从配置中获取到@SPI标记的那个接口的实现类，并将相关信息(全限定类名)进行缓存</span></span><br><span class="line">    <span class="comment">// 将需要使用到的类进行加载并返回到这里</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，则加入缓存中</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对这个实现进行注入</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 获取到包装类的缓存</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; wrapperClasses.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 对这个实现进行包装，获取到包装类以当前类型为参数的构造函数，然后调用newInstance创建实例（包装类必须为@SPI接口的实现）</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终就返回了一个经过注入和经过包装的具体实现类的代理类（如果没有包装，就不是代理类）</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Extension instance(name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;)  could not be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载扩展类"><a href="#加载扩展类" class="headerlink" title="加载扩展类"></a>加载扩展类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; (value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;more than 1 default extension name on extension &quot;</span> + type.getName()</span><br><span class="line">                        + <span class="string">&quot;: &quot;</span> + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// 加载对应路径下的文件内容：META-INF/dubbo/internal、META-INF/dubbo、META-INF/services</span></span><br><span class="line">    loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadFile(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadFile(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="comment">// loadFile()方法就不贴了，主要做的事情就是：</span></span><br><span class="line">    <span class="comment">// 1. 是按key=value的方式逐行读取文件内容</span></span><br><span class="line">    <span class="comment">// 2. 如果读取的类标记了@Adaptive，则表示是自适应扩展类，赋值到 cachedAdaptiveClass，并且一个@SPI只能有一个@Adaptive扩展类</span></span><br><span class="line">    <span class="comment">// 3. 如果读取的类标记了@Activate，则表示需要进行自动激活，则加入到 Map&lt;String, Activate&gt; cachedActivates</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展类注入"><a href="#扩展类注入" class="headerlink" title="扩展类注入"></a>扩展类注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对象工厂不为空，这里在构造函数中创建了ExtensionFactory的自适应扩展类</span></span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 1. 方法名需要时set开头 2. 方法需要是public方法 3. 方法参数只有1个参数</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>) &amp;&amp; method.getParameterTypes().length == <span class="number">1</span> &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="comment">// 通过对象工厂获取对象，这里自适应扩展类会使得SpiExtensionFactory和SpringExtensionFactory都执行</span></span><br><span class="line">                        <span class="comment">// 也就是说这里会从spring容器中获取，如果是从SpiExtensionFactory，拿到的是pt的自适应扩展类</span></span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;fail to inject via method &quot;</span> + method.getName()</span><br><span class="line">                                + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自适应扩展类"><a href="#自适应扩展类" class="headerlink" title="自适应扩展类"></a>自适应扩展类</h3><p>首先来看看自适应扩展类的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双重检测锁</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建自适应扩展类</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建自适应扩展类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先获取到自适应扩展类的实例，再为自适应扩展类注入需要的对象</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到自适应扩展类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 这个方法其实前面已经介绍过了，如果 cachedClasses 里没有，则会去加载指定目录（META-INF/XXX）</span></span><br><span class="line">    <span class="comment">// 下的配置文件，并将对应的类加载</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 如果 cachedAdaptiveClass 不为空，则表示这个ExtensionLoader实例的自适应扩展类已经加载过了</span></span><br><span class="line">    <span class="comment">// 什么情况到这里会加载过呢？</span></span><br><span class="line">    <span class="comment">// 就是为这个@SPI标记的接口，指定了一个类级的@Adaptive，也就是说将@Adaptive标记在类上</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里就是标记方法级的@Adaptive，这里需要进行动态生成代码并编译</span></span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 创建动态生成的文件字符串，其实就是通过StringBuilder然后各种判断后拼接字符串，创建出一个xxx$Adaptive类的字符串</span></span><br><span class="line">    String code = createAdaptiveExtensionClassCode();</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    <span class="comment">// 使用编译器编译这个类的字符串</span></span><br><span class="line">    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这边测试的时候动态生成的一个自适应扩展类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.com.xiaocainiaoya.spi.dubbo.adaptive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarService</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">cn</span>.<span class="title">com</span>.<span class="title">xiaocainiaoya</span>.<span class="title">spi</span>.<span class="title">dubbo</span>.<span class="title">adaptive</span>.<span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有标记@Adaptive注解的方法是不允许通过自适应扩展类访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;method public abstract void cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.CarService.display() of interface cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService is not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被标记@Adaptive注解的方法，通过URL设置了一些参数规则，根据这个参数规则，获取到对应的参数来路由到对应的实现类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;car.service&quot;</span>, <span class="string">&quot;electric&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension(cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;.CarService) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([car.service])&quot;</span>);</span><br><span class="line">        cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService extension = (cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService) </span><br><span class="line">                ExtensionLoader.getExtensionLoader(cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService.class).getExtension(extName);</span><br><span class="line">        extension.run(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动激活机制"><a href="#自动激活机制" class="headerlink" title="自动激活机制"></a>自动激活机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (CarService carService : tankServices) &#123;</span><br><span class="line">  carService.run(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取需要自动激活的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key, String group)</span> </span>&#123;</span><br><span class="line">  String value = url.getParameter(key);</span><br><span class="line">  <span class="keyword">return</span> getActivateExtension(url, value == <span class="keyword">null</span> || value.length() == <span class="number">0</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(value), group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取自动激活的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">        <span class="comment">// 加载这个@SPI接口对应的相关信息「去加载META-INF文件夹下的文件」</span></span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            Activate activate = entry.getValue();</span><br><span class="line">            <span class="comment">// 组是否对应</span></span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">                <span class="comment">// 获取对应的扩展类，到这一步其实就已经在加载名为name的这个类了</span></span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                <span class="comment">// 1. 如果当前循环的这个name不落在names中时（因为names是直接指定，优先级比较低，是在下方的那个for循环中加入到exts结果列表中）</span></span><br><span class="line">                <span class="comment">// 2. 如果names中不包含“-name”时（这个目前不太清楚是干嘛用的，可能是有一些特殊的操作判断）</span></span><br><span class="line">                <span class="comment">// 3. isActive()是否符合激活规则（url参数中指定的规则）</span></span><br><span class="line">                <span class="keyword">if</span> (!names.contains(name) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">                    exts.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="comment">// 用户直接指定的实现，比如这种写法 loader.getActivateExtension(url, new String[]&#123;&quot;tank&quot;, &quot;electric&quot;&#125;); </span></span><br><span class="line">    <span class="comment">// 就是直接激活@Activate中value=tank和value=electric的扩展类</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">        String name = names.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                    usrs.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                usrs.add(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        exts.addAll(usrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前按我理解：自动激活机制的意思是，会将整个组都激活（加载），但是接口会根据相应的规则来获取对应的扩展类。（比如groupA下有V1，V2，V3，groupB下有W1，W2，W3，如果是加载groupA，那么V1，V2，V3都会激活，但是会根据一些规则判断，返回其中的某个或者某些，比如只返回V1，或者返回V1,V2）</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;dubbo的Spi机制&quot;&gt;&lt;a href=&quot;#dubbo的Spi机制&quot; class=&quot;headerlink&quot; title=&quot;dubbo的Spi机制&quot;&gt;&lt;/a&gt;dubbo的Spi机制&lt;/h1&gt;&lt;p&gt;结合之前说到的&lt;a href=&quot;https://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/&quot; target=&quot;_blank&quot;&gt;springboot的Spi机制&lt;/a&gt;本篇将简单介绍一下&lt;code&gt;Doubbo&lt;/code&gt;的SPI机制，&lt;code&gt;Dobbo&lt;/code&gt;没有使用&lt;code&gt;jdk&lt;/code&gt;的这套&lt;code&gt;SPI&lt;/code&gt;机制，而是自己实现了一套，提供了一些更灵活、更易于使用的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="doubbo" scheme="http://xiaocainiaoya.github.io/categories/doubbo/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spi" scheme="http://xiaocainiaoya.github.io/tags/spi/"/>
    
  </entry>
  
  <entry>
    <title>k8s入门</title>
    <link href="http://xiaocainiaoya.github.io/2024/07/29/k8s/k8s%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2024/07/29/k8s/k8s%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-29T13:43:58.000Z</published>
    <updated>2024-07-29T13:26:27.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s入门"><a href="#k8s入门" class="headerlink" title="k8s入门"></a>k8s入门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><span id="more"></span><p><b>1.私有网络VPC</b></p><p>​    在集群内通过设置VPC来进行私有网络（专有网络）配置。</p><p><img src="https://s2.loli.net/2024/07/14/xGjEFrJ8U4Tb69K.png" alt="VPC.png"></p><p>集群内的机器通过私有IP进行访问，这样不需要走公网IP的流量，访问时也不会因为公网的带宽限制。一般云服务器都会默认分配对应的专有网络，也可以自己配置专有网络。</p><p>若自己配置专有网络，需要配置IP网段，这个网段标志着这个专有网络最多能容纳多少台服务器。</p><p>比如配置的网段是：192.168.0.1/16(192.168.0.0 ~ 192.168.255.255)其中头尾IP被占用，剩下的IP就可以分配给对应的服务器，之后就可以通过私有网络进行访问。</p><p>在一些云产商，在配置了专用VPC之后，还可以配置交换机。再一级的细分网段。</p><p>所以比如这时可以加两个交换机（192.168.0.1/24）（192.168.10.1/24）。</p><p><b>如果创建了多个VPC，VPC与VPC之间是相互隔离的，相互VPC之下的机器是无法互通。</b></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Pod：是<code>K8s</code>调度的基本单位，一个<code>Pod</code>中支持多个容器，其中多个容器共享网络和文件系统，可以通过进程通信和文件共享这种简单高效的方式组合完成服务。每个<code>Pod</code>都有一个特殊的根容器<code>Pause</code>容器，以及一个或多个的业务容器组成。<code>Pause</code>容器作为根容器，以它的状态来代表这个<code>Pod</code>的运行状态，每个<code>Pod</code>都分配了一个唯一的<code>IP</code>地址（<code>Pod IP</code>)。<code>Pod</code>内的所有业务容器都共享根容器的<code>Ip</code>，以及共享根容器挂载的<code>Volume</code>。</li><li>Node：是<code>Pod</code>真正运行的主机，可以是物理机也可以是虚拟机，为了更好的管理<code>Pod</code>，在每个<code>Node</code>节点上至少要容器引擎（<code>docker</code>）、<code>kubelet</code>、<code>kubelet-proxy</code>服务。</li><li>Namespace：命名空间，是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或者用户组。</li><li>Label：是<code>k8s</code>对象的标签，以键值的方式附加到各种资源上，一个资源对象可以定义任意数量的<code>Label</code>，同一个<code>Label</code>也可以被添加到任意数量的资源上，<code>k8s</code>通过<code>Label Selector</code>（标签选择器）来查询和筛选某些<code>Label</code>资源对象。</li><li>Service：是一个服务的访问入口，通过标签选择器<code>Label Selector</code>与<code>Pod</code>副本集群之间进行对接，定义了一组的<code>Pod</code>访问策略（<code>iptable</code>），防止<code>Pod</code>失联。在创建<code>Service</code>时会自动为它分配一个虚拟的<code>IP</code>地址，即<code>Cluster IP</code>，服务发现就是通过<code>Service</code>的<code>Name</code>和<code>ClusterIP</code>地址做了一个<code>DNS</code>域名映射来解决。</li><li>RepllcaSet(RC)：用来确保预期的<code>Pod</code>副本数量，如果有过多的<code>Pod</code>副本运行，则会停止一些，反之则再启动一些。一般很少主动操作<code>RC</code>，都是通过<code>Deployment</code>这个更高层次的资源对象使用，从而形成一整套<code>Pod</code>创建、删除、更新的编排机制。</li><li>Deployment：用于部署无状态应用，只需要在<code>Deployment</code>上描述想要的目标状态，它就会将<code>Pod</code>和<code>RC</code>的实际状态改变到目标状态。</li></ul><h2 id="架构组件"><a href="#架构组件" class="headerlink" title="架构组件"></a>架构组件</h2><p><img src="https://s2.loli.net/2024/06/13/dZ17RHOM3BuYVFp.png" alt="k8s.png"></p><p><b>k8s主要由以下核心组件组成：</b>在<code>k8s</code>集群中分为<code>master</code>主节点和<code>node</code>工作节点。</p><p><b>在主节点中：（控制平面）</b></p><ul><li>kube-apiserver：提供了资源操作的唯一入口，各组件的协调者，以<code>Http Rest</code>方式提供接口服务，所有对象资源的增、删、改、查和监听都交给它处理后再提交到<code>etcd</code>中存储。</li><li>etcd：键值数据库，保存了整个集群的一些信息。比如<code>Pod</code>、<code>Service</code>等对象信息。</li><li>kube-scheduler：调度器，根据调度算法为新创建的<code>Pod</code>选择一个<code>node</code>工作节点，可以任意部署，可以部署在同一个工作节点上，也可以部署在不同的工作节点上。</li><li>kube-controller-manager：是所有资源对象的自动化控制中心，一个资源对应一个控制器，而它就是负责管理这些控制器。比如有：<ul><li>节点控制器</li><li>任务控制器</li><li>端点控制器</li><li>副本控制器</li><li>服务账户与令牌控制器</li></ul></li></ul><p><b>在工作节点中：</b></p><ul><li>kubelet：它是<code>master</code>主节点在<code>node</code>工作节点上的<code>agent</code>(代理），主节点通过它来管理当前工作节点的运行容器的生命周期，负责<code>Pod</code>对应容器的创建、启停等，实现集群管理的基本功能。</li><li>kube-proxy：在工作节点上实现<code>Pod</code>网络代理，实现<code>kubernets Service</code>的通信，维护网络规则和四层负责均衡工作。</li><li>docker engine：容器引擎，负责本机的容器创建和管理工作。</li></ul><h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><p><b>环境部署前遇到的一些问题</b></p><ul><li>由于需要使用到<code>yum</code>来下载一些包，但是<code>yum</code>需要访问镜像仓库，始终无法访问到<code> mirrorlist.centos.org</code>，所以需要更换为国内的的一些镜像源。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos7的镜像源文件的目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment"># 将原本的CentOS-Base.repo备份后</span></span><br><span class="line"><span class="comment"># 使用阿里云镜像站，如果能使用wget，则直接下载，如果不能，可以先下载文件后贴进去</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用网易镜像站</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.<span class="built_in">help</span>/CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure><p>添加安装<code>docker</code>镜像源，这个命令执行之后，会在<code>/etc/yum.repos.d</code>目录下生成<code>docker-ce.repo</code>文件。是专门针对<code>docker</code>的软件包镜像源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装<code>docker</code>，安装<code>docker</code>要注意需要和<code>k8s</code>版本匹配。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置加速镜像源</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://gr4yxx0x.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><b>接着就可以开始安装K8S</b></p><ul><li>设置<code>hostname</code>，每台服务器的主机名不可重复。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主机名</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure><ul><li>关闭交互区，一些安全配置</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 交换分区</span></span><br><span class="line">  free -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）  第一行是临时禁用，第二行是永久禁用</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap；第一行是临时禁用，第二行是永久禁用</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 iptables 检查桥接流量 （K8s 官方要求）</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让配置生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><ul><li>安装k8s三大件（<code>kubelet</code>、<code>kubeadm</code>、<code>kubectl</code>）版本使用<code>1.20.9</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置k8s的yum源</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装三大件</span></span><br><span class="line">yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动kubelet</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubelet 状态：一会停止 一会运行。 这个状态是对的，kubelet 等待 kubeadm 发号指令。</span></span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p>在<code>k8s</code>组件中，除了<code>kubelet</code>，其他组件都是通过容器的方式下载运行。</p><ul><li>安装其他组件的容器</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置镜像，生成 images.sh</span></span><br><span class="line"><span class="comment"># 逻辑上只需要在master节点上下载所有的容器镜像，在work节点上只需要下载kube-proxy</span></span><br><span class="line">sudo tee ./images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure><ul><li>初始化主节点</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个要在每个节点上都配置对主节点的本地路由映射</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;10.211.55.15  cluster-endpoint&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主节点初始化 （只在 master 服务器执行， 其他 node 不用）</span></span><br><span class="line"><span class="comment"># --apiserver-advertise-address: master 的 IP</span></span><br><span class="line"><span class="comment"># --control-plane-endpoint: master 的域名</span></span><br><span class="line"><span class="comment"># --image-repository docker镜像仓库</span></span><br><span class="line"><span class="comment"># --service-cidr 和 --pod-network-cidr 是网络范围，建议不要改。要改的话 2 个cidr 和 vps（172.31.x.x） 的，3 个网络互相不能重叠；还要修改 calico.yaml的 IP（下图有写）。</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.211.55.15 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure><p>如果使用的是云服务器要注意，至少要允许在<code>2c</code>的服务器上。</p><p>安装成功后会得到以下提示信息，需要根据以下信息进行操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and <span class="keyword">then</span> running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c </span><br></pre></td></tr></table></figure><ul><li>这时通过<code>kubectl get nodes</code>可以看到当前的节点状态，但是此时的主节点状态还是<code>NotReady</code>，是因为还需要下载一个网络组件。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用calico网络组件，在主节点下载 calico.yaml</span></span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">curl https://docs.projectcalico.org/v3.20/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><p>这里有一个问题：我使用的是阿里云的镜像加速器，但是好像一直无法下载<code>calico</code>镜像。所以只能通过一些非常规手段下载。创建<code>calico.sh</code>，之后<code>chmod +x calico.sh &amp;&amp; ./calico.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/projectcalico/calico/releases/tag/v3.20.6 通过这个地址下载release-v3.20.6.tgz包，然后上传到服务器中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后创建cailco.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf release-v3.20.6.tgz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> release-v3.20.6</span><br><span class="line"><span class="built_in">cd</span> images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环加载 image</span></span><br><span class="line">sudo tee load-images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">tars=(</span><br><span class="line">calico-kube-controllers.tar</span><br><span class="line">calico-node.tar</span><br><span class="line">calico-typha.tar</span><br><span class="line">calico-cni.tar</span><br><span class="line">calico-pod2daemon-flexvol.tar</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> tar <span class="keyword">in</span> <span class="variable">$&#123;tars[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker load &lt; <span class="variable">$tar</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod +x load-images.sh &amp;&amp; ./load-images.sh</span><br></pre></td></tr></table></figure><p>同时需要修改下载的<code>calico.yaml</code>中的镜像地址。(<b>注意：如果是通过这种方式，则工作节点也需要同样操作，因为工作节点也需要这个镜像。</b>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本 calico.yaml 中所规定的 image 资源都是长这样的 docker.io/calico/cni:v3.20.6， 由于这个 docker.io/ 前缀会导致 k8s 去 DockerHub 上找 image (前面已解释了走不了阿里加速器的原因)，而不是使用刚才我们导入进本地的 images。所以我们用 sed -i 来全局查找替换，去掉它们。</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/image: docker.io\//image: /g&#x27;</span> calico.yaml</span><br></pre></td></tr></table></figure><ul><li>工作节点运行命令，使得工作节点加入集群</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果使用虚拟机部署，要注意服务器之间的防火墙有没有关闭，可能出现无法访问的情况。    </span></span><br></pre></td></tr></table></figure><p>加入集群的令牌的有效期是24小时，重新获取令牌。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新获取令牌</span></span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p>在k8s中一般都是通过<code>.yaml</code>来进行一些操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml</span><br><span class="line">kubectl delete -f xxx.yaml</span><br></pre></td></tr></table></figure><p>我在测试时候使用的是云服务器，后面转到虚拟机上，部署了同样的环境。(不行，这个修改方式有问题，虽然乍一看修改之后是没有什么问题，通过<code>kubectl get nodes</code>查看的状态也是对的，但是我在创建<code>pod</code>的时候一直创建不起来，甚至连<code>pod</code>都没有去创建，也不知道是因为什么，通过<code>systemctl status kubelet</code>查看日志，其中有打印出还是通过旧的地址访问<code>serverapi</code>接口，说明哪里改漏了，没有改到，但是具体哪里就不知道了。)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 但是由于我部署的时候是和我后面用的时候不是同一个wifi网络环境，导致我在重启虚拟机之后ip变了。</span></span><br><span class="line"><span class="comment"># 重启虚拟机之后要先启动docker，再启动k8s</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/kubernetes/manifests</span><br><span class="line">vi etcd.yaml</span><br><span class="line">vi kube-apiserver.yaml</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 k8s 集群 所有节点</span></span><br><span class="line">kubectl get nodex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 k8s 集群 部署了 哪些应用运行的应用在 docker 中叫 container（容器），在 k8s 中叫 pod</span></span><br><span class="line">kubectl get pods -A对应 docker 中 的docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 默认命名空间（default）部署的应用</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 完整的信息，有 部署的 节点、节点IP 等。</span></span><br><span class="line">kubectl get pod -A -owide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 整个状态变化过程</span></span><br><span class="line">kubectl get pod -w</span><br></pre></td></tr></table></figure><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 某个命名空间（kubernetes-dashboard）部署的应用</span></span><br><span class="line">kubectl get pod -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建命名空间 hello</span></span><br><span class="line">kubectl create ns hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命名空间 hello</span></span><br><span class="line">kubectl delete ns hello</span><br></pre></td></tr></table></figure><h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 mynginx-k8s 的 Pod （默认命名空间）</span></span><br><span class="line">kubectl run mynginx-k8s --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到 Pod 里面（和 docker exec -it 一样的）</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it Pod名字 -- /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod mynginx-k8s 的描述</span></span><br><span class="line">kubectl describe pod mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 在默认命名空间的 mynginx-k8s</span></span><br><span class="line">kubectl delete pod mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 在 xxx 命名空间的 mynginx-k8s</span></span><br><span class="line">kubectl delete pod mynginx-k8s -n xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod mynginx-k8s 的运行日志（默认的命名空间）</span></span><br><span class="line">kubectl logs mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 运行日志（-n 就是 namespace 命名空间）</span></span><br><span class="line">kubectl logs -f -n xxx命名空间 xxxPodName</span><br></pre></td></tr></table></figure><h4 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Deployment 部署 Pod，deploy 名为 mytomcat，使用镜像 tomcat:8.5.68</span></span><br><span class="line">kubectl create deployment mytomcat --image=tomcat:8.5.68</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Deployment 创建的资源</span></span><br><span class="line">kubectl get deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Deployment 创建的资源，用 delete 是删不掉的</span></span><br><span class="line">kubectl delete deploy mytomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># --replicas=3，部署 3个 Pod my-dep</span></span><br><span class="line">kubectl create deployment my-dep --image=nginx --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Deployment my-dep 扩容 成 5 个 Pod</span></span><br><span class="line">kubectl scale deploy/my-dep --relicas=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Deployment my-dep 缩容 成 2 个 Pod</span></span><br><span class="line">kubectl scale deploy/my-dep --relicas=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前用的镜像（spec.container.image）</span></span><br><span class="line">kubectl get deploy/my-dep -oyaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前用的镜像</span></span><br><span class="line">kubectl get deploy/my-dep -oyaml | grep image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变 my-dep 中 nginx 版本（nginx 最新版 -&gt; 1.16.1）滚动更新</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/my-dep nginx=nginx:1.16.1 --recordkubectl rollout status deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史记录</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 my-dep 某个历史详情</span></span><br><span class="line">kubectl rollout histroy deployment/my-dep --revision=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># my-dep 回滚（回到上个版本）</span></span><br><span class="line">kubectl rollout undo deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># my-dep 回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment/my-dep --to-revision=2</span><br></pre></td></tr></table></figure><p>在<code>deployment</code>中还有一些细分：</p><ul><li>Deployment：无状态应用部署，比如微服务，提供多副本等功能。</li><li>StatefulSet：有状态应用部署，比如redis，提供稳定的存储、网络等功能</li><li>DeamonSet：守护型应用部署，比如日志收集组件，在每个机器都运行一份。</li><li>Job/CronJob:定时任务部署，比如垃圾清理组件，可以在指定时间运行。</li></ul><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><code>Pod</code>的服务发现与负责均衡，将一组<code>Pods</code>公开为网络服务的抽象方法。如果访问是通过直接<code>IP</code>的方式，当其中的一个<code>Pod</code>或者是服务器宕了之后，就直接无法访问了，所以在<code>k8s</code>中，<code>Pod</code>的网络控制由<code>Service</code>管理，请求访问到<code>Service</code>上，由<code>Service</code>转到对应的<code>Pod</code>上，当然它也有负载均衡的能力。</p><p><b>Service有两种创建方式，或者说有两种创建类型</b></p><ul><li>ClusterIP：默认的访问方式（创建的时候不写就是使用这种方式），只能集群内访问。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl expose 暴露端口，只能在集群内部 ClusterIP 访问。--type=ClusterIP 不传默认就是ClusterP</span></span><br><span class="line"><span class="comment"># target-port 目标Pod的端口（源端口） </span></span><br><span class="line"><span class="comment"># port service的端口</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在集群内通过域名访问：服务名.命名空间.svc ; 比如 my-dep-02.default.svc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 service，里面有 CLUSTER-IP</span></span><br><span class="line"><span class="comment"># kubectl get service 或者 kubectl get svc</span></span><br><span class="line">kubectl get service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pod 标签</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">kubectl delete svc my-dep-02</span><br></pre></td></tr></table></figure><ul><li>NodePort：在公网上可以访问，但是这种方式暴露的端口是随机的。这种模式可以访问每一台服务器的暴露端口，比如创建之后生成的端口是30999，那么每一台服务器的IP:30999,都能访问到，且具备负责均衡。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只能集群内部访问（--type不写 默认 ClusterIP）</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80 --<span class="built_in">type</span>=ClusterIP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群外部也可以访问</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure><p><b>小Tip:</b>使用<code>ClusterIP</code>类型分配的IP地址，在初始化时其实配置了IP地址的范围。下方的<code>--service-cidr</code>。同样的下方的<code>--pod-network-cidr</code>是所有的<code>pod</code>的<code>IP</code>范围。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=172.31.0.2 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>它是<code>Service</code>的统一网关入口，底层是<code>nginx</code>。所有的请求都是先到<code>ingress</code>，由<code>ingress</code>来打理这些请求，类似微服务中的网关层。</p><p><img src="https://s2.loli.net/2024/07/17/NS2nabyhVDUkWZF.png" alt="k8s.png"></p><p>安装<code>ingress</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line">vi deploy.yaml</span><br><span class="line"><span class="comment"># 将 image 的值改为如下值</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装资源</span></span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装的结果</span></span><br><span class="line">kubectl get pod,svc -n ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后别忘记把 svc 暴露的端口 在安全组放行</span></span><br></pre></td></tr></table></figure><p>删除<code>ingress</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不知道为啥会删不干净</span></span><br><span class="line">kubectl get ns ingress-nginx -o json &gt; tmp.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启本地访问</span></span><br><span class="line">kubectl proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再开一个窗口</span></span><br><span class="line">curl -k -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X PUT --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/ingress-nginx/finalize</span><br></pre></td></tr></table></figure><p>安装之后查看安装结果，可以看到<code>ingress-nginx-controller</code>通过<code>NodePort</code>方式暴露了两个端。</p><p><code>31276</code>这个是<code>http</code>的访问端口，<code>31267</code>这个是<code>https</code>的访问端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master home]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME                                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.96.2.61     &lt;none&gt;        80:31276/TCP,443:31267/TCP   2m44s</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.96.31.252   &lt;none&gt;        443/TCP                      2m44s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问<code>http://10.211.55.15:31067/</code>出现了<code>nginx</code>的404页面。</p><p>这里就简单的做个<code>ingress</code>的测试：如果访问的是<code>user.xiaocainiao.com</code>那么显示”Hello World!“。如果访问的是<code>pay.xiaocainiaoya.com</code>那么显示的是<code>nginx</code>的欢迎页面。</p><p>创建两个<code>Deployment</code>和两个<code>Service</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在<code>k8s</code>中执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi test.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f test.yaml</span><br></pre></td></tr></table></figure><p>接着创建路由规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-host-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;user.xiaocainiao.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span> <span class="comment"># hello-server （service） 的端口是 8000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;pay.xiaocainiaoya.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span>  <span class="comment">#java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>然后在<code>k8s</code>中执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ingress-rule.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f ingress-rule.yaml</span><br></pre></td></tr></table></figure><p>刚执行完命令，可能在<code>ADDRESS</code>一栏为空，稍微等一等之后会分配这个<code>ingress</code>的访问地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master home]<span class="comment"># kubectl get ingress -A</span></span><br><span class="line">NAMESPACE   NAME               CLASS   HOSTS                                        ADDRESS        PORTS   AGE</span><br><span class="line">default     ingress-host-bar   nginx   user.xiaocainiao.com,pay.xiaocainiaoya.com   10.211.55.16   80      12m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我是用虚拟机做测试，需要进行本机的路由代理。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.16 user.xiaocainiao.com</span><br><span class="line">10.211.55.16 pay.xiaocainiaoya.com</span><br></pre></td></tr></table></figure><p>用这个访问地址+刚刚安装的<code>ingress-manager</code>暴露的端口进行访问。</p><p><img src="https://s2.loli.net/2024/07/24/e5HU4rxQOaPpsyS.png" alt="ingress.png"></p><h4 id="存储挂载"><a href="#存储挂载" class="headerlink" title="存储挂载"></a>存储挂载</h4><p>在<code>k8s</code>的场景中，<code>pod</code>在集群中部署的节点机是由<code>deployment</code>决定，假设说某一个<code>pod</code>挂了之后，可能<code>deployment</code>在识别到之后通过故障恢复，会将在其他机器上重新部署一个该<code>pod</code>。所以这时会存在一种情况，重新部署的<code>pod</code>理应能读取到之前<code>pod</code>故障之前写入到磁盘的一些持久性数据，所以在<code>k8s</code>体系中，引入了存储层框架。</p><p>在<code>k8s</code>中可以使用的一些存储层框架：Glusterfs、NFS、CephFS。</p><p>这里以NFS为例，需要在每一台节点机上安装<code>NFS</code>。每个机器上安装一个NFS存储层框架，然后相互之间进行数据同步，假设某一个<code>pod</code>故障之后，被转移到了其他的机器上，也能通过相同的挂载目录读取到之前持久化数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在主节点上运行</span></span><br><span class="line"><span class="comment"># 只在 mster 机器执行：nfs主节点，rw 读写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure><p>到此就表示，在master机器上开放了<code>/nfs/data/</code>目录，用来做成存储空间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查，下面的 IP 是master IP</span></span><br><span class="line">showmount -e 192.168.27.251</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器 执行，执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器执行，将远程 和本地的 文件夹 挂载</span></span><br><span class="line">mount -t nfs 192.168.27.251:/nfs/data /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 master 服务器，写入一个测试文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello nfs server&quot;</span> &gt; /nfs/data/test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器查看</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/data</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><b>原生方式 数据挂载</b></p><p>在 /nfs/data/nginx-pv 挂载，然后 修改， 里面 两个 Pod 也会 同步修改。</p><p>问题：①如果某个Pod不需要了，删掉Pod之后，文件还在，内容也在，②空间受机器空间管理，创建之后逻辑上是无限大的空间，除非达到机器上限，是没法管理大小的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 挂载目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="comment"># 和 volumeMounts.name 一样</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="comment"># master IP</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data/nginx-pv</span> <span class="comment"># 要提前创建好文件夹，否则挂载失败</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /nfs/data</span><br><span class="line">mkdir -p nginx-pv</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">vi deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制上面配置</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod -owide</span><br></pre></td></tr></table></figure><p><b>6.3 PV 和 PVC</b></p><p><strong>PV</strong>：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置</p><p><strong>PVC</strong>：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格</p><p>静态供应：在主节点上的<code>nfs/data/</code>目录下创建三个文件夹，并且通过yaml文件对其进行配置。</p><ul><li><code>01</code>：挂载名称为<code>pv01-10m</code>，且持久卷池的名称为<code>nfs</code>，空间为10M，多节点可读写</li><li><code>02</code>：挂载名称为<code>pv02-1gi</code>，且持久卷池的名称为<code>nfs</code>，空间为1G，多节点可读写</li><li><code>03</code>：挂载名称为<code>pv03-3gi</code>，且持久卷池的名称为<code>nfs</code>，空间为3G，多节点可读写</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 nfs主节点（master服务器） 执行</span></span><br><span class="line">mkdir -p /nfs/data/01</span><br><span class="line">mkdir -p /nfs/data/02</span><br><span class="line">mkdir -p /nfs/data/03</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv01-10m</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 限制容量</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10M</span></span><br><span class="line">  <span class="comment"># 读写模式：可读可写</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 表示持久卷池子的名称</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="comment"># 挂载 上面创建过的文件夹</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/01</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 这个name 要小写，如 Gi 大写就不行</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv02-1gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/02</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv03-3gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/03</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制上面文件</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pv， kubectl get pv</span></span><br><span class="line">kubectl get persistentvolume</span><br></pre></td></tr></table></figure><p><b>创建、绑定 PCV</b></p><p>创建一个持久卷声明：从持久卷池子名为<code>nfs</code>的池子中申请一个至少有200M大小的空间。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="comment"># 需要 200M的 PV</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="comment"># 上面 PV 写的什么 这里就写什么    </span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure><p>绑定到<code>pod</code>上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="comment"># 之前是 nfs，这里用 pvc</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span> </span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">nginx-pvc</span> <span class="comment"># 绑定持久卷声明</span></span><br></pre></td></tr></table></figure><p>既然有静态供应那么也就会有动态供应，在静态供应商中，是创建好了一个个不同大小的PV,并把这些PV进行分组命名（池子名称），等需要使用时，通过这个分组名称（池子名称）去这个组里获取到最适合的空间大小的PV。这种方式比较麻烦的是，需要手动创建一个个PV,且空间大小上无法相对准确的预估，容易存在浪费。比如我只需要20M的空间，但是池子里的PV分别为1G，2G，3G，那么这时至少会给我1G的那个PV。</p><p>动态供应：就是可以动态的创建具体的PV，那么这种方式创建的PV的空间大小就会相对符合需要，不会造成过多的浪费。</p><h4 id="配置集ConfigMap"><a href="#配置集ConfigMap" class="headerlink" title="配置集ConfigMap"></a>配置集ConfigMap</h4><p>在<code>k8s</code>中部署<code>POD</code>，比如<code>redis</code>的启用，需要依赖于一些配置（配置一些服务器地址等），这时可以将这个配置内容添加到<code>k8s</code>的配置集中，那么所有的<code>pod</code>就可以都引用到这份配置文件，并且当需要修改配置时，只需要对这个配置集进行修改，<code>POD</code>中指定的配置文件也会相应的同步新的配置（一小段时间之后）。</p><p>假设我有配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 设置Redis监听的端口，默认为6379</span><br><span class="line">port 6379</span><br><span class="line"> </span><br><span class="line"># 设置Redis监听的网络接口的IP地址</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"> </span><br><span class="line"># 设置Redis是否以守护进程方式运行</span><br><span class="line">daemonize no</span><br><span class="line"> </span><br><span class="line"># 设置Redis的日志文件路径</span><br><span class="line">logfile &quot;&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log&quot;</span><br><span class="line"> </span><br><span class="line"># 设置数据库的数量，默认16个数据库（0...15），可以通过select &lt;dbid&gt;命令选择数据库</span><br><span class="line">databases 16</span><br><span class="line"> </span><br><span class="line"># 设置密码认证</span><br><span class="line"># requirepass yourpassword</span><br><span class="line"> </span><br><span class="line"># 设置快照功能，即持久化</span><br><span class="line">#  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#  save 900 1</span><br><span class="line">#  save 300 10</span><br><span class="line">#  save 60 10000</span><br><span class="line"> </span><br><span class="line"># 设置持久化的文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"> </span><br><span class="line"># 设置当主服务器失效时，从服务器是否仍然可读</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"># 设置是否在每个命令后进行日志记录</span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># 设置更新日志的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"> </span><br><span class="line"># 设置更新日志写入策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># 设置Redis最大内存容量</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"> </span><br><span class="line"># 设置内存淘汰策略</span><br><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi redis.conf</span><br><span class="line"><span class="comment"># 写</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置，redis保存到k8s的etcd；</span></span><br><span class="line">kubectl create cm redis-conf --from-file=redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get cm</span><br><span class="line"></span><br><span class="line">rm -rf redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ConfigMap 的 yaml 配置咋写的</span></span><br><span class="line">kubectl get cm redis-conf -oyaml</span><br></pre></td></tr></table></figure><p>显示这个配置集的内容如下。（它是存储在<code>tecd</code>中）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># key为redis.conf 值为具体的redis启动配置值</span></span><br><span class="line">  <span class="attr">redis.conf:</span> <span class="string">&quot;# 设置Redis监听的端口，默认为6379\nport 6379\n \n# 设置Redis监听的网络接口的IP地址\n# bind 127.0.0.1\n</span></span><br><span class="line"><span class="string">    \n# 设置Redis是否以守护进程方式运行\ndaemonize no\n \n# 设置Redis的日志文件路径\nlogfile \&quot;/var/log/redis/redis-server.log\&quot;\n</span></span><br><span class="line"><span class="string">    \n# 设置数据库的数量，默认16个数据库（0...15），可以通过select &lt;dbid&gt;命令选择数据库\ndatabases 16\n \n# 设置密码认证\n#</span></span><br><span class="line"><span class="string">    requirepass yourpassword\n \n# 设置快照功能，即持久化\n#  save &lt;seconds&gt; &lt;changes&gt;\n#  save</span></span><br><span class="line"><span class="string">    900 1\n#  save 300 10\n#  save 60 10000\n \n# 设置持久化的文件\ndbfilename dump.rdb\ndir</span></span><br><span class="line"><span class="string">    /var/lib/redis\n \n# 设置当主服务器失效时，从服务器是否仍然可读\nslave-serve-stale-data yes\n \n# 设置是否在每个命令后进行日志记录\nappendonly</span></span><br><span class="line"><span class="string">    no\n \n# 设置更新日志的文件名\nappendfilename \&quot;appendonly.aof\&quot;\n \n# 设置更新日志写入策略\n# appendfsync</span></span><br><span class="line"><span class="string">    always\nappendfsync everysec\n# appendfsync no\n \n# 设置Redis最大内存容量\n# maxmemory</span></span><br><span class="line"><span class="string">    &lt;bytes&gt;\n \n# 设置内存淘汰策略\n# maxmemory-policy volatile-lru\n&quot;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2024-07-24T16:02:55Z&quot;</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:data:</span></span><br><span class="line">        <span class="string">.:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:redis.conf:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2024-07-24T16:02:55Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-conf</span> <span class="comment"># 创建了一个名为redis-conf的配置集</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;14777&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">a626dec1-6e28-4ed0-a5ce-0aaeafffe12f</span></span><br></pre></td></tr></table></figure><p>创建<code>pod</code>来引用这个配置集</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="comment"># 启动命令 如果是直接启动redis，一般写为 redis-server /path/to/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-server</span></span><br><span class="line">      <span class="comment"># 指的是redis容器内部的位置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/redis-master/redis.conf&quot;</span>  </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span> <span class="comment"># 引用名称是叫dada的卷</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/redis-master</span> <span class="comment"># 这里表示挂载pod的这个位置</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 引用名称叫config的卷</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span> <span class="comment"># 创建一个名称叫data的卷</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 创建一个名称叫config的卷</span></span><br><span class="line">      <span class="attr">configMap:</span> <span class="comment"># 它是一个configMap配置集类型</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">redis-conf</span> <span class="comment"># 找到配置集中的这个cm</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">redis.conf</span> <span class="comment"># 获取到key为redis.conf的配置</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">redis.conf</span> <span class="comment"># 把key为redis.conf的配置的值写入到这个地址</span></span><br></pre></td></tr></table></figure><p>注：配置集是具备了热更新的能力，修改了配置集中的配置值的内容，它会同步到<code>pod</code>中配置的制定文件上，但是如果<code>pod</code>中的应用想要获取到配置热更新之后的值，应用本身得拥有热更新的能力。（所以这时可能需要重启<code>pod</code>来读取最新的配置值）</p><h4 id="密钥集Secret"><a href="#密钥集Secret" class="headerlink" title="密钥集Secret"></a>密钥集Secret</h4><p>用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod的定义或者容器镜像中来说更加安全和灵活。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##命令格式</span></span><br><span class="line">kubectl create secret docker-registry regcred \</span><br><span class="line">  --docker-server=&lt;你的镜像仓库服务器&gt; \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br><span class="line">  </span><br><span class="line">kubectl create secret docker-registry cgxin-docker-secret \</span><br><span class="line">--docker-username=leifengyang \</span><br><span class="line">--docker-password=Lfy123456 \</span><br><span class="line">--docker-email=534096094@qq.com</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">private-cgxin-docker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">private-cgxin-docker</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cgxin/cgxin_docker:1.0</span></span><br><span class="line">  <span class="comment"># 加上 Secret  </span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cgxin-docker-secret</span> <span class="comment"># 使用密钥集Secret</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;k8s入门&quot;&gt;&lt;a href=&quot;#k8s入门&quot; class=&quot;headerlink&quot; title=&quot;k8s入门&quot;&gt;&lt;/a&gt;k8s入门&lt;/h1&gt;&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://xiaocainiaoya.github.io/categories/k8s/"/>
    
    
    <category term="k8s" scheme="http://xiaocainiaoya.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>KubeSphere入门</title>
    <link href="http://xiaocainiaoya.github.io/2024/07/29/k8s/KubeSphere%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2024/07/29/k8s/KubeSphere%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-29T13:43:58.000Z</published>
    <updated>2024-08-07T15:57:43.417Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="KubeSphere入门"><a href="#KubeSphere入门" class="headerlink" title="KubeSphere入门"></a>KubeSphere入门</h1><p>全栈的 Kubernetes 容器云 PaaS 解决方案：<a href="https://kubesphere.io/zh/">https://kubesphere.io/zh/</a></p><p>KubeSphere 是在 Kubernetes 之上构建的以应用为中心的多租户容器平台，提供全栈的 IT 自动化运维的能力，简化企业的 DevOps 工作流。KubeSphere 提供了运维友好的向导式操作界面，帮助企业快速构建一个强大和功能丰富的容器云平台。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>KubeSphere有两种安装模式：</p><ul><li>在已有的<code>k8s</code>环境中安装</li><li>在<code>linux</code>环境中安装</li></ul><p>其实<code>KubeSphere</code>的安装已经做的很简便了，不管是使用那种方式进行安装，都是开箱即用，通过简单的几个命令就可以安装成功。</p><h3 id="在已有的k8s环境中安装"><a href="#在已有的k8s环境中安装" class="headerlink" title="在已有的k8s环境中安装"></a>在已有的k8s环境中安装</h3><p>前置环境：<a href="https://kubesphere.io/zh/docs/v3.4/quick-start/minimal-kubesphere-on-k8s/">https://kubesphere.io/zh/docs/v3.4/quick-start/minimal-kubesphere-on-k8s/</a></p><ul><li>在安装之前，需要配置 Kubernetes 集群中的<strong>默认</strong>存储类型。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有机器执行</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在 mster 机器执行：nfs主节点，rw 读写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure><p>从节点配置加入到这个存储NFS中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查，下面的 IP 是master IP</span></span><br><span class="line">showmount -e 192.168.27.251</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器 执行，执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器执行，将远程 和本地的 文件夹 挂载</span></span><br><span class="line">mount -t nfs 192.168.27.251:/nfs/data /nfs/data</span><br></pre></td></tr></table></figure><p>配置默认存储，使其支持动态供应能力。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建了一个存储类</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-storage</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">archiveOnDelete:</span> <span class="string">&quot;true&quot;</span>  <span class="comment">## 删除pv的时候，pv的内容是否要备份</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/nfs-subdir-external-provisioner:v4.0.2</span></span><br><span class="line">          <span class="comment"># resources:</span></span><br><span class="line">          <span class="comment">#    limits:</span></span><br><span class="line">          <span class="comment">#      cpu: 10m</span></span><br><span class="line">          <span class="comment">#    requests:</span></span><br><span class="line">          <span class="comment">#      cpu: 10m</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span> <span class="comment">## 指定自己nfs服务器地址</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span>  </span><br><span class="line">              <span class="attr">value:</span> <span class="string">/nfs/data</span>  <span class="comment">## nfs服务器共享的目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumeclaims&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;storage.k8s.io&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;storageclasses&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;events&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">run-nfs-client-provisioner</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;endpoints&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>集群监控组件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-admin:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-edit:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-view:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:aggregated-metrics-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes/stats</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server-auth-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">extension-apiserver-authentication-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server:system:auth-delegator</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:auth-delegator</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--cert-dir=/tmp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-insecure-tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--secure-port=4443</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-use-node-status-port</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/metrics-server:v0.4.3</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/livez</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">https</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">4443</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/readyz</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">https</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">tmp-dir</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">metrics-server</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">name:</span> <span class="string">tmp-dir</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">v1beta1.metrics.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">  <span class="attr">groupPriorityMinimum:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">insecureSkipTLSVerify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">versionPriority:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>确保您的机器满足安装的前提条件之后，可以按照以下步骤安装 KubeSphere。</p><ol><li><p>执行以下命令开始安装：(可以先把这两个文件通过wget下载下来，然后在通过kubectl执行)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.4.1/kubesphere-installer.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置文件可以控制开启一些可插拔的功能 </span></span><br><span class="line"><span class="comment"># https://kubesphere.io/zh/docs/v3.4/pluggable-components/</span></span><br><span class="line">kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.4.1/cluster-configuration.yaml</span><br></pre></td></tr></table></figure></li><li><p>检查安装日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>kubectl get pod --all-namespaces</code> 查看所有 Pod 是否在 KubeSphere 的相关命名空间中正常运行。如果是，请通过以下命令检查控制台的端口（默认为 <code>30880</code>）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc/ks-console -n kubesphere-system</span><br></pre></td></tr></table></figure></li><li><p>确保在安全组中打开了端口 <code>30880</code>，并通过 NodePort <code>(IP:30880)</code> 使用默认帐户和密码 <code>(admin/P@88w0rd)</code> 访问 Web 控制台。</p></li><li><p>登录控制台后，您可以在<strong>系统组件</strong>中检查不同组件的状态。如果要使用相关服务，可能需要等待某些组件启动并运行。</p></li></ol><p><b>解决etcd监控证书找不到问题</b></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubesphere-monitoring-system create secret generic kube-etcd-client-certs  --from-file=etcd-client-ca.crt=/etc/kubernetes/pki/etcd/ca.crt  --from-file=etcd-client.crt=/etc/kubernetes/pki/apiserver-etcd-client.crt  --from-file=etcd-client.key=/etc/kubernetes/pki/apiserver-etcd-client.key</span><br></pre></td></tr></table></figure><h3 id="在linux环境中安装"><a href="#在linux环境中安装" class="headerlink" title="在linux环境中安装"></a>在linux环境中安装</h3><h4 id="设置服务器名"><a href="#设置服务器名" class="headerlink" title="设置服务器名"></a>设置服务器名</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kubeshpere-master ~]<span class="comment"># hostnamectl set-hostname master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@kubeshpere-node ~]<span class="comment"># hostnamectl set-hostname node</span></span><br></pre></td></tr></table></figure><h4 id="下载KubeKey"><a href="#下载KubeKey" class="headerlink" title="下载KubeKey"></a>下载KubeKey</h4><p>只需要在<code>master</code>节点执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KKZONE=cn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v1.1.1 sh -</span><br><span class="line"></span><br><span class="line">chmod +x kk</span><br></pre></td></tr></table></figure><h4 id="创建集群配置文件"><a href="#创建集群配置文件" class="headerlink" title="创建集群配置文件"></a>创建集群配置文件</h4><p>使用<code>kk</code>工具创建集群的配置文件，执行之后会生成一个<code>config-sample.yaml</code>配置文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ./kk create config --with-kubernetes v1.20.4 --with-kubesphere v3.1.1</span></span><br><span class="line">[root@master ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg  config-sample.yaml  kk  kubekey-v1.1.1-linux-amd64.tar.gz  original-ks.cfg  README.md  README_zh-CN.md</span><br></pre></td></tr></table></figure><p>修改配置文件中的集群信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubekey.kubesphere.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="comment"># 集群的相关信息</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">master</span>, <span class="attr">address:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.17</span>, <span class="attr">internalAddress:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.17</span>, <span class="attr">user:</span> <span class="string">root</span>, <span class="attr">password:</span> <span class="string">jjm7560808</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">node</span>, <span class="attr">address:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.18</span>, <span class="attr">internalAddress:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.18</span>, <span class="attr">user:</span> <span class="string">root</span>, <span class="attr">password:</span> <span class="string">jjm7560808</span>&#125;</span><br><span class="line">  <span class="attr">roleGroups:</span></span><br><span class="line">    <span class="attr">etcd:</span> <span class="comment"># etcd放在那台机器上</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">master:</span> <span class="comment"># 主节点是那台机器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">worker:</span> <span class="comment"># 工作节点是那台机器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># 主节点也作为工作节点</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">controlPlaneEndpoint:</span></span><br><span class="line">    <span class="attr">domain:</span> <span class="string">lb.kubesphere.local</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6443</span></span><br><span class="line">  <span class="attr">kubernetes:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.20.4</span></span><br><span class="line">    <span class="attr">imageRepo:</span> <span class="string">kubesphere</span></span><br><span class="line">    <span class="attr">clusterName:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">network:</span></span><br><span class="line">    <span class="attr">plugin:</span> <span class="string">calico</span></span><br><span class="line">    <span class="attr">kubePodsCIDR:</span> <span class="number">10.233</span><span class="number">.64</span><span class="number">.0</span><span class="string">/18</span></span><br><span class="line">    <span class="attr">kubeServiceCIDR:</span> <span class="number">10.233</span><span class="number">.0</span><span class="number">.0</span><span class="string">/18</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">registryMirrors:</span> []</span><br><span class="line">    <span class="attr">insecureRegistries:</span> []</span><br><span class="line">  <span class="attr">addons:</span> []</span><br></pre></td></tr></table></figure><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ./kk create cluster -f config-sample.yaml</span></span><br><span class="line">+--------+------+------+---------+----------+-------+-------+-----------+--------+------------+-------------+------------------+--------------+</span><br><span class="line">| name   | sudo | curl | openssl | ebtables | socat | ipset | conntrack | docker | nfs client | ceph client | glusterfs client | time         |</span><br><span class="line">+--------+------+------+---------+----------+-------+-------+-----------+--------+------------+-------------+------------------+--------------+</span><br><span class="line">| node   | y    | y    | y       | y        |       | y     |           |        |            |             |                  | CST 22:52:17 |</span><br><span class="line">| master | y    | y    | y       | y        |       | y     |           |        | y          |             | y                | CST 20:07:22 |</span><br><span class="line">+--------+------+------+---------+----------+-------+-------+-----------+--------+------------+-------------+------------------+--------------+</span><br><span class="line">node: conntrack is required. </span><br><span class="line">master: conntrack is required. </span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行之后它会检查每个机器上是否有一些必须安装的项没有安装</span></span><br><span class="line">[root@master ~]<span class="comment"># yum install -y conntrack</span></span><br></pre></td></tr></table></figure><p><b>我在安装的时候出现的问题：</b></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Please, check the contents of the <span class="variable">$HOME</span>/.kube/config file.</span><br><span class="line">ERRO[20:36:11 CST] Failed to add worker to cluster: Failed to <span class="built_in">exec</span> <span class="built_in">command</span>: sudo env PATH=<span class="variable">$PATH</span> /bin/sh -c <span class="string">&quot;/usr/local/bin/kubeadm join  lb.kubesphere.local:6443 --token cizh27.yysycm95alsr418r     --discovery-token-ca-cert-hash sha256:babe3bc05ea57c183e800628d06c42587cc6425822eea5db652b3c28312f944b&quot;</span> </span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING FileExisting-socat]: socat not found <span class="keyword">in</span> system path</span><br><span class="line">        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 26.1.4. Latest validated version: 19.03</span><br><span class="line">error execution phase preflight: couldn<span class="string">&#x27;t validate the identity of the API Server: Get &quot;https://lb.kubesphere.local:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s&quot;: x509: certificate has expired or is not yet valid: current time 2024-08-06T23:23:26+08:00 is before 2024-08-07T12:20:40Z</span></span><br><span class="line"><span class="string">To see the stack trace of this error execute with --v=5 or higher: Process exited with status 1  node=10.211.55.18</span></span><br><span class="line"><span class="string">WARN[20:36:11 CST] Task failed ...                              </span></span><br><span class="line"><span class="string">WARN[20:36:11 CST] error: interrupted by error                  </span></span><br><span class="line"><span class="string">Error: Failed to join node: interrupted by error</span></span><br></pre></td></tr></table></figure><p>找了很多资料都没有找到怎么解决，根据之前逐个安装的经验，感觉是因为<code>calico</code>安装的问题。但是我没有去尝试机器中先安装<code>calico</code>再安装一次，而是跟换了版本，我直接升级到最高版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除旧版</span></span><br><span class="line">./kk create cluster -f config-sample.yaml</span><br><span class="line"></span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.13 sh -</span><br><span class="line"></span><br><span class="line">./kk create config --with-kubesphere v3.4.1 --with-kubernetes v1.22.12</span><br><span class="line"></span><br><span class="line">./kk create cluster -f config-sample.yaml</span><br></pre></td></tr></table></figure><p>尝试最新版之后本以为会一切顺利，没想到在安装后卡在：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please <span class="built_in">wait</span> <span class="keyword">for</span> the installation to complete:     &lt;---&lt;&lt; </span><br></pre></td></tr></table></figure><p>退出进程后，查看集群Pod的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]<span class="comment"># kubectl get pods -A</span></span><br><span class="line">NAMESPACE                      NAME                                             READY   STATUS              RESTARTS        AGE</span><br><span class="line">kube-system                    calico-kube-controllers-5d5bbb5dc-5qpg5          1/1     Running             0               78m</span><br><span class="line">kube-system                    calico-node-b28p6                                1/1     Running             0               78m</span><br><span class="line">kube-system                    calico-node-kslgp                                1/1     Running             2 (6m11s ago)   78m</span><br><span class="line">kube-system                    coredns-5495dd7c88-czhp4                         1/1     Running             0               78m</span><br><span class="line">kube-system                    coredns-5495dd7c88-jdk5j                         1/1     Running             0               78m</span><br><span class="line">kube-system                    kube-apiserver-master                            1/1     Running             2 (6m1s ago)    78m</span><br><span class="line">kube-system                    kube-controller-manager-master                   1/1     Running             7 (6m11s ago)   78m</span><br><span class="line">kube-system                    kube-proxy-2zgvn                                 1/1     Running             2 (6m11s ago)   78m</span><br><span class="line">kube-system                    kube-proxy-jhdpm                                 1/1     Running             0               78m</span><br><span class="line">kube-system                    kube-scheduler-master                            1/1     Running             7 (6m11s ago)   78m</span><br><span class="line">kube-system                    nodelocaldns-2h8bc                               1/1     Running             0               78m</span><br><span class="line">kube-system                    nodelocaldns-bwkwf                               1/1     Running             2 (6m10s ago)   78m</span><br><span class="line">kube-system                    openebs-localpv-provisioner-58d9ff469c-j94fg     1/1     Running             6 (6m ago)      78m</span><br><span class="line">kube-system                    snapshot-controller-0                            0/1     ErrImagePull        0               76m</span><br><span class="line">kubesphere-controls-system     default-http-backend-5bf68ff9b8-l4qwm            0/1     ErrImagePull        0               74m</span><br><span class="line">kubesphere-monitoring-system   kube-state-metrics-554c8c5d65-bthnt              0/3     ErrImagePull        0               68m</span><br><span class="line">kubesphere-monitoring-system   node-exporter-l8245                              0/2     ErrImagePull        0               68m</span><br><span class="line">kubesphere-monitoring-system   node-exporter-vxcqg                              0/2     ContainerCreating   0               68m</span><br><span class="line">kubesphere-monitoring-system   notification-manager-operator-8694799c76-l6zkf   0/2     ContainerCreating   0               63m</span><br><span class="line">kubesphere-monitoring-system   prometheus-operator-8955bbd98-84fml              0/2     ErrImagePull        0               68m</span><br><span class="line">kubesphere-system              ks-apiserver-7fd66f7885-dfsrm                    0/1     ContainerCreating   0               74m</span><br><span class="line">kubesphere-system              ks-console-85c97b6d7d-d4g7w                      0/1     ErrImagePull        0               74m</span><br><span class="line">kubesphere-system              ks-controller-manager-798444f496-gqk2w           0/1     ImagePullBackOff    0               74m</span><br><span class="line">kubesphere-system              ks-installer-5594ffc86d-kl8g6                    1/1     Running             0               78m</span><br></pre></td></tr></table></figure><p>发现好多的容器状态不对，通过<code>describe</code>命令查看状态：看状态像是容器拉取失败，所以尝试修改了对<code>docker</code>配置文件进行修改，添加阿里云的镜像加速。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master docker]<span class="comment"># kubectl describe pod -n kubesphere-monitoring-system node-exporter-vxcqg</span></span><br><span class="line"></span><br><span class="line">  Warning  Failed          26m                kubelet            Failed to pull image <span class="string">&quot;kubesphere/kube-rbac-proxy:v0.11.0&quot;</span>: rpc error: code = Unknown desc = error pulling image configuration: download failed after attempts=6: dial tcp 111.243.214.169:443: i/o timeout</span><br><span class="line">  Warning  Failed          26m (x3 over 62m)  kubelet            Error: ErrImagePull</span><br><span class="line">  Normal   Pulling         26m (x4 over 69m)  kubelet            Pulling image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span></span><br><span class="line">  Warning  Failed          17m (x4 over 66m)  kubelet            Error: ErrImagePull</span><br><span class="line">  Warning  Failed          17m (x2 over 56m)  kubelet            Failed to pull image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span>: rpc error: code = Unknown desc = context canceled</span><br><span class="line">  Normal   Pulling         17m (x4 over 66m)  kubelet            Pulling image <span class="string">&quot;kubesphere/kube-rbac-proxy:v0.11.0&quot;</span></span><br><span class="line">  Normal   SandboxChanged  11m                kubelet            Pod sandbox changed, it will be killed and re-created.</span><br><span class="line">  Normal   Pulling         11m                kubelet            Pulling image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span></span><br><span class="line">  Warning  Failed          8m55s              kubelet            Failed to pull image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span>: rpc error: code = Unknown desc = error pulling image configuration: download failed after attempts=6: dial tcp 128.121.243.228:443: i/o timeout</span><br><span class="line">  Warning  Failed          8m55s              kubelet            Error: ErrImagePull</span><br><span class="line">  Normal   Pulling         8m55s              kubelet            Pulling image <span class="string">&quot;kubesphere/kube-rbac-proxy:v0.11.0&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;KubeSphere入门&quot;&gt;&lt;a href=&quot;#KubeSphere入门&quot; class=&quot;headerlink&quot; title=&quot;KubeSphere入门&quot;&gt;&lt;/a&gt;KubeSphere入门&lt;/h1&gt;&lt;p&gt;全栈的 Kubernetes 容器云 PaaS 解决方案：&lt;a href=&quot;https://kubesphere.io/zh/&quot;&gt;https://kubesphere.io/zh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;KubeSphere 是在 Kubernetes 之上构建的以应用为中心的多租户容器平台，提供全栈的 IT 自动化运维的能力，简化企业的 DevOps 工作流。KubeSphere 提供了运维友好的向导式操作界面，帮助企业快速构建一个强大和功能丰富的容器云平台。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://xiaocainiaoya.github.io/categories/k8s/"/>
    
    
    <category term="k8s" scheme="http://xiaocainiaoya.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Type接口</title>
    <link href="http://xiaocainiaoya.github.io/2024/06/24/java/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://xiaocainiaoya.github.io/2024/06/24/java/%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-06-24T13:43:58.000Z</published>
    <updated>2024-06-25T14:06:06.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>​    序列化是将数据对象转换为可传输格式的过程。是一种数据持久化的手段，一般广泛应用于网络传输、RPC、RMI等场景中。</p><span id="more"></span><p>常见的序列化框架：</p><table><thead><tr><th>java</th><th>jdk自带，使用方便，可序列化所有类，速度慢，占空间</th></tr></thead><tbody><tr><td>protobuf</td><td>速度快，但需要先进行静态编译</td></tr><tr><td>kryo</td><td>速度快，序列化后体积小；跨语言支持较复杂</td></tr></tbody></table><p>在<code>java</code>的序列化机制中，需要进行序列化的对象需要实现<code>Serializable</code>接口，这个接口没有方法或者字段，单纯是为了表示可序列化语义。自定义的类通过实现<code>Serializable</code>接口，进而在<code>IO</code>过程中实现序列化和反序列化。</p><p>在序列化过程中，会对将要序列化/方序列化的类进行检查，要求操作对象必须是字符串、枚举类、数组类型或者是实现了<code>Serializable</code>的类。</p><p>创建一个继承于<code>Serializable</code>接口的类，然后通过流处理将这个类写入到<code>1.txt</code>中，注意，这里写入之后，如果直接打开文件，会发现这是个乱码文件，这是因为序列化写入的是二进制文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend friend = <span class="keyword">new</span> Friend();</span><br><span class="line">        friend.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">            objectOutputStream.writeObject(friend);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义序列化逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的序列化调用链：<code>objectOutputStream.writeObject()</code> &rarr;<code>writeObject0(obj, false);</code> &rarr; <code>writeOrdinaryObject(obj, desc, unshared);</code>(区分是<code>Serializable</code>还是<code>Externalizable</code>)&rarr;如果没有实现自定义的序列化策略则调用<code>defaultWriteFields(obj, slotDesc);</code>，如果实现了自定义序列化策略，则通过反射调用到自定义序列化策略<code>slotDesc.invokeWriteObject(obj, this);</code>。</p><p>但是需要注意，就算是自定义了序列化接口<code>writeObject()</code>，且不进行写入动作，最终的输出文件依然不会是空文件，为了反序列化，包含了一些格式信息，不单纯只有数据，比如有字段类型等信息。</p><p><b>Externalizable</b>的作用是什么？</p><p>它相比于<code>Serializable</code>更为灵活，比如一个类有一个父类，在序列化时，如果也想序列化父类中的属性，则这个父类也需要实现<code>Serializable</code>接口；另一种做法是是子类实现<code>Externalizable</code>接口，但是实现该接口需要重写<code>writeExternal()</code>和<code>readExternal()</code>方法，这种情况下就可以指定需要序列化的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        name = in.readUTF();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>serialVersionUID的作用？</b></p><p>一般一个类在继承<code>Serializable</code>接口后，都会定义一个字段<code>private static final long serialVersionUID = 1L;</code>，那么它的作用是什么？</p><p>它主要是用来校验是否允许进行反序列化的，当将某个类进行序列化后，比如是存储到文件中，会将这个值也序列化到文件中，当进行反序列化时，将这个<code>serialVerionUID</code>进行比对，如果不一致，则抛出<code>InvalidCastException</code>异常。</p><p>如果类发生了改变（比如新增字段、删除字段、改变字段类型等），这时如果进行反序列化，可能出现不匹配的情况，如果没有显示声明这个字段值，<code>java</code>会生成一个默认的<code>serialVersionUID</code>，这个值是基于类的结构生成的，当类的结构发生变化的时候，再次序列化时这个值也会发生变化，就会导致使用变更之前的数据进行反序列化会抛出异常。但是我们在使用时，通常为了确保即使类发生了变化，也要序列化成功，会显示的声明这个值。</p><p><b>数组的序列化</b></p><p>在序列化的过程中，如果被序列化对象自定义实现了<code>writeObject()</code>和<code>readObject()</code>方法，则会尝试使用自定义的方法进行序列化和方序列化。</p><p>在<code>ArrayList</code>中，它的存储是<code>transient Object[] elementData</code>，但是这个对象数组又被声明为<code>transient</code>，所以在默认的序列化策略中，并不会对它进行序列化，这是因为<code>ArrayList</code>是动态数组，每次在放满之后会进行动态的扩容，那么就会出现一个数组中有多个<code>null</code>元素，为了保证<code>null</code>元素不被序列化，所以将数组设置为<code>transient</code>后，通过自定义序列化策略进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span><span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 写入固定格式</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入容器大小</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入元素值，只循环size次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span><span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 也只读出size值的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h1&gt;&lt;p&gt;​    序列化是将数据对象转换为可传输格式的过程。是一种数据持久化的手段，一般广泛应用于网络传输、RPC、RMI等场景中。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring日志系统</title>
    <link href="http://xiaocainiaoya.github.io/2024/05/22/Spring/spring%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://xiaocainiaoya.github.io/2024/05/22/Spring/spring%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-05-22T12:53:58.000Z</published>
    <updated>2024-06-04T07:50:07.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring日志系统"><a href="#spring日志系统" class="headerlink" title="spring日志系统"></a>spring日志系统</h1><p>​    <code>spring</code>通过门面模式来应对项目中依赖不同的组件时，各组件使用不同的日志框架，有<code>log4j</code>、<code>log4j2</code>、<code>lockback</code>等，门面有<code>sl4j</code>和<code>commons-logging</code>。</p><span id="more"></span><p><img src="https://s2.loli.net/2024/05/22/KxUy7luX86DkjCB.png" alt=".png"></p><p>在开发的过程中，经常需要使用到日志框架来打印一些信息，来帮助开发者定位产生的相关问题等，在使用时只需要通过<code>log.info()</code>等方式就可以打印出一条日志信息，但是这条日志是如何打印出来，理清日志框架的工作过程及原理，能有效帮助开发者扩展日志功能以及优雅的进行日志打印等级切换等等。</p><h2 id="springboot日志框架"><a href="#springboot日志框架" class="headerlink" title="springboot日志框架"></a>springboot日志框架</h2><p><code>springboot</code>的默认日志框架是<code>logback</code>。具官网介绍<code>logback</code>的性能高于<code>log4j</code>，而<code>log4j2</code>是在<code>logback</code>之后诞生的，性能高于<code>logback</code>。<code>springboot</code>中默认引入的是<code>logback</code>日志框架，如果需要在<code>springboot</code>项目中使用<code>sl4j2</code>作为日志框架，需要将原生框架中的<code>logback</code>依赖排除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--排除lockback的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入log4j2依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    然后就可以在<code>resource</code>下创建<code>sl4j2.xml</code>配置文件，配置一些打印相关操作，比如指定多个打印器，指定打印路径，指定打印格式、打印等级等等。当然，也可以不创建这个配置文件，在<code>springboot</code>有兜底配置。</p><p>​    接着一步步来了解一下，以及<code>springboot</code>是如果设计，达到可以自由切换日志框架的目的。以及<code>sl4j2</code>的一些工作原理。</p><p>​    如果项目中结合了<code>lombok</code>可以发现，在实体上标记了<code>@Slf4j</code>之后，就可以通过<code>log</code>对象来打印日志，而这个打印日志的<code>log</code>对象就是<code>org.slf4j.Logger</code>类对象，它仅仅是定义了一系列的日志打印接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object arg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String msg, Throwable t)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果工程是使用<code>sl4j2</code>，那么此时就会进入到<code>org.apache.logging.slf4j.Log4jLogger</code>，它是<code>org.slf4j.Logger</code>门面接口的实现，它是在依赖<code>org.apache.logging.log4j:log4j-slf4j-impl</code>中。</p><p>如果工程是使用<code>logback</code>，那么此时就会进入到<code>ch.qos.logback.classic.Logger</code>，它也是<code>org.slf4j.Logger</code>门面对象的实现，他是在依赖<code>ch.qos.logback:logback-classis</code>中，这里要注意，<code>loback</code>对门面接口类的实现的类的名称也是叫<code>Logger</code>。</p><h2 id="log4j2的简单工作原理"><a href="#log4j2的简单工作原理" class="headerlink" title="log4j2的简单工作原理"></a>log4j2的简单工作原理</h2><p>从上述可以知道，其实打印日志都是获取<code>Logger</code>对象，通过它来进行日志打印操作。在<code>log4j2</code>中的<code>Logger</code>对象有两个属性<code>PrivateConfig</code>和<code>LoggerContext</code>。</p><ul><li><code>PrivateConfig</code>中包含了通过<code>log4j2.xml</code>文件解析出来的<code>appender</code>和具体的<code>logger</code>。</li><li><code>LoggerContext</code>是根据配置规则，缓存了每个类打印时需要使用到的<code>logger</code>和<code>appender</code>的关系。</li></ul><p><img src="https://s2.loli.net/2024/06/03/sJRqwL2lvr1TkGO.png" alt="logger.png"></p><p>在配置文件中的&lt;Appenders&gt;标签下每增加一项，解析得到的<code>Configuration</code>中的<code>Appenders</code>就多一个<code>Appender</code>。在&lt;Loggers&gt;标签下每增加一项，解析得到的<code>Configuration</code>中的<code>loggerConfigs</code>就多一项。</p><p>在<code>LoggerConfig</code>中持有所有<code>Appender</code>的引用，而解析后的<code>Configuration</code>中的<code>loggerConfigs</code>表示的是某一个<code>logger</code>持有的<code>Appender</code>引用。</p><p>如果需要使用到打印，都会先到<code>LoggerContext</code>的注册器<code>LoggerRegistry</code>中获取，如果没有，则会创建出一个<code>Logger</code>并注册到<code>LoggerRegistry</code>中。</p><p><img src="https://s2.loli.net/2024/06/03/f7j52o8GTA6bdFM.png" alt="loggerRegistry.png"></p><p>比方说我这个工程中的这个类<code>cn.com.xiaocainiaoya.common.CustomizeConfiguration</code>，如果需要打印就会从这个注册器中获取到这个<code>Logger</code>，然后通过这个<code>Logger</code>的日志等级配置以及<code>Appender</code>等等进行打印操作。</p><h2 id="Springboot日志启动机制"><a href="#Springboot日志启动机制" class="headerlink" title="Springboot日志启动机制"></a>Springboot日志启动机制</h2><p><code>Springboot</code>的日志启动依赖于<code>springboot</code>的事件监听机制，在<code>spring</code>的启动过程中，需要进行一系列的准备、加载等动作，所以<code>Spring</code>在对容器最终加载完成的整个生命周期中，设置了很多监听事件，比如刚刚启动容器、<code>Enviroment</code>准备完成、<code>ApplicatonContext</code>准备完成等等。日志启动是依赖于<code>LoggingApplicationListener</code>类，它实现了<code>ApplicationListener</code>的封装类<code>GenericApplicationListener</code>，所以它能接收到多种消息事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在启动SpringApplicatioin之后就发布了事件，先于Environment和ApplicationContext可用之前发布</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationStartingEvent) &#123;</span><br><span class="line">        onApplicationStartingEvent((ApplicationStartingEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Environment加载完成之后立即发布</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">        onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ApplicationContext准备好后但是刷新容器之前发布</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">        onApplicationPreparedEvent((ApplicationPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent</span><br><span class="line">            &amp;&amp; ((ContextClosedEvent) event).getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onContextClosedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationFailedEvent) &#123;</span><br><span class="line">        onApplicationFailedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>1.监听到<code>ApplicationStartingEvent</code>事件</b></p><p>在<code>Springboot</code>中操作日志最关键的一个对象就是<code>LoggingSystem</code>，这个对象在整个生命周期中掌握着日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationStartingEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem.beforeInitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在接收到这个事件通知之后，就到系统属性中去读取<code>LoggingSystem</code>具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; systems = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    systems.put(<span class="string">&quot;ch.qos.logback.core.Appender&quot;</span>, <span class="string">&quot;org.springframework.boot.logging.logback.LogbackLoggingSystem&quot;</span>);</span><br><span class="line">    systems.put(<span class="string">&quot;org.apache.logging.log4j.core.impl.Log4jContextFactory&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.springframework.boot.logging.log4j2.Log4J2LoggingSystem&quot;</span>);</span><br><span class="line">    systems.put(<span class="string">&quot;java.util.logging.LogManager&quot;</span>, <span class="string">&quot;org.springframework.boot.logging.java.JavaLoggingSystem&quot;</span>);</span><br><span class="line">    SYSTEMS = Collections.unmodifiableMap(systems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次加载的时候会从以上的SYSTEMS的map中去找，通过类加载器，逐个查找，看哪一个类是在类路径中，就启用哪一个LoggingSystem。我这里使用的是Log4j日志框架，那么这里就会找到并加载Log4J2LoggingSystem。如果使用的是logback，那么加载的就是LogbackLoggingSystem。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggingSystem <span class="title">get</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String loggingSystem = System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(loggingSystem)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NONE.equals(loggingSystem)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NoOpLoggingSystem();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(classLoader, loggingSystem);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 通过类加载器来找有没有引入对应的类，第一个匹配到谁就是谁</span></span><br><span class="line">    <span class="keyword">return</span> SYSTEMS.entrySet().stream().filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))</span><br><span class="line">            .map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No suitable logging system located&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到<code>LogginSystem</code>之后，就会调用它的<code>beforeInitialize()</code>，这个方法的主要作用就是进行一些事前初始化动作，这里添加了一个日志过滤器，但实际上是一个阻断器，这个阻断器拒绝了所有的日志打印。所以到达这一步，仍然是无法打印出日志的，就算日志框架接收到需要打印日志的请求，也会被阻断器拒绝。这样的设计是为了防止日志系统在完成初始化之前打印出不可控的日志信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.beforeInitialize();</span><br><span class="line">    loggerContext.getConfiguration().addFilter(FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.监听到<code>ApplicationEnvironmentPreparedEvent</code>事件</b></p><p>当<code>Environment</code>准备完成之后，继续进行日志框架的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggingSystem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用enviroment中配置的信息对日志框架进行初始化</span></span><br><span class="line">    initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableEnvironment environment, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把在enviroment中的配置信息读取出来，并设置到system中，比如有打印文件的路径</span></span><br><span class="line">    <span class="comment">// 文件大小、打印格式等等</span></span><br><span class="line">    <span class="keyword">new</span> LoggingSystemProperties(environment).apply();</span><br><span class="line">    <span class="keyword">this</span>.logFile = LogFile.get(environment);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logFile.applyToSystemProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将预制的web和sql日志打印初始化LoggerGroups</span></span><br><span class="line">    <span class="keyword">this</span>.loggerGroups = <span class="keyword">new</span> LoggerGroups(DEFAULT_GROUP_LOGGERS);</span><br><span class="line">    <span class="comment">// 读取系统级别的debug或者trace是否设置为true</span></span><br><span class="line">    <span class="comment">// 哪个类型为true就将springbootLogging的级别设置为那个</span></span><br><span class="line">    <span class="comment">// trace的优先级高于debug</span></span><br><span class="line">    initializeEarlyLoggingLevel(environment);</span><br><span class="line">    <span class="comment">// 执行loggingSystem.initialize()初始化方法</span></span><br><span class="line">    initializeSystem(environment, <span class="keyword">this</span>.loggingSystem, <span class="keyword">this</span>.logFile);</span><br><span class="line">    <span class="comment">// 完成日志打印组和日志打印器的级别的设置</span></span><br><span class="line">    initializeFinalLoggingLevels(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">    registerShutdownHookIfNecessary(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来看下<code>LoggingSystem</code>的初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeSystem</span><span class="params">(ConfigurableEnvironment environment, LoggingSystem system, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    LoggingInitializationContext initializationContext = <span class="keyword">new</span> LoggingInitializationContext(environment);</span><br><span class="line">    <span class="comment">// 从系统变量中获取logging.config</span></span><br><span class="line">    String logConfig = environment.getProperty(CONFIG_PROPERTY);</span><br><span class="line">    <span class="comment">// 如果没有就根据规则从类路径中找</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreLogConfig(logConfig)) &#123;</span><br><span class="line">        system.initialize(initializationContext, <span class="keyword">null</span>, logFile);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果有，就直接加载指定的文件。所以如果通过yaml直接配置，或者通过jar启动命令指定</span></span><br><span class="line">        <span class="comment">// 就直接走到这里</span></span><br><span class="line">        <span class="comment">// ... 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达Log4J2LoggingSystem的初始化方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里移除了前面设置的日志阻断器</span></span><br><span class="line">    loggerContext.getConfiguration().removeFilter(FILTER);</span><br><span class="line">    <span class="comment">// 调用父类方法找到log4j2的配置文件，并进行初始化</span></span><br><span class="line">    <span class="keyword">super</span>.initialize(initializationContext, configLocation, logFile);</span><br><span class="line">    <span class="comment">// 标记初始化完成</span></span><br><span class="line">    markAsInitialized(loggerContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类方法最终会走到这里，按类路径查找，</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithConventions</span><span class="params">(LoggingInitializationContext initializationContext, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑上是要找到一个 classpath:xxxx的地址</span></span><br><span class="line">    String config = getSelfInitializationConfig();</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; logFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把这个配置文件中的东西解析出来为Configuration</span></span><br><span class="line">        reinitialize(initializationContext);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">        config = getSpringInitializationConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadConfiguration(initializationContext, config, logFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadDefaults(initializationContext, logFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就会将日志打印器<code>logger</code>进行分组。这样做的好处是便于管理，分组之后，如果需要对某个组改日志级别，只需要将这个组的日志级别进行修改，就不需要逐个去找打印器并进行修改。</p><p><img src="https://s2.loli.net/2024/06/03/M6NR7afJlAHk5Xn.png" alt="loggerGroups.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 可以通过yaml进行设置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">common:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line">    <span class="attr">common:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cn.com.xiaocainiaoya.common</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">com.lee.xiaocainiaoya.user</span></span><br></pre></td></tr></table></figure><p>如果设置了<code>trace=true</code>或者是<code>bebud=true</code>，那么<code>springboot</code>会将自己的某些类的打印开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeFinalLoggingLevels</span><span class="params">(ConfigurableEnvironment environment, LoggingSystem system)</span> </span>&#123;</span><br><span class="line">    bindLoggerGroups(environment);</span><br><span class="line">    <span class="comment">// 只要trace=true 或者是 debug=true就开启springbootlogging</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.springBootLogging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        initializeLogLevel(system, <span class="keyword">this</span>.springBootLogging);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置用户自定义的打印器的日志级别</span></span><br><span class="line">    setLogLevels(system, environment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeLogLevel</span><span class="params">(LoggingSystem system, LogLevel springBootLogging)</span> </span>&#123;</span><br><span class="line">    initializeSpringBootLogging(system, springBootLogging);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeSpringBootLogging</span><span class="params">(LoggingSystem system, LogLevel springBootLogging)</span> </span>&#123;</span><br><span class="line">    BiConsumer&lt;String, LogLevel&gt; configurer = getLogLevelConfigurer(system);</span><br><span class="line">    SPRING_BOOT_LOGGING_LOGGERS.getOrDefault(springBootLogging, Collections.emptyList())</span><br><span class="line">            .forEach((name) -&gt; configureLogLevel(name, springBootLogging, configurer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    MultiValueMap&lt;LogLevel, String&gt; loggers = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 如果是debug就开这些</span></span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;web&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;org.springframework.boot&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果是trace 就开这些</span></span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.springframework&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.apache.tomcat&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.apache.catalina&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.eclipse.jetty&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.hibernate.tool.hbm2ddl&quot;</span>);</span><br><span class="line">    SPRING_BOOT_LOGGING_LOGGERS = Collections.unmodifiableMap(loggers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能按组设置就按组设置，不能按组设置就单独设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureLogLevel</span><span class="params">(String name, LogLevel level, BiConsumer&lt;String, LogLevel&gt; configurer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggerGroups != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LoggerGroup group = <span class="keyword">this</span>.loggerGroups.get(name);</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.hasMembers()) &#123;</span><br><span class="line">            group.configureLogLevel(level, configurer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    configurer.accept(name, level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>3.监听到<code>ApplicationPreparedEvent</code>事件</b></p><h3 id="日志级别热更新"><a href="#日志级别热更新" class="headerlink" title="日志级别热更新"></a>日志级别热更新</h3><p>其实对应的日志框架都已经提供了对应的日志级别更新方法，只需要获取到<code>LoggingSystem</code>类，并调用<code>setLogLevel</code>方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingSystem.setLogLevel(<span class="string">&quot;cn.com.xiaocainiaoya.BootStrap&quot;</span>, LogLevel.DEBUG);</span><br></pre></td></tr></table></figure><p>这里简单分析一下过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogLevel</span><span class="params">(String loggerName, LogLevel logLevel)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 转换为log4j对应的日志级别枚举类</span></span><br><span class="line">Level level = LEVELS.convertSystemToNative(logLevel);</span><br><span class="line"><span class="comment">// 到Configuration中去找这个loggerName的LoggerConfig(初始化之后所有的LoggerConfig都在这里)</span></span><br><span class="line">LoggerConfig loggerConfig = getLoggerConfig(loggerName);</span><br><span class="line"><span class="comment">// 如果不存在，则需要创建这个LoggerConfig，并添加到Configuration的ConcurrentMap&lt;String, LoggerConfig&gt; loggerConfigs中。</span></span><br><span class="line"><span class="keyword">if</span> (loggerConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">loggerConfig = <span class="keyword">new</span> LoggerConfig(loggerName, level, <span class="keyword">true</span>);</span><br><span class="line">getLoggerContext().getConfiguration().addLogger(loggerName, loggerConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果存在，则直接更新这个loggerConfig的日志级别</span></span><br><span class="line">loggerConfig.setLevel(level);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⭐️逐个更新loagger</span></span><br><span class="line">getLoggerContext().updateLoggers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateLoggers</span><span class="params">(<span class="keyword">final</span> Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Configuration old = <span class="keyword">this</span>.configuration;</span><br><span class="line">    <span class="comment">// 逐个更新loagger</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Logger logger : loggerRegistry.getLoggers()) &#123;</span><br><span class="line">        logger.updateConfiguration(config);</span><br><span class="line">    &#125;</span><br><span class="line">    firePropertyChangeEvent(<span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>, PROPERTY_CONFIG, old, config));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateConfiguration</span><span class="params">(<span class="keyword">final</span> Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.privateConfig = <span class="keyword">new</span> PrivateConfig(newConfig, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我刚看到这个地方时候，我是有点困惑的，在我标记⭐️的地方。在更新完<code>loggerConfig</code>的的日志级别之后，尽然需要将所有的<code>loggerRegistry</code>都取出来进行重新创建<code>PrivateConfig</code>。难道不是<code>loggerConfig</code>的日志级别修改了之后持有这个对象的引用获取到信息也是更新之后的值。但是其实这里是有可能获取不到<code>loggerConfig</code>，那么就需要创建一个新的<code>loggerConfig</code>到<code>Configuration</code>池子里。根据日志名称匹配规则，新增了一个<code>loggerConfig</code>那么其实对缓存中的所有信息有所影响，比如某个类的全限定类名是<code>cn.com.xiaocainiao.FeignUtil</code>，原本它是使用名称为<code>root</code>的打印器，但是我调用<code>setLogLevel(&quot;cn.com.xiaocainiao&quot;, &quot;DEBUG&quot;)</code>那么这时会创建一个新的打印器器，也就导致了<code>cn.com.xiaocainiao.FeignUtil</code>应该使用新创建的这个打印器，而不是根打印器，所以这里的将所有的<code>logger</code>进行了更新。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring日志系统&quot;&gt;&lt;a href=&quot;#spring日志系统&quot; class=&quot;headerlink&quot; title=&quot;spring日志系统&quot;&gt;&lt;/a&gt;spring日志系统&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;通过门面模式来应对项目中依赖不同的组件时，各组件使用不同的日志框架，有&lt;code&gt;log4j&lt;/code&gt;、&lt;code&gt;log4j2&lt;/code&gt;、&lt;code&gt;lockback&lt;/code&gt;等，门面有&lt;code&gt;sl4j&lt;/code&gt;和&lt;code&gt;commons-logging&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事务的aop浅析</title>
    <link href="http://xiaocainiaoya.github.io/2024/04/15/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84aop%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2024/04/15/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84aop%E6%B5%85%E6%9E%90/</id>
    <published>2024-04-15T13:49:00.000Z</published>
    <updated>2024-04-16T13:55:49.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring事务的aop浅析"><a href="#Spring事务的aop浅析" class="headerlink" title="Spring事务的aop浅析"></a>Spring事务的aop浅析</h1><p>​    结合之前说到的<a href="https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/" target="_blank">SpringAop浅析（二）</a>本篇将从事务的角度，来看下<code>spring</code>或者说<code>springboot</code>是如何通过一些简单的配置就可以将一些方法进行事务的管理，并了解一些事务在管理过程中的一些简单<code>api</code>。</p><span id="more"></span><h2 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h2><p>​    在没有<code>spring</code>之前，或者说在不引入<code>spring</code>的时候，在获取数据库访问的时候，通常是通过<code>Connection</code>来进行。通过<code>Connection</code>类来进行<code>sql</code>的执行操作，然后在<code>sql</code>执行完毕之后调用<code>commit()</code>方法，将事务提交，当然了，在借助<code>spring</code>框架之后，在编码过程中，再也没有通过这种方式来进行事务的提交。但是大差不差，这些事情是一定要做的，既然我们在编码过程中没有做，那么这件事情就一定被<code>spring</code>做了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = getConnection();</span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//执行一系列的sql</span></span><br><span class="line">conn.commit();</span><br></pre></td></tr></table></figure><p>​    根据上篇文章<code>springAop</code>，不难猜测，<code>spring</code>肯定是借助于<code>aop</code>，对标记了<code>@Transactional</code>的方法进行拦截并进行事务的增强。那么它是怎么实现的呢？</p><p>在<code>spring</code>中开启事务需要通过<code>EnableTransactionManagement</code>注解，实际上就是通过它来进行一些开箱即用的处理。这个注解的实现上引入了<code>@Import</code>注解，这个注解的作用是为了将某些类引入到<code>Spring</code>容器中。这样做有一个好处是，在启用这个注解的情况下，才引入某些类到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到<code>TransactionManagementConfigurationSelector</code>类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableTransactionManagement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过selectImports方法将某些类加载到容器中，这个方法返回一个字符串数组</span></span><br><span class="line"><span class="comment"> * 这个字符串是类的全限定类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line"><span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line"><span class="keyword">case</span> PROXY:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line"><span class="keyword">case</span> ASPECTJ:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来了，这里引入了两个类：</p><ol><li><code>AutoProxyRegistrar</code></li><li><code>ProxyTransactionManagementConfiguration</code></li></ol><h3 id="1-AutoProxyRegistar"><a href="#1-AutoProxyRegistar" class="headerlink" title="1.AutoProxyRegistar"></a>1.AutoProxyRegistar</h3><p>它实现了<code>ImportBeanDefinitionRegistrar</code>接口。所以它的主要作用是将<code>InfrastructureAdvisorAutoProxyCreator</code>这个后置处理器类注入到容器中，那么容器在进行每一个<code>bean</code>对象初始化时都会将这个后置处理作用在对应的<code>bean</code>上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 它的主要作用在AopConfigUtils.registerAutoProxyCreatorIfNecessary中，为了将org.springframework.aop.framework.autoproxy.InfrastructureAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * 类注册到spring中，这个类实现了spring的后置处理器，主要作用是在spring的bean初始化的过程中，对bean进行检查，如果符合一定的条件</span></span><br><span class="line"><span class="comment"> * 则把这个bean的aop代理对象注入到spring容器中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line"><span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line"><span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object mode = candidate.get(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">Object proxyTargetClass = candidate.get(<span class="string">&quot;proxyTargetClass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;</span><br><span class="line">Boolean.class == proxyTargetClass.getClass()) &#123;</span><br><span class="line">candidateFound = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"><span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下<code>InfrastructureAdvisorAutoProxyCreator</code>类。它自己本身没有什么太多的实现，它继承与<code>AbstractAdvisorAutoProxyCreator</code>抽象类，这个抽象类实现了一些查询那些增强可以作用在目标<code>bean</code>对象上处理。本篇想聊的后置处理的实现是在它的父类<code>AbstractAutoProxyCreator</code>上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfrastructureAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AbstractAutoProxyCreator</code>中，实现了具体的后置处理的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里获取到需要的增强链，这里会获取到刚刚最早提到的，通过@EnableTransactionManagement</span></span><br><span class="line">  <span class="comment">// 的import注解注入了两个类的第二个类，第二个配置类的作用是引入事务增强类。</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-ProxyTransactionManagementConfiguration"><a href="#1-ProxyTransactionManagementConfiguration" class="headerlink" title="1.ProxyTransactionManagementConfiguration"></a>1.ProxyTransactionManagementConfiguration</h3><p>上面已经给出了结论，这个类的作用是引入了事务处理需要使用到的增强类。使得<code>springBean</code>对象在初始化时进入到后置处理器中，后置处理器再获取到这个类通过<code>@Bean</code>注解注入到容器中的增强类，从而实现将需要进行事务处理的类进行代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入到容器中的事务增强类，它是Advisor接口的实现。它有两个参数，这两个参数也是通过容器来获取</span></span><br><span class="line"><span class="comment"> * 也是在下方进行声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">TransactionAttributeSource transactionAttributeSource,</span></span></span><br><span class="line"><span class="function"><span class="params">TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line">BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">advisor.setAdvice(transactionInterceptor);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面增强类的第一个参数，这个bean的作用主要是用来获取事务属性的；比如配置的传播机制，异常信息等等；</span></span><br><span class="line"><span class="comment"> * 这个bean当中提供了一个方法来获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面增强类的第二个参数，这个bean的作用主要是用来拦截，拦截目标方法之后进行事务的开启、提交、回滚等动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下<code>BeanFactoryTransactionAttributeSourceAdvisor</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义了切点的查找规则，也就是说bean进入了前面提到的后置处理器之后，会取出容器中的所有增强通知，然后逐个进行匹配</span></span><br><span class="line"><span class="comment">// 看遍历的到的通知是否需要作用到bean对象中，当遍历到这个增强时，就会通过TransactionAttributeSource类来进行匹配</span></span><br><span class="line"><span class="comment">// 也就是导入的配置类ProxyTransactionManagementConfiguration中定义的第二个bean对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里具体的匹配规则在类<code>AnnotationTransactionAttributeSource</code>中。</p><p>具体的匹配规则在它的父类<code>AbstractFallbackTransactionAttributeSource#getTransactionAttribute()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 计算是否匹配</span></span><br><span class="line">TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line"><span class="comment">// ...省略代码，主要是推入缓存</span></span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..省略代码，主要是前置校验，是不是已经是代理类等等的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点在这，通过这个方法获取到TransactionAttribute对象</span></span><br><span class="line"><span class="comment">// 这个方法的实现由AnnotationTransactionAttributeSource自己实现</span></span><br><span class="line">TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到<code>AnnotationTransactionAttributeSource</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">findTransactionAttribute</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line"><span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> attr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终走到SpringTransactionAnnotationParser中，通过这个方法获取被@Transactional标记的方法或者类的信息</span></span><br><span class="line"><span class="comment">// 将@Transactional中定制化配置的信息读取到AnnotationAttributes对象中。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <code>spring</code>事务的代理是通过<code>@EnableTransactionManagement</code>注解来开启，这个注解通过<code>@Import</code>注解来导入两个类，一个类是后置处理器，它的作用是在每个<code>bean</code>对象创建之后将第二个导入类中定义的增强作用在这个对象上，并形成代理对象。第二个导入类的作用是定义了一个增强，这个增强包含了如何确定切面、切点、连接点等信息，也包含了拦截的逻辑，也就是事务的开启、提交和回滚等处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring事务的aop浅析&quot;&gt;&lt;a href=&quot;#Spring事务的aop浅析&quot; class=&quot;headerlink&quot; title=&quot;Spring事务的aop浅析&quot;&gt;&lt;/a&gt;Spring事务的aop浅析&lt;/h1&gt;&lt;p&gt;​    结合之前说到的&lt;a href=&quot;https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/&quot; target=&quot;_blank&quot;&gt;SpringAop浅析（二）&lt;/a&gt;本篇将从事务的角度，来看下&lt;code&gt;spring&lt;/code&gt;或者说&lt;code&gt;springboot&lt;/code&gt;是如何通过一些简单的配置就可以将一些方法进行事务的管理，并了解一些事务在管理过程中的一些简单&lt;code&gt;api&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringAop浅析（二）</title>
    <link href="http://xiaocainiaoya.github.io/2024/04/11/Spring/SpringAop%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2024/04/11/Spring/SpringAop%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-04-11T14:22:00.000Z</published>
    <updated>2024-04-15T13:48:06.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringAop浅析（二）"><a href="#SpringAop浅析（二）" class="headerlink" title="SpringAop浅析（二）"></a>SpringAop浅析（二）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    接两年前的旧文<a href="https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/" target="_blank">SpringAop浅析</a>，时隔两年再一次对<code>SpringAop</code>相关源码进行分析，只能说之前阅读的不够透彻，理解的不扎实，再加上工作上常年忙于业务的处理，现在已经少有看源码的时间，不过最近不知道是因为什么打了鸡血，还是想再沉淀沉淀。</p><span id="more"></span><h2 id="上篇回顾"><a href="#上篇回顾" class="headerlink" title="上篇回顾"></a>上篇回顾</h2><p>​    前面说到<code>SpringAop</code>的大致创建时机、创建流程和基本的调用流程。<code>SpringAop</code>是采用动态代理的方式实现，通过<code>@EnableAspectJAutoProxy</code>的方式开启，开启的原理为添加<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanDefinitionMap</code>中；在<code>Bean</code>对象实例化之前可以通过用户自定义的方式进行提前生成代理对象。或者是在<code>Bean</code>对象初始化之后，通过上述后置处理器的<code>postProcessAfterInitialization</code>方法，将<code>Bean</code>对象转为代理对象。</p><p>本篇想说明一个问题：被<code>SpringAop</code>代理之后的对象是什么对象？在调用被代理方法时，它具体的执行过程？</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>​    直接<code>debug</code>可以得知，被<code>SpringAop</code>代理之后的对象是<code>CglibAopProxy#DynamicAdvisedInterceptor</code>类的实现。（使用<code>cglib</code>代理的前提）</p><p>这个类是<code>CglibAopProxy</code>的内部类，它实现了<code>MethodInterceptor</code>接口，学过<code>cglib</code>动态代理的知道<code>MethodInterceptor</code>是它的代理类的增强，所以<code>DynamicAdvisedInterceptor</code>这个类就是为了<code>aop</code>来做增强的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ...代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它定义了<code>AdvisedSupport</code>增强支持类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个类记录了被代理对象、被代理方法等等一系列的动态代理需要的参数等</span></span><br><span class="line">    <span class="comment">// 这个是一个重要的参数，它记录了这个被代理对象需要被执行增强的列表</span></span><br><span class="line">    <span class="comment">// 比如说你定义了一个方法，需要在这个方法上做</span></span><br><span class="line">    <span class="comment">// 1.打印访问时长的增强A，</span></span><br><span class="line">    <span class="comment">// 2.记录方法执行前后参数、返回值的增强B</span></span><br><span class="line">    <span class="comment">// 都会被记录在这个列表里</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以到这里可以知道，在项目中我们通过<code>SpringAop</code>得到的代理对象的增强是<code>DynamicAdvisedInterceptor</code>。故在执行被代理方法时，会直接进入到它的拦截方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在被代理类初始化时，会根据一些匹配规则，将符合条件的增强放置在列表中，这里把这个列表里的增强取出</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">        <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建CglibMethodInvocation类，并执行processd()方法</span></span><br><span class="line">            <span class="comment">// CglibMethodInvocation类实际上是一个调用链对象，也就是说这里将目标类、代理对象、代理方法、调用参数、以及最关键的增强列表&lt;chain&gt;</span></span><br><span class="line">            <span class="comment">// 记录到这个对象中，还包含了当前索引下标等等信息。也就是调用它的process()方法之后，它就会遍历这个增强列表，执行每一个增强。</span></span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到<code>process()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 到达链尾时进入被代理对象的目标方法中，至此递归结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历下标，取出对应的增强</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// 根据对应的信息进行匹配器的匹配，若匹配成功则执行增强的拦截方法</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 匹配失败，则进入到下一个链节点</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上便是<code>springAop</code>的大致过程，这里还要提到一个问题，如果对<code>aop</code>的这个执行过程进行过<code>debug</code>的会发现，假设我只设置了一个<code>aop</code>的注解拦截，对于上面提到的增强拦截链的<code>List&lt;Advisor&gt; advisors</code>实际上会有两个对象，如果设置了两个<code>aop</code>的注解拦截，那么这个列表中会有3个对象。</p><p>​    通过观察不难发现，是<code>springAop</code>在创建实例对象，如果需要被<code>aop</code>代理时，它会将<code>ExposeInvocationInterceptor</code>类，固定放置在这个列表的下标为0的位置。</p><p><code>AbstractAdvisorAutoProxyCreator</code>它实现了<code>spring</code>后置处理器接口，就是它在创建具体的代理对象时，将<code>ExposeInvocationInterceptor</code>放置在增强链的头部位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出满足这个将要创建的bean对象的增强，做法是从容器中首先找出所有Advisor.class的实现类</span></span><br><span class="line"><span class="comment">// 再根据一定的逻辑进行匹配，这里在获取之后会进行缓存，下次在获取Advisor.class的实现时直接</span></span><br><span class="line"><span class="comment">// 通过缓存就能获取到。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">   <span class="comment">// 最后会走到下面的那个方法中，在列表的头部加一个增强。</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">makeAdvisorChainAspectJCapableIfNecessary</span><span class="params">(List&lt;Advisor&gt; advisors)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对获取到的增强列表进行遍历，这里来了一个二次核查，如果存在aop的增强，则在列表下标为0的位置，添加</span></span><br><span class="line">    <span class="comment">// ExposeInvocationInterceptor类。</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> foundAspectJAdvice = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// Be careful not to get the Advice without a guard, as this might eagerly</span></span><br><span class="line">            <span class="comment">// instantiate a non-singleton AspectJ aspect...</span></span><br><span class="line">            <span class="keyword">if</span> (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">                foundAspectJAdvice = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">            advisors.add(<span class="number">0</span>, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这个被加到增强列表头部的增强，有什么特殊的作用？</p><p>直接看它的拦截方法，他的拦截方法也比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 这里接收到的参数MethodInvocation实际上是aop代理类（链对象）</span></span><br><span class="line">    <span class="comment">// 重新来捋一下这个过程，在执行到对应aop的代理类之时：</span></span><br><span class="line">    <span class="comment">// 1.进入到了CglibAopProxy#intercept拦截方法</span></span><br><span class="line">    <span class="comment">// 2.用匹配的增强列表、代理类、被代理目标类（方法）的信息、具体方法、参数等创建CglibMethodInvocation</span></span><br><span class="line">    <span class="comment">//    注意这个类实现了MethodInvocation，然后调用了它的process()方法。</span></span><br><span class="line">    <span class="comment">// 3.这个process()拦截方法的实现上，主要是要遍历增强列表，进行增强的播放，当进入到首个增强时</span></span><br><span class="line">    <span class="comment">//    进入到ExposeInvocationInterceptor#invoke()方法中，来执行以下这段代码。</span></span><br><span class="line">    <span class="comment">// 4.这段代码的作用是将这个aop代理类对象放置到线程上下文中，以便于后续的增强获取。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从线程上下文中获取旧methodInvocation对象</span></span><br><span class="line">    MethodInvocation oldInvocation = invocation.get();</span><br><span class="line">    <span class="comment">// 将线程上下文替换为这个aop代理类对象，在后面的遍历增强类的过程中，</span></span><br><span class="line">    <span class="comment">// 通过线程上下文来获取这个aop代理类对象。</span></span><br><span class="line">    invocation.set(mi);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 还原现场</span></span><br><span class="line">        invocation.set(oldInvocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    <code>springAop</code>在初始化对象之后的代理类是<code>CglibAopProxy#DynamicAdvisedInterceptor</code>的实现（使用<code>cglib</code>代理的情况下），当执行到这个代理类进入到了<code>CglibAopProxy#intercept</code>拦截方法，这个方法中用匹配的增强列表、代理类、被代理目标类（方法）的信息、具体方法、参数等创建<code>CglibMethodInvocation</code>，注意这个类实现了<code>MethodInvocation</code>，然后调用了它的<code>process()</code>方法。这个<code>process()</code>拦截方法的实现上，主要是要遍历增强列表，进行增强的播放，当进入到首个增强时，进入到<code>ExposeInvocationInterceptor#invoke()</code>方法中，将这个<code>aop</code>代理类对象(<code>CglibAopProxy#DynamicAdvisedInterceptor</code>)放置到线程上下文中，以便于后续的增强获取。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringAop浅析（二）&quot;&gt;&lt;a href=&quot;#SpringAop浅析（二）&quot; class=&quot;headerlink&quot; title=&quot;SpringAop浅析（二）&quot;&gt;&lt;/a&gt;SpringAop浅析（二）&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    接两年前的旧文&lt;a href=&quot;https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/&quot; target=&quot;_blank&quot;&gt;SpringAop浅析&lt;/a&gt;，时隔两年再一次对&lt;code&gt;SpringAop&lt;/code&gt;相关源码进行分析，只能说之前阅读的不够透彻，理解的不扎实，再加上工作上常年忙于业务的处理，现在已经少有看源码的时间，不过最近不知道是因为什么打了鸡血，还是想再沉淀沉淀。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Filter无法进入全局异常捕获</title>
    <link href="http://xiaocainiaoya.github.io/2023/10/09/Spring/Filter%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <id>http://xiaocainiaoya.github.io/2023/10/09/Spring/Filter%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</id>
    <published>2023-10-09T14:20:58.000Z</published>
    <updated>2023-10-09T03:37:19.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Filter无法进入全局异常捕获"><a href="#Filter无法进入全局异常捕获" class="headerlink" title="Filter无法进入全局异常捕获"></a>Filter无法进入全局异常捕获</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    我接手的一个服务没有依赖于公司建设项目一体化体系中的认证中心，导致这个服务自身需要支持认证授权模块，由于需求上只需要一个简单的登录模块，所以引入了<code>spring-security</code>模块来进行认证授权相关处理。早上收到一个测试提出的<code>bug</code>，服务在使用一段时间不使用后，再操作，会出现警告异常提示。定位问题发现是由于<code>token</code>失效导致后端校验报错，由于这个校验是在<code>filter</code>中处理，导致全局异常无法捕获，前端获取的异常结构与标准结构（约定异常体结构&lt;msg,code,info&gt;等）不符，导致前端也无法解析具体异常信息，所以界面上显示的是直接抛出的异常信息。</p><span id="more"></span><p>​    为什么<code>filter</code>中抛出的异常无法被全局异常处理器捕获？这是因为安全校验模块，不论是<code>spring-security</code>或者<code>shiro</code>这类，都是基于<code>javax.servlet.filter</code>过滤器来拦截请求，进行认证处理。而全局异常处理器<code>@ControllerAdvice</code>是对<code>Controller</code>控制层进行拦截，也就是说请求都还没有到达控制层已经抛出异常了，所以全局异常处理器无法捕获。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    我查询了一些资料，大多数人都从两个解决方案出发解决这个问题。</p><p><b>方案一：</b>在<code>filter</code>中直接将异常信息写到<code>response</code>流中。这里有一个小细节，我个人建议具体的异常信息还是由全局异常处理器生成，而不是自己通过<code>map</code>或者异常类手动生成一个异常对象，虽然说一般情况下，异常结构与前端有约定不会随意更改，但是如果出现非一般情况，变更了异常结构，但<code>filter</code>中的异常没有相应更改，出现的问题往往是致命的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseErrorHandle</span><span class="params">(HttpServletResponse response, BusinessException businessException)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ErrorResponse&lt;?&gt; result = globalDefaultExceptionHandler.processBusinessException(businessException, response);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(result);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>方案二 ：</b>通过转发到控制层，再由控制层抛出具体的异常信息。（这个方案我个人不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在filter中如果出现异常，通过getRequestDispatcher转发到抛出异常的控制层接口中。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/common/throwException&quot;</span>).forward(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getThrowException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getThrowException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/postThrowException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">postThrowException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/throwException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">throwException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不推荐这个方案的原因是：</p><ol><li>通过<code>getRequestDispatcher().forward()</code>这个是请求转发，在<code>filter</code>中无法设置请求参数，而一般应用系统自定义的异常信息不只是只有提示信息，有时也伴随着一下其他参数，比如异常编码、异常等级、告警方式等等，这些内容由于无法通过<code>parameter</code>传递，所以只能通过<code>restful</code>风格，通过地址栏参数来进行传递，比如<code>/common/throwException/&#123;code&#125;</code>，这种方式传参比较有限，且后期可能不容易扩展。</li><li>由于是转发请求，所以请求方式取决于原请求，也就是假设浏览器（客户端）发起的请求是<code>post</code>，那么转发的请求就是<code>post</code>；如果浏览器发起的请求是<code>get</code>，那么转发的请求就是<code>get</code>。这就转发的目标控制层接口，不能使用<code>@PostMapping</code>或者<code>GetMapping</code>单一接口来标记，而必须使用<code>RequestMapping</code>，且设置<code>method</code>属性值为<code>get</code>、<code>post</code>数组。</li></ol><p>综上，我比较推荐方案一的方式进行<code>filter</code>中的异常信息抛出，并且尽可能通过全局异常处理器来生成对应的异常结构，便于扩展。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Filter无法进入全局异常捕获&quot;&gt;&lt;a href=&quot;#Filter无法进入全局异常捕获&quot; class=&quot;headerlink&quot; title=&quot;Filter无法进入全局异常捕获&quot;&gt;&lt;/a&gt;Filter无法进入全局异常捕获&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;​    我接手的一个服务没有依赖于公司建设项目一体化体系中的认证中心，导致这个服务自身需要支持认证授权模块，由于需求上只需要一个简单的登录模块，所以引入了&lt;code&gt;spring-security&lt;/code&gt;模块来进行认证授权相关处理。早上收到一个测试提出的&lt;code&gt;bug&lt;/code&gt;，服务在使用一段时间不使用后，再操作，会出现警告异常提示。定位问题发现是由于&lt;code&gt;token&lt;/code&gt;失效导致后端校验报错，由于这个校验是在&lt;code&gt;filter&lt;/code&gt;中处理，导致全局异常无法捕获，前端获取的异常结构与标准结构（约定异常体结构&amp;lt;msg,code,info&amp;gt;等）不符，导致前端也无法解析具体异常信息，所以界面上显示的是直接抛出的异常信息。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx之proxy_pass</title>
    <link href="http://xiaocainiaoya.github.io/2023/09/13/nginx/nginx%E4%B9%8Bproxy_pass/"/>
    <id>http://xiaocainiaoya.github.io/2023/09/13/nginx/nginx%E4%B9%8Bproxy_pass/</id>
    <published>2023-09-13T13:51:58.000Z</published>
    <updated>2023-10-09T07:45:09.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx之proxy-pass"><a href="#nginx之proxy-pass" class="headerlink" title="nginx之proxy_pass"></a>nginx之proxy_pass</h1><ul><li>往期回顾：<a href="https://xiaocainiaoya.github.io/2020/04/13/nginx/nginx/">nginx</a></li></ul><p><code>proxy_pass</code>是<code>nginx</code>中常见的反向代理指令。</p><blockquote><p>格式：proxy_pass {传输协议}{主机名}{URI}</p></blockquote><ul><li>传输协议：<code>http://</code>或者<code>https://</code></li><li>主机名：<code>IP:PORT</code></li><li><code>URI</code>：具体的访问地址</li></ul><span id="more"></span><p>先下结论：</p><p>当<code>URI</code>是<code>\</code>时，表示是绝对路径，则不会将<code>location</code>后的匹配规则路径携带到转发目标路径中。</p><p>当<code>URI</code>为空时，表示是相对路径，则会将<code>location</code>后的匹配规则路径携带到转发目标路径中。</p><p>假设访问地址是：<code>http:test.nginx.com/proxy/getUserName</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.URI=/,表示是绝对路径。所以最终的访问地址是: http://127.0.0.1:81/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.URI=空,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/proxy/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.URI=/v1,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/v1getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81/v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.URI=/v1/,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/v1/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81/v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上所述：只有当<code>URI</code>为空时，才会将<code>location</code>后的匹配字符串带到最终的转发目标路径上。</p><h2 id="proxy-set-header-排坑"><a href="#proxy-set-header-排坑" class="headerlink" title="proxy_set_header 排坑"></a>proxy_set_header 排坑</h2><p>​    这里简单描述一下我遇到的场景，在排查过程中耗费了较多的精力。这里我们需要对接外部服务，但是外部服务有一些安全策略，互联网无法直接访问，需要通过跳板机进行访问，同样”外部服务“也只能通过跳板机访问”服务集群“，这里在跳板机上部署了<code>nginx2</code>。<code>nginx1</code>是原本环境中的反向代理。</p><p><img src="https://s2.loli.net/2023/09/18/GubszUkKHY8TRMW.png" alt="pass_header.png"></p><p>​    在<code>nginx</code>中配置了这样一段，用于”外部服务“请求”服务集群“。用于</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> https://test.service.cn/;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host $host:$server_port;</span><br><span class="line">  <span class="attribute">proxy_hide_header</span> <span class="string">&quot;X-Frame-Options&quot;</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-Ip $remote_addr;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-For $remote_addr;</span><br><span class="line">  <span class="attribute">client_max_body_size</span>  <span class="number">100m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在测试中发现，”外部服务“始终无法调用到”服务集群“的接口，而在<code>nginx2</code>的访问日志中显示<code>404</code>，一直以为是”服务集群“中部署有问题，但是通过<code>curl</code>又能正常访问。</p><p>​    在折腾一段时间之后，发现是<code>proxy_set_header</code>这个变量设置的有问题导致请求到达<code>nginx1</code>时出现问题。在了解这个具体问题之前，先来简单解释一下<code>nginx</code>的工作方式。</p><p><code>nginx</code>作为反向代理时，它是需要监听<code>service_name</code>和端口的。</p><ul><li><p>第一步根据请求中的<code>IP</code>和端口先匹配到具体的代理<code>server</code>。</p></li><li><p>第二步才是进行路径的匹配，根据<code>location</code>的路径规则，进行具体的代理逻辑。</p></li></ul><p>​    然而第一步中的匹配不是根据<b>请求的地址中的IP和端口</b>，而是通过请求头中的<code>Host</code>属性进行匹配。再回到最开始出现问题的地方，由于我设置了<code>proxy_set_header Host $host:$server_port;</code>，导致到达<code>nginx1</code>的请求的请求头中的<code>Host</code>是<code>nginx2</code>本机地址，从而导致<code>nginx1</code>代理规则匹配失败，所以这里出现的<code>404</code>是由于<code>nginx1</code>无法匹配到具体的代理<code>server</code>导致。</p><p>​    若没有配置则默认是：<code>proxy_set_header Host $proxy_host;</code>，表示代理的地址。</p><table><thead><tr><th>变量名</th><th>端口</th><th>值</th></tr></thead><tbody><tr><td>$host</td><td>没有端口</td><td>本机地址</td></tr><tr><td>$pass_host</td><td>80不显示，其他显示</td><td>被代理服务的ip和端口</td></tr><tr><td>$http_host</td><td>端口存在则显示</td><td>请求时的ip和端口</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nginx之proxy-pass&quot;&gt;&lt;a href=&quot;#nginx之proxy-pass&quot; class=&quot;headerlink&quot; title=&quot;nginx之proxy_pass&quot;&gt;&lt;/a&gt;nginx之proxy_pass&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;往期回顾：&lt;a href=&quot;https://xiaocainiaoya.github.io/2020/04/13/nginx/nginx/&quot;&gt;nginx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;proxy_pass&lt;/code&gt;是&lt;code&gt;nginx&lt;/code&gt;中常见的反向代理指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;格式：proxy_pass {传输协议}{主机名}{URI}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;传输协议：&lt;code&gt;http://&lt;/code&gt;或者&lt;code&gt;https://&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主机名：&lt;code&gt;IP:PORT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URI&lt;/code&gt;：具体的访问地址&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://xiaocainiaoya.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://xiaocainiaoya.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>java参数命令</title>
    <link href="http://xiaocainiaoya.github.io/2023/08/18/java/java%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/"/>
    <id>http://xiaocainiaoya.github.io/2023/08/18/java/java%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/</id>
    <published>2023-08-18T13:51:58.000Z</published>
    <updated>2023-10-09T07:25:53.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java参数命令"><a href="#java参数命令" class="headerlink" title="java参数命令"></a>java参数命令</h1><h3 id="java启动命令中-D和–的区别"><a href="#java启动命令中-D和–的区别" class="headerlink" title="java启动命令中-D和–的区别"></a>java启动命令中-D和–的区别</h3><p>两种方式都可以<b>直接覆盖</b><code>yaml</code>或者<code>properties</code>配置中的同名配置项。</p><ul><li><code>-D</code>（包括<code>-X</code>）表示添加的参数是<code>jvm</code>虚拟机变量。<code>java</code>应用中通过<code>System.getProperties(&quot;&quot;)</code>获取。</li><li><code>--</code>表示添加的参数是操作系统的环境变量。<code>java</code>应用中通过<code>System.getEnv(&quot;&quot;)</code>获取。</li></ul><p><code>-D</code>参数要放置在<code>-jar</code>命令之前，<code>--</code>参数要放置在<code>-jar</code>命令之后。</p><blockquote><p>java -Dserver.port=8080 -Xms128m <b>-jar</b> –server.name=myApp</p></blockquote><p>可通过<code>jps</code>命令查看<code>java</code>应用具体的参数值。</p><ul><li><code>jps -v</code>：可以查看<code>-D</code>、<code>-X</code>参数</li></ul><p>示例：<code>1 jar -Djava.util.Arrays.useLegacyMergeSort=true -Djava.security.egd=file:/dev/./urandom -Xms128m -Xmx512m</code></p><ul><li><code>jps -m</code>：可以查看<code>--</code>参数</li></ul><p>示例：<code>1 jar --spring.profiles.active=dev --logging.config=logback-spring.xml</code></p><h3 id="crf反编译工具"><a href="#crf反编译工具" class="headerlink" title="crf反编译工具"></a>crf反编译工具</h3><blockquote><p><a href="http://www.benf.org/other/cfr/">http://www.benf.org/other/cfr/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java参数命令&quot;&gt;&lt;a href=&quot;#java参数命令&quot; class=&quot;headerlink&quot; title=&quot;java参数命令&quot;&gt;&lt;/a&gt;java参数命令&lt;/h1&gt;&lt;h3 id=&quot;java启动命令中-D和–的区别&quot;&gt;&lt;a href=&quot;#java启动命令中-D和–</summary>
      
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息投递确认</title>
    <link href="http://xiaocainiaoya.github.io/2023/08/16/mq/RabbitMQ%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E7%A1%AE%E8%AE%A4/"/>
    <id>http://xiaocainiaoya.github.io/2023/08/16/mq/RabbitMQ%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E7%A1%AE%E8%AE%A4/</id>
    <published>2023-08-16T14:13:58.000Z</published>
    <updated>2023-08-16T08:27:11.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ消息投递确认"><a href="#RabbitMQ消息投递确认" class="headerlink" title="RabbitMQ消息投递确认"></a>RabbitMQ消息投递确认</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    在项目中引入了<code>RabbitMQ</code>用于服务间一些解耦操作，在运行了一段时间之后，突然在某个环境中出现了一些异常情况。</p><span id="more"></span>    <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    从投递者日志来看，确实投递者有将对应的数据投递出去；从消费者日志来看，一直未监听到对应的消息，并且从<code>RabbitMQ</code>后台来看，对应队列上是存在监听，并且通过<code>RabbitMQ</code>控制台通过<code>Publish message</code>发出的消息，在消费者服务的日志中可以看到对应的消费信息。</p><p>​    经过反复的查看，确定投递者服务投递的消息对应的交换机和路由器应该是没有问题的。排查到这里实际上我已经没有任何排查思路了，我猜测既然消费者的日志中并没有出现消费的相关日志，那么大概率问题应该是在投递端。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    在<code>RabbitMQ</code>中是有消息投递确认的回调处理，当投递失败时，可以通过回调接口在投递者服务中打印出对应的信息，这样至少排查问题时可以知道，是投递出现了问题。</p><p>这里先简单解释两个概念：</p><p>消息是由投递者投递到<b>交换机</b>，再由交换机根据指定路由键投递到对应的<b>队列</b>。</p><ul><li><p><code>publisher-confirm</code>：发送者确认，消息成功投递到交换机返回<code>ack</code>，消息未投递到交换机返回<code>nack</code>。<b>注意，这里的维度是交换机，也就是交换机接收了，就认为你投递成功。</b></p></li><li><p><code>publisher-return</code>：发送者回执，消息发送队列失败会回调这个方法。<b>注意，这里的维度是队列，就是交换机有没有将消息投递到具体的队列上，若投递不到具体的队列，则回调这个方法。</b></p></li></ul><p>1.在<code>spring</code>配置项中开启投递确认</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple 同步等待confirm结果，直到超时</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated </span></span><br><span class="line"><span class="comment"># 开始publish-return功能，同样基于callback机制，不过是定义ReturnCallback</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 定义消息路由失败时的策略，true则调用ReturnCallback; false则丢弃</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>2.设置投递确认和投递回执监听</p><p>我这里为了快捷测试，就通过<code>@PostConstruct</code>设置对应的回调信息，实际项目中，应通过<code>@Configuration</code>或者<code>@Bean</code>抽取到对应的配置类中，因为<code>setReturnsCallback</code>等方法对应每一个<code>rabbitTemplate</code>实例只能设置一次，第二次赋值，将会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> RabbitTemplate.ReturnsCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由key&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                    returnedMessage.getReplyCode(), returnedMessage.getReplyText(), returnedMessage.getExchange(),</span><br><span class="line">                    returnedMessage.getRoutingKey(), returnedMessage.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息投递异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/testMq&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;测试发送消息&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title">testMq</span><span class="params">(<span class="meta">@RequestParam(&quot;exchange&quot;)</span> String exchange, <span class="meta">@RequestParam(&quot;route&quot;)</span> String route)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchange, route, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.&lt;Boolean&gt;builder().data(<span class="keyword">null</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>测试结论：</b></p><p>1.若投递一个不存在的交换机，<code>setConfirmCallback()</code>中返回<code>false</code>。<b>不会进入<code>returnCallback</code>监听方法。</b>这里还是要老生常谈一下，一定要注意，若交换机投递失败，<code>returnCallback</code>是不会接受到监听回调。</p><p>2.若投递一个存在的交换机且存在的路由键，<code>setConfirmCallback()</code>中返回<code>true</code>，<b>不会进入<code>returnCallback</code>监听方法。</b>因为只有投递队列失败才会进入到这个方法中。</p><p>3.若投递一个存在的交换机且不存在的路由键，<code>setConfirmCallback()</code>中返回<code>true</code>，<b>会进入<code>returnCallback</code>监听方法。</b></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RabbitMQ消息投递确认&quot;&gt;&lt;a href=&quot;#RabbitMQ消息投递确认&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消息投递确认&quot;&gt;&lt;/a&gt;RabbitMQ消息投递确认&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    在项目中引入了&lt;code&gt;RabbitMQ&lt;/code&gt;用于服务间一些解耦操作，在运行了一段时间之后，突然在某个环境中出现了一些异常情况。&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://xiaocainiaoya.github.io/categories/MQ/"/>
    
    
    <category term="MQ" scheme="http://xiaocainiaoya.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>maven插件整理</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/26/maven/maven%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/26/maven/maven%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</id>
    <published>2023-07-26T14:13:58.000Z</published>
    <updated>2023-10-09T07:47:01.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven插件整理"><a href="#maven插件整理" class="headerlink" title="maven插件整理"></a>maven插件整理</h1><p>​    常用<code>maven</code>插件整理，<code>maven</code>本质上是一个插件框架，它的核心并不具备执行任何构建任务的能力，所有的任务都是交由插件完成。</p><span id="more"></span>    <p>​    <code>maven</code>插件<a href="https://maven.apache.org/plugins/index.html">官网</a>，里面有一个<code>Supported By The Maven Project</code>标题下的列表中的插件，是由<code>maven</code>官方支持的插件。还有一个<code>Outside The Maven Land</code>下的<code>At MojoHaus (formerly known as codehaus.org)</code>这个不是官网的插件列表，但其中的部分插件也是比较常用的。</p><h2 id="1-maven-antrun-plugin"><a href="#1-maven-antrun-plugin" class="headerlink" title="1.maven-antrun-plugin"></a>1.maven-antrun-plugin</h2><p>​    主要作用是能让用户在<code>maven</code>项目中运行<code>Ant</code>任务。</p><h2 id="2-maven-archetype-plugin"><a href="#2-maven-archetype-plugin" class="headerlink" title="2.maven-archetype-plugin"></a>2.maven-archetype-plugin</h2><p>​    <code>Archtype</code>指项目的骨架，主要作用是创建项目骨架原型。</p><ul><li><code>archetype:generate</code>：使用交互式的方式提示用户输入必要的信息以创建项目</li></ul><h2 id="3-maven-assembly-plugin"><a href="#3-maven-assembly-plugin" class="headerlink" title="3.maven-assembly-plugin"></a>3.maven-assembly-plugin</h2><p>​    这个插件就比较常用，用来对项目制作一些压缩包，定制压缩包中的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/config/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-maven-dependency-plugin"><a href="#4-maven-dependency-plugin" class="headerlink" title="4.maven-dependency-plugin"></a>4.maven-dependency-plugin</h2><p>​    主要作用是分析项目中的依赖。</p><ul><li><code>dependency:list</code>：项目最终解析到的依赖列表</li><li><code>dependency:tree</code>：进一步的描绘项目依赖树</li><li><code>dependency:analyze</code>：项目依赖潜在的问题</li><li><code>dependency:copy-dependencies</code>：能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面</li></ul><h2 id="5-maven-enforcer-plugin"><a href="#5-maven-enforcer-plugin" class="headerlink" title="5.maven-enforcer-plugin"></a>5.maven-enforcer-plugin</h2><p>​    设置约束项目的一系列规则并强制遵守，比如<code>maven</code>的版本，<code>java</code>的版本，禁止某些依赖，某些依赖的版本最低版本，在父<code>pom</code>中配置规则，当不符合规则时，会报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>display-info<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--规则检查不通过就构建失败;Default:false. --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;failFast&gt;true&lt;/failFast&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--maven的版本要大于3.0.4--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requireMavenVersion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">requireMavenVersion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--java的版本要大于1.6--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requireJavaVersion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">requireJavaVersion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--bannedDependencies表示禁止使用的依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bannedDependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否检查传递性依赖(间接依赖)--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">searchTransitive</span>&gt;</span>true<span class="tag">&lt;/<span class="name">searchTransitive</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--禁止的依赖列表--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>junit:junit<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">message</span>&gt;</span>must use TestNG<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bannedDependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>exclude</code>标签中，可以通过通配符的方式设置一些依赖规则，其他详见<a href="http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html">内置版本范围规则</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--groupId[:artifactId][:version][:type][:scope][:classifier]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:log4j<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:log4j:1.0<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:1.2<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span><span class="comment">&lt;!--排除1.2及其以上版本,等价于[1.2,)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:[1.2]<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span><span class="comment">&lt;!--明确排除1.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:*:jar:test<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*:*:*:jar:compile:tests<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-maven-help-plugin"><a href="#6-maven-help-plugin" class="headerlink" title="6.maven-help-plugin"></a>6.maven-help-plugin</h2><p>​    一个辅助工具，用来获取一些详细使用信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看`versions-maven-plugin`这个插件的详细描述，会输出这个插件的所有`goal`</span></span></span><br><span class="line">mvn help:describe -Dplugin=org.codehaus.mojo:versions-maven-plugin:2.7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看指定的某个goal</span></span></span><br><span class="line">mvn help:describe -Dplugin=org.codehaus.mojo:versions-maven-plugin:2.7 -Dgoal=set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看有效settings</span></span></span><br><span class="line">mvn help:effective-settings</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;maven插件整理&quot;&gt;&lt;a href=&quot;#maven插件整理&quot; class=&quot;headerlink&quot; title=&quot;maven插件整理&quot;&gt;&lt;/a&gt;maven插件整理&lt;/h1&gt;&lt;p&gt;​    常用&lt;code&gt;maven&lt;/code&gt;插件整理，&lt;code&gt;maven&lt;/code&gt;本质上是一个插件框架，它的核心并不具备执行任何构建任务的能力，所有的任务都是交由插件完成。&lt;/p&gt;</summary>
    
    
    
    <category term="maven" scheme="http://xiaocainiaoya.github.io/categories/maven/"/>
    
    
    <category term="maven" scheme="http://xiaocainiaoya.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>spring-statemachine入门</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-15T14:20:58.000Z</published>
    <updated>2023-10-09T07:49:30.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-statemachine入门"><a href="#spring-statemachine入门" class="headerlink" title="spring-statemachine入门"></a>spring-statemachine入门</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring-statemachine</code>是<code>spring</code>设计于处理状态的变化，以及定义状态之间的转换规则。</p><span id="more"></span><p><strong>状态机的基本组成</strong></p><p>状态机主要由4要素组成：</p><ul><li>现态：当前所处的状态。</li><li>条件：或者称为“事件”，在状态转换图中使用箭头标识，当满足某个条件（触发某个事件）之后，由一个状态转移到另一个状态。比如下图中“支付”这个箭头。</li><li>动作：表示由现态转换到次态之后，需要执行的动作，不是必须的，可以是转换转换后不执行任何动作。比如下图中从[待收货]转换到[已收货]是否设置某个动作。</li><li>次态：下一环状态。</li></ul><p>​    比如一个支付下单流程的状态转换图：</p><p><img src="https://s2.loli.net/2023/07/15/a71AErSKG2TLFNw.png" alt="状态装换图.png"></p><p>​    订单的开始状态为[待支付]，当用户支付之后状态流转为[已支付]，这个地方是个分支节点，当状态流转到[已支付]后，根据一些业务规则，将状态流转到[待收货]或者[待开票]，若是[待收货]，通过收货行为，使状态流转到[结束];若是[待开票]状态，通过投递行为，使状态流转到[结束]。</p><h2 id="Spring-stateMachine"><a href="#Spring-stateMachine" class="headerlink" title="Spring stateMachine"></a>Spring stateMachine</h2><p><code>Spring StateMachine</code>是一个基于 <code>Spring</code>框架的状态机框架，使用<code>Spring StateMachine</code>可以方便地在 <code>Java</code>应用中实现状态机功能，并可以与<code>Spring</code>框架的其他功能结合使用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><b>1.添加依赖</b></p><p>我这里使用的是<code>springboot</code>工程，最好先引入官方提供的<code>spring-statemachine-bom</code>，这样基本上不会出现与<code>spring framework</code>版本不对应，出现的一些无法解释的坑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>2.订单状态枚举类</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UNPAID(<span class="string">&quot;unpaid&quot;</span>,<span class="string">&quot;待支付&quot;</span>),</span><br><span class="line">    PAID(<span class="string">&quot;paid&quot;</span>,<span class="string">&quot;已支付&quot;</span>),</span><br><span class="line">    WAITING_FOR_RECEIVE(<span class="string">&quot;waitingForReceive&quot;</span>,<span class="string">&quot;待收货&quot;</span>),</span><br><span class="line">    DONE(<span class="string">&quot;done&quot;</span>,<span class="string">&quot;结束&quot;</span>),</span><br><span class="line">    INVOICE(<span class="string">&quot;invoice&quot;</span>, <span class="string">&quot;开票&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    StateEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StateEnum <span class="title">getByState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (StateEnum stateEnum : StateEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stateEnum.getType().equals(state)) &#123;</span><br><span class="line">                <span class="keyword">return</span> stateEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.事件枚举类</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EventEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PAY(<span class="string">&quot;pay&quot;</span>,<span class="string">&quot;支付&quot;</span>),</span><br><span class="line">    RECEIVE(<span class="string">&quot;receive&quot;</span>,<span class="string">&quot;收货&quot;</span>),</span><br><span class="line">    DELIVERY(<span class="string">&quot;delivery&quot;</span>,<span class="string">&quot;发货&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    EventEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.状态机配置</b></p><p>状态机配置类中包含状态配置、状态转换事件关系配置、监听器配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 这里最好手动设置name， 如果不设置, 默认使用stateMachineFactory这个名字, 由于这个类</span></span><br><span class="line"><span class="comment">// 需要注入到spring容器中, 如果需要创建两个不一样的状态机会出现重名的冲突。</span></span><br><span class="line"><span class="meta">@EnableStateMachineFactory(name = &quot;feeStateMachineFactory&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeeStateMachineConfig</span> <span class="keyword">extends</span> <span class="title">StateMachineConfigurerAdapter</span>&lt;<span class="title">StateEnum</span>, <span class="title">EventEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态: 初始状态、</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineStateConfigurer&lt;StateEnum, EventEnum&gt; states)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        states.withStates()</span><br><span class="line">            <span class="comment">// 初始状态</span></span><br><span class="line">            .initial(StateEnum.UNPAID)</span><br><span class="line">            <span class="comment">// 分支节点, 如果存在分支节点, 必须要在这里声明</span></span><br><span class="line">            .choice(StateEnum.PAID)</span><br><span class="line">            <span class="comment">// 状态的所有值</span></span><br><span class="line">            .states(EnumSet.allOf(StateEnum.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态机监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2023/7/14 16:04:34</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineConfigurationConfigurer&lt;StateEnum, EventEnum&gt; config)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        config.withConfiguration()</span><br><span class="line">            <span class="comment">// 设置全局监听器</span></span><br><span class="line">            .listener(listener())</span><br><span class="line">            <span class="comment">// 设置状态机的ID, 可以认为是状态机的名称，在通过StateMachineFactory.getStateMachine()需要通过这个名称获取</span></span><br><span class="line">            <span class="comment">// 在测试的过程中发现, 有些人写的文章里没有设置这个名称, 然后在使用StateMachineFactory.getStateMachine(machineId)</span></span><br><span class="line">            <span class="comment">// 中的machineId使用的是数据库中查出的订单ID, 这样的写法在不使用OnTransition相关监听注解是不会有问题，但是如果</span></span><br><span class="line">            <span class="comment">// 需要使用到@OnTransition相关注解就会导致无法进入到这个注解标记的方法中。</span></span><br><span class="line">            .machineId(<span class="string">&quot;stateMachine&quot;</span>)</span><br><span class="line">            .autoStartup(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态转换和事件的转换关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transitions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineTransitionConfigurer&lt;StateEnum, EventEnum&gt; transitions)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        transitions</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.UNPAID)</span><br><span class="line">            .target(StateEnum.PAID)</span><br><span class="line">            .event(EventEnum.PAY)</span><br><span class="line">            <span class="comment">// guard()守卫函数，状态转移后进入, 如果返回的是true, 才进入到action方法中。</span></span><br><span class="line">            .guard(<span class="keyword">new</span> Guard&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(StateContext&lt;StateEnum, EventEnum&gt; context)</span> </span>&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;进入订单守卫函数&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.UNPAID.getValue(), StateEnum.PAID.getValue()))</span><br><span class="line">        .and()</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">            .target(StateEnum.DONE)</span><br><span class="line">            .event(EventEnum.RECEIVE)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.WAITING_FOR_RECEIVE.getValue(), StateEnum.DONE.getValue()))</span><br><span class="line">        .and()</span><br><span class="line">            <span class="comment">// 表示分支</span></span><br><span class="line">            .withChoice()</span><br><span class="line">            .source(StateEnum.PAID)</span><br><span class="line">            <span class="comment">// 类似于 if(first的第二个参数的方法如果是true)则进入到first第一个参数的状态，并进入first第三个参数的action</span></span><br><span class="line">            <span class="comment">// 如果first的第二个参数返回的是false，则进入到last的第一个参数状态，并进入到first第二个参数的atction</span></span><br><span class="line">            .first(StateEnum.INVOICE, ctx -&gt; (<span class="keyword">boolean</span>) Optional.ofNullable(ctx.getMessage().getHeaders().get(<span class="string">&quot;invoice&quot;</span>)).orElse(<span class="keyword">true</span>), ctx -&gt; log.info(<span class="string">&quot;进入发票分支&quot;</span>))</span><br><span class="line">            .last(StateEnum.WAITING_FOR_RECEIVE, ctx -&gt; log.info(<span class="string">&quot;进入收货分支&quot;</span>))</span><br><span class="line">        .and()</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.INVOICE)</span><br><span class="line">            .target(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">            .event(EventEnum.DELIVERY)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.INVOICE.getValue(), StateEnum.WAITING_FOR_RECEIVE.getValue()))</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StateMachineListener&lt;StateEnum, EventEnum&gt; <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StateMachineListenerAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当状态的转移在configure方法配置中时，会走到该方法。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;StateEnum, EventEnum&gt; transition)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;listener[&#123;&#125;]状态变更:&#123;&#125; -&gt; &#123;&#125;&quot;</span>, transition.getKind().name(),</span><br><span class="line">                    transition.getSource() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getSource().getId()),</span><br><span class="line">                    transition.getTarget() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getTarget().getId()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当发生的状态转移不在configure方法配置中时，会走到该方法，此处打印error日志，方便排查状态转移问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;EventEnum&gt; event)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;事件未收到: &#123;&#125;&quot;</span>, event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> Object <span class="title">ofNullableState</span><span class="params">(StateEnum s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.ofNullable(s)</span><br><span class="line">                    .map(StateEnum::getValue)</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>4.测试调用</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.sendEvent(MessageBuilder.withPayload(EventEnum.PAY)</span><br><span class="line">                    .setHeader(JSON_STR, JSON.toJSONString(feeOrder))</span><br><span class="line">                    .build())</span><br></pre></td></tr></table></figure><h3 id="使用注解方式配置监听器"><a href="#使用注解方式配置监听器" class="headerlink" title="使用注解方式配置监听器"></a>使用注解方式配置监听器</h3><p>​    前面说到，如果需要使用注解方式配置监听器，一定一定要注意<code>machineId</code>的赋值。因为可以通过多种方式来处理状态转移之后的监听，所以并不一定所有人在使用时都会使用这种方式，但是使用这种方式就是一定要注意<code>machineId</code>的赋值问题。(可以在定义配置时就设置<code>action</code>也可以达到状态转移后进入某个函数进行相关处理。)</p><p>​    <code>spring stateMachine</code>中设置的监听，这些监听都有设置对应的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateMachineListener</span>&lt;<span class="title">S</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(State&lt;S,E&gt; from, State&lt;S,E&gt; to)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateEntered</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateExited</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;E&gt; event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transitionStarted</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transitionEnded</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineStarted</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineStopped</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineError</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine, Exception exception)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extendedStateChanged</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateContext</span><span class="params">(StateContext&lt;S, E&gt; stateContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过注解的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/7/15 09:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@WithStateMachine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnTransition(target = &quot;UNPAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@StatesOnTransition</span></span><br><span class="line">    <span class="meta">@OnTransition(source = &quot;UNPAID&quot;, target = &quot;PAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Message&lt;EventEnum&gt; obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取消息中的订单对象</span></span><br><span class="line">        <span class="comment">//Order order = (Order) message.getHeaders().get(&quot;order&quot;);</span></span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        <span class="comment">//order.setStates(States.WAITING_FOR_RECEIVE);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户支付完毕，状态机反馈信息：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>​    一般来说，我们的处理逻辑为从状态机工程中获取到一个状态机，但是不一定说每一台状态机都是从初始状态开始走，有可能订单目前处在某个状态，但是由于一些原因重启了服务，那么这是如果重新创建状态机那么状态需要从头开始走，这显然不符合逻辑，所以在获取到状态机之后，需要为这台状态机重新赋状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从状态机工厂获取一个状态机</span></span><br><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.stop();</span><br><span class="line">stateMachine.getStateMachineAccessor().doWithAllRegions(sma -&gt; &#123;</span><br><span class="line">    <span class="comment">//配置状态机拦截器，当状态发生转移时，会走到该拦截器中</span></span><br><span class="line">    sma.addStateMachineInterceptor(<span class="keyword">new</span> StateMachineInterceptorAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStateChange</span><span class="params">(State&lt;StateEnum, EventEnum&gt; state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Message&lt;EventEnum&gt; message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Transition&lt;StateEnum, EventEnum&gt; transition,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; stateMachine,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; rootStateMachine)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;preStateChange&quot;</span>);</span><br><span class="line">            FeeOrder result = JSON.parseObject(String.class.cast(message.getHeaders().get(JSON_STR)), FeeOrder.class);</span><br><span class="line">            <span class="comment">//更新状态机转移后的状态</span></span><br><span class="line">            result.setOrderStatus(state.getId().getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//将状态机的初始状态配置为DB中对应状态</span></span><br><span class="line">    sma.resetStateMachine(<span class="keyword">new</span> DefaultStateMachineContext&lt;&gt;(stateEnum, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;stateMachine&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动状态机</span></span><br><span class="line">stateMachine.start();</span><br></pre></td></tr></table></figure><p>​    尽管可以手动对状态机赋状态，但是这种方式也解决不了根本问题，以订单为例子，如果用户在发起创建订单之后，订单处在待支付状态，然后用户一直没有去支付，这时出现需要重启服务器的情况；或者如果部署了多个实例，某一台实例中状态机处在待支付状态，而用户去支付时请求走到了另一台服务器，这时在另一台服务器上状态走到了待开票，如果开票的请求又走到了原本处在待支付状态的服务器上呢？所以这里就变成必须与数据库中的订单状态实时校验？</p><p>所以这里引入的持久化。主要针对于故障恢复、可恢复性、长时间运行等情况。</p><p>持久化有多种方式，基于内存、基于<code>db</code>、基于<code>redis</code>、基于<code>MongoDB</code>等，这里以<code>redis</code>为例。</p><p><b>1.引入依赖</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>2.redis配置</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachinePersisterConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Redis持久化配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisStateMachinePersister&lt;StateEnum, EventEnum&gt; <span class="title">persister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt; repository</span><br><span class="line">            = <span class="keyword">new</span> RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt;(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisStateMachinePersister&lt;&gt;(<span class="keyword">new</span> RepositoryStateMachinePersist&lt;&gt;(repository));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.使用redis进行持久化</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sendEvent</span><span class="params">(Events changeEvent, Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      stateMachine.start();</span><br><span class="line">      <span class="comment">//尝试恢复状态机状态</span></span><br><span class="line">      stateMachineMemPersister.restore(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">      Message message = MessageBuilder.withPayload(changeEvent)</span><br><span class="line">              .setHeader(<span class="string">&quot;order&quot;</span>, order).build();</span><br><span class="line">      result = stateMachine.sendEvent(message);</span><br><span class="line">      <span class="comment">//持久化状态机状态</span></span><br><span class="line">      stateMachineMemPersister.persist(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;操作失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      stateMachine.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    <code>spring stateMachine</code>在简单实用之后感觉虽然在一定层度上对状态装换过程的代码编写风格进行了解耦，但是感觉由于<code>spring stateMachine</code>有点过于重量化，导致如果使用不当容易出现一些不可预判、出乎意料之外的问题。就比如之前提到的版本不对应监听注解失效的问题，在使用过程中它也不会报错，仅仅是始终无法进入到对应的注解中；还比如<code>choice</code>分支的问题、状态机不持久化带来的问题、若使用了持久化，持久化带来的问题等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring-statemachine入门&quot;&gt;&lt;a href=&quot;#spring-statemachine入门&quot; class=&quot;headerlink&quot; title=&quot;spring-statemachine入门&quot;&gt;&lt;/a&gt;spring-statemachine入门&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring-statemachine&lt;/code&gt;是&lt;code&gt;spring&lt;/code&gt;设计于处理状态的变化，以及定义状态之间的转换规则。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK9特性</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/</id>
    <published>2023-07-12T13:51:58.000Z</published>
    <updated>2023-10-09T07:51:45.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK9特性"><a href="#JDK9特性" class="headerlink" title="JDK9特性"></a>JDK9特性</h1><span id="more"></span><h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><p>​    模块是代码、数据和资源的集合。它是一组相关的包和类型（类、抽象类、接口等），包含代码、数据文件和一些静态资源。说人话就是，<code>JDK9</code>在<code>JDK8</code>之上对<code>package</code>再进行了一层包装，以往的<code>JDK</code>中在<code>.jar</code>包中就是<code>package</code>包了，也就是说如果你在工程中引入了一个<code>.jar</code>，这么这整个<code>.jar</code>下的包都被引入到你的工程，在你的工程中就可以使用引入的这个<code>.jar</code>文件的所有包下的类。但是在<code>JDK9</code>模块化之后，在<code>.jar</code>下，<code>package</code>上，添加了一层<code>module</code>，也就是说，如果你在工程中引入一个<code>.jar</code>，这时也不能访问到<code>.jar</code>下的所有包，要看两个条件，一个条件是这个<code>.jar</code>是否将这个包开放访问，二是当前模块是否需要访问<code>.jar</code>中的某个包。</p><p><b>示例：</b></p><p>在工程中引入<code>lombok</code>，显然根据上面说的，如果在<code>JDK9</code>之前，这样就可以访问到<code>lombok</code>中的相关类资源。但是这里是访问不到的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.18.26&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>想要访问到<code>lombok</code>中的类资源，这时需要两个条件都满足，当前工程才可以使用<code>lombok</code>相关类。</p><ol><li><p><code>lombok</code>将自身的某些允许访问的包暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lombok &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.compiler;</span><br><span class="line">    <span class="keyword">requires</span> java.instrument;</span><br><span class="line">    <span class="keyword">requires</span> jdk.unsupported;</span><br><span class="line">    <span class="comment">// lombok中暴露 lombok 这个包</span></span><br><span class="line">    <span class="keyword">exports</span> lombok;</span><br><span class="line">    <span class="keyword">exports</span> lombok.experimental;</span><br><span class="line">    ... 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当前工程需要<code>lombok</code>中的某些包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="keyword">requires</span> common;</span><br><span class="line">    <span class="comment">// 当前工程中引入 lombok 包</span></span><br><span class="line">    <span class="keyword">requires</span> lombok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><b>这两个条件都需要在对应的<code>module-info.java</code>显示声明。</b></p><p>根据上面的例子可以看出，<code>JDK9</code>是通过在顶层类路径下添加<code>module-info.java</code>来控制模块化。这个文件称为<b>模块描述符</b>。可以通过反向的域名来定义模块名。</p><h3 id="1-模块描述符"><a href="#1-模块描述符" class="headerlink" title="1.模块描述符"></a>1.模块描述符</h3><p>1.需要引入某些模块，使用<code>requires</code>引入模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况是不支持透传, 也就是A -&gt; B, B -&gt; C, 下面这种写法A是不引用C的。</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传，也就是A -&gt; B, B -&gt; C, 下面这种写法A也是依赖于C</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> transitive <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态引入：编译的时候必须要包含这些类的jar包才能够编译通过。但是在运行的时候我们可能不会用到这些类</span></span><br><span class="line"><span class="comment">// 表示在编译时的依赖是强制的，但在运行时是可选的</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">static</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.需要暴露某些模块，供其他模块引入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将某个包暴露, 其他引用模块才可以通过requires关键字引入</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">   <span class="keyword">exports</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点对点暴露</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">exports</span> <span class="keyword">module</span>.nameA to <span class="keyword">module</span>.nameB, <span class="keyword">module</span>.nameC, <span class="keyword">module</span>.nameD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><p>A模块中有两个包路径：<code>xiaocainiao.common.entity</code>和<code>xiaocainiao.common.vo</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="comment">// 暴露A模块的其中一个包路径</span></span><br><span class="line">    <span class="keyword">exports</span> xiaocainiao.common.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B模块中有两个包路径：<code>xiaocainiao.user.entity</code>和<code>xiaocainiao.user.vo</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="comment">// B模块引用整个A模块</span></span><br><span class="line">    <span class="keyword">requires</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，B模块仍然也只能引用到A模块暴露出来的一个包，另一个没有暴露出来的包，B模块无法访问。这个时候对于B来说，是引用了整个A模块，当然也可以点对点引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将A模块修改为仅对B模块暴露, 其他模块引入A模块后将无法访问到cn.com.xiaocainiaoya.common.facade</span></span><br><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.facade to user_center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我在学习<code>jdk9</code>模块化时，这里有一个小插曲，我先引入了<code>hutool5.7.20</code>的依赖，然后通过<code>requires cn.hutool; </code>发现无法引入，而在<code>idea</code>的<code>pom.xml</code>有个小提示，提示我引入最新版本的<code>hutool</code>，所以我尝试引入<code>hutool5.8.18</code>后，发现<code>requires cn.hutool;</code>生效了，但是我又观察了一下，<code>hutool5.8.18</code>中并没有<code>module-info.class</code>文件，这个时候我就很疑惑了，对比观察了下，发现两者的<code>MANIFEST.MF</code>中存在一点差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hutool 5.7.20</span></span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Built-By: looll</span><br><span class="line">Created-By: Apache Maven <span class="number">3.8</span><span class="number">.1</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_261</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hutool 5.8.18</span></span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Implementation-Title: hutool-all</span><br><span class="line">Automatic-Module-Name: cn.hutool</span><br><span class="line">Implementation-Version: <span class="number">5.8</span><span class="number">.18</span></span><br><span class="line">Build-Timestamp: <span class="number">2023</span>-<span class="number">04</span>-16T15:<span class="number">40</span>:28Z</span><br><span class="line">Built-By: looll</span><br><span class="line">Build-OS: Windows <span class="number">11</span></span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Created-By: Maven JAR Plugin <span class="number">3.3</span><span class="number">.0</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_333</span></span><br></pre></td></tr></table></figure><p>到这你应该有所发现，在高版本中有一个参数<code>Automatic-Module-Name</code>，属性是用来为自动模块指定一个模块名称的。通过声明这个属性，就可以为没有显式模块信息的 JAR 文件赋予一个模块名称，使其成为一个合法的模块。</p><p>然后进入<code>git</code>看了下源码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Automatic-Module-Name</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">Automatic-Module-Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">index</span>&gt;</span>true<span class="tag">&lt;/<span class="name">index</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-OS</span>&gt;</span>$&#123;os.name&#125;<span class="tag">&lt;/<span class="name">Build-OS</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>$&#123;user.name&#125;<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-Jdk</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">Build-Jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-Timestamp</span>&gt;</span>$&#123;maven.build.timestamp&#125;<span class="tag">&lt;/<span class="name">Build-Timestamp</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--通过maven打包工具，将这个属性添加到MANIFEST.MF中--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Automatic-Module-Name</span>&gt;</span>$&#123;Automatic-Module-Name&#125;<span class="tag">&lt;/<span class="name">Automatic-Module-Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.开放更高访问权限，使用<code>open</code>关键字。</p><p>​    在模块化系统中，模块会隔离其内部的包，只有 <code>public</code> 修饰的包才能在模块外部访问。然而，有时候我们希望允许其他模块访问模块中的所有非 <code>public</code> 类型，而不用逐个包或类型地进行声明。这时可以使用 <code>open</code> 关键字来声明一个模块为 “开放模块”，这样其他模块就可以访问该模块中的所有非 <code>public</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用open只是为了提高访问权限, 改exports暴露的还是要暴露</span></span><br><span class="line"><span class="comment">// 整个模块open</span></span><br><span class="line">open <span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.entity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="comment">// 单独暴露这个包</span></span><br><span class="line">    opens cn.com.xiaocainiaoya.common.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>open</code>是运行时用于控制反射访问的权限，如果仅仅使用<code>open</code>声明，那么类是无法被引用到，也就是编译器都无法通过，所以还需要使用<code>exports</code>或者使用<code>require static</code>配合使用。</p><p>通过<code>open</code>引入模块后，使用反射操作是不需要<code>.setAccessible(true)</code>操作授权。</p><p>在<code>git</code>上看到一些<code>JDK9</code>的示例工程中出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.web &#123;</span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开放权限给spring的部分模块, 由于目前我还没有引入spirng, 可能是在spring中对其进行</span></span><br><span class="line">    <span class="comment">// 反射之类的操作, 这里先记录下, 日后若遇到问题, 再进行详细的记录。</span></span><br><span class="line">    opens pers.darren to spring.beans, spring.core, spring.context;</span><br><span class="line">    opens pers.darren.controller.role to spring.beans, spring.core, spring.web;</span><br><span class="line">    opens pers.darren.controller.user to spring.beans, spring.core, spring.web;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>uses</code> 和 <code>provides</code> 是模块化系统中用于服务（Service）的关键字。</p><p><code>uses</code> 关键字用于声明一个模块使用某个服务。服务是一种提供特定功能的接口或抽象类，它可以由一个或多个模块实现。通过 <code>uses</code> 关键字，我们可以在模块中声明对特定服务的依赖，以便在运行时获取该服务的实现。这样，模块就可以在不依赖具体实现类的情况下使用服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common模块: 在facade包下有一个FeeFacade接口，在service包下有一个FeeService实现</span></span><br><span class="line"><span class="keyword">module</span> xiaocainiao.common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.facade;</span><br><span class="line">    <span class="keyword">requires</span> transitive lombok;</span><br><span class="line"></span><br><span class="line">    provides cn.com.xiaocainiaoya.common.facade.FeeFacade with cn.com.xiaocainiaoya.common.service.FeeService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// userCenter模块, 通过uses可以使用ServiceLoader进行加载</span></span><br><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="comment">// 引入common模块</span></span><br><span class="line">    <span class="keyword">requires</span> xiaocainiao.common;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> lombok;</span><br><span class="line"></span><br><span class="line">    uses cn.com.xiaocainiaoya.common.facade.FeeFacade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>user-center</code>模块中使用<code>ServiceLoader</code>进行加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;FeeFacade&gt; moduleServices = ServiceLoader</span><br><span class="line">    .load(FeeFacade.class).stream()</span><br><span class="line">    .map(ServiceLoader.Provider::get)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>​    接上面的<code>open</code>关键字说到，看到一些实例工程中使用<code>open</code>将包的权限开放给<code>spring</code>中的部分模块。许多库依赖于反射来发挥它们的魔力，默认情况下，在<code>JDK9</code>中只能访问到暴露包中的公共类、方法和字段，即使通过反射来访问非公共成员并调用<code>setAccessible(true)</code>，<b>也是无法访问到。</b>只能通过<code>open</code>、<code>opens</code>、<code>opens..to</code>的方式授予运行时访问权限。</p><h3 id="3-模块路径"><a href="#3-模块路径" class="headerlink" title="3.模块路径"></a>3.模块路径</h3><p>​    模块是从<code>modulePath</code>加载的，就像<code>jdk8</code>及之前的<code>jdk</code>的类是从类路径加载。所以你一定知道什么是类路径地狱，有时可能会出现在本地环境中可以成功启动项目，在其他环境无法启动成功，这是由于<code>java</code>对引用类的解析规则为第一次遇见策略，所以未知的排序依赖关系，可能会出现一些未知的问题。</p><p>​    从<code>java9</code>开始，将进入另一种地狱：<code>modulepath</code>地狱。</p><p>模块路径是一系列的模块：以文件夹或者<code>JAR</code>方式呈现，如果模块是文件夹格式，则表示该模块是分解模块的格式；如果是<code>jar</code>则是模块化的<code>jar</code>.模块和模块描述符提供的可靠配置有助于消除许多此类运行时类路径问题。每个模块都显式地声明其依赖项，这些依赖项作为应用程序启动来解析。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK9特性&quot;&gt;&lt;a href=&quot;#JDK9特性&quot; class=&quot;headerlink&quot; title=&quot;JDK9特性&quot;&gt;&lt;/a&gt;JDK9特性&lt;/h1&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Rancher入门（一）</title>
    <link href="http://xiaocainiaoya.github.io/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-06-12T13:51:58.000Z</published>
    <updated>2023-06-13T02:15:19.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rancher入门（一）"><a href="#Rancher入门（一）" class="headerlink" title="Rancher入门（一）"></a>Rancher入门（一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    公司内网的服务是通过<code>Rancher</code>进行编排，<code>Rancher</code>有<code>V1</code>和<code>V2</code>两个版本，都是提供容器调度与编排，在<code>V1</code>版本中可选不同的编排模式，比如<code>cattle</code>、<code>swarm</code>、<code>kubernetes</code>。所以<code>V1</code>时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于<code>k8s</code>后来发展势不可挡，所以<code>V2</code>版本诞生，移除了其他类型的编排工具，只剩下<code>k8s</code>，所以<code>Rancher</code>的底层是采用<code>k8s</code>编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个<code>k8s</code>集群等。</p><span id="more"></span><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>我这里是在<code>docker.hub</code>上搜索了一个<code>rancher/rancher</code>容器，直接在本机部署拉取这个容器。</p><blockquote><p>docker pull rancher/rancher</p></blockquote><p>启动这个容器：</p><blockquote><p> sudo docker run -d –restart=unless-stopped -p 80:80 -p 443:443 –privileged rancher/rancher</p></blockquote><ul><li><code>--restar</code>：表示指定容器的重启策略，可选值为<code>no</code>、<code>on-failure</code>、<code>always</code>、<code>unless-stopped</code><ul><li><code>no</code>：默认值，表示容器退出时，<code>docker</code>不自动重启容器</li><li><code>on-failure</code>：若容器的退出状态非0，则docker自动重启容器，还可以指定重启次数，若超过指定次数未能启动容器则放弃</li><li><code>always</code>：容器退出时总是重启</li><li><code>unless-stopped</code>：容器退出时总是重启，但不考虑<code>docker</code>守护进程启动时就已经停止的容器</li></ul></li><li><code>--privileged</code>：表示容器内的<code>root</code>拥有的权限，如果<code>=true</code>表示容器内的<code>root</code>拥有真正的<code>root</code>权限，否则容器内的<code>root</code>只是外部的一个普通用户权限，通过<code>--privileged</code>启动的容器，可以看到很多<code>host</code>宿主机上的设备，并且可以执行<code>mount</code>，甚至允许在这个容器中启动新的容器等等。(<code>rancher/rancher</code>这个镜像必须添加这个命令才可以启动)</li></ul><p>默认映射了<code>80</code>和<code>443</code>端口，通过<code>127.0.0.1:80</code>实际上是<code>127.0.0.1</code>就可以直接访问<code>rancher</code>。由于未使用授信证书，会有报警，忽略即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rancher入门（一）&quot;&gt;&lt;a href=&quot;#Rancher入门（一）&quot; class=&quot;headerlink&quot; title=&quot;Rancher入门（一）&quot;&gt;&lt;/a&gt;Rancher入门（一）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;​    公司内网的服务是通过&lt;code&gt;Rancher&lt;/code&gt;进行编排，&lt;code&gt;Rancher&lt;/code&gt;有&lt;code&gt;V1&lt;/code&gt;和&lt;code&gt;V2&lt;/code&gt;两个版本，都是提供容器调度与编排，在&lt;code&gt;V1&lt;/code&gt;版本中可选不同的编排模式，比如&lt;code&gt;cattle&lt;/code&gt;、&lt;code&gt;swarm&lt;/code&gt;、&lt;code&gt;kubernetes&lt;/code&gt;。所以&lt;code&gt;V1&lt;/code&gt;时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于&lt;code&gt;k8s&lt;/code&gt;后来发展势不可挡，所以&lt;code&gt;V2&lt;/code&gt;版本诞生，移除了其他类型的编排工具，只剩下&lt;code&gt;k8s&lt;/code&gt;，所以&lt;code&gt;Rancher&lt;/code&gt;的底层是采用&lt;code&gt;k8s&lt;/code&gt;编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个&lt;code&gt;k8s&lt;/code&gt;集群等。&lt;/p&gt;</summary>
    
    
    
    <category term="rancher" scheme="http://xiaocainiaoya.github.io/categories/rancher/"/>
    
    
    <category term="rancher" scheme="http://xiaocainiaoya.github.io/tags/rancher/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture任务编排</title>
    <link href="http://xiaocainiaoya.github.io/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
    <id>http://xiaocainiaoya.github.io/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/</id>
    <published>2023-06-02T13:51:58.000Z</published>
    <updated>2023-06-02T06:21:59.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture任务编排"><a href="#CompletableFuture任务编排" class="headerlink" title="CompletableFuture任务编排"></a>CompletableFuture任务编排</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    <code>CompletableFuture</code>是对<code>Future</code>的扩展，弥补了<code>Future</code>的局限性，同时又实现了对任务进行编排的能力。    </p><span id="more"></span><p>​    <code>CompletableFuture</code>实现于<code>Future</code>和<code>CompletionStage</code>，对于<code>Future</code>的扩展内容，都在<code>CompletionStage</code>接口中。在这个接口中定义了任务编排的方法，执行某个任务完成或者进行并行执行等操作的方法。</p><p><img src="https://s2.loli.net/2023/06/02/9GnaLSmQPoBFt3I.png" alt="CompletableFuture类图.png"></p><p>​    <code>CompletableFutrue</code>在对任务编排的基础上，结合<code>Futrue</code>的特性，做到可以将某个任务异步到其他线程执行，内部通过<code>Futrue</code>的阻塞相关接口来等待任务的完成，再执行编排的接下来任务。默认使用<code>ForkJoinPool</code>。</p><p><b>任务编排主要分为4大类</b></p><h3 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1.依赖关系"></a>1.依赖关系</h3><ul><li><code>thenApply()</code>：入参为以上一个任务的执行结果为入参的<code>Function</code>方法，也就是<code>thenApply()</code>中的<code>Function</code>方法的返回值是上一个任务执行结果的类型。</li><li><code>thenCompose()</code>：入参为以上一个任务的执行结果为<code>Function</code>方法的入参类型，以<code>CompletableFuture</code>为出参类型。也就是<code>thenCompose()</code>中的<code>Function</code>方法的返回值是<code>CompletableFuture</code>类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 结果转换，thenApply使用上一轮结果进行计算</span></span><br><span class="line">    <span class="comment">// thenApply 加不加async仅表示是否使用异步线程来完成任务(可指定线程池)</span></span><br><span class="line">    CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenApply(value -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenComposeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// thenCompose 与 thenApply 类似，但是thenCompose的返回值必须是CompletableFuture</span></span><br><span class="line">     <span class="comment">// thenCompose是将上一次计算的结果作为参数传进来，然后需要返回一个新的CompletableFuture</span></span><br><span class="line">     CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCompose(param -&gt; CompletableFuture.supplyAsync(() -&gt; param + <span class="string">&quot;d&quot;</span>));</span><br><span class="line">     System.out.println(result.join());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-合并关系"><a href="#2-合并关系" class="headerlink" title="2.合并关系"></a>2.合并关系</h3><p>合并A、B任务，当A、B任务完成之后执行C任务。</p><ul><li><code>thenCombine</code>：合并A、B任务，当A、B任务完成之后执行<code>thenCombine()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiFunction</code>方法，接收A、B任务的返回值作为入参，且有返回值。</li><li><code>thenAccepetBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>thenAccepetBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiConsumer</code>方法，接收A、B任务的返回值作为入参，且无返回值。</li><li><code>runAfterBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>runAfterBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>Runnable</code>，不接收参数，且无返回值。</li></ul><p>综上：其实三个方法的主要却别在于第二个参数所使用的的是<code>BiFunction</code>、<code>BiConsumer</code>、<code>Runnable</code>来控制是否需要接收前面任务的参数、是否需要有返回值。其他核心逻辑并无二至。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombineTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 联合</span></span><br><span class="line">     CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">1000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">         System.out.println(s1 + s2);</span><br><span class="line">         System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hij&quot;</span>;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.println(s1 + s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), () -&gt; &#123;</span><br><span class="line">        <span class="comment">//System.out.println(s1 + s2);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-并联关系"><a href="#3-并联关系" class="headerlink" title="3.并联关系"></a>3.并联关系</h3><p>A、B两个任务，只要有一个完成，就执行C任务。</p><ul><li><code>applyToEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>applyToEither()</code>的第二个参数是<code>Function</code>，表示使用前一个任务的返回值为入口参数，且有返回值。</li><li><code>acceptEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Consumer</code>，表示使用前一个任务的返回值为入口参数，无返回值。</li><li><code>runAfterEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Runnable</code>，表示AB任意一个任务完成后，就执行一个任务，这个任务无入参无返回值。</li></ul><p>综上：与<b>合并关系</b>其实差不多，三个方法上都是在对第二个函数式接口参数上做文章，主要为了用户在根据任务的参数需要和返回值需要选择特定的方法。</p><h3 id="4-并行关系"><a href="#4-并行关系" class="headerlink" title="4.并行关系"></a>4.并行关系</h3><p>多个任务时，多个任务都完成或者其中一个任务完成时，进行下一个任务的执行，返回的是新的<code>CompletableFuture</code>。</p><ul><li><code>allOf()</code>:当所有给定的<code>CompletableFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li><li><code>anyOf()</code>:当任何一个给定的<code>CompletablFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 只要有一个有结果就得到result, 但是存在一种情况，如果future1先完成，那么future2还是在执行，</span></span><br><span class="line">    <span class="comment">// 如果在future1执行完成后，future2执行完成前获取result的值，那么result的值就是future1的值</span></span><br><span class="line">    <span class="comment">// 获取值时如果都完成，那么由前往后取，也就是都完成的情况下，根据anyOf()方法参数定义的顺序获取。</span></span><br><span class="line">    CompletableFuture&lt;Object&gt; result = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 两个都完成了</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; result = CompletableFuture.allOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-结果处理"><a href="#5-结果处理" class="headerlink" title="5.结果处理"></a>5.结果处理</h3><p>当任务执行结束可以对任务执行的结果或者任务抛出的异常进行处理。</p><ul><li><p><code>whenComplete</code>:当任务完成时，将使用结果(或<code>null</code>)和此阶段的异常(或<code>null</code>)执行给定操作</p></li><li><p><code>exceptionally</code>:为了捕获任务中抛出的异常进行处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当某个任务完成之后，进行下一个任务</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="comment">// 上一个任务若有异常则这里的s=null, throwable=异常; 若正常执行完成则s=上一个任务的返回值, throwable=null</span></span><br><span class="line">    <span class="comment">// async表示使用可能会去使用其他线程如果使用同一线程池也可能被同一个线程执行</span></span><br><span class="line">    <span class="comment">// 不指定线程池的情况下使用的是ForkJoinPool.commonPool()</span></span><br><span class="line">    .whenComplete((s, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionallyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;).thenApply(result -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply接收到的参数 = &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常：&quot;</span> + throwable.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终返回的结果 = &quot;</span> + future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>​    在<code>CompletableFuture</code>中针对<b>每个方法</b>都定义了两个<code>xxxAsync</code>接口，以<code>whenComplete</code>方法为了，如下所示，两个<code>xxxAsync</code>接口的区别在于是否显示指定使用的线程池。如果不使用<code>xxxAsync</code>接口，则使用当前线程执行任务，如果使用<code>xxxAysnc</code>没有显示指定线程池，则使用默认的<code>ForkJoinPool</code>提供的线程池。但<code>ForkJoinPool</code>是公共线程池，如果所有的<code>CompletableFuture</code>都共享一个线程池，如果某一些任务执行较慢，会导致线程池中的所有线程阻塞，造成线程饥饿，从而影响整个系统的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在京东的开源框架<code>AsyncTool</code>，主要就是对<code>CompletableFuture</code>进行了组装和包装，使得任务的编排和回调在使用上变更更加方便。并对任务回调相关内容做了一个优化。比如在<code>CompletableFuture</code>中，如果你编排了多个任务，当前执行到那个任务，每一个任务的执行结果实际上是不知道的，只有等任务都执行完毕，最总汇总结果。<code>AysncTool</code>认为这种方式不是友好的，一个并行框架需要对每一步的执行有能进行监控，每一步无论执行成功与失败，都应该有一个回调，才算完整。比如在某些场景中，某些任务单元是需要被跳过不执行的，但是不执行的这个任务是不是也需要一个回调，进行类似于一些通知之类的动作？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CompletableFuture任务编排&quot;&gt;&lt;a href=&quot;#CompletableFuture任务编排&quot; class=&quot;headerlink&quot; title=&quot;CompletableFuture任务编排&quot;&gt;&lt;/a&gt;CompletableFuture任务编排&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;CompletableFuture&lt;/code&gt;是对&lt;code&gt;Future&lt;/code&gt;的扩展，弥补了&lt;code&gt;Future&lt;/code&gt;的局限性，同时又实现了对任务进行编排的能力。    &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>德鲁伊简单使用</title>
    <link href="http://xiaocainiaoya.github.io/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-11T14:13:58.000Z</published>
    <updated>2023-05-12T09:14:30.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="德鲁伊简单使用"><a href="#德鲁伊简单使用" class="headerlink" title="德鲁伊简单使用"></a>德鲁伊简单使用</h1><p>​    在翻阅项目底层代码时发现，在底层的<code>framework</code>模块中有引入<code>druid</code>监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下<code>druid</code>的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。</p><span id="more"></span><p><b>注：我使用的版本是<code>1.1.22</code>，如果不是这版本请绕道，避免引起不适，不同版本中修改了部分配置的前缀！！</b></p><h2 id="启用德鲁伊管理页"><a href="#启用德鲁伊管理页" class="headerlink" title="启用德鲁伊管理页"></a>启用德鲁伊管理页</h2><p>1.根据配置项加载这个管理页<code>bean</code>。前缀为<code>my.druid.monitor.enable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建德鲁伊数据源</span></span><br><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="title">druidServlet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-password:admin&#125;&quot;)</span> String password,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-username:admin&#125;&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.reset-enable:true&#125;&quot;)</span> String reset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.url-pattern:/druid/*&#125;&quot;)</span> String urlPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.allow:&#125;&quot;)</span> String allow,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.deny:&#125;&quot;)</span> String deny</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; reg = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">    reg.setServlet(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">    reg.addUrlMappings(urlPattern);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, reset);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, userName);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, password);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;allow&quot;</span>,deny );</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;deny&quot;</span>,allow);</span><br><span class="line">    <span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>yaml</code>或者<code>properties</code>配置文件中添加相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 忽略默认自动注入druid,避免走默认druid配置</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure</span></span><br><span class="line">  <span class="comment">#数据库连接池配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">        <span class="attr">allow:</span></span><br><span class="line">        <span class="attr">deny:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局druid参数，单独数据源配置为空取全局配置</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 声明默认的主数据源</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">druid:</span></span><br><span class="line">        <span class="comment"># 连接池的配置信息</span></span><br><span class="line">        <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">        <span class="attr">initial-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">        <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line">        <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">        <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">        <span class="attr">validation-query:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">        <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">        <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span></span><br></pre></td></tr></table></figure><p>到此在本地启动项目，访问<code>http://127.0.0.1:8064/xxxx/druid/login.html</code>进入管理页，登录之后，虽然进入了管理页，但是其实只是一个空壳，执行对应的<code>SQL</code>发现，并不会在监控页面上显示出来，后经过查询资料发现，这里的<code>filter</code>为空。</p><p><img src="https://s2.loli.net/2023/05/12/YQLoPJjbdrHqm3W.png" alt="druid中filter为空.png"></p><p>在配置文件中明明在<code>spring.datasource.druid.filters</code>设置了<code>stat,wall</code>等过滤器，但是实际上没有读到，排查发现，在<code>1.1.22</code>上，并不是这个配置，修改了配置前缀为<code>spring.datasource.druid.filter.stat.enabled</code></p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(FILTER_STAT_PREFIX)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = FILTER_STAT_PREFIX, name = &quot;enabled&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatFilter <span class="title">statFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 主要是为了创建这个filter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置后，在启动项目，在管理页上就显示出了执行的<code>SQL</code>语句。</p><h2 id="开发环境启用"><a href="#开发环境启用" class="headerlink" title="开发环境启用"></a>开发环境启用</h2><p>​    本以为到这里基本上已经万事大吉了，开发环境只需要复刻本地环境的配置即可。但是操作之后发现，在开发环境上访问<code>login.html</code>之后原本应该跳转到<code>druid/index.html</code>，但是<code>404</code>，看样子是<code>nginx</code>拦截处理了。</p><p>​    在<code>nginx</code>中，对于<code>/index.html</code>的路径直接转发到本地的某个文件夹中，所以修改<code>nginx.conf</code>相关配置信息，是的对<code>/druid/index.html</code>不进行这个拦截处理。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ (?!.*druid/index.html$).*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启<code>nginx</code>之后，发现还是有问题，观察发送的请求，在<code>login.html</code>提交表单之后，发起了一个<code>submitLogin</code>请求，如果用户名密码校验正确，会直接跳转到<code>druid/index.html</code>，但是这个<code>druid/index.html</code>的请求居然进行了<code>302</code>跳转，又跳回<code>druid/login.html</code>页面。通过和本地的工程发起的请求对比发现，在<code>submitLogin</code>登录之后会返回一个<code>JSESSIONID</code>的<code>cookies</code>，发起<code>druid/index.html</code>请求需要携带这个<code>cookies</code>值，但是在开发环境中不知道是<code>nginx</code>还是哪里给弄丢了，由于时间紧迫我没有细看在那个环节丢调了这个<code>cookies</code>值，我手动将这个<code>cookies</code>值打入浏览器的<code>cookies</code>中，正常访问。</p><h2 id="关闭广告"><a href="#关闭广告" class="headerlink" title="关闭广告"></a>关闭广告</h2><p>​    在开源项目若依中看到，感觉挺好玩的，便记录一下，用过<code>druid</code>管理页都知道，在面板的最下方有一个阿里的横幅广告，这个广告是请求服务器的<code>common.js</code>中会添加到页脚，请求公网的<code>banner</code>连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildFooter : function() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;&lt;a href=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner_click&quot; target=&quot;new&quot;&gt;&lt;img src=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner&quot;&gt;&lt;/a&gt;&lt;br/&gt;&#x27;</span> +</span><br><span class="line">              <span class="string">&#x27; powered by &lt;a href=&quot;https://github.com/alibaba/&quot; target=&quot;_blank&quot;&gt;Alibaba&lt;/a&gt; &amp; sandzhang &amp; &lt;a href=&quot;http://melin.iteye.com/&quot; target=&quot;_blank&quot;&gt;melin&lt;/a&gt; &amp; &lt;a href=&quot;https://github.com/shrekwang&quot; target=&quot;_blank&quot;&gt;shrek.wang&lt;/a&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br><span class="line">    $(document.body).append(html);</span><br></pre></td></tr></table></figure><p>​    所以思路上，通过对获取<code>common.js</code>进行拦截，并将这段页脚的<code>html</code>代码重写，即可达到关闭广告的目的。</p><p>1.设置一个过滤器，对<code>js/common.js</code>的请求进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DruidAdRemoveFilter 过滤器，过滤 common.js 的广告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; <span class="title">druidAdRemoveFilterFilter</span><span class="params">(DruidStatProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 druid web 监控页面的参数</span></span><br><span class="line">        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();</span><br><span class="line">        <span class="comment">// 提取 common.js 的配置路径</span></span><br><span class="line">        String pattern = config.getUrlPattern() != <span class="keyword">null</span> ? config.getUrlPattern() : <span class="string">&quot;/druid/*&quot;</span>;</span><br><span class="line">        String commonJsPattern = pattern.replaceAll(<span class="string">&quot;\\*&quot;</span>, <span class="string">&quot;js/common.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 DruidAdRemoveFilter Bean</span></span><br><span class="line">        FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; registrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> DruidAdRemoveFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.拦截过滤器中替换这段<code>html</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidAdRemoveFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * common.js 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_JS_ILE_PATH = <span class="string">&quot;support/http/resources/js/common.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="comment">// 重置缓冲区，响应头不会被重置</span></span><br><span class="line">        response.resetBuffer();</span><br><span class="line">        <span class="comment">// 获取 common.js</span></span><br><span class="line">        String text = Utils.readFromResource(COMMON_JS_ILE_PATH);</span><br><span class="line">        <span class="comment">// 正则替换 banner, 除去底部的广告信息</span></span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;&lt;a.*?banner\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;powered.*?shrek.wang&lt;/a&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        response.getWriter().write(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>替换之后的<code>html</code>变量值为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;&#x27;</span> +</span><br><span class="line">                      <span class="string">&#x27; &#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;德鲁伊简单使用&quot;&gt;&lt;a href=&quot;#德鲁伊简单使用&quot; class=&quot;headerlink&quot; title=&quot;德鲁伊简单使用&quot;&gt;&lt;/a&gt;德鲁伊简单使用&lt;/h1&gt;&lt;p&gt;​    在翻阅项目底层代码时发现，在底层的&lt;code&gt;framework&lt;/code&gt;模块中有引入&lt;code&gt;druid&lt;/code&gt;监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下&lt;code&gt;druid&lt;/code&gt;的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="druid" scheme="http://xiaocainiaoya.github.io/tags/druid/"/>
    
  </entry>
  
</feed>
