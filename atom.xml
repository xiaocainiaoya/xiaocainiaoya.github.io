<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2023-05-05T08:42:19.695Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis序列化配置</title>
    <link href="http://xiaocainiaoya.github.io/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://xiaocainiaoya.github.io/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-05T12:50:58.000Z</published>
    <updated>2023-05-05T08:42:19.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis序列化配置"><a href="#redis序列化配置" class="headerlink" title="redis序列化配置"></a>redis序列化配置</h1><blockquote><p>使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。</p></blockquote><span id="more"></span><h2 id="模板类RedisTemplate"><a href="#模板类RedisTemplate" class="headerlink" title="模板类RedisTemplate"></a>模板类RedisTemplate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplate</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">RedisAccessor</span> <span class="keyword">implements</span> <span class="title">RedisOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableTransactionSupport = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> exposeConnection = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableDefaultSerializer = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ClassLoader classLoader;</span><br><span class="line"><span class="comment">//序列化器</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> RedisSerializer&lt;String&gt; stringSerializer = RedisSerializer.string();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ScriptExecutor&lt;K&gt; scriptExecutor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常用数据结构操作类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ValueOperations&lt;K, V&gt; valueOps = <span class="keyword">new</span> DefaultValueOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListOperations&lt;K, V&gt; listOps = <span class="keyword">new</span> DefaultListOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SetOperations&lt;K, V&gt; setOps = <span class="keyword">new</span> DefaultSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StreamOperations&lt;K, ?, ?&gt; streamOps = <span class="keyword">new</span> DefaultStreamOperations&lt;&gt;(<span class="keyword">this</span>,</span><br><span class="line">ObjectHashMapper.getSharedInstance());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ZSetOperations&lt;K, V&gt; zSetOps = <span class="keyword">new</span> DefaultZSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GeoOperations&lt;K, V&gt; geoOps = <span class="keyword">new</span> DefaultGeoOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HyperLogLogOperations&lt;K, V&gt; hllOps = <span class="keyword">new</span> DefaultHyperLogLogOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClusterOperations&lt;K, V&gt; clusterOps = <span class="keyword">new</span> DefaultClusterOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有5个序列化器：</p><ul><li><code>keySerializer</code>：对存入<code>redis</code>中的<code>key</code>的序列化器</li><li><code>valueSerializer</code>：对存入<code>redis</code>中的<code>value</code>的序列化器</li><li><code>hashKeySerializer</code>：对以<code>hash</code>结构数据存入的<code>hashkey</code>序列化器</li><li><code>hashValueSerializer</code>：对以<code>hash</code>结构数据存入的<code>hashvalue</code>序列化器</li><li><code>stringSerializer</code>：字符串方式序列化器</li></ul><p>序列化器具体的实现：</p><ol><li><code>FastJsonRedisSerializer</code>由阿里巴巴的<code>fastjson</code>提供的转为<code>JSON</code>格式进行序列化。</li><li><code>Jackson2JsonRedisSerializer</code>在<code>spring</code>中已经集成，采用<code>Jackson</code>的方式转换为<code>JSON</code>格式进行序列化。</li><li><code>JdkSerializationRedisSerializer</code>jdk默认提供的序列化方式，如果是<code>POJO</code>需要实现<code>Serializable</code>接口。</li><li><code>StringRedisSerializer</code>字符方式序列化，如果是<code>POJO</code>，相当于调用了<code>toString</code>进行序列化。</li></ol><p><b>默认情况下使用的是<code>jdk</code>方式进行键和值的序列化，如果需要修改默认方式，在接入<code>spring</code>的情况下需要设置这些序列化器之后添加到<code>spring</code>容器中。你可以仅仅修改你想要修改的序列化器，其他的保持默认，模板类提供了一个后置接口。</b></p><p>它会逐个进行判断处理，如果某个序列化器为空，则设置对应的默认序列化器。所以一般在设置完成之后会调用一次这个后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</span><br><span class="line">classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableDefaultSerializer) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">keySerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">valueSerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">hashKeySerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">hashValueSerializer = defaultSerializer;</span><br><span class="line">defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h2><p>对<code>RedisTemplate</code>进行配置，设置<code>value</code>的序列化器为<code>jdk</code>提供的序列化器，<b><code>POJO</code>需要实现<code>Serializable</code>接口。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用jdk序列化方式进行序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式进行序列化之后，在<code>redis-cli</code>上查看时，默认获取的值会被转换为<b>十六进制</b>，导致在排查问题时可读性较差。</p><blockquote><p>\xAC\xED\x00\x05sr\x00\x1Ecn.com.xiaocainiaoya.vo.Person\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x04L\x00\x03aget\x00\x13Ljava/lang/Integer;L\x00\x06housest\x00\x10Ljava/util/List;L\x00\x08passwordt\x00\x12Ljava/lang/String;L\x00\x08userNameq\x00<del>\x00\x03xpsr\x00\x11java.lang.Integer\x12\xE2\xA0\xA4\xF7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xAC\x95\x1D\x0B\x94\xE0\x8B\x02\x00\x00xp\x00\x00\x00\x0Csr\x00\x13java.util.ArrayListx\x81\xD2\x1D\x99\xC7a\x9D\x03\x00\x01I\x00\x04sizexp\x00\x00\x00\x01w\x04\x00\x00\x00\x01sr\x00\x1Dcn.com.xiaocainiaoya.vo.House\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x02L\x00\x07addressq\x00</del>\x00\x03L\x00\x04areat\x00\x16Ljava/math/BigDecimal;xpt\x00\x06\xE5\x8C\x97\xE4\xBA\xACsr\x00\x14java.math.BigDecimalT\xC7\x15W\xF9\x81(O\x03\x00\x02I\x00\x05scaleL\x00\x06intValt\x00\x16Ljava/math/BigInteger;xq\x00<del>\x00\x06\x00\x00\x00\x01sr\x00\x14java.math.BigInteger\x8C\xFC\x9F\x1F\xA9;\xFB\x1D\x03\x00\x06I\x00\x08bitCountI\x00\x09bitLengthI\x00\x13firstNonzeroByteNumI\x00\x0ClowestSetBitI\x00\x06signum[\x00\x09magnitudet\x00\x02[Bxq\x00</del>\x00\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFE\x00\x00\x00\x01ur\x00\x02[B\xAC\xF3\x17\xF8\x06\x08T\xE0\x02\x00\x00xp\x00\x00\x00\x02\x03\xE9xxxt\x00\x03123t\x00\x03tom</p></blockquote><p>根据比对调用反序列化时的二进制流，发现这一串乱码中“\xAC”表示的十六进制，“\x05sr”中的“\x05”表示一个十六进制，“sr”需要按位解析为二进制，按这个逻辑进行解析之后，得到的结果就是反序列化字节流，所以根据这个逻辑就可以简单通过一段代码将这串乱码反序列化为原始对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String value = <span class="string">&quot;\\xAC\\xED\\x00\\x05t\\x00\\x18Pj/1x/ZLXkvm0q6bNZiOYw==&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] hexValues = value.split(<span class="string">&quot;\\\\x&quot;</span>);</span><br><span class="line">    <span class="comment">// 结果字节流长度，适当调整长度，如果类过大，可能长度不够会报数组长度越界</span></span><br><span class="line">    <span class="keyword">byte</span>[] resultValue = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> resultIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hexValues.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 切割之后可能出现首个或者末个是空串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isEmpty(hexValues[i]))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// AC/ED/00等表示为单个十六进制</span></span><br><span class="line">        <span class="keyword">if</span>(hexValues[i].length() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(hexValues[i], <span class="number">16</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 05t等认为前两位为十六进制，后面按字符逐个转换为字节</span></span><br><span class="line">            String str = hexValues[i];</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(str.substring(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 后面的按字符转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; str.length(); j++)&#123;</span><br><span class="line">                resultValue[resultIndex++] = (<span class="keyword">byte</span>) str.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对转换的字节流进行反序列化解析为对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> JdkSerializationRedisSerializer().deserialize(resultValue);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在排查问题时，可以尝试使用这种方式对乱码串进行解析，得到原始对象。(<b>前提是你的工程存在这个类！！</b>)</p><h2 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h2><p>字符序列化器，一般对于存入的<code>key</code>和非<code>POJO</code>都会采用这种方式进行序列化，在<code>redis-cli</code>上也能直观的看到对应的键和值是什么。</p><p>在<code>Spring</code>中已经提供了对键和值都采用字符序列化器的方式进行操作的模板类<code>StringRedisTemplate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setKeySerializer(RedisSerializer.string());</span><br><span class="line">setValueSerializer(RedisSerializer.string());</span><br><span class="line">setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> RedisSerializer&lt;String&gt; <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringRedisSerializer.UTF_8;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 设置为编码为UTF-8的字符序列化器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer UTF_8 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jackson2JsonRedisSerializer"><a href="#Jackson2JsonRedisSerializer" class="headerlink" title="Jackson2JsonRedisSerializer"></a>Jackson2JsonRedisSerializer</h2><p><code>jackson</code>机制进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>jackson</code>方式进行序列化之后的值，如下所示，对于复杂对象会表示它的类型，这种存储方式会导致占用的序列化串长度过长，占用一定的存储空间。</p><blockquote><p>[“cn.com.xiaocainiaoya.vo.Person”,{“userName”:”tom”,”password”:”123”,”age”:12,”houses”:[“java.util.ArrayList”,[[“cn.com.xiaocainiaoya.vo.House”,{“address”:”北京”,”area”:[“java.math.BigDecimal”,100.1]}]]]}]</p></blockquote><h2 id="FastJsonRedisSerializer"><a href="#FastJsonRedisSerializer" class="headerlink" title="FastJsonRedisSerializer"></a>FastJsonRedisSerializer</h2><p>阿里巴巴提供的<code>fastjson</code>序列化器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer = <span class="keyword">new</span> FastJsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        <span class="comment">// 全局开启AutoType，不建议使用</span></span><br><span class="line">        <span class="comment">// ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span></span><br><span class="line">        <span class="comment">// 建议使用这种方式，小范围指定白名单</span></span><br><span class="line">        <span class="comment">//ParserConfig.getGlobalInstance().addAccept(&quot;cn.com.xiaocainiao&quot;);</span></span><br><span class="line">        template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式生成的<code>JSON</code>串结果如下所示，对比<code>jackson</code>序列化器生成的结果串，发现复杂对象的所在类不会生成，减少一定的空间占用。</p><blockquote><p>{“age”:12,”houses”:[{“address”:”北京”,”area”:100.1}],”password”:”123”,”userName”:”tom”}</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis序列化配置&quot;&gt;&lt;a href=&quot;#redis序列化配置&quot; class=&quot;headerlink&quot; title=&quot;redis序列化配置&quot;&gt;&lt;/a&gt;redis序列化配置&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot部分功能浅析</title>
    <link href="http://xiaocainiaoya.github.io/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/</id>
    <published>2023-04-26T14:51:58.000Z</published>
    <updated>2023-04-28T02:10:47.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot部分功能浅析"><a href="#springboot部分功能浅析" class="headerlink" title="springboot部分功能浅析"></a>springboot部分功能浅析</h1><span id="more"></span><h2 id="1-绑定器"><a href="#1-绑定器" class="headerlink" title="1.绑定器"></a>1.绑定器</h2><p><code>org.springframework.boot.context.properties.bind.Binder</code>是<code>springboot</code>从<code>environment</code>对象中获取配置信息的绑定器，可以很方便的就获取到对应的配置值信息。</p><p>1.创建配置类(必须要提供<code>set</code>方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DtpProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.配置文件中的配置项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.dynamic.enabledBanner</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.dynamic.apollo.namespace</span>=<span class="string">aaa</span></span><br></pre></td></tr></table></figure><p>2.通过<code>Binder</code>获取配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binder.get(environment).bind(<span class="string">&quot;spring.dynamic&quot;</span>, Bindable.ofInstance(dtpProperties));</span><br></pre></td></tr></table></figure><h2 id="2-Import引入"><a href="#2-Import引入" class="headerlink" title="2.@Import引入"></a>2.@Import引入</h2><p>通过<code>@Import</code>引入将某些配置类或者扩展点接口添加到容器中。</p><p><b>示例：</b></p><p>1.创建一个注解<code>EnableMyConfig</code>，该注解使用<code>@Import</code>标记，并添加<code>MyConfigurationSelector.class</code>，这个类实现了<code>ImportSelector</code>顶层接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MyConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现<code>DeferredImportSelector#selectImports</code>接口，那么在<code>Spring</code>加载到这个引入类<code>MyConfigurationSelector</code>时就会将<code>MyBeanDefinitionRegistrar</code>类添加到<code>Spring</code>容器中，作用等同于为<code>MyBeanDefinitionRegistrar</code>添加<code>@Component</code>等自动注入注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;MyBeanDefinitionRegistrar.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.这个引入类一般以注册类居多，如果是配置类一般通过<code>@Component</code>或者<code>@Configuration</code>等注解就可自动注入，我这里的示例是一个注册类。实现于<code>ImportBeanDefinitionRegistrar</code>接口，<code>MyBeanDefinitionRegistrar</code>这个<code>spring</code>生命周期中会执行到<code>registerBeanDefinitions</code>，即为<code>MyProperties</code>类创建<code>BeanDefinition</code>对象，并将这个对象注入到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BeanDefinition对象构建器</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(DtpProperties.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注入属性键和属性值</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;enabledBanner&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里手动注册bean对象</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myProperties&quot;</span>, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：<code>@EnableMyConfig</code>注解需要标记到某个类上，且这个类在扫描范围之内才会生效，我曾经深深陷入于这个注解已经是在扫描范围之内，为什么需要标记到某个类上，扫描到这个注解后这个注解不是被<code>@Import</code>标记吗，难道不能直接获取到<code>@Import</code>中的值。实际上还是需要通过标记的这个类上拥有<code>@Component</code>等自动注入的注解。</b></p><p>整个过程大致为：由<code>Spring</code>容器MapperScan入口<code>refresh</code>方法 &rArr;执行容器中实现<code>BeanDefinitionRegistryPostProcessor</code>的<code>bean</code>对象&rArr;<code>ConfigurationClassPostProcessor</code>是对<code>BeanDefinitionRegistryPostProcessor</code>的实现，主要处理逻辑在这个类中。&rArr;之后会执行实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>，也就是这时会执行<code>MyBeanDefinitionRegistrar</code>这个自定义类，在这个自定义类中又注册了新的<code>BeanDefinition</code>&rArr;之后<code>Spring</code>容器会创建这个<code>Bean</code>对象。</p><p>综上：从<code>Spring</code>容器的角度来说，<code>MyBeanDefinitionRegistrar</code>是在<code>ConfigurationClassPostProcessor</code>执行时加载的，<code>MyProperties</code>是在<code>MyBeanDefinitionRegistrar</code>加载之后加载。</p><p>​    目前在<code>Spring</code>的生态中一般都是通过<code>@EnableXX</code>注解标记<code>@Import</code>注解来引入某些配置的方式，进行动态的引入某些配置类。比如<code>EnableScheduling</code>，只有将这个注解标记在扫描配置类之上，才会通过<code>@Import</code>引入配置<code>SchedulingConfiguration</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Import</code>也可以配合<code>ImportSelector</code>实现类，进行动态创建类。比如<code>MapperScan</code>。在<code>MapperScannerRegistrar</code>中动态的创建 <code>MapperScannerConfigurer</code>对象并注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置类加载"><a href="#3-配置类加载" class="headerlink" title="3.配置类加载"></a>3.配置类加载</h2><p><code>EnableConfigurationProperties</code>注解配合<code>ConfigurationProperties</code>注解进行使用。</p><p>假设说创建了一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个类没有标记<code>@Configuration</code>注解，那么这个容器中不会有这个类的<code>Bean</code>对象。</p><p>所以将此配置类添加到容器中有两种方式，一种是直接添加注入容器注解<code>@Configuration</code>。第二种是通过<code>@EnableConfigurationProperties</code>注解指向这个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRegistry <span class="title">myRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当加载<code>DtpBaseBeanConfiguration</code>这个类时，会读取到<code>EnableConfigurationProperties</code>注解，这里又是一个<code>@Import</code>的应用，引入了<code>EnableConfigurationPropertiesRegistrar</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnableConfigurationPropertiesRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">registerInfrastructureBeans(registry);</span><br><span class="line">registerMethodValidationExcludeFilter(registry);</span><br><span class="line">ConfigurationPropertiesBeanRegistrar beanRegistrar = <span class="keyword">new</span> ConfigurationPropertiesBeanRegistrar(registry);</span><br><span class="line">    <span class="comment">// 获取到指向的配置类(这里是MyProperties),这里会将MyProperties转换为</span></span><br><span class="line">    <span class="comment">// BeanDefinition对象注册到容器中, 等到根据BeanDefinition创建具体的bean</span></span><br><span class="line">    <span class="comment">// 对象的时候，会读取到ConfigurationProperties注解进行配置属性值的绑定</span></span><br><span class="line">getTypes(metadata).forEach(beanRegistrar::register);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：这个<code>EnableConfigurationProperties</code>注解的作用仅仅是将某个配置类转换为<code>BeanDefinition</code>注册到<code>Spring</code>容器中，结合<code>@ConditionXXX</code>可以减少无用<code>bean</code>对象的创建。</b></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot部分功能浅析&quot;&gt;&lt;a href=&quot;#springboot部分功能浅析&quot; class=&quot;headerlink&quot; title=&quot;springboot部分功能浅析&quot;&gt;&lt;/a&gt;springboot部分功能浅析&lt;/h1&gt;</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>springboot的Spi机制</title>
    <link href="http://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/</id>
    <published>2023-04-10T14:51:58.000Z</published>
    <updated>2023-04-10T06:45:06.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot的Spi机制"><a href="#springboot的Spi机制" class="headerlink" title="springboot的Spi机制"></a>springboot的Spi机制</h1><p>​    在与<code>Springboot</code>打交道的过程中，应该大家对<code>starter</code>都不会陌生，<code>springboot</code>中的各种<code>starter</code>其实就是利用了<code>springboot</code>的<code>SPI</code>机制。</p><span id="more"></span><p>​    在<code>springboot</code>中，会默认扫描<code>Applicatoin</code>启用类及其子包里面的配置类<code>Bean</code>(比如标记<code>@Configuration</code>，<code>@Component</code>，<code>@Server</code>等)然后进行初始化，那么如果你是为别人提供二方包，三方包的库，如果你的需要加载的类路径跟他的不一样，那么根据<code>Springboot</code>的<code>bean</code>加载机制是不会加载到的。</p><p><b>主工程：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── Application.java</span><br></pre></td></tr></table></figure><p><b>二方库A：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure><p><b>二方库B：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure><p>这时只有<b>二方库A</b>可以正确加载<code>MybatisXmlReloadConfig</code>这个<code>bean</code>，因为它的路径在<b>主工程</b>的<code>Application</code>的包以及子包下，那么就出现所有的二方库、三方库都需要与主工程的类路径一致？</p><p>这里<code>Springboot</code>就提供了<code>Spi</code>的机制用来获取二方库，三方库中需要加载的<code>Bean</code>对象。</p><p><code>注意</code>：一定要确保二方库、三方库的类路径不在主工程<code>Application</code>下的情况，在考虑<code>SPI</code>逻辑，我之前就掉入一个陷阱，因为我的二方库的类路径与主工程一致，但是那个时候我的<code>spring.factories</code>指向的路径是错的，导致一度怀疑自己理解的<code>SPI</code>有出入。</p><p><b>二方库、三方库类路径与主工程启动类路径不一致的情况下！！！(再次强调！)</b>如果使得主工程可以加载到对应库中的<code>bean</code>对象。</p><ol><li><p>创建<code>META-INF/spring.factories</code>文件。这个文件中是<code>k-v</code>的结构，一个<code>key</code>对应多个逗号分隔的<code>value</code>。对于这个文件来说，可以配置的<code>key</code>有很多，比如有<code>EnableAutoConfiguration</code>，<code>ApplicationContextInitializer</code>，<code>ApplicationListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li><li><p>在主工程启动时，会加载<code>META-INF/spring.factories</code>文件，对这个文件内指向的<code>bean</code>对象进行逐个加载。</p></li></ol><p>主要源码在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line"><span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：在<code>Springboot2.7</code>之后引入了新的<code>SPI</code>配置方式。</b></p><ol><li><p>创建<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件。这个文件的文件名是固定，文件内容是<code>value</code>，各个<code>value</code>之间通过回车分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bosssoft.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li></ol><p>主要源码同样是在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中进行了兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line"><span class="comment">// 兼容</span></span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot的Spi机制&quot;&gt;&lt;a href=&quot;#springboot的Spi机制&quot; class=&quot;headerlink&quot; title=&quot;springboot的Spi机制&quot;&gt;&lt;/a&gt;springboot的Spi机制&lt;/h1&gt;&lt;p&gt;​    在与&lt;code&gt;Springboot&lt;/code&gt;打交道的过程中，应该大家对&lt;code&gt;starter&lt;/code&gt;都不会陌生，&lt;code&gt;springboot&lt;/code&gt;中的各种&lt;code&gt;starter&lt;/code&gt;其实就是利用了&lt;code&gt;springboot&lt;/code&gt;的&lt;code&gt;SPI&lt;/code&gt;机制。&lt;/p&gt;</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用zip4j打包文件</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/</id>
    <published>2023-03-24T13:51:58.000Z</published>
    <updated>2023-03-27T09:37:54.099Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近接到需求需要为打包后的<code>zip</code>文件设置压缩密码，而我们之前使用的<code>ZipOutputStream</code>结合<code>hutool</code>的<code>NoiUtil</code>进行打包生成<code>zip</code>文件，但是<code>ZipOutputStream</code>没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问<code>chatGPT</code>)，它的回答是<code>Zip4j</code>。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Zip4j</code>是一个用于处理<code>ZIP</code>文件格式的<code>Java</code>库，它提供了一个易于使用的<code>API</code>，可以方便地创建、提取和修改<code>ZIP</code>文件，以及支持密码保护的ZIP文件。</p><p><code>Zip4j</code>的主要特点包括：</p><ol><li>支持标准<code>ZIP</code>文件格式以及<code>ZIP64</code>扩展格式，可以处理包含数百万文件的<code>ZIP</code>文件。</li><li>支持密码保护的<code>ZIP</code>文件，包括标准密码和<code>AES</code>加密密码。</li><li>支持<code>ZIP</code>文件的分卷（spanned）和自解压缩（self-extracting）功能。</li><li>支持<code>ZIP</code>文件的压缩级别、注释和<code>UTF-8</code>编码文件名等属性的设置。</li><li>提供了方便的<code>API</code>，可以方便地添加、提取和修改<code>ZIP</code>文件中的文件和文件夹，以及获取<code>ZIP</code>文件中的文件列表和属性信息。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我使用的是<code>2.1.6</code>版本，新版本对旧版本中的一些常量和接口有调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstDemo</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    List&lt;File&gt; fileToAdds = Arrays.asList(file1, file2);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    zipFile.addFiles(fileToAdds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    String filePath1 = <span class="string">&quot;/xxx/demo1.txt&quot;</span>;</span><br><span class="line">    String filePath2 = <span class="string">&quot;/xxx/demo2.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(filePath1);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(filePath2);</span><br><span class="line"></span><br><span class="line">    ZipDemo zipDemo = <span class="keyword">new</span> ZipDemo();</span><br><span class="line">    zipDemo.firstDemo(file1, file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>fileToAdds</code>列表打包为目标地址为<code>/xxx/result.zip</code>的压缩文件。这种写法是最简单的打包方式，将需要打包的源文件都打包在目标<code>zip</code>文件的顶层目录下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├─────── demo1.txt</span><br><span class="line">  └─────── demo2.txt</span><br></pre></td></tr></table></figure><p>但是有时候，甚至大部分时候都是需要将打包源文件进行分级(压缩包内文件夹)的方式进行打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├───── dir1</span><br><span class="line">  │       └─ demo1.txt</span><br><span class="line">  └───── demo2.txt</span><br></pre></td></tr></table></figure><p><b>1.设置目标<code>zip</code>文件内文件夹结构示例代码：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customInnerFilePath</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化压缩参数</span></span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 将设置的压缩参数作用在某个文件上</span></span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置文件夹加密：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptZip</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line">    zipParameters.setEncryptFiles(<span class="keyword">true</span>);</span><br><span class="line">    zipParameters.setEncryptionMethod(EncryptionMethod.AES);</span><br><span class="line">    zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：</b>上述代码中仅仅是对<code>file1</code>设置了<code>zipParameters</code>参数，也就是说现在有两个被打包文件，但是压缩参数只设置到了其中的一个文件上，打开压缩后的文件会发现，是需要解压密码才能解压，但是如果你有一些不需要解压可以查看<code>zip</code>包内部情况的工具可以发现，可以<code>file2</code>所对应的文件是无需密码就可以查看，也就是说，如果要对压缩包内所有文件在没有解压密码之前都不能访问，需要每个文件添加时设置<code>zipParameters</code>参数，设置为加密开启。</p><p><img src="https://s2.loli.net/2023/03/27/qbauo5fZCevzDUS.png" alt="zip文件内部分文件加密.png"></p><p>还有一点：踩过一个坑，由于我在打包文件的时候，可能出现某一个压缩包已经打包过了，但是业务上并不知道已经打包过了，所以会出现重复打包的情况，而我在针对重复打包的情况，会先将目标<code>zip</code>设置为一个空文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过java标准库中的方法，这时这个目标文件存在，但是内容被清除，结果是0B</span></span><br><span class="line">Files.newByteChannel(result, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE).close();</span><br></pre></td></tr></table></figure><p>但是这种情况下运行会报错：</p><blockquote><p>Zip file size less than minimum expected zip file size. Probably not a zip file or a corrupted zip file</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zip4jRaf.length() &lt; ENDHDR) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ZipException(<span class="string">&quot;Zip file size less than minimum expected zip file size. &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;Probably not a zip file or a corrupted zip file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思是目标文件是一个空文件，校验了目标文件头部的一个什么长度。没有细究这个问题，我的做法是改成直接删除旧文件，然后再生成文件。</p><p><b>3.打包分卷</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">zip</span><span class="params">(List&lt;String&gt; srcFiles, String destFile, <span class="keyword">long</span> fileSize)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(destFile);</span><br><span class="line">    List&lt;File&gt; filesToAdd = srcFiles.stream().map(File::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    ZipParameters parameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    parameters.setCompressionMethod(CompressionMethod.DEFLATE);</span><br><span class="line">    parameters.setCompressionLevel(CompressionLevel.NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未指定则设置为512KB</span></span><br><span class="line">    <span class="keyword">if</span>(fileSize==<span class="number">0</span>)&#123;</span><br><span class="line">        fileSize = <span class="number">65536</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置压缩分卷</span></span><br><span class="line">    zipFile.createSplitZipFile(filesToAdd, parameters, <span class="keyword">true</span>, fileSize);</span><br><span class="line">    <span class="keyword">return</span> zipFile.getSplitZipFiles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分卷生成的文件结构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标文件目录</span><br><span class="line">  ├─────── result.z01</span><br><span class="line">  └─────── result.z02</span><br></pre></td></tr></table></figure><p>这里会生成<code>.z</code>+<code>数字排列</code>的压缩包，要提取或打开这样的分卷<code>ZIP</code>文件，必须将所有的<code>ZIP</code>文件都放在同一个目录下。这种场景就可以用于大文件分卷为多个小文件后，传输小文件到目标地址。</p><p><b>4.提取</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> ZipException</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个ZipFile对象，用于打开要提取的ZIP文件</span></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置解压缩密码（如果需要）</span></span><br><span class="line">    <span class="keyword">if</span> (zipFile.isEncrypted()) &#123;</span><br><span class="line">        zipFile.setPassword(<span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.将所有文件都提取到当前目录下</span></span><br><span class="line">    zipFile.extractAll(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.仅提取一个文件</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;demo1.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.提取的这个文件不是在顶层目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/demo3.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.提取整个内部目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<code>Zip4j</code>是一个非常实用的<code>Java</code>库，可以帮助程序员方便地处理<code>ZIP</code>文件格式，节省大量的开发时间和工作量。还包含其他的一些，比如添加某个文件到<code>zip</code>文件中，修改<code>zip</code>中的某个文件等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近接到需求需要为打包后的&lt;code&gt;zip&lt;/code&gt;文件设置压缩密码，而我们之前使用的&lt;code&gt;ZipOutputStream&lt;/code&gt;结合&lt;code&gt;hutool&lt;/code&gt;的&lt;code&gt;NoiUtil&lt;/code&gt;进行打包生成&lt;code&gt;zip&lt;/code&gt;文件，但是&lt;code&gt;ZipOutputStream&lt;/code&gt;没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问&lt;code&gt;chatGPT&lt;/code&gt;)，它的回答是&lt;code&gt;Zip4j&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（六）---锁（第二弹）</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/</id>
    <published>2023-03-02T14:13:58.000Z</published>
    <updated>2023-03-03T07:31:25.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（六）—锁（第二弹）"><a href="#mysql45讲学习总结（六）—锁（第二弹）" class="headerlink" title="mysql45讲学习总结（六）—锁（第二弹）"></a>mysql45讲学习总结（六）—锁（第二弹）</h1><p>​    本篇主要为了记录间隙锁和<code>next-key lock</code>相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。</p><span id="more"></span><p>这里简单回顾一下：</p><p>表锁：如果查询条件中不包含索引字段，则是表锁。</p><p>行锁：行锁只能锁住行，跟行锁有冲突的是“另外一个行锁”</p><p>间隙锁：间隙锁是锁住两个值之间的空隙，跟间隙锁有冲突的是“往这个间隙插入一个记录”这个动作，所以某一个间隙可以被多个线程上间隙锁。</p><p><code>Next-Key Lock</code>是行锁和间隙锁的结合体。</p><p><b>无论任何锁的释放，都不是在执行完事务内的某条语句之后，是整个事务提交之后才会释放锁。</b></p><h2 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `USER_INFO` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_NAME` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`),</span><br><span class="line">  KEY `IDX_USER_ID` (`USER_ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br></pre></td></tr></table></figure><p>可以看到上面示例中有一张<code>USER_INFO</code>表，在<code>ID</code>上有主键索引，在<code>USER_ID</code>上有非唯一索引。这时有两个事务并发，事务1是删除，事务2是插入。</p><p><strong>分析一下上锁过程：</strong></p><p>因为<code>USER_ID</code>是有非唯一索引，那么对<code>USER_ID</code>索引上<code>Next-Key Lock</code>。(假设事务1比事务2快一点点到达)</p><ol><li>上锁的基本单位是<code>Next-Key Lock</code>，上<code>Next-Key Lock</code>为(前一个<code>USER_ID</code>, 10]，前开后闭。</li><li>由于<code>USER_ID</code>是非唯一索引，这时还需要向后扫描到第一个不等值才返回(不等于10)，但是由于目前这张表中的最大<code>USER_ID=10</code>，所以这时会变成<code>mysql</code>预设的最大值(+suprenum)。</li><li>所以最后锁的范围为(前一个formId， +suprenum)</li></ol><p><font color="red">在步骤2中，由于间隙锁需要锁住一个空间，但是在<code>USER_ID=10</code>之后没有其他数据，才会导致锁住了<code>USER_ID=10</code>之后的所有空间，这也不能理解，由于是非唯一索引，所以无法保证不会在<code>USER=10</code>之后再插入一条<code>USER_ID=10</code>的数据。</font></p><p>所以这个时候的事务2进来是就需要等待事务1提交事务之后才能进行数据插入。</p><p>可以自己通过脚本测试一下，验证结论是否正确。开两个<code>SQL</code>窗口，进行两个线程测试。</p><p>线程1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">-- 延迟 提交事务</span></span><br><span class="line"><span class="keyword">SELECT</span> sleep(<span class="number">10</span>) <span class="keyword">FROM</span> USER_INFO limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>线程2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h2 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h2><ol><li>原则1：加锁的基本单位就是<code>Next-Key Lock</code>，<code>Next-Key Lock</code>是前开后闭区间。</li><li>原则2：在加锁过程中访问到的对象(记录)才会被锁。</li><li>优化1：对唯一索引的等值查询，<code>Next-Key Lock</code>退化为行锁。</li><li>优化2：索引上的等值查询，从第一个满足等值条件的索引记录开始向右遍历到第一个不满足等值条件记录，并将第一个不满足等值条件记录上的<code>Next-Key Lock</code>退化为间隙锁</li></ol><p>下文通过这个脚本中的表和数据为例，进行加锁规则的一些解释。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这时对于主键索引来说，具有的值为<code>0、5、10、15、20、25</code>，以及7个间隙。</p><p><img src="https://s2.loli.net/2023/03/02/IqU9dRAu2c6VCYz.png" alt="间隙锁2.png"></p><h3 id="1-等值查询间隙锁"><a href="#1-等值查询间隙锁" class="headerlink" title="1.等值查询间隙锁"></a>1.等值查询间隙锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>update t set d=d+1 where id=7</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>Insert into t values(8, 8, 8)<br>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update set d=d+1 where id=10;<br/>(<font color='green'>Query OK</font>)</td><td>T3</td></tr></tbody></table><ol><li>在<code>T1</code>时刻，由于没有<code>id=7</code>这条记录，根据加锁规则，锁住<code>B</code>这个间隙，由于<code>Next-Key Lock</code>是前开后闭，所以锁住空间为<code>(5,10]</code></li><li><font color="red">若表中存在<code>id=7</code>这条记录，则根据优化1，锁住的仅仅为<code>id=7</code>这条记录。但是由于没有这条记录，故进入优化2的加锁规则。</font>根据优化2，等值查询<code>where id=7</code>向右遍历时，遇到的最后一个不满足等值条件的记录时，<code>Next-Key Lock</code>退化为间隙锁，所以<code>T1</code>时刻后最终加锁的范围为<code>(5,10)</code></li></ol><p>所以<code>T2</code>时刻的<code>SessionB</code>操作被阻塞，<code>T3</code>时刻的<code>SessionC</code>操作没有被阻塞。</p><h3 id="2-非唯一索引等值锁"><a href="#2-非唯一索引等值锁" class="headerlink" title="2.非唯一索引等值锁"></a>2.非唯一索引等值锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select id form t where c=5 lock in share mode;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where id=5;<br>(<font color='green'>Query OK</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(7, 7,7)<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li>根据原则1，加锁单位是<code>Next-Key Lock</code>,所以会给<code>(0,5]</code>上<code>Next-Key Lock</code>锁。</li><li>由于<code>c</code>是非唯一索引，当访问到<code>c=5</code>这条记录后不会停下来，会继续向后遍历，当遍历到<code>c=10</code>这条记录后停止，所以这时要对<code>(5,10]</code>上<code>Next-Key Lock</code>，但根据优化2，这时<code>Next-Key Lock</code>退化为间隙锁<code>(5,10)</code></li></ol><p>所以最终，在<code>T1</code>时刻，上锁的范围是<code>(0, 5]</code>的<code>Next-Key Lock</code>和<code>(5,10)</code>的间隙锁，故<code>T3</code>时刻，<code>SessionC</code>插入<code>c=7</code>的数据被阻塞。</p><p><font color="red">这里为什么<code>T2</code>时刻的<code>SessionB</code>执行成功？</font>这是因为加锁规则中的原则2，只有访问到的对象才会加锁，因为这条<code>SQL</code>采用的是索引覆盖，所以并不需要访问主键索引，所以也就没有对主键索引上锁，所以<code>sessionB</code>才会执行成功。</p><p><b>注意:<code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>不一样，<code>Mysql</code>这时认为接下来要更新数据，会顺便为主键索引上锁。</b>所以如果你要用<code>lock in share mode</code>来给行添加读锁避免数据被更新，就必须绕过覆盖索引的优化，在查询字段中添加索引中不存在的字段，让它必须进行一次回表。</p><h3 id="3-主键范围索引锁"><a href="#3-主键范围索引锁" class="headerlink" title="3.主键范围索引锁"></a>3.主键范围索引锁</h3><p>这两条<code>SQL</code>虽然在查询结果是一致的，但是它们的加锁规则不太一样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;=10 and id&lt;11 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(8, 8,8);<br>(<font color='green'>Query OK</font>)<br>insert into t values(13, 13,13);<br/>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update t set d=d+1 where id=15;<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li>开始执行时，从<code>id=10</code>开始查询，这里本来应该是<code>(5,10]</code>的<code>Next-Key Lock</code>，由于<code>id</code>是唯一索引，退化为行锁，这时只加了<code>id=10</code>这一行的行锁。</li><li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code>，这里要扫到<code>id=15</code>是正常的，只有扫到了这条记录，才会知道需不需要继续往后找。</li></ol><p><b>注意：</b><code>sessionA</code>的步骤一首次定位<code>id=10</code>是用等值查询来判断的，步骤二继续向右遍历用的是范围查询判断(范围查询并没有在两个优化中，所以这里的<code>(10, 15]</code>不会退化为间隙锁！！！这个要注意，优化只有在等值查询的时候才会发生，我在第一次看的时候当时也突然卡住，没有想明白为什么没有退化为间隙锁！)</p><h3 id="4-非唯一索引范围锁"><a href="#4-非唯一索引范围锁" class="headerlink" title="4.非唯一索引范围锁"></a>4.非唯一索引范围锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;=10 and c&lt;11 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(8, 8,8);<br>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update t set d=d+1 where c=15;<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><p>这个与案例3的区别在于通过字段<code>c</code>来进行查询，字段<code>c</code>是非唯一索引。</p><ol><li>根据<code>c=10</code>找到了<code>c=10</code>这条记录，所以添加对<code>(5,10]</code>添加<code>Next-Key Lock</code>，由于是非唯一索引，所以不会退化为间隙锁。</li><li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code></li></ol><p>综上：这里对索引<code>c</code>上了<code>(5,10]</code>和<code>(10, 15]</code>两个<code>Next-Key Lock</code>。</p><h3 id="5-唯一索引范围锁bug"><a href="#5-唯一索引范围锁bug" class="headerlink" title="5.唯一索引范围锁bug"></a>5.唯一索引范围锁bug</h3><p>在开头叙述的两个原则，两个优化的加锁原则之外，还有一个加锁<code>bug</code>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;10 and id&lt;=15 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where id=20;<br/>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(16, 16,16);<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><p><code>sessionA</code>是一个范围查询，根据原则1，这时为<code>(10,15]</code>上<code>Next-Key Lock</code>，并且<code>id</code>是唯一键，所以判断到<code>id=15</code>这一行就应该停止了，但实际上<code>InnoDB</code>会继续向后遍历到第一个不满足条件的行为止，也就是<code>id=20</code>这条记录，所以<code>(15,20]</code>也会上<code>Next-Key Lock</code>。所以这时<code>SessionB</code>和<code>SessionC</code>也会被锁住。</p><p>照理来说，扫描到<code>id=15</code>这行后，就可以不用继续往后查询了，但实际上<code>InnoDB</code>实际上还是这么做了。所以在<code>mysql 45讲</code>的作者认为这是一个<code>bug</code>。</p><h3 id="6-非唯一索引上存在等值的情况"><a href="#6-非唯一索引上存在等值的情况" class="headerlink" title="6.非唯一索引上存在等值的情况"></a>6.非唯一索引上存在等值的情况</h3><p>开头创建的表结构和数据中，没有存在索引<code>c</code>上有等值的数据，所以这里插入一条等值数据。</p><blockquote><p>insert into t values(30,10,30);</p></blockquote><p>执行之后，表中有两条<code>c=10</code>的数据。下图为索引<code>c</code>的间隙状态如下(上方是<code>c</code>，下方是主键)</p><p><img src="https://s2.loli.net/2023/03/02/FpGekvjcSrM7zCt.png" alt="非唯一索引间隙锁.png"></p><p>这时有两个<code>c=10</code>的记录，他们的主键<code>id</code>值不同（分别是<code>10</code>和<code>30</code>），但是这两个记录之间也是有间隙的。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>delete from t where c=10</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where c=15;<br/>(<font color='green'>Query OK</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(12, 12,12);<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li><code>sessionA</code>在遍历时先访问第一个<code>c=10</code>的记录，这时先对<code>(c=5,id=5)</code>到<code>(c=10,id=10)</code>这个<code>Next-Key Lock</code></li><li>继续向后遍历，直到碰到<code>(c=15,id=15)</code>这一行，遍历停止，根据优化2，这时一个等值查询，向右遍历第一个不满足条件的的行会退化为<code>(c=10,id=10) </code>到<code> (c=15,id=15)</code>的间隙锁。</li></ol><p>也就是说这个<code>delete</code>语句在索引<code>c</code>上的加锁范围就是下图中标记的区域，这里不包含两边的两条记录，是开区间，即<code> (c=5,id=5)</code> 和<code>(c=15,id=15)</code>这两行上都没有锁。<b>同时主键索引上锁(10,10,10) 和 (30,10,30) 两行,是行锁。</b></p><p><img src="https://s2.loli.net/2023/03/02/E5r6kSWTJDxpNQu.png" alt="非唯一索引间隙锁2.png"></p><h3 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h3><p>这个是对案例6的一个对照案例。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>delete from t where c=10 limit 2;</td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(12, 12, 12);<br/>(<font color='green'>Query OK</font>)</td><td>T2</td></tr></tbody></table><p>这个例子对比案例6的<code>sessionA</code>，仅在<code>delete</code>语句上加了<code>limit 2</code>，可能你会觉得数据库中<code>c=10</code>的记录只有两条，加不加<code>limit 2</code>删除的效果都是一样的，但是实际上加锁的访问有所不同。</p><p>这是因为，案例7的<code>delete</code>语句明确了<code>limit 2</code>的限制，因此在遍历到<code>(c=10, id=30)</code>这一行之后，就已经满足语句了，遍历就结束了。所以索引<code>c</code>的加锁范围就变成了<code>（c=5,id=5)</code>到<code>（c=10,id=30)</code>这个前开后闭区间。所以这时<code>T2</code>时刻的<code>sessionB</code>插入<code>c=12</code>是可以执行成功的。</p><p>所以这个例子对我们的实践是有指导意义的，<b>在删除数据的时候尽量加<code>limit</code>，</b>这样不仅可以控制删除的条数，也可以减少加锁的范围。</p><h3 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>select from t where c=10 lock in share mode;</td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where c=10;<br/>(<font color='green'>Query OK</font>)</td><td>T2</td></tr><tr><td>insert into t values(8, 8, 8)</td><td></td><td>T3</td></tr><tr><td></td><td>ERROR 1213:Deadlock found when trying to get lock; try restarting transaction</td><td>T4</td></tr></tbody></table><ol><li><code>session A </code>启动事务后执行查询语句加<code> lock in share mode</code>，在索引 <code>c </code>上加了<code> next-key lock(5,10]</code> 和间隙锁<code> (10,15)</code>；</li><li><code>session B </code>的<code> update</code> 语句也要在索引 <code>c </code>上加<code> next-key lock(5,10]</code> ，进入锁等待；</li><li>然后 <code>session A</code> 要再插入<code> (8,8,8)</code> 这一行，被<code>session B</code>的间隙锁锁住。由于出现了死锁，<code>InnoDB</code> 让 <code>session B </code>回滚。</li></ol><p>实际上步骤2中加<code>Next-Key Lock</code>是两步操作，分成间隙锁和行锁，在步骤2中加间隙锁是不会冲突，但是在加行锁的时候进入了等待，而T3时刻，<code>sessionA</code>插入数据需要等待<code>sessionB</code>释放间隙锁，所以出现了相互等待的情况，从而导致死锁。</p><p>虽然在分析<code>Next-Key Lock</code>表示间隙锁和行锁的结合，但是具体执行的时候要分为两段来执行。</p><h3 id="9-非唯一索引排序"><a href="#9-非唯一索引排序" class="headerlink" title="9.非唯一索引排序"></a>9.非唯一索引排序</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;=15 and c&lt;=20 order by c desc lock in share mode;</td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(6,6,6);<br/>(<font color='red'>blocked</font>)</td><td>T2</td></tr></tbody></table><ol><li>由于这里有<code>order by c desc</code>所以首先从<code>c=20</code>开始定位，所以首先加上间隙锁<code>(20, 25)</code>和<code>Next-Key Lock</code>锁<code>(15, 20]</code>。</li><li>在索引<code>c</code>向左遍历，需要扫描到<code>c=10</code>这条记录才会停止，所以<code>(5, 10]</code>。所以<code>sessionB</code>会阻塞。</li><li>在扫描的过程中，会对<code>c=10</code>，<code>c=15</code>，<code>c=20</code>这三行有数据，且查询字段是<code>select * </code>，需要进行回表，所以会在主键索引上上三个行锁。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（六）—锁（第二弹）&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（六）—锁（第二弹）&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（六）—锁（第二弹）&quot;&gt;&lt;/a&gt;mysql45讲学习总结（六）—锁（第二弹）&lt;/h1&gt;&lt;p&gt;​    本篇主要为了记录间隙锁和&lt;code&gt;next-key lock&lt;/code&gt;相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java的agent探针技术</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/02/java/java%E7%9A%84agent%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/02/java/java%E7%9A%84agent%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/</id>
    <published>2023-03-02T13:51:58.000Z</published>
    <updated>2023-04-12T02:51:08.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java的agent探针技术"><a href="#java的agent探针技术" class="headerlink" title="java的agent探针技术"></a>java的agent探针技术</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>Java Agent</code>直译过来就是<code>java</code>代理或者有的地方叫做<code>java</code>探针。这个<code>jar</code>包不能独立运行，需要依附于目标<code>JVM</code>进程中。主要作用是通过对<code>JVM</code>进程进行代理，可以在目标<code>JVM</code>运行过程中获取到对应虚拟机中相关参数。</p><span id="more"></span><p>​    主要应用场景为：热部署、<code>IDEA</code>的<code>DEBUG</code>调试功能，<code>Arthas</code>线上诊断工具、性能监控等。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>java Agent</code>有两个入口，两个入口的执行时机有所不同，一个是在目标应用启动之前，一个是在目标应用运行过程中。</p><p><b>目标应用刚启动时：</b></p><p>​    通过在目标应用的启动参数中添加<code>-javaagent:xxx/xxx/xxxAgent.jar</code>的方式启动，在执行目标应用的<code>main</code>方法之前会进入到<code>xxxAgent.jar</code>的<code>premain()</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个方法都存在的情况下，会进入这个方法，不会进入单个参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ premain方法，有一个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ premain方法，有一个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：这种方式是在目标应用要执行<code>main</code>方法，之前进入这个<code>premain</code>方法，也就是说这时<code>jvm</code>虚拟机中并没有加载过多的类。由于这种加载逻辑，导致在基本上在类加载之后就无法修改字节码，所以这种方式存的灵活性存在一定的限制。</b></p><p><b>目标应用运行过程中：</b></p><p>​    通过中间程序动态附着到目标<code>JVM</code>中的方式启动，所以中间程序就可以做到动态化，也就是达到某个条件之后就附着。</p><p><code>agent.jar</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个方法都存在的情况下，会进入这个方法，不会进入单个参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ agentmain方法 有两个入参 ------ agentArgs:&quot;</span> + agentArgs + <span class="string">&quot; inst:&quot;</span> + inst.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ agentmain方法 有两个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BridgeProject</code>（中间程序）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException </span>&#123;</span><br><span class="line">    VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(VirtualMachineDescriptor vmDescriptor : VirtualMachine.list())&#123;</span><br><span class="line">        <span class="keyword">if</span>(vmDescriptor.displayName().contains(<span class="string">&quot;XxxBootstrap&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入附着jvm&quot;</span>);</span><br><span class="line">            vm = VirtualMachine.attach(vmDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm.loadAgent(<span class="string">&quot;xxx/xxx/agent.jar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说拥有<code>XxxBootstrap</code>启动类的目标应用当前正处在运行状态，然后启动中间程序<code>BridgeProject#main</code>方法，它会获取<code>XxxBootstrap</code>对应的虚拟机之后，将<code>agent.jar</code>附着到该虚拟机上，这时就会进入到<code>agent.jar</code>包中的<code>agentmain</code>方法，就可以动态的进行一些处理。</p><p><code>Arthas</code>就是使用<code>agentmain</code>这种方式，它在首次使用的时候是仅下载这个中间程序<code>curl -O https://arthas.aliyun.com/arthas-boot.jar</code>，当通过<code>java -jar arthas-boot.jar</code>命令启动这个<code>springboot</code>程序之后，它会罗列当前环境中的虚拟机（如果你开多个应用，会有多个虚拟机）。当你选中某个应用之后，它会校验<code>arthasHome=~/.arthas/lib/</code>这个目录是否有<code>agent.jar</code>包，如果没有它会去下载<code>agent.jar</code>包，当然它的逻辑会更复杂，它不单单只有<code>agent.jar</code>包。也就是说实际上通过<code>curl</code>下载的<code>arthas-boot.jar</code>实际上是对上述中间程序的一个封装，做一些外围非核心逻辑的处理，当选中某个应用时，再去下载核心<code>agent.jar</code>包，进行探针修改字节码相关逻辑处理。</p><p><b><code>Instrumentation</code>相关接口:</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加一个Class文件的转换器，该转换器用于改变class二进制流的数据，</span></span><br><span class="line"><span class="comment"> * 参数canRetransform设置是否允许重新转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addTransformer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载之前，重新定义class文件，ClassDefinition表示一个类新的定义，</span></span><br><span class="line"><span class="comment"> * 如果在类加载之后，需要用retransformClasses方法重新定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redefineClasses(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类加载之后，重新定义class。事实上，该方法update了一个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retransformClasses();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加jar文件到BootstrapClassLoader中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendToBootstrapClassLoaderSearch();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加jar文件到system class loader。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendToSystemClassLoaderSearch();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加载的所有类数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getAllLoadedClasses();</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="1-打包"><a href="#1-打包" class="headerlink" title="1.打包"></a>1.打包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span> <span class="comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 添加 mplementation-*和Specification-*配置项--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addDefaultSpecificationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultSpecificationEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--指定premain方法所在的类--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.com.xiaocainiaoya.Agent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--添加这个即可--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.com.xiaocainiaoya.Agent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>descriptorRef</code>这是会将<code>pom</code>中的依赖打入到<code>agent.jar</code>包中，所以是否启动这个要取决于你的探针中需要的类库在目标程序中是否存在。比如我的目标程序中不存在<code>directory-watcher</code>依赖，但是<code>agent.jar</code>是需要这个依赖，所以我这里使用<code>descriptorRef</code>将这个依赖也打入到最终的<code>agent.jar</code>包中，如果不希望部分依赖打入到<code>agent.jar</code>包中(如果主工程中也存在这个依赖，会出现冲突的情况)，需要在<code>pom.xml</code>的依赖项中添加<code>&lt;scope&gt;</code>标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-tool-jar工具"><a href="#2-tool-jar工具" class="headerlink" title="2.tool.jar工具"></a>2.tool.jar工具</h3><p>其中<code>VirtualMachine</code>是<code>JDK</code>工具包下的类，如果系统环境变量没有配置，需要自己在<code>Maven</code>中引入本地文件。一般采用方案二时，动态附着需要使用到这些类。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.sun&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">    &lt;systemPath&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/lib/tools.jar&lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-ClassFileTransformer"><a href="#3-ClassFileTransformer" class="headerlink" title="3.ClassFileTransformer"></a>3.ClassFileTransformer</h3><p>通过实现这个类<code>ClassFileTransformer</code>，然后通过<code>Instrumentation</code>添加到类转换器中，即可对类进行动态修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inst.addTransformer(<span class="keyword">new</span> ProfilingTransformer());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java的agent探针技术&quot;&gt;&lt;a href=&quot;#java的agent探针技术&quot; class=&quot;headerlink&quot; title=&quot;java的agent探针技术&quot;&gt;&lt;/a&gt;java的agent探针技术&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;Java Agent&lt;/code&gt;直译过来就是&lt;code&gt;java&lt;/code&gt;代理或者有的地方叫做&lt;code&gt;java&lt;/code&gt;探针。这个&lt;code&gt;jar&lt;/code&gt;包不能独立运行，需要依附于目标&lt;code&gt;JVM&lt;/code&gt;进程中。主要作用是通过对&lt;code&gt;JVM&lt;/code&gt;进程进行代理，可以在目标&lt;code&gt;JVM&lt;/code&gt;运行过程中获取到对应虚拟机中相关参数。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>mybatis的MetaObject反射工具类</title>
    <link href="http://xiaocainiaoya.github.io/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-12-05T12:51:58.000Z</published>
    <updated>2022-12-05T14:30:58.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis的MetaObject反射工具类"><a href="#mybatis的MetaObject反射工具类" class="headerlink" title="mybatis的MetaObject反射工具类"></a>mybatis的MetaObject反射工具类</h1><p>​    <code>MetaObject</code>是<code>mybatis</code>中用于处理反射相关的工具类，通过<code>MetaObject</code>就可以进行获取和设置对象值。</p><span id="more"></span><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><b>简单类型：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Blog对象</span></span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">  <span class="comment">// 使用默认配置创建一个MetaObject对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">  <span class="comment">// 直接为Blog的id属性赋值</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>复杂类型：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    <span class="comment">// 为Bolg中的对象赋值，如果对象为空，会通过该对象的构造函数创建一个空对象</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;author.name&quot;</span>, <span class="string">&quot;tommy&quot;</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>集合类型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    List&lt;Comment&gt; commentList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 尽管设置了数组长度为5，以下调用还是报错，原因是set(index, value)方法中有判断</span></span><br><span class="line">    <span class="comment">// 若 index &gt;= size 则报越界，而size只有add(value)方法会进行叠加</span></span><br><span class="line">    <span class="comment">//commentList.set(0,new Comment());</span></span><br><span class="line">    commentList.add(<span class="keyword">new</span> Comment());</span><br><span class="line">    <span class="comment">// 1.如果是Object对象，为空时会通过构造函数进行创建，但是集合不能自动创建</span></span><br><span class="line">    <span class="comment">// 2.setValue的底层是调用集合的List.set(index, value)方法，不是List.add方法，所以要注意数组越界</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments&quot;</span>, commentList);</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments[0]&quot;</span>, <span class="keyword">new</span> Comment());</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;comments[0].user.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要由<code>MetaObject</code>、<code>ObjectWrapper</code>、<code>MetaClass</code>、<code>Reflector</code>构成。</p><p><img src="https://s2.loli.net/2022/12/05/MQDxLNbn4OgvKRw.png" alt="MetaObject.png"></p><h3 id="1-MetaObject"><a href="#1-MetaObject" class="headerlink" title="1.MetaObject"></a>1.MetaObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line">    <span class="comment">// 包装对象，根据不同对象的不同类型进行包装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同对象的不同对象进行包装</span></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完<code>MetaObject</code>之后，从<code>MetaObject</code>调用的<code>setValue</code>、<code>getValue</code>等属性操作方法实际上都委派给了<code>ObjectWrapper</code>进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="comment">// 如果存在下一层表达式，则创建下一层MetaObject</span></span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">        MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 通过创建的下一层的MetaObject对象，再次调用getValue，进入递归</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在下一层表达式，通过wrapper对象进行反射获取值</span></span><br><span class="line">        <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ObjectWrapper"><a href="#2-ObjectWrapper" class="headerlink" title="2.ObjectWrapper"></a>2.ObjectWrapper</h3><p><code>ObjectWrapper</code>是顶层接口，定义了<code>wrapper</code>包装原始对象的处理接口，如果原始对象是<code>Bean</code>对象那么具体的获取属性等操作在<code>BeanWrapper</code>，如果原始对象是<code>Map</code>则通过<code>MapWrapper</code>进行实现具体的属性操作，同理<code>List</code>则通过<code>CollectionWrapper</code>进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line">    </span><br><span class="line">    String[] getGetterNames();</span><br><span class="line">    </span><br><span class="line">    String[] getSetterNames();</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getSetterType(String name);</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getGetterType(String name);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanWrapper</code>和<code>MapWrapper</code>是继承于抽象类<code>BaseWrapper</code>，由抽象类继承顶层接口<code>ObjectWrapper</code>。<code>CollectionWrapper</code>是直接继承于顶层接口。这是因为如果原始对象是集合，它仅有<code>add</code>和<code>addAll</code>操作，其他接口均抛异常。</p><p><b>在BeanWrapper中解析表达式为词法分析器后进行属性操作</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以set方法为例，通过PropertyTokenizer词法分析器，对比如“comment[0].user.id”进行解析</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object collection = resolveCollection(prop, object);</span><br><span class="line">    setCollectionValue(prop, collection, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setBeanProperty(prop, object, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到对象的set方法</span></span><br><span class="line">        Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">        Object[] params = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射赋值</span></span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>PropertyTokenizer：词法分析器</b>，实现迭代器接口，通过<code>next()</code>方法解析下一层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里以 comments[0].user.id为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前层的名字: comments</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 若是集合则为comments[0]，否则indexedName和name值一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">    <span class="comment">// 表示下标: 若不是集合或者Map，则为空</span></span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="comment">// 表示子表达式: user.id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-MetaClass"><a href="#3-MetaClass" class="headerlink" title="3.MetaClass"></a>3.MetaClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reflector reflector;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">      <span class="comment">// 通过这个反射工厂来创建一个反射器</span></span><br><span class="line">      <span class="keyword">this</span>.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReflectorFactory</code>这个反射工厂的主要作用是对<code>Reflector</code>反射器进行缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultReflectorFactory</span> <span class="keyword">implements</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> classCacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">        <span class="comment">// 如果缓存中存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Reflector"><a href="#4-Reflector" class="headerlink" title="4.Reflector"></a>4.Reflector</h3><p>根据创建的<code>Class</code>对象，解析出这个类的所有<code>get</code>、<code>set</code>方法，构造函数，所有属性字段等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">      type = clazz;</span><br><span class="line">      addDefaultConstructor(clazz);</span><br><span class="line">      addGetMethods(clazz);</span><br><span class="line">      addSetMethods(clazz);</span><br><span class="line">      addFields(clazz);</span><br><span class="line">      readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">      writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">      <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis的MetaObject反射工具类&quot;&gt;&lt;a href=&quot;#mybatis的MetaObject反射工具类&quot; class=&quot;headerlink&quot; title=&quot;mybatis的MetaObject反射工具类&quot;&gt;&lt;/a&gt;mybatis的MetaObject反射工具类&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;MetaObject&lt;/code&gt;是&lt;code&gt;mybatis&lt;/code&gt;中用于处理反射相关的工具类，通过&lt;code&gt;MetaObject&lt;/code&gt;就可以进行获取和设置对象值。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis执行器</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/</id>
    <published>2022-11-22T14:13:58.000Z</published>
    <updated>2022-11-28T02:50:00.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis执行器"><a href="#mybatis执行器" class="headerlink" title="mybatis执行器"></a>mybatis执行器</h1><span id="more"></span><p>在<code>mybatis</code>中包含四大件是指<strong>：executor, statementHandler,parameterHandler，resultHandler对象</strong>。</p><p>它们都是sqlSession的底层类实现，本篇的重点是了解一下<code>executor</code>执行器的作用和一些原理。</p><p>在<code>mybatis</code>中有三类执行器：</p><ul><li>简单执行器：<code>SimpleExecutor</code>，是执行器的默认实现，继承了<code>BaseExecutor</code>抽象类，利用<code>StatementHandler</code>完成。每次调用执行方法都会构建一个<code>StatementHandler</code>，并预设参数，然后执行。</li><li>可重用执行器：<code>ReuseExecutor</code>，可重复使用<code>JDBC</code>中<code>Statement</code>，减少预编译次数。该执行器在执行<code>SQL</code>时会把<code>Statement</code>缓存起来，如果下次碰到相同的SQL，就会取出来使用。</li><li>批处理执行器：<code>BatchExecutor</code>，每次的执行操作 不会立即提交到数据库，而是把对应的<code>Statement</code>对象填充好参数之后暂存起来。调用<code>doFlushStatements</code>的时候一次性提交到数据库，可用于批处理插入的场景。</li></ul><p><img src="https://s2.loli.net/2022/11/22/meG7dva9NcRCg8U.png" alt="执行器.png"></p><p>执行器的顶层接口为<code>Executor</code>，它定义了数据修改、数据查询、缓存维护等基本功能，还有一些辅助的API接口，比如提交事务、回滚事务等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单列几个接口，还有一些没列出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象接口<code>BaseExecutor</code>实现<code>Executor</code>并提供一些通用能力，比如有一级缓存，获取连接等。比如针对查询来说，它实现了顶层接口的<code>query</code>方法，并实现一级缓存的相关逻辑，若缓存查询不同，通过<code>doQuery</code>方法，下放给具体实现子类，也就是说，子类只需要实现具体的<code>doQuery</code>方法。</p><p>在<code>mybatis</code>中有三种执行器，分别为简单执行器、可重用执行器、批处理执行器。在这种结构下，若希望添加一级缓存应该如何处理？可以在<code>BaseExecutor</code>上层抽象一层接口，这个抽象接口实现二级缓存的逻辑。但是<code>mybatis</code>不采用这种方式，它通过装饰者模式，构建<code>CachingExecutor</code>类实现于<code>Executor</code>接口，并将<code>Executor</code>作为他的一个属性，当自身的二级缓存获取不到值时，调用<code>delegate</code>的同名方法，进入具体的执行器中。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p><img src="https://s2.loli.net/2022/11/23/tVWrlBgjGM7L21F.png" alt="一级缓存.png"></p><p>​    一级缓存实际上就是一个<code>HashMap</code>，根据一些相关的参数信息生成一个<code>key</code>，结果集为值的<code>hashMap</code>。它的<code>CacheKey</code>的主要参数为<code>statementID</code>，<code>SQL</code>，执行参数等，所以有时候尽管是一模一样的<code>SQL</code>也不会命中<code>mybatis</code>的一级缓存。</p><p>​    <code>mybatis</code>的代码是极其精简的，这是仅是使用<code>HashMap</code>来存储一级缓存的内容，它甚至都不使用<code>concurrentHashMap</code>，这是因为<code>SqlSession</code>本身就不是线程安全的，对于<code>SqlSession</code>来说他需要创建一个执行器，执行器对应于一条<code>statementID</code>，如果出现并发，两个线程获取同一个<code>SqlSession</code>，那么就有可能导致执行器中绑定的<code>statementId</code>不一致，导致得到一级缓存的返回类型值不一样，从而报错。并且<code>SqlSession</code>获取对应的<code>JDBCConnection</code>连接同时得到事务，如果两个线程获取同一个线程，那么就表示两个线程拥有同一个事务，所以<code>SqlSession</code>不是线程安全了，在<code>Spring</code>中通过很多的手段去保证并发情况下<code>SqlSession</code>的线程安全。</p><p>​    所以一级缓存是与会话相关，如果会话被关闭，那么一级缓存就失效。</p><p><img src="https://s2.loli.net/2022/11/23/B5TGkf1XstumUOF.png" alt="一级缓存执行流程.png"></p><p>​    由<code>mybatis</code>生成对应的<code>mapper</code>的动态代理，在执行对应的<code>SQL</code>方法时，开启一个<code>SqlSession</code>会话，通过会话和相关信息开启一个执行器，在执行器中先调用<code>BaseExecutor#query()</code>，具体的一级缓存逻辑就是在<code>query()</code>方法中，如果一级缓存中获取不到，调用执行器实现子类的<code>doQuery()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserMapper mapper = context.getBean(UserMapper.class);</span><br><span class="line">        User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    看一段结合<code>Spring</code>之后的缓存问题，测试结果为<code>false</code>，说明一级缓存没有生效，这是由于<code>Spring</code>在每次执行具体的调用时都自动进行了事务的提交，也就是说每执行一次<code>selectById</code>就会开启一次会话。所以很多人会说在<code>Spring</code>集成了<code>mybatis</code>之后，<code>mybatis</code>的一级缓存失效了。</p><p>​    那么如果就是想在<code>Spring</code>中使用<code>mybatis</code>的一级缓存。可以通过手动开启事务的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpringTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    DataSourceTransactionManager transactionManager = (DataSourceTransactionManager)context.getBean(<span class="string">&quot;txManager&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动开启事务</span></span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line"></span><br><span class="line">    User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Spring</code>中对<code>Mapper</code>做了一些动态代理的处理，通过<code>getBean()</code>获取到的<code>UserMapper</code>对象实际上已经是被<code>Spring</code>动态代理过的对象，</p><p><img src="https://s2.loli.net/2022/11/23/jzn7olaNiGMetWy.png" alt="spring结合mybatis会话.png"></p><ul><li><code>Mapper</code>：是被<code>spring</code>修改过的动态代理对象，做一些<code>statementID</code>相关预处理等操作。</li><li><code>SqlSessionTemplate</code>：它实现了<code>SqlSession</code>接口，并将数据库的相关操作，比如<code>query</code>、<code>update</code>、<code>insert</code>转发给具体的<code>sqlSession</code>。而它的能力为拦截之后获取对应的<code>sqlSession</code>会话对象。</li><li><code>SqlSessionFactory</code>：去创建对应的事务、执行器，然后返回<code>DefaultSqlSession</code>对象。</li></ul><p>那么现在来看一些<code>spring</code>使得<code>mybatis</code>一级缓存没有生效的具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略一些代码..</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个SqlSessionHolder，这个是存储在ThreadLocal对象中</span></span><br><span class="line"><span class="comment">// 也就是说它是跟线程绑定，与事务和线程绑定的原理对应上  </span></span><br><span class="line">SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里获取对应的session</span></span><br><span class="line">SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在<code>sessionHolder</code>处如果获取到对应的<code>session</code>则直接返回，如果获取不到则创建一个新的<code>session</code>,所以这里实际上事务决定了会话，如果事务被提交，则事务被删除，也就导致<code> session</code>会话被删除，如果一个事务一直不提交，那么在这个事务内的所有数据库操作就会触发一级缓存的相关逻辑。  </p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>​    二级缓存也称作是应用级缓存，与一级缓存不同的是它的作用范围是整个应用，而且可以跨线程调用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。由于二级缓存的作用范围是整个应用，所以需要为二级缓存考虑溢出淘汰的机制，而一级缓存的生命周期是一个会话，所以并没有特别为一级缓存考虑淘汰机制。</p><p>​    <img src="https://s2.loli.net/2022/11/24/w7NDM1HQ8ceiSYC.png" alt="二级缓存功能.png"></p><ul><li>过期清理：清理一些存放时间过久的数据，设置一个有效期，对超过有效期的缓存进行清理。</li><li>线程安全：二级缓存是跨线程使用的，所以需要考虑到线程安全的问题。</li><li>命中率统计：根据命中率统计来给用户提供反馈，告诉用户某次查询是否命中了缓存。</li></ul><p><img src="https://s2.loli.net/2022/11/24/ynvgEjMatCF6hHx.png" alt="二级缓存设计结构.png"></p><p>通过装饰者模式结合责任链的方式来实现二级缓存。每一种类型的缓存都是单一职责，当做完自己本身需要做的事情之后，就将需要缓存的相关参数等信息传递给责任链的下一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      这是缓存的顶层接口，非常简单，它通过接口屏蔽了复杂的底层调用，在使用的过程中，只需要通过这个接口<code>Cache</code>进行相关缓存的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache cache = configuration.getCache(<span class="string">&quot;cn.com.xiaocainiaoya.mapper.UserMapper&quot;</span>);</span><br><span class="line">    User user = Mock.newUser();</span><br><span class="line">    cache.putObject(<span class="string">&quot;cacheTest&quot;</span>, user);<span class="comment">// 设置缓存</span></span><br><span class="line">    cache.getObject(<span class="string">&quot;cacheTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/24/96SgDRdh4eLoFVQ.png" alt="二级缓存.png"></p><p>1.<code>chcheEnabled</code>：全局缓存开关，只要这个参数配置了<code>false</code>，整个二级缓存就关闭。</p><p>2.<code>useCache</code>：表示当前的<code>statement</code>要不要使用缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flushCache</code>：在查询时，将整个二级缓存清空。注意是整个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(flushCache = Options.FlushCachePolicy.TRUE)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectByid2在没有配置flushCache的情况下，也是命中不了缓存的。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询1</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    UserMapper mapper1 = session1.getMapper(UserMapper.class);</span><br><span class="line">    mapper1.selectByid2(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// flush cache清空</span></span><br><span class="line">    User user = mapper1.selectByid(<span class="number">10</span>); <span class="comment">//清空了，提交</span></span><br><span class="line">    </span><br><span class="line">    session1.commit();</span><br><span class="line">    <span class="comment">// 查询2</span></span><br><span class="line">    SqlSession session2 = factory.openSession();</span><br><span class="line">    UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line">    User use2 = mapper2.selectByid2(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>&lt;cache/&gt;</code>或<code>@CacheNamespace</code>是标记在<code>xml</code>文件或者对应的<code>mapper</code>文件，默认都是使用全限定类名作为缓存的命名空间，如果两个文件同时标记时会报错。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">&lt;cache/&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>5.在第四点中说到，对应的<code>mapper</code>文件和<code>xml</code>不能同时标记，那么如果就是想共用，那么就需要使用到缓存空间引用。<code>&lt;cache-ref/&gt;</code>或<code>CacheNamespaceRef</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">&lt;cache-ref namespace=<span class="string">&quot;cn.com.xiaocainiao.UserMapper&quot;</span> /&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>由于二级缓存是跨线程使用，所以需要在事务提交之后的数据库操作，才能命中缓存。</p><p><img src="https://s2.loli.net/2022/11/24/23OhkEWzlsTXw6j.png" alt="二级缓存脏读.png"></p><p>每一个会话都有一个事务缓存管理器，暂存区的个数取决于访问了多少个<code>mapper</code>。下方的缓存空间就是对应的<code>mapper</code>的缓存命名空间。会话一旦关闭，它所对应的事务缓存管理器就会被清理，从而导致暂存区数据被清理。在数据的操作过程，都是先操作暂存区，只有在事务提交或者事务回滚之后才会将暂存区数据提交到对应的缓存空间。</p><p>![image-20221127115857163](/Users/jiangjiamin/Library/Application Support/typora-user-images/image-20221127115857163.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个简单的代码，debug下暂存区的结构</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存的执行流程：</p><p><img src="https://s2.loli.net/2022/11/24/I4Ysoi9WlELVMK8.png" alt="二级缓存执行流程.png"></p><p>根据上图可知：查询是直接查询缓存空间，其他操作是对暂存区数据进行操作，当进行<code>commit</code>操作时将暂存区的操作数据添加到缓存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionalCache#commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出需要填充到二级缓存空间的数据，遍历进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis执行器&quot;&gt;&lt;a href=&quot;#mybatis执行器&quot; class=&quot;headerlink&quot; title=&quot;mybatis执行器&quot;&gt;&lt;/a&gt;mybatis执行器&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis处理器</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-11-22T14:13:58.000Z</published>
    <updated>2022-12-05T11:50:44.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis处理器"><a href="#mybatis处理器" class="headerlink" title="mybatis处理器"></a>mybatis处理器</h1><span id="more"></span><h2 id="一、statementHandler"><a href="#一、statementHandler" class="headerlink" title="一、statementHandler"></a>一、statementHandler</h2><p>​    <code>JDBC</code>处理器，基于<code>JDBC</code>构建<code>Statement</code>并设置参数，然后去执行具体的<code>SQL</code>语句，每调用会话当中一次<code>SQL</code>，都会有与之相对应且唯一的<code>Statement</code>实例。</p><p><img src="https://s2.loli.net/2022/11/28/OsSeqNWphfcyRGt.png" alt="statementHandler.png"></p><p><code>StatementHandler</code>为顶层接口，为<code>Statement</code>处理器相关实现设置标准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写操作</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读操作</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读游标</span></span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 辅助接口：获取动态语句</span></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 辅助接口：获取参数解析器</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BaseStatementHandler</code>抽取了具体子类的公共部分，比如有设置超时时间、设置获取行数等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseStatementHandler#prepare</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// BaseStatementHandler的抽象方法，由具体的子类来实现</span></span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      <span class="comment">// 根据子类返回的statement对象，来进行超时时间、获取行数的设置</span></span><br><span class="line">      setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法，由具体的子类实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>本篇中没有特殊说明都是以<code>PreparedStatementHandler</code>为例。具体的子类需要实现这个方法，使用<code>Conection</code>对象生成对应的<code>statement</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreparedStatementHandler#instantiateStatement</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">      <span class="comment">// 基于jdbc的connection#prepareStatement方法来创建PreparedStatement</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>StatementHandler执行流程：</strong></p><p><img src="https://s2.loli.net/2022/11/28/rmSGMb6WdnNoyu4.png" alt="statementHandler执行过程.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleExecutor#doQuery</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 1.通过Configuration对象创建StatementHandler对象</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 2.预处理</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 3.最后执行，对于PreparedStatement来说就是调用它的execute()方法。</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.通过<code>Configuration</code>对象创建<code>StatementHandler</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RoutingStatementHandler导航类来根据需要不同类型的statement进行创建</span></span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoutingStatementHandler#new()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.预处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的预处理接口来创建一个Statement对象</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 这里会调用参数解析器DefaultPrepareterHander来对statement对象的参数值(会经过类型转换等操作)</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后执行，对于<code>PreparedStatement</code>来说就是调用它的<code>execute()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// PreparedStatement的execute()方法。</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 执行完语句之后，使用结果集处理器对结果进行javabean的映射</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>BaseStatementHandler</code>将具体的<code>StatementHandler</code>中编写了具体子类的共性部分，实际上是由它来进行具体的<code>JDBC</code>抽象，创建它需要执行器、参数解析器、结果集处理器、动态语句等的参与。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BoundSql boundSql;</span><br></pre></td></tr></table></figure><h2 id="二、ParamenterHandler"><a href="#二、ParamenterHandler" class="headerlink" title="二、ParamenterHandler"></a>二、ParamenterHandler</h2><p>参数名称解析器<code>ParamNameResolver</code>。</p><p><b>单个参数：</b>默认不做任何处理，除非设置了<code>@Param</code></p><p><b>多个参数：</b></p><ol><li>根据参数声明的顺序将参数转换为<code>param1</code>、<code>param2</code>…</li><li>通过<code>@Param</code>指定变量名称</li><li>基于反射转换成变量名，如果不支持则根据声明的顺序转换成<code>arg0</code>、<code>arg1</code>…</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个参数情况下：</span></span><br><span class="line"><span class="comment"> *    args的值直接为这个参数的值 &#123;0, &quot;arg0&quot;&#125;</span></span><br><span class="line"><span class="comment"> * 多参数情况下：</span></span><br><span class="line"><span class="comment"> *    如果在mapper中对字段标记了<span class="doctag">@Param</span>注解并设置了对应的字段名称，则names的值为 &#123;&#123;0, &quot;field1&quot;&#125;, &#123;1, &quot;field2&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    如果没有标记<span class="doctag">@Param</span>注解，则names的值为&#123;&#123;0, &quot;arg0&quot;&#125;, &#123;1, &quot;arg1&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    所以这里仅仅是将字段名称和具体的参数值进行对应成param，实际的解析参数名的参数，在上层调用端。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// names 是一个SortMap</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果没有@Param注解，并且参数个数为1，直接返回原值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 直接将args参数中的值添加到param中</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认还会为参数根据声明的顺序设置param1， param2 ...</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不存在同名的情况下，可能有人字段名直接命名成paramX。</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">            param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所以如果不出现同名的情况，假设mapper接口设置了两个参数，那么这里返回有两份参数，</span></span><br><span class="line">        <span class="comment">// 一份要么是根据@Param解析规则，或者反射参数(启动参数) -parameters ,或者默认的arg0, arg1</span></span><br><span class="line">        <span class="comment">// 一份是param1， param2...</span></span><br><span class="line">        <span class="comment">// 要注意arg是从0下标开始，param是从1下标开始</span></span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以根据返回<code>param</code>不同的类型，使用的方式也有所不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是单个参数，那么这里的#&#123;userId&#125;,写什么都行，#&#123;param1&#125;, #&#123;arg0&#125;都可，实际上</span></span><br><span class="line"><span class="comment">// 根据就不校验名称，直接复制了</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的#&#123;name&#125;也可以写成#&#123;param1&#125;， 但是注意不能写#&#123;arg0&#125;， 因为#&#123;arg0&#125;已经变成@param</span></span><br><span class="line"><span class="comment">// 注解中的名称</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where name=#&#123;name&#125; or age=#&#123;user.age&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByNameOrAge</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;user&quot;)</span> User user)</span></span>;</span><br></pre></td></tr></table></figure><p>结合前文提到的<code>StatementHandler</code>执行流程时序图中，在<b>预处理</b>阶段，会<font color="red">为PrearedStatement设置参数</font>，来具体看一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以SimpleExecutor为例, 在调用doUpdate或者是doQuery方法创建StatementHandler之后，都会进行设置参数。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 创建statement</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 为statement设置参数</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreparedStatementHandler#parameterize</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 进入参数解析器，为statement设置参数</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里就进入到了<code>ParameterHandler</code>的<code>setParameters</code>中，为创建的<code>preparedStatement</code>设置具体的参数。先来看一下<code>ParameterHandler</code>的接口，<code>ParameterHandler</code>是<code>mybatis</code>中的参数处理器，负责为<code>PreparedStatement</code>的<code>SQL</code>语句参数动态赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">// 读取参数</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 用于对PreparedStatement的参数赋值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只有一个实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个parameterObject就是前面说到通过ParameterNameSolver解析之后的对象</span></span><br><span class="line"><span class="comment">// 如果是单个参数，就是具体的值</span></span><br><span class="line"><span class="comment">// 如果是多个参数就是一个map对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getParameterObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parameterObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  <span class="comment">// parameterMappings是对具体执行语句的映射，将将要执行的语句映射成ParamterMapping对象，</span></span><br><span class="line">  <span class="comment">// 将具体需要填充的参数#&#123;&#125;解析出来，形成参数列表</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数化sql就需要进行参数设置，遍历这个参数列表，将参数设置到PreparedStatement中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="comment">// ParameterMode.OUT 存储过程的参数模式</span></span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        <span class="comment">// 声明value，最后就是将这个值设置到PreparedStatement中</span></span><br><span class="line">        Object value; </span><br><span class="line">        <span class="comment">// 获取执行语句声明的#&#123;&#125;中的参数变量名称</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; </span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 多个参数会走到这里，将map对象，转换成MetaObject对象，就可以直接通过字段名称来获取具体的值  </span></span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从parameterMapping获取TypeHandler类型转换器对象</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        <span class="comment">// 从TypeHandler类型转换器中获取对应的数据库类型</span></span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TypeHandler.setParameter实际上最后会调用到PreParedStatement.set*()方法，为要执行的语句绑定参数值</span></span><br><span class="line">          <span class="comment">// 比如说TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setBigDecimal(i, parameter);</span></span><br><span class="line">          <span class="comment">// TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setByte(i, parameter);</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>debugger</code>了解一下<code>ParameterMapping</code>中的内容： 主要是将<code>mybatis</code>在<code>SQL</code>或者是在实体上设置的一些配置进行映射，包含有字段名称、<code>javaType</code>数据类型、<code>jdbcType</code>数据库类型，<code>typeHandler</code>类型处理器等。</p><p><img src="https://s2.loli.net/2022/12/05/VkmnT5IjZgsGvP9.png" alt="parameterMapping.png"></p><h2 id="三、ResultHandler"><a href="#三、ResultHandler" class="headerlink" title="三、ResultHandler"></a>三、ResultHandler</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis处理器&quot;&gt;&lt;a href=&quot;#mybatis处理器&quot; class=&quot;headerlink&quot; title=&quot;mybatis处理器&quot;&gt;&lt;/a&gt;mybatis处理器&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis控制部分字段不打印</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/</id>
    <published>2022-11-13T14:13:58.000Z</published>
    <updated>2022-11-14T01:39:24.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis控制部分字段不打印"><a href="#mybatis控制部分字段不打印" class="headerlink" title="mybatis控制部分字段不打印"></a>mybatis控制部分字段不打印</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在<code>MySQL</code>的一些执行打印了<code>text</code>等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭<code>mybatis</code>的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为<code>text</code>等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。</p><span id="more"></span>    <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    具体的<code>mybatis</code>的几个核心组件执行流程这里不过多介绍，这里仅简单说明一条<code>SQL</code>的执行，是要先经过参数解析器，将具体的参数和数据类型解析处理，而后通过执行器，通过<code>Statement</code>或者是<code>PrepareStatement</code>等进行执行之后，再由结果集处理器进行结果映射相关逻辑。</p><p>​    在跟踪了一下<code>mybatis</code>的执行代码之后发现，日志的打印逻辑是在执行器<code>Executor</code>中，而数据类型相关的处理是在参数解析器中，也就是说如果想做到部分字段不打印，就需要在执行器中修改打印的逻辑。</p><p>我这边测试的是通过<code>PreparedStatement</code>方式进行插入数据，处理打印的类是<code>PreparedStatementLogger</code>的<code>invoke</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 打印数据在这里</span></span><br><span class="line">        debug(<span class="string">&quot;Parameters: &quot;</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... 省略很多无效代码</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用父类<code>BaseJdbcLogger</code>的<code>getParameterValueString</code>方法获取要打印的数据。可以看到这里就是直接将<code>columnValues</code>列表中的值进行拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">  <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      typeList.add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      typeList.add(objectValueString(value) + <span class="string">&quot;(&quot;</span> + value.getClass().getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">  <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，由于这个地方并没有提供扩展点，所以如果我想要打印的时候忽略某些类型的字段，我需要重写这个类，再有我需要在这里能获取到对应的数据类型，尝试之后发现，这个对象中主要是有一个<code>Map</code>对象，键是序号（填充最后执行<code>SQL</code>的序号），值就是对应要填充<code>SQL</code>的值。所以单纯的重写这个类型，获取不到对应的类型，也就无法进行类型的判断，所以需要外层这个类的地方，将执行<code>SQL</code>的类型信息传进来。</p><p><b>类型相关信息是解析到了<code>BoundSql</code>对象中。所以需要想方设法的将<code>BoundSql</code>对象传进来</b>，这个<code>PreparedStatementLogger</code>的创建和被调用并不是在同一个时间节点，也就是说将类型相关参数传进来有两种手段，一种是在<code>PreparedStatementLogger</code>创建的时候，跟着原本构造函数相关的参数带进来，另一种是在<code>invoke</code>方法在调用之前传进来。当然了根据尝试，否定了第一种方式，原因是创建这个对象的地方也没有类型相关信息。</p><p>后来发现在<code>PreparedStatementLogger#invoke</code>方法被调用之前是可以获取到<code>BoundSql</code>对象，调用的地方是<code>PreparedStatementHandler</code>的<code>update</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里是动态代理，通过这里进入到PreparedStatementLogger#invoke中</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只需要在这里做文章，将<code>BoundSql</code>对象传到<code>PreparedStatementLogger</code>中基本上就可以达到目的。</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p>1.将<code>PreparedStatementLogger</code>拷贝到应用的类路径下，并创建同名类路径<code>org.apache.ibatis.logging.jdbc.PreparedStatementLogger</code>类，然后添加一个属性字段<code>BoundSql</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BoundSql boundSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略很多代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同样，将<code>PreparedStatementHandler</code>拷贝到应用类路径下，并创建同名类路径<code>org.apache.ibatis.executor.statement.PreparedStatementHandler</code>，并在执行前设置<code>boundSql</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里获取到的是PreparedStatementLogger的动态代理对象，所以需要获取到被代理对象target</span></span><br><span class="line">  <span class="comment">// 然后判断被代理对象是否为PreparedStatementLogger，是的话就赋值boundSql</span></span><br><span class="line">  <span class="keyword">if</span> (Proxy.isProxyClass(statement.getClass())) &#123;</span><br><span class="line">    MetaObject metaObject = SystemMetaObject.forObject(statement);</span><br><span class="line">    Object target = metaObject.getValue(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> PreparedStatementLogger)&#123;</span><br><span class="line">      PreparedStatementLogger preparedStatementLogger = (PreparedStatementLogger) target;</span><br><span class="line">      preparedStatementLogger.boundSql = boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后在需要忽略日志打印的实体字段上标记能识别到<code>jdbcType</code>的注解，我这里用的是<code>tk.mybatis</code>，所以标记注解是<code>tk.mybatis.mapper.annotation.ColumnType</code>。如果用的是<code>mybatis-plus</code>应该是<code>com.baomidou.mybatisplus.annotation.TableField</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;GROUP_ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;PROJECT_ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="meta">@ColumnType(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="keyword">private</span> String extraInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的打印逻辑我这里就不去写了，附一张到这里的断点图，到这里已经能获取到字段的类型和字段的值。</p><p><img src="https://s2.loli.net/2022/11/14/Kp4nfxJ5MHWEekQ.png" alt="mybaits控制字段打印.png"></p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>​    这里通过自己定义了与<code>mybatis</code>中相关的包路径和同名类来达到替换第三方<code>jar</code>包中的同名对象。原理实际上就是<code>jdk</code>的类加载机制，采用的是双亲委派模型，如果一个类加载器收到了需要加载类的请求，它不会马上进行解析，而是把这个请求委派给父类去加载，每一个层级的类加载器都是入参，当最上层加载器无法解析之后，它才会一层一层往下委派。</p><p>​    比如<code>java.lang.Object</code>存放在<code>rt.jar</code>中，如果编写另一个<code>java.lang.Object</code>并放到<code>ClassPath</code>中，编译上是没有问题的，但是由于双亲委派模型，当获取<code>java.lang.Object</code>时会委派到最上级的启动类加载器，而类路径<code>ClassPath</code>是应用程序类加载器。</p><p>​    但是对于上面重写的两个类，使用到的都是应用程序类加载器，但是如果在在应用<code>ClassPath</code>下创建同名路径，那么编译之后，代码是在<code>classes</code>文件夹中，而第三方包是在<code>lib</code>文件夹中，这里加载类进行查找对应<code>.class</code>文件时也有一个优先级的关系，会优先获取<code>classes</code>中的<code>.class</code>文件。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;a href=&quot;#mybatis控制部分字段不打印&quot; class=&quot;headerlink&quot; title=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;/a&gt;mybatis控制部分字段不打印&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在&lt;code&gt;MySQL&lt;/code&gt;的一些执行打印了&lt;code&gt;text&lt;/code&gt;等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭&lt;code&gt;mybatis&lt;/code&gt;的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为&lt;code&gt;text&lt;/code&gt;等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>nacos简单入门</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-27T13:04:58.000Z</published>
    <updated>2022-10-28T02:42:43.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nacos入门"><a href="#nacos入门" class="headerlink" title="nacos入门"></a>nacos入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近闲来无事看到一篇关于<code>DynamicTp</code>动态可监控线程池框架，也去<code>DynamicTp</code>官网看了一下，发现原来跟<code>Hutool</code>出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中<code>apollo</code>已经使用比较多，所以这次想尝试一下使用<code>nacos</code>。<span id="more"></span></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>​    因为我使用的是<code>mac</code>，且安装了<code>docker</code>和<code>kitematic</code>，本以为只需要从容器仓库中拉一个<code>nacos</code>的镜像就大工告成，没想到，事情没有我想象的那么顺利，还是一波三折。</p><p>​    通过<code>kitematic</code>直接搜索<code>nacos</code>镜像，并下载启动。</p><p><img src="https://s2.loli.net/2022/10/27/DqZVrThs5FeLSip.png" alt="nacos部署.png"></p><p>启动后直接报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No DataSource set</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.DumpService.dumpOperate(DumpService.java:236)</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.ExternalDumpService.init(ExternalDumpService.java:52)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)</span><br><span class="line">... 53 common frames omitted</span><br></pre></td></tr></table></figure><p>看报错信息，大概率是数据连接的问题，到目前为止，容器是镜像下载之后直接启动的，我并没有配置数据库连接相关信息，到这里，我第一反应是将<code>nacos</code>的部分文件/文件夹挂载到宿主机，修改是也方便，但是对于容器的修改挂载点有点复杂，有的说去修改底层的那个<code>config.v2.json</code>文件，有的说通过<code>export</code>修改，不知道是我操作有问题还是怎么样，我尝试了之后是没有成功。后面我是将这个运行容器删掉，利用镜像重新启动一个容器，这时就可以指定对应的挂载卷，本来想把整个<code>/nacos</code>文件夹都挂载出来，但是指定之后，死活报错，某个文件找不到，启动失败，无奈只能走最下策，进入容器操作。</p><p>所以进入容器中，查看相关配置信息。</p><p>进入容器中定位到<code>/home/nacos/conf/application.properties</code>，不同容器应该会不太一样，但是大概率是在<code>~/nacos/conf</code>文件夹。</p><p>想将<code>conf</code>文件夹下的数据库脚本文件<code>shcema.sql</code>脚本，拿到数据库中执行之后，在修改<code>application.properties</code>文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">$&#123;SERVER_SERVLET_CONTEXTPATH:/nacos&#125;</span></span><br><span class="line"><span class="meta">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">$&#123;NACOS_APPLICATION_PORT:8848&#125;</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">$&#123;SPRING_DATASOURCE_PLATFORM:mysql&#125;</span></span><br><span class="line"><span class="meta">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="meta">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="meta">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">$&#123;MYSQL_DATABASE_NUM:1&#125;</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://$&#123;MYSQL_SERVICE_HOST:docker.for.mac.host.internal&#125;:$&#123;MYSQL_SERVICE_PORT:32786&#125;/$&#123;MYSQL_SERVICE_DB_NAME:nacos&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&#125;</span></span><br><span class="line"><span class="comment"># db.url.1=jdbc:mysql://$&#123;MYSQL_SERVICE_HOST&#125;:$&#123;MYSQL_SERVICE_PORT:3306&#125;/$&#123;MYSQL_SERVICE_DB_NAME&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&#125;</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">$&#123;MYSQL_SERVICE_USER:root&#125;</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">$&#123;MYSQL_SERVICE_PASSWORD:root&#125;</span></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">$&#123;NACOS_AUTH_SYSTEM_TYPE:nacos&#125;</span></span><br></pre></td></tr></table></figure><p>填写上数据库相关信息之后，重启还是报错，在这个地方磨了好久，一直想不明白为什么数据库连接不上。</p><p>这里主要原因是因为我的<code>mysql</code>数据库不是直接安装在本机上，也是通过<code>docker</code>容器部署，所以我最开始的时候通过<code>nacos</code>容器去<code>ping</code>连接<code>mysql</code>的容器，在<code>ping</code>通的情况下，我以为<code>nascos</code>容器通过<code>mysql</code>容器的<code>ip</code>可以直接访问到数据库。一直报错之后，使用<code>telnet</code>命令查看端口是否可访问时，报错了，才发现了问题。</p><p>按我理解，访问不到的原因可能是如果<code>ip</code>写的是<code>mysql</code>容器的<code>ip</code>，那么端口应该写哪个合适?是写容器对应开放的端口，还是写宿主机绑定的端口？我两种都尝试了一次，结果都是访问不到。所以将访问<code>ip</code>修改为访问宿主机<code>ip</code>+宿主机绑定<code>mysql</code>容器的端口，这种方式是可以访问到的。</p><p>这里必须安利一波<code>mac</code>上的<code>docker</code>和<code>kitematic</code>，基本上所有的类似组件，比如<code>rabbitmq</code>，<code>mysql</code>，<code>redis</code>，<code>jenkins</code>，<code>nexus3</code>等我都是通过容器化部署，只需要把对应的数据卷挂载到宿主机，保证重启是数据不丢失即可，好处当然多多，一是干净，二是简单。</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><blockquote><p>127.0.0.1:4567/nacos/index.html</p></blockquote><p><code>nacos</code>的默认账号和密码都是<code>nacos</code></p><p><img src="https://s2.loli.net/2022/10/27/IM5EVBWFh98iYw4.png" alt="nacos登录页.png"></p><p>在<code>nacos</code>中有命名空间和分组的概念，每一个命名空间中可以划分多个组，在<code>spring</code>配置文件中，可以指定需要拉取哪个命名空间下的那个组的配置。</p><p>通过『命名空间』创建<code>dev</code>、<code>test</code>命名空间之后，在『配置列表』会显示出对应的命名空间。</p><p><img src="https://s2.loli.net/2022/10/27/ymrj5ZHOnDb7cpo.png" alt="nacos配置列表.png"></p><h2 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h2><p>引入<code>nacos</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类启用<code>nacos</code>配置注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@NacosPropertySource(dataId = &quot;simple-dev-yaml&quot;, groupId = &quot;DEV_GROUP&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootSimpleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootSimpleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件添加<code>nacos</code>服务器访问地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nacos.config.server-addr</span>=<span class="string">127.0.0.1:4567</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NacosValue(value = &quot;$&#123;useLocalCache:false&#125;&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useLocalCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useLocalCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是想使用一下<code>nacos</code>，所以采用的都是最简单的写法，写死的方式指定了<code>dataId</code>和<code>groupId</code>，在实际的使用中一般都是使用配置文件来进行管理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nacos入门&quot;&gt;&lt;a href=&quot;#nacos入门&quot; class=&quot;headerlink&quot; title=&quot;nacos入门&quot;&gt;&lt;/a&gt;nacos入门&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近闲来无事看到一篇关于&lt;code&gt;DynamicTp&lt;/code&gt;动态可监控线程池框架，也去&lt;code&gt;DynamicTp&lt;/code&gt;官网看了一下，发现原来跟&lt;code&gt;Hutool&lt;/code&gt;出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中&lt;code&gt;apollo&lt;/code&gt;已经使用比较多，所以这次想尝试一下使用&lt;code&gt;nacos&lt;/code&gt;。</summary>
    
    
    
    <category term="nacos" scheme="http://xiaocainiaoya.github.io/categories/nacos/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatis-plus特性</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/</id>
    <published>2022-10-14T14:13:58.000Z</published>
    <updated>2022-11-14T01:43:44.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-plus特性"><a href="#mybatis-plus特性" class="headerlink" title="mybatis-plus特性"></a>mybatis-plus特性</h1><span id="more"></span><h2 id="1-字段类型转换器"><a href="#1-字段类型转换器" class="headerlink" title="1.字段类型转换器"></a>1.字段类型转换器</h2><p>如果出现实体字段类型与数据库类型不一致情况，比如实体是<code>String</code>但是数据库是<code>Date</code>，或者实体中是对象，而数据库中是<code>varchar</code>存储<code>json</code>；则可以通过字段类型转换器进行统一转换，无需业务层在每次存取时进行手段转换。</p><p><b>1.实体上设置转换器类型(设置之后，在通过基础接口的处理都会进行转换)</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里需要设置autoResultMap = true, 否则查询时不会将数据库中的json转换为对应实体</span></span><br><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">    <span class="comment">// 设置转换器的类型,这个是内置转换器,也可以自定义</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserExtraInfo userExtraInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.第一步骤中的设置仅导致通过内置接口的处理会进行转换，但是通过自定义XML的脚本语句不会进行转换。</b><br>法一：在<code>mapper</code>语句上通过<code>@Results</code>设置对应的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Results(value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;user_extra_info&quot;, property = &quot;userExtraInfo&quot;, typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：需要在<code>xml</code>文件中配置<code>resultMap</code>结果集，并在结果集映射中设置对应的类型转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.entity.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MOBILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deleteStatus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DELETE_STATUS&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userExtraInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;USER_EXTRA_INFO&quot;</span> <span class="attr">typeHandler</span> = <span class="string">&quot;com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testXmlSql&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-基础类扩展"><a href="#2-基础类扩展" class="headerlink" title="2.基础类扩展"></a>2.基础类扩展</h2><p>直接通过继承<code>mybatis-plus</code>提供的三层基础接口，可以直接具备一些数据操作能力，比如通过<code>deleteById</code>可以直接通过<code>id</code>删除记录，无需编写<code>SQL</code>语句。同时<code>mybatis-plus</code>还提供了对基础层的扩展，用户可自定义扩展点后，业务处理再继承于自定义的扩展点，使得系统应用具备自定义扩展底层接口的能力。<br><img src="https://s2.loli.net/2022/10/14/eropFI59y32lt4k.png" alt="mybatis-plus基础接口扩展.png"></p><p>上图中<code>userFacade</code>、<code>userService</code>、<code>userMapper</code>是业务层；<code>customerService&lt;User&gt;</code>、<code>CustomerServiceImpl</code>、<code>CustomerMapper</code>是自定义扩展层；<code>IService&lt;T&gt;</code>、<code>ServiceImpl</code>、<code>BaseMapper</code>是<code>mybatis-plus</code>的三次基础接口。</p><p><b>假设现在要扩展<code>Insert ignore</code>的插入语句</b></p><p><b>1.继承<code>AbstractMethod</code>编写具体<code>SQL</code>的拼写等处理：</b>可以参考原有的其他对<code>AbstractMethod</code>的实现，比如<code>com.baomidou.mybatisplus.core.injector.methods</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIgnore</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        CustomerSqlMethod sqlMethod = CustomerSqlMethod.INSERT_IGNORE_ONE;</span><br><span class="line">        String columnScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlColumnMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlPropertyMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(tableInfo.getKeyProperty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(sqlMethod.getMethod(), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, sqlMethod.getMethod(), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置自定义<code>SQL</code>注入器并注入到<code>Spring</code>容器：</b>将步骤一中创建的具体<code>SQL</code>执行器注入到<code>mybatis-plus</code>相应处理中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">iSqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomerSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.创建扩展的<code>mapper</code>层：</b>添加需要扩展的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>service</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>serviceImpl</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insertIgnore(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>5.到这里，业务层只要继承于扩展层，就具备了自定扩展的处理能力</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> <span class="keyword">extends</span> <span class="title">CustomerService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserExtraInfo userExtraInfo = UserExtraInfo.builder()</span><br><span class="line">                .address(<span class="string">&quot;北京市&quot;</span>)</span><br><span class="line">                .city(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                .id(<span class="string">&quot;12312311&quot;</span>)</span><br><span class="line">                .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                .mobile(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .deleteStatus(<span class="number">0</span>)</span><br><span class="line">                .userExtraInfo(userExtraInfo)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 这里就可以直接调用到扩展的接口</span></span><br><span class="line">        insertIgnore(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-逻辑删除"><a href="#3-逻辑删除" class="headerlink" title="3.逻辑删除"></a>3.逻辑删除</h2><p>只需要设置<code>@TableLogic</code>就具备了逻辑删除的能力，但是这仅限制与通过<code>mybatis-plus</code>的基础接口处理数据，如果是通过<code>xml</code>手写<code>SQL</code>是无法自动补充逻辑删除条件。</p><ul><li>插入语句不处理，也就是说默认值需要业务方插入或者通过数据库设置默认值来处理</li><li>查找、更新会追加查询条件</li><li>删除转为更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置逻辑删除字段</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis-plus特性&quot;&gt;&lt;a href=&quot;#mybatis-plus特性&quot; class=&quot;headerlink&quot; title=&quot;mybatis-plus特性&quot;&gt;&lt;/a&gt;mybatis-plus特性&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mysql问题汇总</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-10-11T14:13:58.000Z</published>
    <updated>2022-10-11T07:42:47.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL单表数据数据最大两千万？"><a href="#MySQL单表数据数据最大两千万？" class="headerlink" title="MySQL单表数据数据最大两千万？"></a>MySQL单表数据数据最大两千万？</h2><p>相比大家也有听说过<code>MySQL</code>单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。<span id="more"></span></p><p>其实这种说法的背后是索引高度的问题，<code>MySQL</code>索引内部使用的是<code>B+</code>树，叶子节点存具体的数据，非叶子节点是为了去叶子节点寻址。<code>MySQL</code>的数据是按页存储，每一页的大小是16k，读取的时候也是按页读取，也就是说就算你的语句里有<code>limit 1</code>，但是实际上也是将整页都加载到内存中。</p><p>这个16k大小的页包含有页头（页号，寻址指针等内容）、页尾（检验码等）、页目录（这一页内的数据目录，用于快速找到页内数据），剩下的空间就是存放具体的数据记录<code>record</code>。结合<code>B+</code>树的特性，非叶子节点内具体的数据记录<code>record</code>实际上存储的某一页的页号以及这一页的最小记录的<code>id</code>值。叶子节点内具体的数据记录<code>record</code>实际上存储的是行信息(再具体到存储的是行记录的多少内容，要看是什么索引)。</p><p>所以想查询某一行数据的主要过程：从索引的根往下找，先根据非叶子节点的<code>id</code>值匹配，匹配到对应的<code>id</code>值之后根据页号，找到对应的叶子节点，从而获取到整行数据。</p><p>当数据庞大时，树的叶子节点如果想要容纳所有数据就需要增加高度，高度越高，能容纳的数据量也就越大。同时也伴随着更多的磁盘io，一般3层索引树，会有3次磁盘io，并且是随机io。<br>这里有一个计算公式：<code>(x ^ (z-1)) * y</code></p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的<code>record</code>数量为<code>y</code></li><li><code>B+</code>树的层数为<code>z</code></li></ul><p><b>x的值：</b>主键假设是bigint（8Byte），而页号在源码里叫FIL_PAGE_OFFSET（4Byte），那么非叶子节点里的一条数据是12Byte左右，整个数据页16k， 页头页尾那部分数据全加起来大概128Byte，加上页目录毛估占1k吧。那剩下的15k除以12Byte，等于1280，也就是可以指向x=1280页。<br><b>y的值：</b>叶子节点和非叶子节点结构是一致的，这里也假设记录可用空间为15k，假设一行数据需要占用1k空间，那么叶子节点可用容纳15行的数据。</p><p>根据公式：<br>若z=2，则(1280 ^ (2-1)) * 15 ≈ 2w<br>若z=3，则(1280 ^ (3-1)) * 15 ≈ 2.5kw<br>这里的<code>2.5kw</code>也就是通常说的单表数据不要超过2kw的估值，如果高度再加一层，那么所能容纳的数据量就更加庞大。但是你有没有发现，我假设了单行数据的空间是1k，如果表字段不多，单行数据仅0.25k呢，那么这个计算结果就是1亿，也就是在三层高度的情况下，数据量也有可能达到1亿。</p><h2 id="随机IO-顺序IO"><a href="#随机IO-顺序IO" class="headerlink" title="随机IO/顺序IO"></a>随机IO/顺序IO</h2><p>顺序IO是指读写操作的访问地址连续。随机IO是指读写操作的时间连续，但访问的地址不连续。</p><h2 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h2><p>深度分页涉及到的问题通常是使用<code>limit offset, size</code>，对于<code>limit 10, 10</code>和<code>limit 10000, 10</code>，性能上前者是快于后者的，这是因为后者也是需要查出10000条数据，然后丢弃掉，再往后获取10条数据，也就是说前者总共获取了20条数据，后者获取了10010条数据。</p><p>这种情况其实是无解的，因为这是<code>MySQL</code>的内部逻辑，我们根本就触及不到，但是在一定条件下，可以通过一定的手段进行优化。假设有语句：</p><blockquote><p>select * from page order by id limit 10000, 10;</p></blockquote><p>这条查询语句还是有优化空间的，由于这里需要查询整行数据，也就导致了丢弃的10000行数据也去查询了整行数据，实际上这是没有必要的。<br>优化如下，虽然它也是会获取那丢弃的10000条数据，但是这10000条数据仅获取了id值，并没有获取整行数据，当行数据比较长时，还是会有一定的性能提升。</p><blockquote><p>select * from page  where id &gt;=(select id from page  order by id limit 10000, 1) order by id limit 10; </p></blockquote><p>再看在非主键索引上的操作：</p><blockquote><p>select * from page order by user_name  limit 10000, 10;</p></blockquote><p>这里由于是非主键索引，所以会对这丢弃的10000条数据都进行一次回表操作，影响性能。可以通过连接来优化，减少回表次数：</p><blockquote><p>select * from page t1, (select id from page order by user_name limit 10000, 10) t2  WHERE t1.id = t2.id;</p></blockquote><p>前面的优化实际上也都会查询丢弃的10000条数据，所以这里再怎么优化都是治标不治本的优化手段。所以只能通过一些特殊手段控制，比如百度、淘宝的搜索页只会固定页码，到一定页码之后就不允许往后页码查。再比如抖音这种这种滚动下只有翻页没有跳页，可以将当前页设置一个最小值，下一页在这个最小值的基础上查询。这也是同步大表时的一个手段。</p><p>如果同步一个大表，你使用的是<code>select * from tableName</code>，同步到异构系统，比如es等，因为数据量比较大，数据库无法一次性获取到所有数据而报错，如果仅仅通过<code>limit offset, size</code>就有可能出现深度分页的情况，所以一般来说可以通过<code>id</code>排序，将<code>id</code>对应的记录分块，当前块的最大<code>id</code>值，作为下一块<code>id</code>的查询条件。</p><blockquote><p>select * from tableName where id &gt; 上一块id的最大值 order by id limit 100</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;a href=&quot;#MySQL单表数据数据最大两千万？&quot; class=&quot;headerlink&quot; title=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;/a&gt;MySQL单表数据数据最大两千万？&lt;/h2&gt;&lt;p&gt;相比大家也有听说过&lt;code&gt;MySQL&lt;/code&gt;单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（五）---排序</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/</id>
    <published>2022-10-09T14:13:58.000Z</published>
    <updated>2022-10-09T08:50:06.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（五）—排序"><a href="#mysql45讲学习总结（五）—排序" class="headerlink" title="mysql45讲学习总结（五）—排序"></a>mysql45讲学习总结（五）—排序</h1><p>​<br>本篇记录<code>MySQL</code>在执行<code>order by</code>语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。</p><span id="more"></span><h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><blockquote><p>select name, age, address from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>使用<code>explain</code>分析该语句：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>bid_confirm_project</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4033</td><td>10</td><td>Using where; Using filesort</td></tr></tbody></table><p><code>Using filesort</code>：表示需要排序。<code>MySQL</code>会给每个线程分配一块<code>sort_buffer</code>内存空间用于排序。</p><p>假设在<code>name</code>上有索引排序流程：</p><ol><li>初始化<code>sort_buffer</code>空间，确定将用于存入字段<code>name</code>、<code>age</code>、<code>address</code>的值。</li><li>从索引<code>name</code>上找到第一个满足<code>xxx</code>条件的<code>id</code>。</li><li>根据这个<code>id</code>通过主键索引获取整行数据，将<code>name</code>、<code>age</code>、<code>address</code>的值存入到<code>sort_buffer</code>中。</li><li>从索引<code>name</code>取下一个记录的主键。</li><li>重复3,4步骤，直到从索引<code>name</code>取到的值不满足查询条件为止。</li><li>对<code>sort_buffer</code>空间的数据按照<code>age</code>进行排序。</li><li>返回结果集数据。</li></ol><p>​    <b>步骤6中按照<code>age</code>进行排序：这个可能在内存中完成，也有可能需要使用到外部排序。</b>这取决于排序所需要的内存空间大小和参数<code>sort_buffer_size</code>。如果需要排序的数据量小于<code>sort_buffer_size</code>则使用内存空间进行排序，如果需要排序的数量大于<code>sort_buffer_size</code>则需要使用磁盘临时文件辅助排序。</p><p>仅仅使用<code>explain</code>只能分析改语句是否需要排序，至于排序是在内存中排序还是在磁盘中排序就无法得知，需要使用其他手段。<b><code>MySQL</code>版本需要到5.6以上。</b></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开 optimizer_trace，只对本线程有效</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 OPTIMIZER_TRACE 输出 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`</span><br></pre></td></tr></table></figure><p>查询的结果是一个<code>json</code>结果：(<code>json</code>结果比较大，截取一段)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;filesort_summary&quot;: &#123;</span><br><span class="line">  &quot;rows&quot;: 4250,  </span><br><span class="line">  &quot;examined_rows&quot;: 4291, // 排序的行数</span><br><span class="line">  &quot;number_of_tmp_files&quot;: 11,   // 排序过程中使用的临时文件数，如果在内存中排序，则这个值为0</span><br><span class="line">  &quot;sort_buffer_size&quot;: 261696,  // 就是上面说的排序的空间大小，这个是可以通过命令调整</span><br><span class="line">  &quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>假设查询语句变为：</p><blockquote><p>select * from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>对比可知，仅仅是将查询结果的字段修改为了<code>*</code>，这时在步骤1中就需要为很多无需排序的字段开辟空间，那么就会造成<code>sort_buffer_size</code>空间中单行的数据比较长，那么<code>MySQL</code>会怎么做？</p><p>实际上当<code>MySQL</code>判断单行数据过长时，它会修改<code>sort_buffer_size</code>存放值的策略，之前全字段排序时<code>sort_buffer</code>存放的字段为<code>name</code>、<code>age</code>、<code>address</code>，而如果单行数据过长时，<code>sort_buffer</code>存储的字段就变成<code>id</code>、<code>age</code>，排序完成之后，通过主键<code>id</code>索引进行一次回表，也就是说比全字段排序多了一个步骤，在排序完成之后需要进行一次回表。</p><p>同时在刚刚的<code>optimizer_trace</code>的<code>json</code>中的<code>sort_mode</code>项中会标识出是否采用了<code>rowid</code>算法。通过参数<code>max_length_for_sort_data</code>控制单行数据长度。</p><p><b>全字段排序对比rowid排序</b></p><p>如果<code>MySQL</code>认为内存足够大，会优先选择<b>全字段排序</b>，如果认为排序内存太小，影响排序效率，则会采用<code>rowid</code>排序算法，这样排序过程中一次可以排多行，但是需要再回表取相关字段数据。</p><p>排序对于<code>MySQL</code>来说是一个成本比较高的操作，并不是所有的<code>order by</code>都需要排序操作，之所以需要排序操作，是因为查到的数据是无序的，所有才需要进行排序操作，但是在<code>MySQL</code>中有一种方式是天然排序的，那就是索引，可以通过创建对应索引，使得查询到的数据已经是有序，那么就无需在经过排序操作。这种情况下<code>explain</code>得到的结果中就没有<code>filesort</code>。</p><h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><blockquote><p>CREATE TABLE <code>words</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>word</code> varchar(64) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB;</p><p>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=0;<br>  while i&lt;10000 do<br>    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;</p><p>call idata();</p></blockquote><p>然后执行以下语句用于获取随机的前三个数据，这里的<code>order by rand()</code>，会对每一行的数据都生成一个随机值，然后根据这个随机值进行排序，最后取得前三行数据。</p><blockquote><p>select word from words order by rand() limit 3;</p></blockquote><p>使用<code>explain</code>命令执行结果如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>words</td><td>ALL</td><td></td><td></td><td></td><td></td><td>10304</td><td>Using temporary; Using filesort</td></tr></tbody></table><p><code>Using temporary</code>表示需要使用到临时表，这里是因为需要为每一行生成一个随机值进行排序，所以需要一个临时表存储生成的这个随机值。</p><p>对于内存临时表来说，会选用那种算法存放数据？是全字段索引的算法？还是<code>rowid</code>算法？。<br>答案是使用<code>rowid</code>算法，因为对内存临时表来说，回表只是简单的根据数据行的位置直接访问到数据，不会导致访问磁盘，所以这时采用的是<code>rowid</code>排序。</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p><b>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</b></p><h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>当需要到临时表的空间比较大时，超过了<code>tmp_table_size</code>的值，那么内存临时表会转换为磁盘临时表。<br>在磁盘临时表中还有一种优化算法：优先队列排序算法。对于这个查询语句，实际上只需要取值最小的3个值，但是如果使用归并排序的话，是将所有数据都排序了，所以实际上浪费了很大的计算量。所以这里<code>MySQL</code>提供了优先队列排序算法：<br>  先取3行数据构建一个堆，再取下一行数据，与这个堆的最大值进行比较，如果大则丢弃，如果小则替换，依次执行，知道扫描完整个表。</p><p>如果需要的空间大于<code>sort_buffer_size</code>则采用磁盘临时表，通过磁盘临时表进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（五）—排序&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;/a&gt;mysql45讲学习总结（五）—排序&lt;/h1&gt;&lt;p&gt;​&lt;br&gt;本篇记录&lt;code&gt;MySQL&lt;/code&gt;在执行&lt;code&gt;order by&lt;/code&gt;语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（四）---锁</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/</id>
    <published>2022-09-29T14:13:58.000Z</published>
    <updated>2023-03-01T03:14:56.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（四）—锁"><a href="#mysql45讲学习总结（四）—锁" class="headerlink" title="mysql45讲学习总结（四）—锁"></a>mysql45讲学习总结（四）—锁</h1><p>​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><span id="more"></span><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><ul><li><code>DML</code>：数据操纵语言(Data Manipulation Language)</li><li><code>DDL</code>：数据定义语言(Data Definition Language)</li><li><code>MDL</code>：元数据锁(meta data lock)</li></ul><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>​    全局锁顾名思义就是对整个数据库实例上锁，让整个数据库处于只读状态，<code>MySQL</code>提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock(FTWRL)</code>。使用这个命令之后，其他线程的数据更新语句<code>DML</code>(增删改)、数据定义语句<code>DDL</code>(建表、修改字段信息)和更新类事务的提交语句。</p><p>一般来说全局锁的使用场景就是全库的备份，使用<code>FTWRL</code>命令之后，使得整个库处于只读状态之后，进行数据备份。那么有两种情况，如果在主库进行备份，备份期间，主库处于业务停摆；如果在从库备份，从库无法执行主库过来的<code>binlog</code>，导致主从延迟。</p><p>那么有没有什么方式可以不影响业务？</p><p>先简单还原全库备份如果不上全局锁产生的问题：假设有两张表，一张账户余额表，一张用户课程表；事务内的操作顺序为余额表扣款，课程表添加一条课程记录。假设这个动作是在备份过程中执行，在余额表扣款之前，备份了余额表，在课程表添加记录之后，备份了课程表，导致在备份库中，余额表的金额是原值，课程表却新增了一条记录。从语义上简单说就是钱没有花，但是买到了课。</p><p>产生这个问题的原因主要是备份库得到的不是一个逻辑时间点，视图的逻辑是不一致的，所以备份的时候应该要拿到一个时间点的一致性视图。也就是在可重复读隔离级别看开启一个事务，那么在这个事务中的操作，对于每个表来说已经形成了”快照“，对这个”快照“进行备份，从而保证备份库数据逻辑正确。</p><p>官方自带的逻辑备份工具<code>mysqldump</code>，使用参数<code>--single-transaction</code>后备份数据会启动一个事务，来确保拿到的是一致性视图，但是要注意，这个参数需要存储引擎支持可重复读这个隔离级别。比如<code>MyISAM</code>不支持，那么只能使用<code>FTWRL</code>进行备份。</p><p>当然了还有人说可以使用<code>set global readonly = true</code>的方式让整个库处于只读的状态，但是这种做法存在两个致命的问题：</p><ul><li>使用<code>FTWRL</code>命令，当这个线程因为发生异常断开之后，会释放这个全局锁。</li><li>假设其他应用层框架通过这个<code>readonly</code>全局参数判断是否是主库，导致一些应用层逻辑出现问题。</li></ul><p>业务的更新不只是<b>增删改数据（<code>DML</code>)</b>，还有可能是加字段等<b>修改表结构的操作（<code>DDL</code>）</b>。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p><code>MySQL</code>里面的表级别锁有两种：表锁和元数据锁<code>MDL</code>。</p><h2 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h2><blockquote><p>表锁的语法是 lock tables … read/write</p></blockquote><p>与<code>FTWRL</code>类似，可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。</p><p><code>lock tables</code>命令除了会限制别的线程的读写之外，也会限制自身线程的数据访问权限：假设线程A中执行<code>lock tables t1 read, t2 write</code>那么其他线程的写<code>t1</code>、读写<code>t2</code>都会被阻塞。同时当线程A在执行<code>unlock tables</code>之前，自身线程只能执行读<code>t1</code>、读写<code>t2</code>，这时连写<code>t1</code>都不允许，自然不能访问其他表。</p><p>一般不使用<code>lock tables</code>来控制并发，这个锁的面积太大。</p><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>​    <code>MDL</code>不需要显示使用，在访问一个表的时候会自动加上，它的作用是保证读写的正确性，这是因为假设一个查询正在遍历表数据，突然另一个线程变更了表结构，那么查询线程获取到的数据结构跟原本对不上。</p><p>​    所以当对一个表做增删改操作时，加<code>DML</code>读锁，当要对表结构做变更时，加<code>DML</code>写锁。</p><ul><li>读锁之间不互斥，因此你可以多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，一个线程获取了读锁，另一个线程如果要获取写锁就需要进入等待。</li></ul><p>尽管这样还是可能会出现一些问题：</p><p>​    在给一个表添加字段、修改字段或者索引的处理，这些操作是需要全表扫描的。假设线程A获取了<code>DML</code>读锁，在对表进行查询操作，线程B想要获取<code>DML</code>写锁，进行修改表字段操作，这时由于线程A持有<code>DML</code>读锁，线程B阻塞进入等待，同时其他线程若想再查这个表数据，需要获取<code>DML</code>读锁，都会因为线程B而进入等待，如果这个表查询比较频繁，且很多客户端是有重试机制，也就是等待超时之后会重启一个<code>session</code>再次请求，那么这个库的线程很快就会满。<b>事务中的<code>DML</code>锁，在语句执行开始时申请，并不是在语句执行完成后就释放，而是在事务提交之后才释放。</b></p><p>所以一般情况下，首先要解决长事务，事务不提交会一直持有<code>DML</code>锁，或者将这个线程<code>kill</code>掉，但是对于热点表来说，可能<code>kill</code>不是那么有效果，可能刚<code>kill</code>掉，请求马上就又来了，所以只能通过为这个变更语句设置等待时间，如果在这个时间之内能获取到<code>DML</code>锁，就执行变更，如果获取不到，也不要阻塞业务，先放弃，之后在重复执行这个命令。</p><blockquote><p>ALTER TABLE tbl_name NOWAIT add column …</p><p>ALTER TABLE tbl_name WAIT N add column …</p></blockquote><h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>​    <code>MySQL</code>的行锁是各个引擎层自己实现，并不是所有存储引擎都支持行锁，比如<code>MyISAM</code>就不支持行锁，也就是锁它的并发控制只能使用表锁，这种颗粒度严重影响了业务并发度。</p><p>​    行锁就是针对于数据表中行记录的锁，锁的是主键索引，比如事务A更新了一行，这时候事务B也要更新同一行，那么事务B进入等待，如果事务B更新的不是同一行，那么事务B无需等待。</p><p><b>两阶段锁</b></p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;<br>update t set k=k+1 where id=1;<br>update t set k= k+1 where id=2;</td><td></td></tr><tr><td></td><td>Begin;<br>update t set k=k+2 wehre id=1;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这种情况下，事务A在执行两条更新语句之后，持有了这两条记录的行锁，但是事务A是在提交之后才会释放行锁，所以事务B的更新语句，要在事务A提交之后才能执行。</p><p><b>在<code>InnoDB</code>事务中，行锁是在执行语句的时候获取的，但并不是语句执行之后就释放，而是在这个事务提交之后才释放，这就是两阶段协议。</b></p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>间隙锁是用来解决幻读带来的问题，幻读是指事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</p><p>创建一个表，这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。</p><blockquote><p>CREATE TABLE <code>t</code> (<br><code>id</code> int(11) NOT NULL,<br><code>c</code> int(11) DEFAULT NULL,<br><code>d</code> int(11) DEFAULT NULL,<br>PRIMARY KEY (<code>id</code>),<br>KEY <code>c</code> (<code>c</code>)<br>) ENGINE=InnoDB;</p><p>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p></blockquote><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td></td><td>insert into t value(1, 1, 5)</td></tr><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p><code>sessionA</code>第一次查询的时候只返回一条记录，第二次查询的时候由于<code>sessionB</code>已经提交了，所以可以查到两条记录。</p><p>也就是说幻读指一个事务内的两次查询，后一次的查询看到了前一次查询没有看到的行。</p><p>仔细观察<code>sessionA</code>的查询语句，可以发现，<code>for update</code>命令加上之后，是当前读，当前读就是要读到已经提交的最新值，所以<code>sessionA</code>看到<code>sessionB</code>提交的结果看起来并没有什么问题。</p><p>但是，实际上这是有问题的，因为<code>sessionA</code>的第一个查询语句的语义是要锁住所有<code>d=5</code>的行，不允许其他事务进行写操作，如果将<code>sessionB</code>的语句修改为<code>update c=1 where d=5</code>，这时<code>sessionB</code>就会进入等待，等待<code>sessionA</code>提交之后释放锁。</p><p><b>锁的设计是为了在并发时保持数据的一致性，包括数据库内部数据状态的一致性，也包括了日志的一致性。</b></p><p>看下面的例子：</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from where d=5 for update;<br>update t set d=100 where d=5;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=5 where id=0;<br>update t set c=5 where id = 0;</td><td></td><td>T2</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T3</td></tr><tr><td></td><td></td><td>insert into t values(1,1,5);<br>update set c=5 where id=1;</td><td>T4</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T5</td></tr><tr><td>commit;</td><td></td><td></td><td>T6</td></tr></tbody></table><p>当执行完成之后数据库数据结果：</p><ol><li>经过T1之后，id=5这一行变成(5, 5, 100)，但是这个要在T6之后才正式提交。</li><li>经过T2之后，id=0这一行变成(0, 5, 5)</li><li>经过T4之后，表里对了一行(1, 5, 5)</li></ol><p>所以<code>binlog</code>中的语句大概是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure><p>如果使用这个<code>binlog</code>来备份或者是从库同步数据都会出现数据不一致的情况。</p><p>那么是什么导致了这个数据不一致？可以简单的认为是<code>sessionA</code>在T1时未锁住数据导致的，那么如果它在T1时刻锁住了所有扫描到的行又会怎么样？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure><p>可以看到，就算锁住了所有扫描行，阻塞了<code>sessionB</code>的执行，但是也无法锁住<code>sessionC</code>语句的执行，<b>换句话说就是即使是所有数据都上锁，也还是无法阻止新记录的插入。</b>这也就是为什么幻读需要单独拿出来说的原因。</p><p>所以产生幻读的原因是行锁只能锁住数据行，而新插入的数据是插入到数据行之间的间隙，因此为了解决幻读，<code>InnoDB</code>引入了间隙锁(<code>Gap Lock</code>)。</p><p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，在主键索引上这就产生了 7 个间隙。</p><p><img src="https://s2.loli.net/2022/10/12/DqFhULJ4MSvCWje.png" alt="间隙锁.png"></p><p>所以当执行<code>select * from t where d=5 for update</code>时，不止是给数据库中已有的6个记录上锁，同时也加上了7个间隙锁。这样就可以确保数据无法插入。也就是说在扫描行时不仅给行上锁，也给行两边的间隙上锁。</p><p>间隙锁的性质与之前碰到的锁性质有所不同。</p><p>比如行锁分为读写锁，读锁之间不冲突，读写、写写之间是冲突。而间隙锁，两个<code>session</code>可以同时对一个间隙上间隙锁，只要不插入数据就不会产生冲突。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin<br>select * from t where c=7 lock in share mode;</td><td></td></tr><tr><td></td><td>begin<br>select * from t where c=7 lock in share mode;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里的<code>sessionB</code>并不会阻塞，因为表中没有<code>c=7</code>这条记录，对于<code>sessionB</code>来说也是对(5,10)这个范围加间隙锁，它也<code>sessionA</code>锁住的范围是一致的，目标也是一致的，都是为了保护(5,10)这个范围不能插入数据。</p><p>间隙锁和行锁合称<code>next-key lock</code>，每个<code>next-key lock</code>是前开后闭区间。</p><p>当然了间隙锁的引入也会带来一些问题。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where id=5 for update;</td><td></td></tr><tr><td></td><td>select * from where id=5 for update;<br>insert into t values(5,1,5);</td></tr><tr><td>insert into t values(5,1,5);</td><td></td></tr></tbody></table><p>这个会带来死锁，原因是<code>sessionA</code>为(5,10)加上了间隙锁，<code>sessionB</code>也为(5, 10)加上了间隙锁，但是<code>sessionB</code>的插入语句需要等待<code>sessionA</code>释放间隙锁，<code>sessionA</code>的插入语句也在等待<code>sessionB</code>释放间隙锁，从而造成死锁。</p><p>间隙锁实际上是可重复读的隔离级别才会出现，如果隔离级别设置为读提交就不会产生幻读，也就不需要引入间隙锁。在读提交下，一般将日志格式设置为<code>row</code>来解决数据不一致的问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>行锁：对索引记录加锁。</li><li>间隙锁：锁住某个区间。(可以是两个索引记录之间，也可以是第一个索引之前或者最后一个索引之后的空间)</li><li>next-key锁：行锁和间隙锁的组合。</li></ul><p><b>如果检索条件不是索引的话会全表扫描，这时是表级锁。</b></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>如果需要删除一个表里前10000行数据，有一下三种方法可以做到：</p><ol><li>直接执行 <code>delete from T limit 10000</code>：单个语句占用时间过长，锁的时间比较长，而且大事务还会导致主从延迟。</li><li>在一个连接中循环执行20次<code>delete from T limit 500</code>：一般推荐这种方式。</li><li>在20个连接中同时执行<code>delete from T limit 500</code>：人为造成锁冲突。但是如果可以加上特定的条件，将这10000天然的分开，或者可以获取到主键<code>ID</code>，那么这种方式也不错。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（四）—锁&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;/a&gt;mysql45讲学习总结（四）—锁&lt;/h1&gt;&lt;p&gt;​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（三）---事务</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-09-26T14:13:58.000Z</published>
    <updated>2022-09-29T02:51:11.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（三）—事务"><a href="#mysql45讲学习总结（三）—事务" class="headerlink" title="mysql45讲学习总结（三）—事务"></a>mysql45讲学习总结（三）—事务</h1><p>​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在<code>MySQL</code>中，事务支持是在引擎层实现的。<code>MySQL</code>是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如<code>MySQL</code>原生的<code>MyISAM</code>引擎就不支持事务，这也是<code>MyISAM</code>被<code>InnoDB</code>取代的重要原因之一。</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p><p>当数据库上有多个事务同时执行的时候，就可能出现：</p><ul><li>脏读（dirty read）：无效数据的读出，假设事务T1将某一值修改，这是事务T2读取到这一新值，但是事务T1由于某种原因回滚了新值，这就导致事务T2所读到的新值是无效的。</li><li>不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，在这个数据还没有结束时，另一个事务也访问了同一数据，那么第一个事务在两次读取数据之间由于第二个事务的修改，导致前后读取到的数据不一样，因此称为不可重复读，即原始读取不可重复。</li><li>幻读（phantom read）：事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</li></ul><p>对应的<code>SQL</code>标准事务隔离级别包括：</p><ul><li>读未提交（read uncommitted）：一个事务还没有提交时，它做的变更可以被其他事务看到。</li><li>读提交（read committed）：一个事务提交之后，它做的变更才能被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的；未提交的变更对其他事务也是不可见。</li><li>串行化（serializable ）：对同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写冲突时，后访问的事务需等待前访问事务释放锁，才可执行。</li></ul><p><b>例子</b></p><blockquote><p>create table T(c int) engine=InnoDB;</p><p>insert into T(c) values(1);</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>启动事务查询得到值1</td><td>启动事务</td></tr><tr><td></td><td>查询得到值1</td></tr><tr><td></td><td>将1改成2</td></tr><tr><td>查询得到值V1</td><td></td></tr><tr><td></td><td>提交事务B</td></tr><tr><td>查询得到值V2</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td>查询得到值V3</td><td></td></tr></tbody></table><p>不同隔离级别下V1，V2，V3的返回值：</p><ul><li>读未提交：V1=V2=V3=2（V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2）</li><li>读提交：V1=1，V2=V3=2（V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2）</li><li>可重复读：V1=V2=1，V3=2（V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的）</li><li>序列化：V1=V2=1，V3=2（在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2）</li></ul><p>在实现上，<code>MYSQL</code>引入视图的概念，访问的时候以视图的逻辑结果为准。</p><ul><li>读未提交：可以直接看到未提交事务的变更，不存在视图。</li><li>读提交：在每个<code>SQL</code>语句开始执行的时候创建视图。</li><li>可重复读：在事务启动时创建，整个事务存在期间都使用这个视图。</li><li>序列化：直接使用锁来控制并行访问，不存在视图。</li></ul><p><b>不同的隔离级别，数据库的行为有所不同，<code>Oracle</code>数据库的默认隔离级别是”读提交“，<code>MySQL</code>默认的隔离级别是可重复读，如果是将<code>Oracle</code>迁移到<code>MySql</code>的引用，为保证数据库隔离级别一致，可以将<code>MySQL</code>的隔离级别设置为”度提交“</b></p><blockquote><p>show variables like ‘transaction_isolation’</p><p>将参数transaction-isolation 的值设置成 READ-COMMITTED</p></blockquote><p><b>使用”可重复读“的场景</b></p><p>​    假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。        </p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>​    在<code>MYSQL</code>中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值通过一个个回滚操作，可以回到之前的旧值。</p><p>假设一个值从1&rarr;2&rarr;3&rarr;4，最后新值为4，那么在回滚日志和视图如下：</p><p><img src="https://s2.loli.net/2022/09/26/tM79KoGIlz4OVhA.png" alt="事务隔离回滚.png"></p><p>最新值为4，但是不同时刻启动的事务会产生不同的视图，在在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。 对于视图A来说，要想等到值为1，只需要将最新值依次执行回滚动作。所以即使现在有新事务将4改成5，这个事务对视图A，B，C对应的事务不会存在冲突。当系统中没有比回滚日志更早的视图时，这些回滚日志就会被删除。</p><p>所以尽量不要使用长事务，长事务意味着系统里会存在很老的事务视图，导致在这个事务提交之前，这个事务可能用到的回滚记录都必须被保留，也就造成了占用了大量的存储空间。</p><h1 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h1><ol><li>显示启动事务语句，<code>begin</code>或者<code>start transaction</code>，结束事务使用<code>commit</code>，回滚使用<code>rollback</code>。</li><li><code>set autocommit=0</code>，关闭这个线程的自动提交，意味着只要执行一个<code>select</code>事务都会启动，并且不会自动提交，只有到显示<code>commit</code>或者<code>rollback</code>或者断开连接。</li></ol><p>查询持续时间超过60s的事务：</p><blockquote><p>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p></blockquote><h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><blockquote><p>CREATE TABLE <code>t</code> (</p><p>  <code>id</code> int(11) NOT NULL,</p><p>  <code>k</code> int(11) DEFAULT NULL,</p><p>  PRIMARY KEY (<code>id</code>)</p><p>) ENGINE=InnoDB;</p><p>insert into t(id, k) values(1,1),(2,2);</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td></td><td>update t set k=k+1 where id = 1;</td></tr><tr><td></td><td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td><td></td></tr><tr><td>select k from t where id =1;<br/>commit;</td><td></td><td></td></tr><tr><td></td><td>commit;</td><td></td></tr></tbody></table><p><b>注意：</b><code>begin/start transaction</code>命令并不是一个事务的起点，在执行到他们之后的第一个操作<code>InnoDB</code>表的语句，事务才真正启动，若想马上启动则使用<code>start transaction with consistent snapshot</code>命令。</p><p>事务C没有显示的使用<code>begin/commit</code>，表示这个<code>update</code>语句本身是一个事务，语句在执行完成后会自动提交。</p><p>在上述三个事务中：事务A查到的k=1，事务B查到的k=3。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>​    在可重复读隔离级别下，事务在启动的时候就对整个数据库“拍了个快照”。当然了，这个“快照”不是简单理解为拷贝数据，而是通过逻辑手段进行处理。</p><p>​    在<code>InnoDB</code>里面每个事务都有一个唯一的事务<code>ID(transaction id)</code>，在事务开始时向事务组件申请，是严格按照申请顺序递增。</p><p>​    每一行数据都是有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并把这个数据版本上的<code>row trx_id</code>标记为这个事务<code>ID</code>，同时旧数据版本，通过<code>undo log</code>来拿到具体旧数据版本。</p><p>综上：每一行数据，其实可能有多个版本<code>row</code>，每个版本有自己的<code>row_trx_id</code>。</p><p><img src="https://s2.loli.net/2022/09/27/mcCoSq971UtjWpR.png" alt="MVCC例子.png"></p><p>上图就是一个记录被多个事务更新后的状态，虚线框中是一行数据的4个版本，V4是最新的版本；图中的U1，U2，U3就是<code>undo log</code>，但需要获取到前置版本数据时，就是通过<code>undo log</code>计算出来，比如需要V2的时候，就是通过V4依次执行U3，U2计算得出。(上图中的数据版本所对应的事务都是提交状态，避免有人理解为还能对事务id=15的事务进行回滚。)</p><p>所以，某一个事务在启动的时候，会声明：“在我启动时刻为准，如果一个数据版本是在我启动之前生成，我可见；如果是在我启动之后才生成，我不可见，我必须找它之前的我可见的版本；如果是自身事务版本，我也是可见”。</p><p><code>InnoDB</code>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃中”(启动还未提交)的所有事务<code>ID</code>。当一个事务启动时，这个数组中的元素就是“活跃中”事务和自身事务(顺序排列)。当判断数据版本可见性时，就通过这个数组来进行判断，比如一个事务的数组为<code>[7,8, 10]</code>（自身事务id=9）：</p><ul><li>查询某个数据版本的<code>row trx_id=10</code>，这就表示这个数据版本是在当前事务之后生成，故向前获取版本。</li><li>查询某个数据版本的<code>row trx_id=6</code>，比数组中最小的还小，表示是在事务启动前生成的，可见。</li><li>查询某个数据版本的<code>row trx_id=7</code>，落在这个数组中，表示这个版本事务还未提交，不可见。</li><li>查询某个数据版本的<code>row trx_id=8</code>，比数组中最小的大，但是不落在这个数组中，表示这个版本事务已提交，可见。</li></ul><p>根据上述结论，分析之前事务A的查询情况：</p><ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ol><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><p><img src="https://s2.loli.net/2022/09/27/iIohujG3qXvKedk.png" alt="MVCC事务A分析.png"></p><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p><p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>当事务 A 读事务时，由于它的视图数组是 [99,100]。读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id=101，比自身数组的最大值大，不可见</li><li>找到 (1,2) 的时候，判断出 row trx_id=102，比自身数组的最大值大，不可见</li><li>找到 (1,1) 的时候，它的 row trx_id=90，比自身数组的最小值小，可见</li></ul><p>综上：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p><b>但是上述实际上只是查询数据时的逻辑，可以将上述分析结果代入事务B，会发现按这种规则代入，事务B中的k值应该为1，而不是2，问题出在事务B在查询之前执行了一次更新操作。</b></p><p>这是因为事务B要去更新数据时，就不能是历史版本上更新了，否则事务C的更新就丢失了，所以事务B此时的更新操作是在事务C的基础上操作的。</p><p><b>当前读：更新数据都是先读后写，这个读，只能读当前的值。</b></p><p>实际上除了<code>update</code>语句，<code>select</code>语句如果加锁，也是当前读。</p><blockquote><p>select k from t where id=1 lock in share mode;  // 读锁（S 锁，共享锁）</p><p>select k from t where id=1 for update; // 写锁（X 锁，排他锁）</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td></td><td>start transaction with consistent snapshot;<br>update t set k=k+1 where id = 1;</td></tr><tr><td></td><td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td><td></td></tr><tr><td>select k from t where id =1;<br/>commit;</td><td></td><td>commit</td></tr><tr><td></td><td>commit;</td><td></td></tr></tbody></table><p>如果事务C并不是马上提交，而是在事务B执行更新动作之后提交，这时在事务C在执行更新操作时，是获取了这行数据的行锁，事务C在更新之后，事务B的更新操作需要去获取行锁，但是被事务C锁住，故事务B进入等待，直到事务C提交事务后，事务B获取到锁继续往下执行。</p><p>综上：可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（三）—事务&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（三）—事务&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（三）—事务&quot;&gt;&lt;/a&gt;mysql45讲学习总结（三）—事务&lt;/h1&gt;&lt;p&gt;​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在&lt;code&gt;MySQL&lt;/code&gt;中，事务支持是在引擎层实现的。&lt;code&gt;MySQL&lt;/code&gt;是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如&lt;code&gt;MySQL&lt;/code&gt;原生的&lt;code&gt;MyISAM&lt;/code&gt;引擎就不支持事务，这也是&lt;code&gt;MyISAM&lt;/code&gt;被&lt;code&gt;InnoDB&lt;/code&gt;取代的重要原因之一。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（一）---初试</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/</id>
    <published>2022-09-21T14:13:58.000Z</published>
    <updated>2022-09-29T02:51:46.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（一）—初试"><a href="#mysql45讲学习总结（一）—初试" class="headerlink" title="mysql45讲学习总结（一）—初试"></a>mysql45讲学习总结（一）—初试</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    感觉自身对于<code>MYSQL</code>的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说<code>MYSQL</code>45讲对<code>MYSQL</code>介绍比较细致，所以希望通过学习<code>MYSQL</code>45讲让自己的<code>MYSQL</code>形成知识网络。<span id="more"></span></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>​    下方为<code>MYSQL</code>的基本架构示意图，一个执行语句在不查询缓存的情况下，基本查询路径为：客户端&rarr;连接器 &rarr;分析器&rarr;优化器&rarr;执行器&rarr;存储引擎。对应过程：</p><ol><li>连接：连接管理模块，接收请求；连接进行和用户模块，验证通过；连接线程和客户端连接。</li><li>查询：（查询缓存）<ol><li>分析器：内建解析树，对其语法检查，<code>form</code>&rarr;<code>on</code>&rarr;<code>join</code>&rarr;<code>where</code>，检查权限，生成新的解析树，语义检查。</li><li>优化器：将解析树转换为执行计划，选择索引，并评估最优执行。</li><li>执行器：获取锁，打开表，通过<code>meta</code>数据，获取查询数据。</li></ol></li><li>返回结果：返回给连接进程，然后情况，等待新的请求。</li></ol><p><img src="https://s2.loli.net/2022/09/21/tsHEepgh6AIGyJZ.webp" alt="MySQL 的逻辑架构图.png"></p><p>总体来说<code>MYSQL</code>基本架构分为两个部分：</p><h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1.Server层"></a>1.Server层</h3><p><code>Server</code>层包含了很多执行组件，涵盖了<code>MYSQL</code>的大多数核心业务功能，以及所有的内置函数（聚合函数的处理），所有跨存储引擎的功能都是在这一层实现，比如存储过程、触发器、视图等。从图中可以看出所有存储引擎共用同一个<code>Server</code>层。</p><h4 id="1-1连接器"><a href="#1-1连接器" class="headerlink" title="1.1连接器"></a>1.1连接器</h4><p>当使用以下连接命令之后，连接器通过<code>TCP</code>与客户端建立连接、获取权限、维持和管理连接。</p><blockquote><p>mysql -h$ip -P$port -u$user -p</p></blockquote><p>通过以下命令可以查看每个连接的状态</p><blockquote><p>show processlist;</p></blockquote><table><thead><tr><th>Id</th><th>User</th><th>Host</th><th>db</th><th>Command</th><th>Time</th><th>State</th><th>Info</th></tr></thead><tbody><tr><td>5</td><td>root</td><td>172.17.0.1:40922</td><td>binlog_test</td><td>Query</td><td>0</td><td></td><td>show processlist</td></tr><tr><td>6</td><td>root</td><td>172.17.0.1:40926</td><td>binlog_test</td><td>Sleep</td><td>1237</td><td></td><td></td></tr></tbody></table><p><code>Command</code>列中存在一个<code>Sleep</code>，表示有一个连接处于空闲状态。</p><h4 id="1-2分析器"><a href="#1-2分析器" class="headerlink" title="1.2分析器"></a>1.2分析器</h4><p>分析器的主要作用是对接收到的<code>SQL</code>语句进行解析。</p><p>首先进行”词法分析“：识别收到的<code>SQL</code>语句中代表的是什么、识别出列<code>ID</code>，查询条件等。</p><p>其次进行”语法分析“：进行语法规则的校验，判断输入<code>SQL</code>是否满足<code>MYSQL</code>语法，若语法错误则会抛出<code>You have an error in your SQL syntax</code>。</p><h4 id="1-3查询缓存"><a href="#1-3查询缓存" class="headerlink" title="1.3查询缓存"></a>1.3查询缓存</h4><p>​    接收到的<code>SQL</code>在进入到分析器之前，会先进入到查询缓存组件，判断之前是否执行过该语句，如果执行过直接返回结果，若没有执行过则进入分析器。但是大多数的情况下，由于缓存失效的非常频繁，只要对一个表存在更新操作，这个表所对应的所有缓存都失效，导致对缓存的命中率比较低。</p><blockquote><p>query_cache_type设置为DEMAND表示开启，NO表示关闭</p></blockquote><p>或者也可以通过<code>SQL</code>中关键字<code>SQL_CACHE</code>指定：</p><blockquote><p>select SQL_CACHE * from T where ID=10；</p></blockquote><p>同时在<code>MYSQL  8.0</code>版本中移除了缓存模块。</p><h4 id="1-4优化器"><a href="#1-4优化器" class="headerlink" title="1.4优化器"></a>1.4优化器</h4><p>​    优化器接收到了经过了分析器的<code>SQL</code>，优化器的主要作用是对<code>SQL</code>进行优化、多表连接顺序、多索引时选择使用哪个索引等。同一个<code>SQL</code>语句，不同的连接顺序、索引选择虽然查询结果一致，但是执行效率上存在差异。</p><p>​    优化器的作用便是在同样查询结果的情况下，对<code>SQL</code>语句进行优化，尽可能提升语句的查询效率，但是也有可能经过优化器处理之后，反而导致执行时长变长。</p><h4 id="1-5执行器"><a href="#1-5执行器" class="headerlink" title="1.5执行器"></a>1.5执行器</h4><p>​    优化器执行之后，<code>SQL</code>语句的执行方案就确定下来，然后进入执行器，在开始执行之前，需判断登录用户对操作表有没有执行查询的权限，若没有权限则报错：</p><blockquote><p>ERROR 1142 (42000): SELECT command denied to user ‘b’@’localhost’ for table ‘T’</p></blockquote><p>比如查询语句为：</p><blockquote><p>select * from T where ID=10;</p></blockquote><p>表 <code>T</code> 中，<code>ID</code> 字段没有索引，在执行器中的执行流程为：</p><ol><li>调用<code>InnoDB</code>引擎接口取这个表的第一行，判断<code>ID</code>值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>如果<code>ID</code>字段存在索引，只是在第1步骤中使用的调用存储引擎的接口不一致。</p><p>在慢查询日志中会有一个<code>rows_examined</code>的字段，表示这个语句在执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟<code>rows_examined</code>并不是完全相同的。</p><h3 id="2-存储引擎层"><a href="#2-存储引擎层" class="headerlink" title="2.存储引擎层"></a>2.存储引擎层</h3><p>存储引擎层负责数据的存储和提取。其架构模式是插件式，支持<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>。默认情况下使用<code>InnoDB</code>，也就是说通过<code>create Table</code>创建表时，若没有明确指定存储情况，默认就会使用<code>InnoDB</code>。</p><ul><li>InnoDB：事务型数据库的首选存储引擎，支持书屋安全表<code>ACID</code>，支持行锁和外键，<code>InnoDB</code>是<code>MYSQL</code>的默认存储引擎。</li><li>MyISAM：基于<code>ISAM</code>存储引擎，并对其进行扩展，它是在<code>Web</code>、数据仓储和其他应用环境下最常使用的存储引擎之一，拥有较高的插入和查询速度，但不支持事务。</li><li>Memory：内存数据库，将表中的数据存储到内存中。</li></ul><h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><p>​    更新语句和查询语句在执行器之前经过的<code>Server</code>层组件是一样的(唯一不同的是更新语句会移除所操作表的查询缓存)。与查询流程不一样的是，更新流程还涉及到两个重要的日志模块<code>redo log</code>(重做日志)，<code>binlog</code>(归档日志)。</p><h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><p>​    在<code>MYSQL</code>45讲中，使用《孔乙己》中酒店掌柜的例子，粉板和账本指代<code>redo log</code>和磁盘。当有一个更新操作时先将记录写入到<code>redo log</code>中，并不是执行写入磁盘(这么做的话<code>IO</code>成本、查找成本太高)。而是在适当的时机将<code>redo log</code>的内容写入到磁盘中。</p><p>​    通过<code>redo log</code>和磁盘结合的方式进行数据记录，这个整合的过程，就是<code>MYSQL</code>的<code>WAL(Write-Ahead Logging)</code>技术，它的关键点就是先写日志，再写磁盘。</p><h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><p>​    <code>redo log</code>是<code>InnoDB</code>引擎特有的日志，<code>bin log</code>是<code>Server</code>层日志。</p><p>这两种日志的不同点：</p><ul><li><code>redo log</code>是<code>InnoDB</code>引擎特有的；<code>bin log</code>是<code>Server</code>层实现，所有存储引擎都可以使用。</li><li><code>redo log</code>记录的是物理日志，记录的是”在某一个数据页上做了什么修改“，<code>bin log</code>是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c 字段加 1 “。</li><li><code>redo log</code>是循环写，空间是固定(粉板)，当写满之后会覆盖掉以前的日志；<code>bin log</code>是可以追加写，当文件写入到一定大小后会根据规则生成新的日志文件，不会覆盖旧日志。</li></ul><blockquote><p>create table T(ID int primary key, c int);</p><p>update T set c=c+1 where ID=2;</p></blockquote><p><strong>两阶段提交的简单流程</strong></p><ol><li>执行器先通过存储引擎接口获取到<code>ID=2</code>这一行记录，如果<code>ID=2</code>这行记录的数据页在内存中，则直接从内存中获取后返回给执行器。否则需要先将磁盘中这一页数据加载到内存中，再返回。</li><li>执行器得到这一行数据后，对<code>c</code>列执行<code>+1</code>操作，再调用存储引擎接口，将结果写入到这行新数据中。</li><li>存储引擎将这行数据更新到内存中，之后将这个更新操作写入到<code>redo log</code>中，并标记状态为<code>prepare</code>，然后告知执行器可以进行提交<code>commit</code>操作。</li><li>执行器生成这个操作的<code>bin log</code>，并将<code>bin log</code>刷盘。</li><li>执行器调用存储引擎的提交事务接口，存储引擎将刚刚的<code>redo log</code>由<code>perpare</code>修改为<code>commit</code>状态。</li></ol><p>先说这样做的好处：实际上引入<code>redo log</code>的作用是希望<code>MYSQL</code>具备<code>crash-safe</code>(指服务器宕机重启后，能够保证已提交的事务仍然存在)。</p><p>若服务器宕机出现在以上的某个流程中：</p><ul><li>在第3步骤写入<code>redo log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是不完整的，直接回滚事务。</li><li>在第4步骤写入<code>bin log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是完整的，直接提交事务。</li><li>在第5步骤修改<code>redo log</code>状态为<code>commit</code>状态，显然直接提交这个事务。</li></ul><p><strong>若不使用两阶段提交：</strong></p><p>假设两个前提：</p><ul><li>数据在一定周期内进行全量备份，可以是一天一备，也可以是一周一备。</li><li>开启<code>bin log</code>。</li></ul><p>在这种情况下数据恢复到某一时间点的操作为：</p><ol><li>找到最近一次的全量备份，将这个备份恢复到临时库中。</li><li>从备份的时间点开始，将备份时间点之后的的<code>bin log</code>依次取出，在临时库进行重放到需要恢复的这一时刻。</li><li>这时在临时库就有被误删的数据，简单处理可以手动将数据从临时表取出，按需恢复到线上库。</li></ol><p>由于存在两个日志文件，所以就需要保证两个日志文件在<code>MYSQL</code>发生异常时，数据能保持一致。</p><ol><li>**先写<code>binlog</code>后写<code>redo log</code>**：假设在<code>binlog</code>写完之后，<code>MYSQL</code>发生异常，由于<code>redo log</code>还没有写，导致<code>MYSQL</code>重启后<code>binlog</code>存在某一个操作，而<code>redo log</code>中没有这一操作，若从库使用<code>binlog</code>重放，则导致从库会有这一操作，从而导致主从数据不一致。</li><li>**先写<code>redo log</code>再写<code>binlog</code>**：假设在<code>redo log</code>写完之后，<code>MYSQL</code>发生异常，由于<code>binlog</code>还没写，导致重启之后，通过<code>redo log</code>进行数据恢复，所以主库中是存在这一操作，但是由于<code>binlog</code>中没有写入，所以导致使用<code>binlog</code>重放时，从库丢失一个操作。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    <code>redo log</code>的主要作用是利用”粉板”和”账本”的配合，提高<code>MYSQL</code>的吞吐性能，降低<code>IO</code>成本、查找成本。<code>bin log</code>是<code>Server</code>层日志，它存在于<code>redo log</code>之前，<code>redo log</code>是在<code>InnoDB</code>存储引擎诞生时，由<code>innoDB</code>引擎自身携带，其他存储引擎是没有的。还有<code>redo log</code>是对一个日志文件进行循环写，到一定数据量之后会覆盖旧值，不持久保存，<code>binlog</code>才具备”归档“的能力。</p><p>故障恢复是使用<code>redo log</code>日志进行恢复。主从同步是使用<code>binlog</code>进行数据同步。</p><ul><li><code>innodb_flush_log_at_trx_commit</code>：设置为1时表示，表示每次事务的<code>redo log</code>都直接持久化到磁盘。建议设置为1，保证<code>MySQL</code>异常重启之后数据不丢失。</li><li><code>sync_binlog</code>：设置成1的时候，表示每次事务的<code>binlog</code>都持久化到磁盘。建议设置成1，这样可以保证 <code>MySQL</code>异常重启之后<code>binlog</code>不丢失。</li></ul><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（一）—初试&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（一）—初试&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（一）—初试&quot;&gt;&lt;/a&gt;mysql45讲学习总结（一）—初试&lt;/h1&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​    感觉自身对于&lt;code&gt;MYSQL&lt;/code&gt;的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说&lt;code&gt;MYSQL&lt;/code&gt;45讲对&lt;code&gt;MYSQL&lt;/code&gt;介绍比较细致，所以希望通过学习&lt;code&gt;MYSQL&lt;/code&gt;45讲让自己的&lt;code&gt;MYSQL&lt;/code&gt;形成知识网络。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（二）---索引</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/</id>
    <published>2022-09-21T14:13:58.000Z</published>
    <updated>2022-10-17T03:47:17.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（二）—索引"><a href="#mysql45讲学习总结（二）—索引" class="headerlink" title="mysql45讲学习总结（二）—索引"></a>mysql45讲学习总结（二）—索引</h1><p>​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><span id="more"></span><h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>​    索引实际上就像是字典的目录，当需要查询某个字时，通过目录可以快速定位到某一页，从而快速查找到所需要的数据，不必进行全局遍历，达到提高查询效率的目的，实现上一般都是通过设计某种的数据结构，简单介绍几个常用的数据结构。</p><ol><li>哈希表：一种以键值对存储数据的数据结构，类似于<code>Java</code>中的<code>HashMap</code>的实现（当然了<code>jdk8</code>之后是采用数组加红黑树的方式），数据结构为一个数组加链表（有的地方称拉链法），当添加某个值时计算出这个值的<code>HASH</code>值，然后插入到数组对应的链表尾部，这种数据结构对于添加和删除的效率是比较高的，只需要移动一个节点的引用。</li><li>有序数组（规则数组）：通过某种规则将数据存入到数组中，在查询时同样可以根据这种规则直接通过下标获取到数据，如果是有序数组，对于范围查询的效率也是比较高的。这种数据结构瓶颈在于扩容以及空间的使用率上，比如现在是有序数组，数组长度为10，假设现在仅有两个值1和50，那么50的这个值存放在哪个位置？如果将数组长度扩大50，空间利用率就极低。</li><li>二叉树：二叉树是课本中经典的数据结构了，同样在添加、删除节点时，需要进行平衡。</li></ol><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>​    <code>InnoDB</code>引擎中采用<code>B+</code>数索引模型，每一个索引都对应着一颗<code>B+</code>树。分为主键索引和非主键索引。</p><p>​    主键索引又称为聚簇索引，主键索引的叶子节点是整行数据。</p><p><img src="https://s2.loli.net/2022/07/29/Cdn3PoHR5vbi8Iy.png" alt="主键索引示意图.png"></p><p>​        非主键索引又称为二级索引，非主键索引的叶子节点的内容是主键的值。由下图可知，非主键索引的查询逻辑是通过非主键索引获取到要查询数据的主键，再通过主键索引获取到对应行数据，这个过程称为回表。</p><p><img src="https://s2.loli.net/2022/07/29/nI3Ay1ZM4bpQRs8.png" alt="非主键索引示意图.png"></p><h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><p>​    在<code>InnoDB</code>存储引擎中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。<code>InnoDB</code>使用的索引模型为<code>B+</code>树形索引模型，所以数据都是存储在<code>B+</code>树中。</p><p>每一个索引在<code>InnoDB</code>里面都对应着一颗<code>B+</code>树。</p><p>假设有一个表，<code>ID</code>为主键，且还有字段<code>k,name</code>，同时<code>k</code>字段上有索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表中有5条记录：(ID,K)&rarr; (100,1)、(200,2)、(300,3)、(500,5) 、 (600,6)</p><p>主键索引树和<code>k</code>字段索引树如下：(图中主键索引显示为[100, 200]在一页，[300, 500, 600]在一页)</p><p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p><p>由上图可知：</p><p>索引类型分为主键索引(聚簇索引)和非主键(二级索引)索引。</p><ul><li>主键索引的叶子节点存储的是一整行的记录。</li><li>非主键索引的叶子节点存储的是主键ID。</li></ul><p>某个查询语句使用主键索引和非主键索引的差别在于，非主键索引查询到树节点之后得到叶子节点上的主键<code>ID</code>之后，需要再通过主键索引树再查找一轮，得到主键<code>ID</code>对应的行数据，这个过程称为回表。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>​    根据第一小节中的常见的索引模型可知，索引之所以查询速度高，实际上是依赖于索引模型，也就是说在插入数据时，就需要根据索引模型相应的规则进行数据的存储。所以虽然添加索引的查询效率高，但索引的数量并不是越多越好，过多的索引会增加插入数据带来的成本。</p><p>以上方索引树的图为例：</p><ul><li>如果插入的新行<code>ID</code>值为700，则只需要在R5的记录后面插入一条新记录。</li><li>如果插入的新行<code>ID</code>值为400，则需要将500和600往后挪，空出位置。如果R5所在的数据页满了，则需要申请一个新的数据页，然后将部分数据挪过去，这个过程称为页分裂。</li><li>如果相邻两页数据由于删除了数据，导致利用率比较低，那么就会出现合并页，这个过程是页分裂的逆过程。</li></ul><h1 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h1><p>还是这个表为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"># 同时插入6条记录</span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p><p>执行查询语句：</p><blockquote><p>select * from T where k between 3 and 5</p></blockquote><p>执行流程：</p><ol><li>到非主键索引<code>k</code>上搜索<code>k=3</code>的树节点，得到主键<code>ID=100</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R3</code>。</li><li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=5</code>这个树节点，得到主键<code>ID=500</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R4</code>。</li><li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=6</code>这个树节点，不满足<code>where</code>条件，循环结束。</li></ol><p>在步骤1和步骤2都有回表的动作，这是因为需要查询的字段在非主键索引<code>k</code>上没有，那么有没有办法避免回表？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果将执行语句修改为：</p><blockquote><p>select ID from T where k between 3 and 5</p></blockquote><p>由于这时需要查询的字段<code>ID</code>，就是非主键索引<code>k</code>的叶子节点上能获取到的数据，所以就不需要进行回表的操作，也就达到了减少一次回表查询的动作，从而提升查询效率。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>所以为了不进行回表，就需要在数节点上存储的数据做文章，就需要通过联合索引。这里的<code>name_age</code>就是联合索引。</p><p>假设一个市民信息表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure><p>如果这时需要用市民的名称查询他的年龄：</p><blockquote><p>select age from tuser where name = “xxx”</p></blockquote><p>如果使用<code>name_age</code>索引，就不需要进行一次回表就可以查出想要的某个名称对应的年龄，当然了这里会出现多条记录的情况。</p><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>如果将这条查询语句换个查询条件，能否使用这个联合索引呢？</p><blockquote><p>select name from tuser where age = xx</p></blockquote><p><img src="https://s2.loli.net/2022/09/22/uneZG4Os8JbfMRS.jpg" alt="联合索引.jpeg"></p><p>由上图可以看出，联合索引是根据联合索引定义时字段的先后顺序进行排序，也就是这里先根据<code>name</code>排序，再根据<code>age</code>排序。</p><ul><li>当需求为查询所有名字为”张三“的人，可以快速定位到ID4，然后逐个遍历节点与<code>where</code>条件进行比对。</li><li>当需求为查询所有名字第一个字为”张”，查询语句为<code>where name like &#39;张%&#39;</code>，也会命中这个索引，查询到第一个符合条件的节点为ID3，然后逐个遍历节点与<code>where</code>条件进行比对。</li><li>当需求为查询年龄为20的人，就无法使用这个索引。对这个索引来说，是先对<code>name</code>进行排序，在<code>name</code>一致的情况下，对<code>age</code>排序。</li></ul><p>综上：查询条件中不一定要全部定义，只要满足最左前缀，就可以利用这个索引来加速检索。这个最左前缀可以是联合索引的最左<code>N</code>个字段，也可以是字符串索引的最左<code>M</code>个字符。</p><p><b>在建立联合索引的时候，如何安排索引内的字段顺序。</b></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<b>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</b></p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>如果查询语句的查询条件部分满足最左前缀原则呢？</p><p>以市民表的联合索引<code>(name, age)</code>为例</p><blockquote><p>select * from tuser where name like ‘张 %’ and age=10 and ismale=1;</p></blockquote><p>根据最左前缀的规则，这个语句在搜索树时，只能用到”张”，找到第一个满足条件的记录X，然后根据其他判断条件进行判断，就算只有这样，也是要比全表扫描效率高。</p><p>在<code>MYSQL5.6</code>之前，只能从记录X开始一个个回表，到主键索引上找出记录行，在对比字段值。</p><p>在<code>MYSQL5.6</code>之后，引入索引下推优化，可以在所有遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>无索引下推执行过程如下图所示：不会获取联合索引中<code>age</code>的值，在匹配”张“之后，逐个往后遍历，并进行回表取出对应行数据进行查询条件的判断。</p><p><img src="https://s2.loli.net/2022/09/22/Ik84FoZC3MHlWPV.jpg" alt="无索引下推.jpeg"></p><p>采用索引下推的执行过程如下图所示：在匹配”张“之后，会获取<code>age</code>的值与查询条件进行匹配，如果不匹配直接获取下一个节点。所以这里的年龄等于30和20的数据，获取到之后不会进行回表操作。</p><p><img src="https://s2.loli.net/2022/09/22/OzSdyGrlAkwEhUC.jpg" alt="有索引下推.jpeg"></p><h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>重建非主键索引：</p><blockquote><p>alter table T drop index k;</p><p>alter table T add index(k);</p></blockquote><p>重建主键索引：</p><blockquote><p>alter table T drop primary key;</p><p>alter table T add primary key(id);</p></blockquote><p>重建非主键索引的做法是合理的，可以达到省空间的目的；但是重建主键索引的过程是不合理的，不论是删除主键还是创建主键，都会将整个表重建，所以第一个语句其实可有可无，单纯执行第二个语句就会对表进行重建。再者可以使用<code>alter table T engine=InnoDB</code>对表进行重建。</p><p><b>表数据删除一半，表文件大小不变？</b></p><p>​    <code>InnoDB</code>表包含两个部分，表结构定义和数据。在<code>MYSQL8.0</code>之前，表结构是存储在以<code>.frm</code>为后缀的文件里。而<code>MYSQL8.0</code>则已经允许将把表结构定义放在系统数据表，实际上表结构定义占用的空间很小，所以占用空间的主要部分就是表数据。</p><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的：</p><ol><li>这个参数设置为<code>OFF</code>表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为<code>ON</code>表示的是，每个<code>InnoDB</code>表数据存储在一个以<code>.ibd</code>为后缀的文件中。</li></ol><p>从<code>MySQL 5.6.6</code>版本开始，它的默认值就是<code>ON</code>。一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>在<code>InnoDB</code>中，数据都是以<code>B+</code>树模型且按页存储，前面也有说到，在进行查询数据时，<code>MYSQL</code>是将数据的某一页或者某几页加载到内存中。假设要删除<code>A</code>页的<code>R4</code>这条记录，这里只会将这个空间标记为复用，但是占用的空间并没有减少，如果之后又在300~600间插入一条数据，那么会复用这个空间，所以有时候删除记录并不会减少表占用空间。</p><p><img src="https://s2.loli.net/2022/09/23/ARtpzfZ5Dg7G1O6.png" alt="索引数据页结构.png"></p><p>​    当然了，如果将300-600的数据行都删除，那么这整个<code>A</code>数据页就被标记复用，对应数据页的复用，比行的复用稍微灵活，比如上述中将500对应行删除之后，只能在插入300-600之间的数据可以复用这个空间，但是如果整个数据页被标记复用，这个时候如果需要使用新页，这个标记删除的数据页就可以被复用。如果相邻两个数据页的利用率比较低，<code>MYSQL</code>也会将这两个页的数据合并到一个页，将另一个页标记为复用。</p><p>​    所以如果使用<code>delete</code>删除整个表，结果就是这个表的所有数据页被标记为复用，但是占用的磁盘空间并不会减少；但是若使用<code>truncate</code>命令，相当于使用了<code>drop</code>和<code>create</code>命令的结合，单纯从这一方面看，<code>truncate</code>在删除整个表数据时会减少空间。(但是<code>truncate</code>不能加<code>where</code>条件，动作上是先删除表<code>drop</code>再<code>create</code>表，所以它是<code>DDL</code>命令)。</p><p>​    这里将这些标记为复用的空间称为”空洞“。新增、删除、修改(比如将300修改为800，则操作上是将300对应行标记复用，在插入800对应行)数据都会存在生成新的空洞的情况，比如新增一条数据，导致某个页进行了页分裂，但是由于页空间没有填满，造成了较大的空洞，如果空洞比较多，产生的现象就是删除部分数据，并不会导致磁盘空间的减少。所以如果在删除数据之后能将这些空洞去掉，就可以减少占用磁盘空间。</p><h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>​    假设已经存在了一个较多空洞的表<code>A</code>，可以通过创建一个同样的表<code>B</code>，按照主键递增的顺序将数据从<code>A</code>表中读出，再写入到表<code>B</code>中，由于表<code>B</code>是新建表，所以表<code>A</code>主键索引上的空洞在表<code>B</code>是不存在的。这时用表<code>B</code>替换表<code>A</code>，从结果上来看，起到了收缩表<code>A</code>的目的。</p><p>​    在<code>MYSQL</code>中已经存在这个命令，通过使用<code>alter table A engine=InnoDB</code>来重建表。实际上流程就是上述流程，只不过<code>MYSQL</code>将这些操作内置，你只需要通过这一个命令即可。</p><p>​    当然了，这个过程中最消耗资源的过程，就是将表<code>A</code>数据拷贝到表<code>B</code>的过程。但是在这个过程中，如果出现新数据需要写入到表<code>A</code>中，就有可能造成数据丢失，所以在这个过程中表<code>A</code>不能有更新。</p><p>在<code>MYSQL5.6</code>版本开始引入<code>Online DDL</code>，对这个操作流程进行优化。也就是在拷贝的过程中，通过记录一个<code>row log</code>，拷贝完成之后，将<code>row log</code>的操作应用到表<code>B</code>。由于这个优化之后，在表重建过程中，允许对表<code>A</code>做写操作，所以称为<code>Online DDL</code>。</p><p>​    这个<code>DDL</code>在<code>alter</code>启动的时候就获取了<code>DML</code>写锁，但是在真正拷贝数据时，就退化为读锁，这样是为了实现<code>Online</code>，<code>MDL</code>读锁不会阻塞写操作，至于为什么不直接释放锁，是因为要禁止其他线程同时做<code>DDL</code>。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件，对于大表来说，这个操作是很消耗<code>IO</code>和<code>CPU</code>资源，所以可以通过一些比较稳定的开源组件操作，比如<code>GitHub</code>开源的<code>gh-ost</code>。</p><p>据说100万行数据以下，可以使用<code>online ddl</code>超过百万可以使用<code>gh-ost</code></p><p>关于重建表的三个命令：</p><ul><li><code>alter table t engine = InnoDB</code>：在5.6版本之后，默认就是<code>Online DDL</code>的方式。</li><li><code>analyze table t</code>：这个命令实际上不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程加了<code>MDL</code>读锁。</li><li><code>optimize table t</code>：这个命令等于<code>recreate</code>+<code>analyze</code></li></ul><h1 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h1><p>使用唯一索引还是普通索引？这是分为查询过程和更新过程来分析两种索引之间的性能差别</p><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><blockquote><p>select id from T where k=5</p></blockquote><p>这个查询语句在索引树上查找的过程：先从<code>B+</code>树根开始按层搜索叶子节点。</p><ul><li>普通索引：查找到满足条件的第一个记录(5, 500)后，需要查找下一个记录，知道碰到第一个不满足的<code>k=5</code>条件的记录。</li><li>唯一索引：查找到满足条件的第一个记录(5, 500)后，由于唯一索引的特性，直接停止检索。</li></ul><p>所以对于查询语句来说，两种索引的性能差别几乎没有差别，由于<code>MYSQL</code>是按页读写数据，所以当找到<code>k=5</code>的记录时，它所在的数据页都在内存里，那么对于普通索引来说仅比唯一索引多做了一个判断而已，所以几乎忽略不计。</p><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><blockquote><p>change buffer：当需要更新一个数据页时，如果这个数据页在内存中，则直接更新这个数据页；如果这个数据页不在内存中，在不影响数据一致性的情况下，InnoDB会将这些更新动作缓存在 change buffer 中，这样就不需要从磁盘中读出这个数据页，当下次查询出这个数据页时，将数据页读入到内存中，然后先执行 change buffer 中与这个页相关的动作之后，再返回。(虽然这块缓存的名称叫 change buffer 实际上它是可以持久化数据，也就是说 change buffer 的数据也会被写入磁盘中。)</p><p>将 change buffer 的动作应用到操作页，得到最新的数据结果的过程称为 merge。除了访问数据页之外，后台会用定时线程会触发 merge、数据库正常关闭也会触发 merge。</p></blockquote><p>实际上唯一索引并不会用到 change buffer。这是因为唯一索引在更新时，需进行唯一性约束。而这个判断就使得必须将数据页读入内存才能判断，所以如果都已经将数据读入到内存中，那么直接更新内存中的值即可。</p><p>如果要插入一个新记录（4, 400）：</p><p>第一种情况，这个记录要更新的数据行在内存中。</p><ul><li>唯一索引：找到3到5之间的位置，判断到没有冲突，插入新记录。</li><li>普通索引：找到3到5之间的位置，插入新记录。</li></ul><p>普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>第二种情况，这个记录要更新的数据行不在内存中。</p><ul><li>唯一索引：需要将数据页读到内存中，判断没有冲突，插入新记录</li><li>普通索引：将动作插入到 change buffer。</li></ul><p>将数据从磁盘读入到内存中涉及随机IO的访问，是数据库里成本最高的操作之一。change buffer 减少了随机磁盘访问，所以对更新性能是很明显。</p><h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><p>​    在<code>MySQL</code>中一张表是可以创建多个索引，但是具体的<code>SQL</code>语句使用哪个索引来进行查询，是由<code>MySQL</code>来确定，有没有可能<code>MySQL</code>选到的索引不是最优解。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 创建<span class="number">10</span>w条数据: 从(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)，(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)，(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)直到(<span class="number">100000</span>,<span class="number">100000</span>,<span class="number">100000</span>)</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>现在来看一条<code>SQL</code>查询语句：</p><blockquote><p>select * from t where a between 10000 and 20000;</p></blockquote><p>这样查询语句会使用索引<code>a</code>来提高查询效率，用<code>explain</code>命令结果：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td>range</td><td>a</td><td>a</td><td>5</td><td></td><td>10000</td><td>Using where</td></tr></tbody></table><p>果然<code>key=a</code>表示使用了所以<code>a</code>，扫描了10000行数据。</p><p>再来：</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>Start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td>delete from t;<br>call idata();</td></tr><tr><td></td><td></td></tr><tr><td></td><td>explain select * from t where a between 10000 and 20000;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里表示<code>sessionA</code>开启一个事务后，<code>sessionB</code>把数据删了之后，再次调用写10w行数据的存储过程，再通过<code>explain</code>命令查询这条<code>SQL</code>语句的执行。</p><p>这时<code>sessionB</code>的查询语句就不会再选择索引<code>a</code>，但是如果这里使用<code>select * from t force index(a) where a between 10000 and 20000;</code>就会使用索引。</p><p>这个例子对应的就是我们平常不断的删除数据和新增数据的场景，在这种情况下<code>MySQL</code>可能会选错索引。</p><p>在<code>sessionB</code>中删除了所有数据，然后通过<code>call idata()</code>插入10w行数据，看上去这里重新插入了10w行数据，但是<code>sessionA</code>在<code>sessionB</code>删除之前就开启了事务且还没有提交，所以之前的10w行数据还不能删除，这就导致之前的每一行数据都有两个版本，旧版本是数据，新版本被标记<code>delete</code>。所以再重新插入10w行数据之后，索引<code>a</code>上就有两份10w行数据。</p><p>至于为什么会选错索引，实际上优化器在选择索引的时候，有很多判断维度：扫描行、是否使用临时表、是否排序等。这里主要是因为旧的10w行数据的存在，优化器认为需要扫描的行数比较多，索引没有命中索引。其实优化器在对扫描行的判断，是通过采样分析，也是一个预估的值。可以通过<code>analyze table t</code>来重新进行统计。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;geek&#96; (</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;d&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;a&#96;,&#96;b&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;),</span><br><span class="line">  KEY &#96;ca&#96; (&#96;c&#96;,&#96;a&#96;),</span><br><span class="line">  KEY &#96;cb&#96; (&#96;c&#96;,&#96;b&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表<code>geek</code>已经存在联合主键<code>(a, b)</code>，是不是只需要创建<code>(c)</code>索引包含了<code>(ca)</code>和<code>(cb)</code>的场景，为什么需要再创建<code>(ca)</code>和<code>(cb)</code>?</p><p>假设存在以下两条语句：</p><blockquote><p>select * from geek where c=N order by a limit 1;</p><p>select * from geek where c=N order by b limit 1;</p></blockquote><p>那么这时所有<code>ca</code>和索引<code>cb</code>有存在的必要吗？</p><p>假设表中记录为：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>d</td></tr><tr><td>1</td><td>3</td><td>2</td><td>d</td></tr><tr><td>1</td><td>4</td><td>3</td><td>d</td></tr><tr><td>2</td><td>1</td><td>3</td><td>d</td></tr><tr><td>2</td><td>2</td><td>2</td><td>d</td></tr><tr><td>2</td><td>3</td><td>4</td><td>d</td></tr></tbody></table><p>主键<code>a</code>和<code>b</code>的联合主键相当于对数据进行<code>order by a, b</code>。也就是先按<code>a</code>排序，再按<code>b</code>排序，<code>c</code>无序，这里没有使用到<code>d</code>。</p><p>索引<code>ca</code>的组织结果：逻辑上最后一列是<code>ab</code>的值，但是由于联合索引中已经存在了<code>a</code>，索引最后一列中只有<code>b</code>。<b>与索引<code>(c)</code>一致。</b></p><table><thead><tr><th>c</th><th>a</th><th>b(主键的b部分)</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>3</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>1</td><td>2</td></tr><tr><td>3</td><td>1</td><td>4</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>3</td></tr></tbody></table><p>索引<code>cb</code>的组织结果：同理，最后一列也只有<code>b</code>。</p><table><thead><tr><th>c</th><th>a</th><th>a(主键的a部分)</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>3</td><td>1</td></tr><tr><td>3</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>3</td><td>4</td><td>1</td></tr><tr><td>4</td><td>3</td><td>2</td></tr></tbody></table><p>综上：<code>ca</code>索引和<code>c</code>的数据组织结果一致，但<code>cb</code>不一致，若上述两条查询语句为高频语句，则<code>cb</code>可以保留。</p><h2 id="字符串添加索引"><a href="#字符串添加索引" class="headerlink" title="字符串添加索引"></a>字符串添加索引</h2><p>​    字符串字段存在一个问题，如果是热点字段使用比较频繁，在不加字段的情况下，就会出现一直全表扫描，那么如果为字符串字段添加索引？</p><p>如果你仅仅只想到直接为该字符串字段添加一个索引，那么只能说你只看到了问题的表面，因为为字符串字段添加索引需要考虑到这个字符串字段的长度问题，如果这个字符串长度比较长，那么这个索引需要占用的空间就会比较大。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是只取字段的部分长度作为索引：</p><blockquote><p>alter table SUser add index index2(email(6));</p></blockquote><p>设置<code>SUser</code>表的<code>email</code>字段的前6位作为索引。<br>假设表中有数据：</p><table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>xiaocainiaoya@foxmail</td></tr><tr><td>2</td><td>cainiao@foxmail</td></tr><tr><td>3</td><td>niao@foxmail</td></tr></tbody></table><p>那么如果根据<code>email</code>前六位来做为前缀索引就只需要匹配一次，回表一次后，将字段值与查询值再次匹配若匹配成功，则获取数据。<br>所以这种方式需要这个字段存储的值具备一定的规则，然后根据规则设置索引的长度，长度越长，区分度就越高，查询效率就越高，伴随着占用空间就越大。</p><p><b>注：前缀索引会破坏覆盖索引，如果仅查询索引上的字段，但是由于需要回表进行一次匹配（系统不知道这个字段值到底有没有被截断）。所以覆盖索引相关的优化可能就失效了。</b></p><h3 id="倒叙存储"><a href="#倒叙存储" class="headerlink" title="倒叙存储"></a>倒叙存储</h3><p>一些字段的规则比如身份证，身份证的前面6位表示地域位置，在查询时需要遍历的列就比较多，可以将身份证倒叙存储，也就是通过<code>reverse(idCard)</code>进行存储，再通过<code>index(idCard(6))</code>设置索引，减少遍历的行数。</p><h3 id="哈希字段"><a href="#哈希字段" class="headerlink" title="哈希字段"></a>哈希字段</h3><p>再设置一个哈希字段，比如创建身份证字段之后，再创建一个身份证的哈希字段，插入的时候计算身份证的哈希值填入，那么就可以为这个哈希字段添加索引，从而减少索引字段的长度，但是由于不同值经过哈希算法后可能会得到同一个值，所以存在一定的误差，在查询时还是要将身份证的原值加上。</p><blockquote><p>select field_list from t where id_card_crc=crc32(‘input_id_card_string’) and id_card=’input_id_card_string’</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>直接创建完整索引，这样可能比较占用空间；</p></li><li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p></li><li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p></li><li><p>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</p></li></ol><h2 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h2><p>如果在查询条件上添加聚合函数会导致索引失效，这是因为对索引字段进行聚合函数会破坏索引的有序性，导致优化器放弃走索引树的搜索功能，但是并不是说放弃了这个索引，因为如果遍历这个索引比遍历主键索引来的快，还是会使用这个索引，但是结果是使用了这个索引扫描的行也是全表的行数。</p><p>但是尽管有些聚合操作不破坏索引有序性，但是<code>MySQL</code>也不予支持，比如<code>where age + 1 = 1001</code>，不会改变索引的有序性，但是这时候也是扫描全表，要修改为<code>where age = 1001 - 1</code></p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>如果表中有一个<code>varchar</code>字段，但是查询语句是<code>where age = 10</code>，那么就涉及到类型的转换，<code>MySQL</code>采用的是字符串转换成数字的转换。也就是说<code>where age = 10</code>，需要将全表的数据都进行字符串转数字的转换，所以导致了索引失效。<br>如果换过来，表中有一个<code>int</code>字段，但是查询语句是<code>where age = &#39;10&#39;</code>,这个时候实际上是将这个<code>&#39;10&#39;</code>转为数字，在去表中匹配，这时就会命中索引。</p><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>假设有两个表有关联操作，但是关联字段的编码不一样，一个是<code>utf8mb4</code>，一个是<code>utf8</code>，因为<code>utf8mb4</code>是<code>utf8</code>的超集，在做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，是按“数据长度增加的方向”进行转换。</p><p>也就是说，实际上这个语句等同于下面这个写法: </p><blockquote><p>select * from trade_detail  where traideid USING utf8mb4 = $L2.tradeid.value;<br>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</p></blockquote><p>在这种情况下实际上就是需要判断谁是驱动表，谁是被驱动表，</p><blockquote><p>select * from trade_detail  where traideid = CONVERT($L2.tradeid.value USING utf8mb4);</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（二）—索引&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（二）—索引&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（二）—索引&quot;&gt;&lt;/a&gt;mysql45讲学习总结（二）—索引&lt;/h1&gt;&lt;p&gt;​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA插件开发</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2022-09-19T13:51:58.000Z</published>
    <updated>2022-09-22T01:47:29.721Z</updated>
    
    <content type="html"><![CDATA[<p>​    公司中提交<code>MYSQL</code>脚本有相应的规范，需要编写为<code>groovy</code>文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在<code>console</code>控制台上交互，使用上有点繁琐，偶然看到关于<code>IDEA</code>插件开发的博客，想着是否可以通过<code>IDEA</code>插件来写一个<code>UI</code>，生成逻辑直接使用原有代码移植过来。同时记录在开发<code>IntelliJ IDEA</code>插件过程中遇到的一些问题和踩到的一些坑。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>​    <code>IntelliJ IDEA</code>插件开发有两种方式，一种是直接引入<code>Plugin DevKit</code>，然后配置<code>IntelliJ Platform Plugin SDK</code>进行开发，另一种是使用<code>gradle</code>构建项目并引入<code>IDEA</code>插件开发包。使用<code>gradle</code>的好处是同时也可以引入一些其他的库进行使用。</p><p>​    在<code>IDEA 2021.3</code>以及之后的版本，开发需要使用<code>JDK 11</code>进行开发，在我开发的时候我本地也没有<code>JDK 11</code>(一台电脑可以支持多个版本的<code>JDK</code>，问题在于环境变量配置的是哪个版本而已。因为目前只有这里插件开发我才会用到<code>JDK 11</code>，所以没有将它添加到环境变量中，仅通过<code>IDEA</code>工具添加了<code>JDK</code>路径)。</p><p>​    我使用的是<code>gradle</code>的方式进行插件的开发。<code>gradle</code>导入之后，在<code>Libraries</code>下会有一个<code>com.jetbrains:ideaIC:2021.3</code>，这就是<code>IDEA</code>插件的开发包。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// IDEA的插件开发包</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;1.8.1&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// 设置阿里云maven仓库 </span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;cn.hutool:hutool-all:5.6.7&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.alibaba:fastjson:1.2.28&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-core:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-jul:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-slf4j-impl:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.25&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.9.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.9.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idea的使用版本</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    version = <span class="string">&#x27;2021.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">patchPluginXml &#123;</span><br><span class="line">    changeNotes = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Add change notes here.&lt;br&gt;</span></span><br><span class="line"><span class="string">      &lt;em&gt;most HTML tags may be used&lt;/em&gt;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gradle</code>中一些常用项：</p><p><code>intellij -&gt; runIde</code>：这时会新启动一个<code>IDEA</code>工具，可以进行调试插件。</p><p><code>intellij -&gt; buildPlugin</code>：构建插件，用来完成之后将代码打包成<code>.zip</code>。(路径为<code>build/distributions</code>)。</p><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p>点击<code>Help -&gt; Edit Custom Properties...</code>，添加以下配置后重启<code>IDEA</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">idea.is.internal</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>在<code>Tool</code>下会出现<code>Interal Actions</code>和<code>View PSI Structure...</code>按钮。</p><p><img src="https://s2.loli.net/2022/09/20/xouELJspl16qTnj.png" alt="ideaInternal.png"></p><p>参考面板：<code>Internal Actions -&gt; UI -&gt; Show Standard Panels</code>：会弹出一个<code>UI</code>面板，结合<code>UI Debug</code>就可以参考到对应的源码。</p><p><img src="https://s2.loli.net/2022/09/20/p46q5sldBj7Q3cn.png" alt="standPanel.png"></p><p>通过<code>Internal Actions -&gt;UI Debugger</code>可以监控在<code>IDEA</code>中鼠标操作对应的<code>Action</code>。比如创建一个类，在<code>UI Debugger</code>面板上可以看到一个<code>CreateClassAction</code>的类，就可以看到这个创建一个类的源码，如果功能类似甚至可以直接复用。</p><p>与<code>PSI</code>相关<code>API</code>目前占时没有使用，具体如果需要插件能实现在代码里根据某种规则生成内容，则就需要通过<code>PSI</code>相关内容进行处理。</p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idea-plugin</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">    └── main</span><br><span class="line">          └── resources</span><br><span class="line">          │     └── META-INF</span><br><span class="line">          │          └── plugin.xml</span><br><span class="line">          └── java</span><br><span class="line">              └── cn<span class="selector-class">.com</span>.xiaocainiao</span><br><span class="line">                       └── MyWindowFactory<span class="selector-class">.java</span>  </span><br></pre></td></tr></table></figure><h2 id="plugin-xml配置"><a href="#plugin-xml配置" class="headerlink" title="plugin.xml配置"></a>plugin.xml配置</h2><p>我使用的是<code>ToolWindowFactory</code>创建右侧窗体。若是创建<code>Action</code>，可以直接通过<code>New -&gt; Plugin DevKit -&gt; Action</code>进行创建，通过这种方式创建，会自动在<code>plugin.xml</code>文件中添加<code>&lt;action&gt;</code>的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>org.example.SecondIdeaPlugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SecondIdeaPlugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;xiaocainiaoya@foxmail.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://xxx.com&quot;</span>&gt;</span>bosssoft<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">        For simple and quick generation of SQL script files&lt;br&gt;</span><br><span class="line">        &lt;em&gt;Tools that are easy to use&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- please see https://plugins.jetbrains.com/docs/intellij/plugin-compatibility.html</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">toolWindow</span> <span class="attr">id</span>=<span class="string">&quot;generatorSQL&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">secondary</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">anchor</span>=<span class="string">&quot;right&quot;</span> <span class="attr">factoryClass</span>=<span class="string">&quot;cn.com.xiaocainiaoya.MyWindowFactory&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">toolWindow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>​    由于<code>IDEA</code>插件的<code>UI</code>采用的是<code>Swing</code>、<code>Awt</code>来进行窗体开发，当知道使用的是<code>Swing</code>一度想要放弃掉，确实是使用<code>Swing</code>是一件比较痛苦的事情。后借助于<code>IDEA</code>的<code>Swing UI Designer</code>功能通过拖拽简单组件的方式，硬着头皮画出了<code>UI</code>界面。</p><p><img src="https://s2.loli.net/2022/09/19/sTRPS3cQYnVABFD.png" alt="ideaSwing.png"></p><h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><h2 id="1-路径"><a href="#1-路径" class="headerlink" title="1.路径"></a>1.路径</h2><p>​    可能由于项目有别于常用的<code>java</code>项目、<code>spring</code>项目，所以在获取资源文件(<code>/resources/**</code>)时，总是感觉摸不着头脑。参考了一些其他博主写的<code>IDEA</code>插件项目，获取资源文件的方式，与<code>java</code>项目、<code>Spring</code>项目并无差别，但是我在获取资源文件时，一直提交获取不到资源文件，也有可能是<code>velocity</code>组件的问题。</p><p>​    原本使用<code>velocity</code>模板引擎来加载对应模板文件，但是一直报错获取不到对应资源文件之后，将这种动作修改为代码层获取到资源文件内容，在将模板内容提交给<code>velocity</code>模板引擎。</p><p>注：<code>velocity</code>组件和<code>groovy</code>库相关包在<code>com.jetbrains:ideaIC:20201.3</code>中已经存在，所以不能由自身再引入。</p><p>在调试开发过程中，<code>velocity</code>正常使用，但是打包成插件之后，通过插件的方式运行，一直报一个日志相关的异常。</p><p>添加<code>velocity.proerties</code>配置文件相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">runtime.log.logsystem.class</span>=<span class="string">org.apache.velocity.runtime.log.SimpleLog4JLogSystem</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.category</span>=<span class="string">velocity</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.logger</span>=<span class="string">velocity</span></span><br></pre></td></tr></table></figure><p>因为在调试过程的运行和实际插件方式运行是对应的相对路径是不一致的，所以在使用系统级有关的相对路径是需通过使用<code>com.intellij.openapi.application.PathManager</code>类来获取对应的路径：</p><p>比如使用<code>PathManager.getBinPath()</code>：</p><p>在调试运行获取到的路劲为：<code>/usr/local/Cellar/gradle/7.3.1/caches/modules-2/files-2.1/com.jetbrains.intellij.idea/ideaIC/2021.3/75777e10a0e2880bc02945066dda2480a696c3d9/ideaIC-2021.3/bin</code></p><p>在实际插件方式允许获取的路径为：<code>/Applications/IntelliJ IDEA.app/Contents/bin</code></p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://zhuanlan.zhihu.com/p/400059601" target="_blank">IntelliJ IDEA 插件开发指南</a></p><p><a href="https://plugins.jetbrains.com/docs/intellij/welcome.html" target="_blank">插件入门官网</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    公司中提交&lt;code&gt;MYSQL&lt;/code&gt;脚本有相应的规范，需要编写为&lt;code&gt;groovy&lt;/code&gt;文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在&lt;code&gt;console&lt;/code&gt;控制台上交互，使用上有点繁琐，偶然看到关于&lt;code&gt;IDEA&lt;/code&gt;插件开发的博客，想着是否可以通过&lt;code&gt;IDEA&lt;/code&gt;插件来写一个&lt;code&gt;UI&lt;/code&gt;，生成逻辑直接使用原有代码移植过来。同时记录在开发&lt;code&gt;IntelliJ IDEA&lt;/code&gt;插件过程中遇到的一些问题和踩到的一些坑。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="插件" scheme="http://xiaocainiaoya.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>markdown记录</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/</id>
    <published>2022-09-13T13:51:58.000Z</published>
    <updated>2023-04-17T09:28:39.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><span id="more"></span><table><thead><tr><th>符号</th><th>说明</th><th>编码(使用时移除’+’号)</th></tr></thead><tbody><tr><td>←</td><td>左箭头</td><td>&amp;+larr;</td></tr><tr><td>→</td><td>右箭头</td><td>&amp;+rarr;</td></tr><tr><td>↑</td><td>上箭头</td><td>&amp;+uarr;</td></tr><tr><td>↓</td><td>下箭头</td><td>&amp;+darr;</td></tr><tr><td>↔</td><td>水平箭头</td><td>&amp;+harr;</td></tr><tr><td>↕</td><td>竖直箭头</td><td>&amp;+varr;</td></tr><tr><td>⇐</td><td>双线左箭头</td><td>&amp;+lArr;</td></tr><tr><td>⇒</td><td>双线右箭头</td><td>&amp;+rArr;</td></tr><tr><td>⇑</td><td>双线上箭头</td><td>&amp;+uArr;</td></tr><tr><td>⇓</td><td>双线上箭头</td><td>&amp;+dArr;</td></tr><tr><td>⇔</td><td>双线水平双箭头</td><td>&amp;+hArr;</td></tr><tr><td>⇕</td><td>双线竖直箭头</td><td>&amp;+vArr;</td></tr></tbody></table><h1 id="跳转方式"><a href="#跳转方式" class="headerlink" title="跳转方式"></a>跳转方式</h1><p><strong>1.页内定位：</strong></p><ol><li>定义一个锚(id)：<code>&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</code></li><li>使用markdown语法：<code>[点击跳转](#jump)</code></li></ol><p><strong>2.重定向</strong></p><blockquote><p>[描述] (地址)</p></blockquote><p><strong>3.新标签页打开：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>显示字眼<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="表格内换行"><a href="#表格内换行" class="headerlink" title="表格内换行"></a>表格内换行</h1><p>使用<code>&lt;br&gt;</code></p><h1 id="黑体"><a href="#黑体" class="headerlink" title="黑体"></a>黑体</h1><p>部分<code>markdown</code>渲染器无法识别<code>****</code>，可以使用<code>&lt;b&gt;&lt;/b&gt;</code>的<code>html</code>标签来实现。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;箭头&quot;&gt;&lt;a href=&quot;#箭头&quot; class=&quot;headerlink&quot; title=&quot;箭头&quot;&gt;&lt;/a&gt;箭头&lt;/h1&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="markdown" scheme="http://xiaocainiaoya.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
