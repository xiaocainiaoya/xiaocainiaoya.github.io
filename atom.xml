<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2022-09-20T07:27:28.384Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IntelliJ IDEA插件开发</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2022-09-19T13:51:58.000Z</published>
    <updated>2022-09-20T07:27:28.384Z</updated>
    
    <content type="html"><![CDATA[<p>​    公司中提交<code>MYSQL</code>脚本有相应的规范，需要编写为<code>groovy</code>文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在<code>console</code>控制台上交互，使用上有点繁琐，偶然看到关于<code>IDEA</code>插件开发的博客，想着是否可以通过<code>IDEA</code>插件来写一个<code>UI</code>，生成逻辑直接使用原有代码移植过来。同时记录在开发<code>IntelliJ IDEA</code>插件过程中遇到的一些问题和踩到的一些坑。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>​    <code>IntelliJ IDEA</code>插件开发有两种方式，一种是直接引入<code>Plugin DevKit</code>，然后配置<code>IntelliJ Platform Plugin SDK</code>进行开发，另一种是使用<code>gradle</code>构建项目并引入<code>IDEA</code>插件开发包。使用<code>gradle</code>的好处是同时也可以引入一些其他的库进行使用。</p><p>​    在<code>IDEA 2021.3</code>以及之后的版本，开发需要使用<code>JDK 11</code>进行开发，在我开发的时候我本地也没有<code>JDK 11</code>(一台电脑可以支持多个版本的<code>JDK</code>，问题在于环境变量配置的是哪个版本而已。因为目前只有这里插件开发我才会用到<code>JDK 11</code>，所以没有将它添加到环境变量中，仅通过<code>IDEA</code>工具添加了<code>JDK</code>路径)。</p><p>​    我使用的是<code>gradle</code>的方式进行插件的开发。<code>gradle</code>导入之后，在<code>Libraries</code>下会有一个<code>com.jetbrains:ideaIC:2021.3</code>，这就是<code>IDEA</code>插件的开发包。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// IDEA的插件开发包</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;1.8.1&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// 设置阿里云maven仓库 </span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;cn.hutool:hutool-all:5.6.7&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.alibaba:fastjson:1.2.28&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-core:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-jul:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-slf4j-impl:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.25&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.9.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.9.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idea的使用版本</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    version = <span class="string">&#x27;2021.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">patchPluginXml &#123;</span><br><span class="line">    changeNotes = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Add change notes here.&lt;br&gt;</span></span><br><span class="line"><span class="string">      &lt;em&gt;most HTML tags may be used&lt;/em&gt;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gradle</code>中一些常用项：</p><p><code>intellij -&gt; runIde</code>：这时会新启动一个<code>IDEA</code>工具，可以进行调试插件。</p><p><code>intellij -&gt; buildPlugin</code>：构建插件，用来完成之后将代码打包成<code>.zip</code>。(路径为<code>build/distributions</code>)。</p><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p>点击<code>Help -&gt; Edit Custom Properties...</code>，添加以下配置后重启<code>IDEA</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">idea.is.internal</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>在<code>Tool</code>下会出现<code>Interal Actions</code>和<code>View PSI Structure...</code>按钮。</p><p><img src="https://s2.loli.net/2022/09/20/xouELJspl16qTnj.png" alt="ideaInternal.png"></p><p>参考面板：<code>Internal Actions -&gt; UI -&gt; Show Standard Panels</code>：会弹出一个<code>UI</code>面板，结合<code>UI Debug</code>就可以参考到对应的源码。</p><p><img src="https://s2.loli.net/2022/09/20/p46q5sldBj7Q3cn.png" alt="standPanel.png"></p><p>通过<code>Internal Actions -&gt;UI Debugger</code>可以监控在<code>IDEA</code>中鼠标操作对应的<code>Action</code>。比如创建一个类，在<code>UI Debugger</code>面板上可以看到一个<code>CreateClassAction</code>的类，就可以看到这个创建一个类的源码，如果功能类似甚至可以直接复用。</p><p>与<code>PSI</code>相关<code>API</code>目前占时没有使用，具体如果需要插件能实现在代码里根据某种规则生成内容，则就需要通过<code>PSI</code>相关内容进行处理。</p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idea-plugin</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">    └── main</span><br><span class="line">          └── resources</span><br><span class="line">          │     └── META-INF</span><br><span class="line">          │          └── plugin.xml</span><br><span class="line">          └── java</span><br><span class="line">              └── cn<span class="selector-class">.com</span>.xiaocainiao</span><br><span class="line">                       └── MyWindowFactory<span class="selector-class">.java</span>  </span><br></pre></td></tr></table></figure><h2 id="plugin-xml配置"><a href="#plugin-xml配置" class="headerlink" title="plugin.xml配置"></a>plugin.xml配置</h2><p>我使用的是<code>ToolWindowFactory</code>创建右侧窗体。若是创建<code>Action</code>，可以直接通过<code>New -&gt; Plugin DevKit -&gt; Action</code>进行创建，通过这种方式创建，会自动在<code>plugin.xml</code>文件中添加<code>&lt;action&gt;</code>的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>org.example.SecondIdeaPlugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SecondIdeaPlugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;xiaocainiaoya@foxmail.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://xxx.com&quot;</span>&gt;</span>bosssoft<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">        For simple and quick generation of SQL script files&lt;br&gt;</span><br><span class="line">        &lt;em&gt;Tools that are easy to use&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- please see https://plugins.jetbrains.com/docs/intellij/plugin-compatibility.html</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">toolWindow</span> <span class="attr">id</span>=<span class="string">&quot;generatorSQL&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">secondary</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">anchor</span>=<span class="string">&quot;right&quot;</span> <span class="attr">factoryClass</span>=<span class="string">&quot;cn.com.xiaocainiaoya.MyWindowFactory&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">toolWindow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>​    由于<code>IDEA</code>插件的<code>UI</code>采用的是<code>Swing</code>、<code>Awt</code>来进行窗体开发，当知道使用的是<code>Swing</code>一度想要放弃掉，确实是使用<code>Swing</code>是一件比较痛苦的事情。后借助于<code>IDEA</code>的<code>Swing UI Designer</code>功能通过拖拽简单组件的方式，硬着头皮画出了<code>UI</code>界面。</p><p><img src="https://s2.loli.net/2022/09/19/sTRPS3cQYnVABFD.png" alt="ideaSwing.png"></p><h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><h2 id="1-路径"><a href="#1-路径" class="headerlink" title="1.路径"></a>1.路径</h2><p>​    可能由于项目有别于常用的<code>java</code>项目、<code>spring</code>项目，所以在获取资源文件(<code>/resources/**</code>)时，总是感觉摸不着头脑。参考了一些其他博主写的<code>IDEA</code>插件项目，获取资源文件的方式，与<code>java</code>项目、<code>Spring</code>项目并无差别，但是我在获取资源文件时，一直提交获取不到资源文件，也有可能是<code>velocity</code>组件的问题。</p><p>​    原本使用<code>velocity</code>模板引擎来加载对应模板文件，但是一直报错获取不到对应资源文件之后，将这种动作修改为代码层获取到资源文件内容，在将模板内容提交给<code>velocity</code>模板引擎。</p><p>注：<code>velocity</code>组件和<code>groovy</code>库相关包在<code>com.jetbrains:ideaIC:20201.3</code>中已经存在，所以不能由自身再引入。</p><p>在调试开发过程中，<code>velocity</code>正常使用，但是打包成插件之后，通过插件的方式运行，一直报一个日志相关的异常。</p><p>添加<code>velocity.proerties</code>配置文件相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">runtime.log.logsystem.class</span>=<span class="string">org.apache.velocity.runtime.log.SimpleLog4JLogSystem</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.category</span>=<span class="string">velocity</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.logger</span>=<span class="string">velocity</span></span><br></pre></td></tr></table></figure><p>因为在调试过程的运行和实际插件方式运行是对应的相对路径是不一致的，所以在使用系统级有关的相对路径是需通过使用<code>com.intellij.openapi.application.PathManager</code>类来获取对应的路径：</p><p>比如使用<code>PathManager.getBinPath()</code>：</p><p>在调试运行获取到的路劲为：<code>/usr/local/Cellar/gradle/7.3.1/caches/modules-2/files-2.1/com.jetbrains.intellij.idea/ideaIC/2021.3/75777e10a0e2880bc02945066dda2480a696c3d9/ideaIC-2021.3/bin</code></p><p>在实际插件方式允许获取的路径为：<code>/Applications/IntelliJ IDEA.app/Contents/bin</code></p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://zhuanlan.zhihu.com/p/400059601" target="_blank">IntelliJ IDEA 插件开发指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    公司中提交&lt;code&gt;MYSQL&lt;/code&gt;脚本有相应的规范，需要编写为&lt;code&gt;groovy&lt;/code&gt;文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在&lt;code&gt;console&lt;/code&gt;控制台上交互，使用上有点繁琐，偶然看到关于&lt;code&gt;IDEA&lt;/code&gt;插件开发的博客，想着是否可以通过&lt;code&gt;IDEA&lt;/code&gt;插件来写一个&lt;code&gt;UI&lt;/code&gt;，生成逻辑直接使用原有代码移植过来。同时记录在开发&lt;code&gt;IntelliJ IDEA&lt;/code&gt;插件过程中遇到的一些问题和踩到的一些坑。&lt;/p&gt;</summary>
    
    
    
    <category term="插件" scheme="http://xiaocainiaoya.github.io/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="插件" scheme="http://xiaocainiaoya.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本基础</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-13T13:51:58.000Z</published>
    <updated>2022-09-13T03:11:30.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。</p></blockquote><span id="more"></span><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>最精简的<code>if</code>语句：<code>condition</code>是判断条件，<code>statement</code>判断条件为真时的执行语句。在<code>shell</code>脚本中不是通过大括号<code>&#123;&#125;</code>开标识代码的开始与结束。而是通过<code>fi</code>来闭合。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>也可以写成：当<code>condition</code>和<code>then</code>在同一行时，需要使用分号隔开，否则报语法错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition; <span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>结合<code>else</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statement2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>再结合<code>else if</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statementn</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>判断表达式：</p><blockquote><p>-e filename 如果 filename存在，则为真<br>-d filename 如果 filename为目录，则为真<br>-f filename 如果 filename为常规文件，则为真<br>-L filename 如果 filename为符号链接，则为真<br>-r filename 如果 filename可读，则为真<br>-w filename 如果 filename可写，则为真<br>-x filename 如果 filename可执行，则为真<br>-s filename 如果文件长度不为0，则为真<br>-h filename 如果文件是软链接，则为真<br>filename1 -nt filename2 如果 filename1比 filename2新，则为真。<br>filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</p></blockquote><p>整数变量表达式：</p><blockquote><p>-eq 等于<br>-ne 不等于<br>-gt 大于<br>-ge 大于等于<br>-lt 小于<br>-le 小于等于</p></blockquote><p>字符串变量表达式：</p><blockquote><p>If  [ $a = $b ]         如果string1等于string2，则为真<br>if  [ $string1 !=  $string2 ]  如果string1不等于string2，则为真<br>if  [ -n $string  ]       如果string 非空(非0），返回0(true)<br>if  [ -z $string  ]       如果string 为空，则为真<br>if  [ $sting ]          如果string 非空，返回0 (和-n类似) </p></blockquote><p>逻辑符号：</p><blockquote><p>逻辑非 !     if [ ! 表达式 ]<br>if [ ! -d $num ]         如果不存在目录$num</p><p>逻辑与 –a          条件表达式的并列(类似其他语言的<code>&amp;&amp;</code>)<br>if [ 表达式1  –a  表达式2 ]</p><p>  逻辑或 -o          条件表达式的或(类似其他语言的<code>||</code> )<br>if [ 表达式1  –o 表达式2 ]</p></blockquote><h4 id="2-循环"><a href="#2-循环" class="headerlink" title="2.循环"></a>2.循环</h4><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="shell" scheme="http://xiaocainiaoya.github.io/categories/shell/"/>
    
    
    <category term="shell" scheme="http://xiaocainiaoya.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Spock实践（一）</title>
    <link href="http://xiaocainiaoya.github.io/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-05T13:04:58.000Z</published>
    <updated>2022-08-05T09:24:23.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spock实践（一）"><a href="#Spock实践（一）" class="headerlink" title="Spock实践（一）"></a>Spock实践（一）</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在<code>Spring</code>体系中，常用的单元测试框架就是基于<code>PowerMock</code>或者<code>MockTo</code>等，由于这些框架依赖<code>Spring</code>容器，所以在编写过程需要频繁的启动<code>Spring</code>容器进行单元测试的测试，导致过程比较繁琐。<span id="more"></span></p><p>​    最近看到一篇美团的2021博客点击率<code>TOP10</code>中的一篇<a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">Spock单元测试框架介绍以及在美团优选的实践</a>，使用全新的<code>Spock</code>框架来进行单元测试，这个框架的好处，无需依赖<code>Spring</code>容器来进行单元测试，并且结合<code>groovy</code>动态语言的特点，提供了一些标签，并采用简单、通用、结构化的描述语言，让编写测试代码更加简洁、高效。具体细节参考美团的那篇技术博客。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><h4 id="对于dao层抽象"><a href="#对于dao层抽象" class="headerlink" title="对于dao层抽象"></a>对于dao层抽象</h4><p>​    在将这篇博客中的一些例子简单跑过之后，<code>Spock</code>确实在单元测试的编写上比较简单且直观，但是由于它不依赖于<code>Spring</code>容器，导致了原来<code>Spring</code>框架为我们封装的一些特性无法使用，比如在我们应用中，到处都是通过<code>tk.mybatis</code>或者<code>mybatis plus</code>的一些通过接口<code>api</code>来动态化<code>SQL</code>，而无需进行手动编写<code>SQL</code>。这些特性实际上是通过<code>Spring</code>容器中在创建特定<code>bean</code>对象时通过<code>spring</code>的扩展点进行处理的。在美团的那篇博客中也提到了如果想测试<code>dao</code>层，可以通过<code>MyBatis的SqlSession</code>启动<code>mapper</code>实例，但是这种方式仅仅获取到的是最基础的<code>ibatis</code>的代理对象，没有了<code>tk</code>或者是<code>mp</code>相关的增强。</p><p>​    由于目前只是想简单的引入<code>Spock</code>到某一个服务中，在实际的业务逻辑中，并不确定引入<code>Spock</code>对单元测试的编写是否会有提高，所以这里仅仅研究了如何在不依赖<code>spring</code>容器的情况下，伪造<code>tk.mybatis</code>查询时的<code>mapper</code>对象。</p><p>​    跟踪<code>Springbean</code>对象的创建过程，发现<code>tk.mybatis</code>主要是靠<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>(注意包路径，<code>ibatis</code>包下有一个同名类)来进行一些增强处理。所以创建一个工具类，专门用来获取对应的<code>mapper</code>代理对象。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用mapper工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * @date 2022/7/30 16:11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapperUtil</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MapperHelper mapperHelper = <span class="keyword">new</span> MapperHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config config = <span class="keyword">new</span> Config()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapperHelper.setConfig(config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">def</span> getMapper(Class clazz)&#123;</span><br><span class="line">        ClassLoader classLoader = MapperUtil.<span class="keyword">class</span>.getClassLoader()</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(classLoader.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟tk.mybatis相关创建过程</span></span><br><span class="line">        MapperFactoryBean mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean(clazz)</span><br><span class="line">        mapperFactoryBean.setSqlSessionFactory(sqlSessionFactory)</span><br><span class="line">        mapperFactoryBean.setMapperHelper(mapperHelper)</span><br><span class="line">        mapperFactoryBean.afterPropertiesSet()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperFactoryBean.getObject()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="H2内存数据库"><a href="#H2内存数据库" class="headerlink" title="H2内存数据库"></a>H2内存数据库</h4><p>​    在美团的这篇博客中，推荐使用<code>H2</code>数据库进行数据的隔离，在对<code>H2</code>进行一些了解后发现<code>H2</code>对<code>mysql</code>的一些语句并不支持，比如建表时的索引之类，所以需要修改原本的建表脚本，在进行一些字段迭代时，可能会比较繁琐。</p><p>通过直接使用<code>java.sql.Connection</code>对象来创建数据库连接，并执行建表语句。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AUTO_SERVER=TRUE 默认情况下只能单个连接，这个配置用来开启多个连接</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:h2:~/test;MODE=MySQL;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;AUTO_SERVER=TRUE</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>执行处理代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> executeSql(String sqlPath) &#123;</span><br><span class="line">    <span class="comment">// 执行sql文件</span></span><br><span class="line">    File sqlFile = <span class="keyword">new</span> File(sqlPath)</span><br><span class="line">    <span class="keyword">if</span>(!sqlFile.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;sql文件不存在&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Statement statement = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        statement = CONNECTION.createStatement();</span><br><span class="line">        <span class="keyword">boolean</span> success = statement.execute(sqlFile.text)</span><br><span class="line">        <span class="comment">// 这里有点不解，无论是脚本执行成功还是执行失败，这里好像返回的都是false</span></span><br><span class="line">        <span class="comment">// 目前不影响使用，没有进行深究</span></span><br><span class="line">        success ? println(<span class="string">&quot;执行sql文件成功&quot;</span>) : println(<span class="string">&quot;执行sql文件失败&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DbUnit的使用"><a href="#DbUnit的使用" class="headerlink" title="DbUnit的使用"></a>DbUnit的使用</h4><p>​    根据美团的这篇博客中，使用<code>DbUnit</code>来进行数据层数据的访问控制，也就是在初始化某个单元测试接口时进行的一些准备数据脚本的执行，</p><h5 id="基于xml脚本文件"><a href="#基于xml脚本文件" class="headerlink" title="基于xml脚本文件"></a>基于xml脚本文件</h5><p>​    在经过测试发现，<code>DbUnit</code>是通过<code>xml</code>文件来编写插入数据的脚本，这就导致写<code>xml</code>插入数据脚本文件也会花费一些工作量。以下为一个示例，假设要为某个接口准备几十条数据，估计准备数据的过程要疯，后期可以看看<code>DbUnit</code>有没有接口可以通过<code>SQL</code>转换为这个<code>xml</code>文件，或者自己实现一个接口，将<code>SQL</code>转换为<code>xml</code>文件来减少工作流。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataset</span>&gt;</span></span><br><span class="line">    &lt;gpfa_process_business</span><br><span class="line">            id=&quot;10007&quot;</span><br><span class="line">            test_id=&quot;1&quot;</span><br><span class="line">            name=&quot;2&quot;</span><br><span class="line">            value = &quot;1&quot;</span><br><span class="line">            mark = &quot;测试&quot;</span><br><span class="line">            create_time = &quot;2018-01-01&quot;</span><br><span class="line">            /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="基于csv脚本文件"><a href="#基于csv脚本文件" class="headerlink" title="基于csv脚本文件"></a>基于csv脚本文件</h5><p>​    <code>DbUnit</code>还支持通过<code>.csv</code>文件进行数据准备，但是比较繁琐的是它好像不能执行具体的文件，需要执行一个目录，并且目录下需要创建一个<code>table-ordering.txt</code>文件，内容为此目录下要执行的<code>csv</code>文件名称，同时<code>csv</code>文件的名称需与表名保持一致。</p><h4 id="自定义查询SQL语句"><a href="#自定义查询SQL语句" class="headerlink" title="自定义查询SQL语句"></a>自定义查询SQL语句</h4><p>​    对于在<code>xxxMapper.xml</code>文件中的查询语句，目前不知道因为什么原因，字段值无法赋值到实体上，需要通过<code>as</code>关键字将下划线字段别名为驼峰形式才可在实体中获取到，这个问题无疑是致命的，导致基本上所有的<code>mapper.xml</code>文件都无法进行单元测试。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spock实践（一）&quot;&gt;&lt;a href=&quot;#Spock实践（一）&quot; class=&quot;headerlink&quot; title=&quot;Spock实践（一）&quot;&gt;&lt;/a&gt;Spock实践（一）&lt;/h1&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在&lt;code&gt;Spring&lt;/code&gt;体系中，常用的单元测试框架就是基于&lt;code&gt;PowerMock&lt;/code&gt;或者&lt;code&gt;MockTo&lt;/code&gt;等，由于这些框架依赖&lt;code&gt;Spring&lt;/code&gt;容器，所以在编写过程需要频繁的启动&lt;code&gt;Spring&lt;/code&gt;容器进行单元测试的测试，导致过程比较繁琐。</summary>
    
    
    
    <category term="Spock" scheme="http://xiaocainiaoya.github.io/categories/Spock/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2022-07-29T14:13:58.000Z</published>
    <updated>2022-07-29T09:37:49.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>​    在实际应用中，为了加快接口的查询效率，常用的手段就是通过对查询的表添加索引，那么为何索引会提高数据的查询效率？如果添加索引会提高查询效率，那么为每个字段都添加索引是不是查询效率会更好？</p><span id="more"></span><h3 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h3><p>​    索引实际上就像是字典的目录，当需要查询某个字时，通过目录可以快速定位到某一页，从而快速查找到所需要的数据，不必进行全局遍历，达到提高查询效率的目的，实现上一般都是通过设计某种的数据结构，简单介绍几个常用的数据结构。</p><ol><li>哈希表：一种以键值对存储数据的数据结构，类似于<code>Java</code>中的<code>HashMap</code>的实现（当然了<code>jdk8</code>之后是采用数组加红黑树的方式），数据结构为一个数组加链表（有的地方称拉链法），当添加某个值时计算出这个值的<code>HASH</code>值，然后插入到数组对应的链表尾部，这种数据结构对于添加和删除的效率是比较高的，只需要移动一个节点的引用。</li><li>有序数组（规则数组）：通过某种规则将数据存入到数组中，在查询时同样可以根据这种规则直接通过下标获取到数据，如果是有序数组，对于范围查询的效率也是比较高的。这种数据结构瓶颈在于扩容以及空间的使用率上，比如现在是有序数组，数组长度为10，假设现在仅有两个值1和50，那么50的这个值存放在哪个位置？如果将数组长度扩大50，空间利用率就极低。</li><li>二叉树：二叉树是课本中经典的数据结构了，同样在添加、删除节点时，需要进行平衡。</li></ol><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>​    <code>InnoDB</code>引擎中采用<code>B+</code>数索引模型，每一个索引都对应着一颗<code>B+</code>树。分为主键索引和非主键索引。</p><p>​    主键索引又称为聚簇索引，主键索引的叶子节点是整行数据。</p><p><img src="https://s2.loli.net/2022/07/29/Cdn3PoHR5vbi8Iy.png" alt="主键索引示意图.png"></p><p>​        非主键索引又称为二级索引，非主键索引的叶子节点的内容是主键的值。由下图可知，非主键索引的查询逻辑是通过非主键索引获取到要查询数据的主键，再通过主键索引获取到对应行数据，这个过程称为回表。</p><p><img src="https://s2.loli.net/2022/07/29/nI3Ay1ZM4bpQRs8.png" alt="非主键索引示意图.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;p&gt;​    在实际应用中，为了加快接口的查询效率，常用的手段就是通过对查询的表添加索引，那么为何索引会提高数据的查询效率？如果添加索引会提高查询效率，那么为每个字段都添加索引是不是查询效率会更好？&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>tk.mybaits动态表名</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/</id>
    <published>2022-07-27T14:13:58.000Z</published>
    <updated>2022-07-27T13:49:50.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits动态表名"><a href="#tk-mybaits动态表名" class="headerlink" title="tk.mybaits动态表名"></a>tk.mybaits动态表名</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以<code>ORDER_</code>开头。且一些二次开发的组件中也有使用<code>mysql</code>进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。 <span id="more"></span>    </p><h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>​    <code>tk.mybatis</code>的大致处理逻辑：</p><p><img src="https://s2.loli.net/2022/07/27/XcaJ5jdZ2omVnP1.png" alt="tk相关处理过程.png"></p><ol><li>扫描器会将所有被<code>@Mapper</code>标记的类通过<code>SpringBean</code>的创建对象流程中，然后创建相应的对象后，添加到<code>SpringBean</code>容器中。</li><li>将这个标记的类对象包装为<code>MapperFactoryBean</code>对象</li><li>待到创建<code>bean</code>流程的最后，也就是经过了初始化、后置处理器列表等扩展点的相关处理之后，通过包装对象<code>MapperFactoryBean#afterPropertiesSet()</code>进行<code>tk.mybatis</code>对象的二次处理。</li><li>通过这个后置方法，解析出这个<code>@Mapper</code>对象所对应的表实体的表名和其他一些在创建<code>SQL</code>所需要的配置信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在这个map中 实体类 =&gt; 表对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, EntityTable&gt; entityTableMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EntityTable&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>根据这个标记对象所继承的上层接口，逐个解析出对应的<code>SQL</code>语句。以下方代码为例，这里的上层接口<code>CommonMapper</code>继承于<code>Mapper</code>，而<code>Mapper</code>又继承于很多的上层接口，其中就有<code>selectOne</code>接口，那么在这一步就会根据第四步骤中解析出来的表信息和字段信息等，构建一个基于变量的<code>SQL</code>语句，如果业务层调用该方法时，仅将相关参数填充后就形成一条完整的<code>SQL</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxxMapper</span> <span class="keyword">extends</span> <span class="title">CommonMapper</span>&lt;<span class="title">XxxAttachment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">ExampleMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">RowBoundsMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">Marker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectOneMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = &quot;dynamicSQL&quot;)</span></span><br><span class="line">    <span class="function">T <span class="title">selectOne</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>​    根据以上的步骤，可以得出一个结论，如果想要动态（这个动态是指创建时动态，并不是指运行时动态）的修改表名，那么需要在第四步之后，第五步之前将<code>entityTableMap</code>中对应的表名修改为想要的表名。</p><p>​    根据<code>Springbean</code>创建对象的逻辑，在初始化后置方法之前，会经过后置处理器列表，所以可以通过模拟一个后置处理器列表，提前对<code>entityTableMap</code>相关信息进行解析并缓存。</p><p><code>MapperFactoryBean</code> 进行处理的主要逻辑：</p><ol><li><p>根据<code>XxxMapper</code>类获取到对应的表实体</p></li><li><p>通过<code>EntityHelper.initEntityNameMap()</code>方法解析出这个表实体的相关信息，并缓存。</p></li><li><p>将<code>XxxMapper.selectExample() </code>等等内置的通用接口解析为动态SQL语句，缓存在某个地方(这个我没有去找在哪里)</p></li></ol><p>综上：只要能在 第3步之前将<code>EntityHelper</code>中的这个缓存中的<code>EntityTable</code>的表名称修改为相应的值，就能实现将表名动态化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TablePrefixBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * tk.mybatis 在 MapperFactoryBean 进行相关的逻辑处理，所以通过BeanPostProcessor，在执行MapperFactoryBean.afterPropertiesSet()方法之前，</span></span><br><span class="line"><span class="comment">    * 进行一次预处理，将表相关信息通过EntityHelper.initEntityNameMap()方法提前添加到对应的entityTableMap&lt;Class, EntityTable&gt;缓存之后，</span></span><br><span class="line"><span class="comment">    * 然后马上将这个实体所对应的EntityTable的表名进行需要的业务处理。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/7/27 16:04:01</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.lang.Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean.getClass() != <span class="keyword">null</span> &amp;&amp; bean.getClass().toString().contains(<span class="string">&quot;tk.mybatis.spring.mapper.MapperFactoryBean&quot;</span>))&#123;</span><br><span class="line">            Class&lt;?&gt; mapperClass = ((MapperFactoryBean)bean).getMapperInterface();</span><br><span class="line">            Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) types[<span class="number">0</span>];</span><br><span class="line">            Class&lt;?&gt; returnType = (Class&lt;?&gt;)  parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取mapperHelper</span></span><br><span class="line">            MapperHelper mapperHelper = (MapperHelper) ReflectUtil.getFieldValue(bean, <span class="string">&quot;mapperHelper&quot;</span>);</span><br><span class="line">            <span class="comment">// 提前解析这个bean所对应的表实体的相关信息</span></span><br><span class="line">            EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否需要修改表名</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                EntityTable entityTable = EntityHelper.getEntityTable(returnType);</span><br><span class="line">                entityTable.setName(<span class="string">&quot;prefix&quot;</span> + entityTable.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码中的最后的判断语句可以根据相应的规则，比如说自定义一个注解，并且在注解中指定一个前缀的参数，标记在实体上，这里可以通过获取这个注解进行是否需要添加前缀的逻辑处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    实际上以上这种场景应该在真是情况中少之又少，一般情况下并不会说想要统一某个服务中的所有表名前缀，但是在解决的问题的过程中，其实对<code>springBean</code>创建实体的流程，以及<code>tk.mybatis</code>对实体解析的相关逻辑都大致的过了一遍，加强了框架中一些细节处理的印象，对于后续如果出现一些<code>bug</code>可以尽快的定位到问题。</p><p>​    实际上我并不是一下子就想到这么做，在想到这么做之前，我也经过了其他的尝试，比方说我最先想到的是通过写<code>mybatis</code>插件的方式，拦截出<code>BoundSql</code>具体的<code>SQL</code>语句，通过修改这个<code>SQL</code>语句达到目的，但是发现不同类型的<code>SQL</code>判断方式略有不同，操作难度大，所以一直往上层追溯，发现<code>BoundSql</code>中的语句是在<code>Bean</code>初始化过程就已经生成，后面才一点一点整理出上述步骤流程，从而找到下手的地方。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits动态表名&quot;&gt;&lt;a href=&quot;#tk-mybaits动态表名&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits动态表名&quot;&gt;&lt;/a&gt;tk.mybaits动态表名&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以&lt;code&gt;ORDER_&lt;/code&gt;开头。且一些二次开发的组件中也有使用&lt;code&gt;mysql&lt;/code&gt;进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>tk.mybaits和mybatisPlus兼容性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/</id>
    <published>2022-07-21T14:13:58.000Z</published>
    <updated>2022-07-22T03:29:40.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits和mybatisPlus兼容性"><a href="#tk-mybaits和mybatisPlus兼容性" class="headerlink" title="tk.mybaits和mybatisPlus兼容性"></a>tk.mybaits和mybatisPlus兼容性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    项目早期建设时底层采用了<code>tk.mybatis</code>方式来对数据访问层进行数据处理，而后再更新<code>Springboot</code>的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实<code>tk.mybatis</code>官网已经没有维护了）又在底层引入了<code>mybatisPlus</code>，所以新代码采用<code>mybatisPlus</code>编写，旧模块任然使用<code>tk.mybatis</code>编写。<span id="more"></span>    </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    今天同事在移植项目中的一个功能模块时，报了一个错<code>No qualifying bean of type &#39;com.xxxx&#39;..</code>。乍一看猜测大概是因为对应的<code>xxxMapper</code>接口文件没有被扫描到<code>Spring</code>容器中，导致<code>tk.mybatis</code>的表集合中没有该实体。排查发现，启动类中并没有显示使用<code>@MapperScan</code>指定扫描路径，果然，使用的是启动类及以下的包结构，由于是搬迁的功能模块，不想调整原来包结构，故使用<code>@MapperScan</code>来指定扫描路径。</p><p>​    在启动类上通过<code>@MapperScan</code>指定了扫描路径之后可以正常启动，但是在调用接口发现又报错了<strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>，如果对<code>tk.mybatis</code>比较熟悉就知道，这里是因为<code>tk.mybatis</code>会将所有的表信息都缓存到一个集合中，仔细检查了指定的路径，也没有发现问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    经过一段时间的排查，终于找到了原因，在这里记录下，避免以后又遇到同样的问题，以下仅为个人观点，可能存在理解错误，请带着批判的视角阅读。</p><p>​    原来是在<code>tk.mybatis</code>中也有一个同名的<code>tk.mybatis.spring.annotation.MapperScan</code>，若使用<code>org.mybatis.spring.annotation.MapperScan</code>是不会对扫描到的对象进行一些<code>tk.mybatis</code>相关的处理，所以直接将注解更换为前者，再次启动，又报出了新的错误：</p><p>定位进去发现就是<code>tk.mybatis</code>处理对应接口缓存的时候报了类型转换异常：</p><blockquote><p>Caused by: java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getEntityClass(MappedStatement ms) &#123;</span><br><span class="line">    String msId = ms.getId();</span><br><span class="line">    <span class="keyword">if</span> (entityClassMap.containsKey(msId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> entityClassMap.get(msId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; mapperClass = getMapperClass(msId);</span><br><span class="line">        Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType t = (ParameterizedType) type;</span><br><span class="line">                <span class="keyword">if</span> (t.getRawType() == <span class="keyword">this</span>.mapperClass || <span class="keyword">this</span>.mapperClass.isAssignableFrom((Class&lt;?&gt;) t.getRawType())) &#123;</span><br><span class="line">                    <span class="comment">// 报错报在这里</span></span><br><span class="line">                    Class&lt;?&gt; returnType = (Class&lt;?&gt;) t.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取该类型后，第一次对该类型进行初始化</span></span><br><span class="line">                    EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line">                    entityClassMap.put(msId, returnType);</span><br><span class="line">                    <span class="keyword">return</span> returnType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MapperException(<span class="string">&quot;无法获取 &quot;</span> + msId + <span class="string">&quot; 方法的泛型信息!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里直接下结论：</strong>报这个错的原因是因为指定扫描的路径范围太大了，导致扫描到了底层中的二次封装类<code>public interface CommonMapper&lt;T&gt; extends Mapper&lt;T&gt;</code>，结合以上代码不难发现，是取出了<code>T</code>泛型进行强转之后报错，所以只需要将扫描路径的范围缩小即可。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在最后发现问题之后，解决起来就很轻松了，但是在排查的过程中，就非常的痛苦。因为报错的这个地方并没有显式的指明是某个类强转失败，而项目中又存在<code>mybatisPlus</code>和<code>tk.mybatis</code>共存的情况，乍一看代码以为是兼容性的问题，因为对于这两种方式来说，数据访问层接口采用的是不同的继承接口。</p><p>一个是<code>tk.mybatis.mapper.common.Mapper</code><T>，一个是<code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code>，所以一看到这个类型转换异常，就误以为是因为需要通过<code>tk.mybatis</code>来解析的<code>xxxMapper</code>被<code>mybatisPlus</code>接管导致。</p><p>​    在排查跟踪源码的过程中，对<code>tk.mybatis</code>和<code>mybatisPlus</code>相关的一些处理有了进一步的了解，在此做了记录。</p><p><code>tk.mybatis</code>通过<code>tk.mybatis.spring.mapper.ClassPathMapperScanner</code>扫描器将对应的表实体收集到一个集合中，注意<code>mybatis</code>也有自己的扫描器<code>org.mybatis.spring.mapper.ClassPathMapperScanner</code>，也就是说在项目启动过程中，实际上是经过了两次的扫描，并且<code>tk.mybatis</code>的扫描器在<code>mybatis</code>的扫描器之前，至于是怎么插到<code>mybatis</code>之前的，猜测是通过<code>spring</code>的某个后置接口，这个与本篇主题无关，不进一步详解。</p><p>​    其实<code>tk.mybatis</code>的扫描器主要是将指定路径(默认是启动类所在包及子包)中被<code>@Mapper</code>标记的类，解析成<code>BeanDefinition</code>，添加到<code>Spring</code>对应集合中，用于后续将其实例化为具体的<code>bean</code>对象到容器中。这些的主要逻辑在这两个扫描器的父类<code>ClassPathBeanDefinitionScanner#doScan</code>。经过<code>tk.mybatis</code>扫描器处理后的表实体，同样也会在<code>mybatis</code>扫描器被作为候选对象<code>candidate</code>被扫描到。但它会从<code>Spring</code>中查询一次，查看是否存在该<code>BeanDefinition</code>，若存在则打印<code>Skipping MapperFactoryBean with name &#39;xxxMapper&#39; and &#39;com.xx.xxx....mapper.XxxMapper&#39; mapperInterface. Bean already defined with the same name!</code>，大概意思就是这个类已经存在<code>BeanDefinition</code>，当前处理跳过该类的处理，也就是说在指定路径下的实体表只会被这两个扫描器中的其中一个扫描并进行相关处理。</p><p>​    <code>tk.mybatis</code>扫描器中在创建<code>BeanDefinition</code>时，将它的<code>resolvedTargetType</code>和<code>beanClass</code>字段都标记为了<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>，而<code>mybatis</code>扫描器扫描器中这两个字段标记的是<code>org.mybatis.spring.mapper.MapperFactoryBean</code>，这就导致在真正实例化<code>Spring bean</code>对象时调用了不同的后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#invokeInitMethods</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最后会调用初始化的后置接口</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟踪下进入到不同的后置接口的调用方式，继承关系如下代码所示，从上面的代码中的最后调用<code>bean</code>对象的<code>afterPropertiesSet</code>方法，到下面代码中是由于二者的上层接口中<code>DaoSupport</code>实现了<code>InitializingBean</code>方法。且这个后置初始化方法中仅调用了<code>checkDaoConfig</code>和<code>initDao</code>方法，均由具体的子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tk.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoSupport</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, BeanInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">// Let abstract subclasses check their configuration.</span></span><br><span class="line">        checkDaoConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let concrete implementations initialize themselves.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initDao();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Initialization of DAO failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tk.mybatis.spring.mapper.MapperFactoryBean</code>具体的实现：核心的处理在这里，刚刚上文说到，<code>tk.mybatis</code>会将指定路径下的所有<code>@Mapper</code>类的<code>BeanDefinition</code>中的<code>resolvedTargetType</code>和<code>beanClass</code>都标记为<code>tk.MapperFactoryBean</code>，那么也就是说指定路径下的所有<code>@Mapper</code>都会被识别为是<code>tk.mybatis</code>的<code>mapper</code>？其实不是，这里有一个判断<code>mapperHelper.isExtendCommonMapper()</code>，这个判断的主要逻辑是获取这个<code>XxxMapper</code>接口及所有上层父类接口是否有<code>tk.mybatis.mapper.annotation.RegisterMapper</code>注解，如果没有，则不采用<code>tk.mybatis</code>的方式进行解析。到这，应该就可以解答前面提出的问题，所以如果需要用<code>mybatisPlus</code>，那么它的<code>XxxMapper</code>接口的所有上传父类接口必然不会存在<code>tk.RegisterMapper</code>注解，也就不会进行<code>tk.mybatis</code>相关的处理(<code>tk.mybatis</code>这里的处理是将表实体和<code>xxxMapper</code>接口的一些方法等信息缓存起来)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasMapper(<span class="keyword">this</span>.mapperInterface) &amp;&amp; mapperHelper != <span class="keyword">null</span> &amp;&amp; mapperHelper.isExtendCommonMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">        mapperHelper.processConfiguration(getSqlSession().getConfiguration(), <span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>No qualifying bean of type &#39;com.xxxx&#39;..</code>的实际原因是移植的功能模块类路径不落在默认扫描路径范围内（启动类所在的包及子包）</li><li><strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>是因为通过<code>org.mybatis.spring.annotation.MapperScan</code>指定了<code>mybatis</code>的扫描路径，但没有指定<code>tk.MapperScan</code>，导致<code>tk</code>的扫描器使用默认值(默认值为启动类所在的包及子包)，恰好移植的功能模块不属于启动类的包及子包中，所以移植功能中的所有<code>xxxMapper</code>都被解析为了<code>mybatis</code>类型(也就是前面说的<code>beanDefinition</code>中的那两个属性被赋值为了<code>mybatis</code>对应的类)，最后导致在初始化<code>bean</code>对象时，没有进入到<code>tk.mybaits</code>对应类的后置处理器，也就没有将这些表实体相关信息缓存，从而导致以上报错。</li><li>类型转换异常的报错，是因为指定<code>tk.MapperScan</code>设置扫描范围太大，导致扫描到了底层二次封装的抽象父类，导致在获取接口层参数获取到了泛型参数<code>T</code>，泛型参数以<code>T</code>进行类型转换为<code>Class</code>从而导致了报错。</li><li>在都不指定<code>@MapperScan</code>的情况下，二者扫描器的默认扫描路径都是启动类所在的包以及子包，当指定了<code>tk.@MapperScan</code>之后那么<code>tk.mybatis</code>的扫描路径变成了这个具体的指定路径，<code>mybatis</code>的扫描路径还是默认的启动类所在的包极其子包，也就是说两个扫描器的扫描路径是互不影响的、各自维护，这个很重要，如果不明白这个，在排查的过程中，会影响对问题的判断。</li><li>引入<code>tk.mybatis</code>一定会经过两次扫描器，一次是<code>tk.mybatis</code>的扫描器，一次是<code>mybatis</code>原生的扫描器，如果某个<code>mapper</code>对象被<code>tk.mybatis</code>扫描生成了<code>BeanDefinition</code>，<code>mybatis</code>的扫描器会跳过该类，同样的，某个<code>xxxMapper</code>若想使用<code>mybatisPlus</code>的方式进行数据访问层的处理，虽然它在扫描阶段被认为是以<code>tk.mybatis</code>的方式解析，但是在具体创建<code>spring bean</code>对象的时候，<code>kt.mybatis</code>的后置接口中有相应的逻辑判断(所有上层接口是否有标记<code>RegisterMapper</code>)，来控制是否进行相应处理。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits和mybatisPlus兼容性&quot;&gt;&lt;a href=&quot;#tk-mybaits和mybatisPlus兼容性&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits和mybatisPlus兼容性&quot;&gt;&lt;/a&gt;tk.mybaits和mybatisPlus兼容性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    项目早期建设时底层采用了&lt;code&gt;tk.mybatis&lt;/code&gt;方式来对数据访问层进行数据处理，而后再更新&lt;code&gt;Springboot&lt;/code&gt;的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实&lt;code&gt;tk.mybatis&lt;/code&gt;官网已经没有维护了）又在底层引入了&lt;code&gt;mybatisPlus&lt;/code&gt;，所以新代码采用&lt;code&gt;mybatisPlus&lt;/code&gt;编写，旧模块任然使用&lt;code&gt;tk.mybatis&lt;/code&gt;编写。</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>数据库和缓存双写一致性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-07-20T12:50:58.000Z</published>
    <updated>2022-07-20T08:42:46.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和缓存双写一致性"><a href="#数据库和缓存双写一致性" class="headerlink" title="数据库和缓存双写一致性"></a>数据库和缓存双写一致性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。<span id="more"></span></p><p><img src="https://s2.loli.net/2022/07/20/m6zT1AH2oZvSwa8.png" alt="双写一致性.png"></p><p>通常来说，常见的应用场景为：</p><ol><li>用户请求查询某些数据，先进入缓存查看是否存在</li><li>存在则直接返回数据</li><li>不存在则查数据库，查到则将数据添加一份到缓存中，再返回，使得下次查询可以直接从缓存中获取，从而提高系统的响应速度。</li></ol><h2 id="双写的四种场景"><a href="#双写的四种场景" class="headerlink" title="双写的四种场景"></a>双写的四种场景</h2><ol><li>先更新缓存，再更新数据库</li></ol><p>​    如果采用这种方式，极易产生数据不一致的情况。因为先更新缓存，如果因为某些原因出现数据写入失败，比如主键冲突、非空字段未填值、数据库宕机等等情况导致数据库写入失败，这时就出现了缓存中是新值，数据库中是旧值，造成了数据库和缓存数据不一致。</p><ol start="2"><li>先更新数据库，再更新缓存</li></ol><p>​    假设更新数据库的操作和更新缓存的操作在同一个事务中，那么更新数据库之后，再更新缓存，如果出现缓存更新失败，那么事务回滚，保证了数据的一致性。但由于数据库和缓存实际上都是采用远程链接的方式读写数据，所以一般来说只有在低并发的场景下，才会将二者放在同一个事务中，否则若写缓存过慢，直接导致数据库事务时间被拉长，而形成长事务。如果二者不在同一个事务中，若数据库更新数据成功，缓存中更新数据失败，就会导致数据的不一致。</p><p>​    假设在高并发场景下，且更新缓存和更新数据库不在同一个事务中执行。假设有两个写操作，当写操作A更新数据库之后，在将数据写入缓存的过程中出现网络拥堵等情况，这时写操作B，也更新了数据库，拿着更新之后的值，写入到缓存中，同时写操作A的网络不拥堵了，写操作A又更新了缓存，这时数据库中是写操作B的值，缓存中是写操作A的值，从而造成了数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/rq9LGBjQ4EfCvRh.png" alt="先更新数据库再更新缓存.png"></p><ol start="3"><li>先删除缓存，再更新数据库</li></ol><p>​    同样在高并发下，如果请求A在删除缓存之后，写入数据库之前的这段时间内，如果有请求B进行获取数据，这是它从缓存中获取不到，则从数据库中获取，由于这时A还未将数据写入到数据库中，请求B读到的是旧值，而请求B又将读到的旧值写入到缓存中，之后请求A又将新值写入到数据库中，造成了数据库和缓存数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/lZQImSBoycYAO5b.png" alt="先删缓存再写库.png"></p><p>可以通过<strong>缓存双删</strong>的方式解决这个问题，写操作A在写入数据库之后，再删除一次缓存，这时又有一个新的问题，如果写操作A在一更新数据库之后，就去删缓存，可能存在某些线程中已经获取了旧值，只不过还没写入到缓存中，也就是上图的步骤7和步骤8。所以一般是在更新数据库之后一段时间之后进行缓存删除，比如500ms。</p><ol start="4"><li>先更新数据库，再删除缓存</li></ol><p>​    同样假设有两个请求，一个读请求A，一个写请求B。</p><ul><li>当写请求B先到，在更新数据库的过程中或者更新数据库后还未删除缓存时，读请求到达，读取了缓存中的数据，然后写请求B再删除缓存，对于这种场景仅读请求A读取了一次旧值。</li><li>当读请求A先到，读取到了缓存中的数据，直接返回了，这时写请求B在更新数据库，再删除缓存，同样对于这种场景，仅读请求A读取了一次旧值。</li></ul><p>但是还是有一种场景下，会导致数据不一致，也就是缓存过期了。</p><p>也就是当写操作A到达，在更新数据时出现拥堵，这时读操作B来读取缓存，刚好缓存过期，则从数据库中获取到了旧值，同时写操作A更新了数据库，且删除了缓存，然后读操作B再将旧值写入到缓存中，造成数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/jD6v2BzV7gylqRE.png" alt="写库再删缓存.png"></p><p>但是一般来说认为要造成上述场景需要满足两个条件：</p><ol><li>缓存刚好过期了</li><li>读操作B从数据库读到数据之后，更新缓存的耗时比写操作A更新数据库+删除缓存的耗时长。(一般来说对缓存的操作耗时要远小于对数据的操作耗时)</li></ol><p><strong>综上，一般来说还是需要采用先更新数据库再删除缓存的策略。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实际上不论是方案3中的缓存双删还是方案4都存在一个问题，在二者操作不在同一个事务的前提下，如果删除缓存操作失败了，那么就会导致缓存和数据库数据不一致。</p><p>​    这时就需要引入重试机制，缓存删除失败之后进行重试。关于重试就可简单可复杂了，简单就是直接捕获异常进行重试操作，但这可能影响接口时效，也可以将设置专门线程池，将重试操作推给线程池，又或者引入一些任务调度或者是<code>MQ</code>的中间件来处理。在查资料的过程中，有看到有人说也可以通过订阅<code>mysql</code>的<code>binlog</code>，如果发现了更新数据请求，则删除对应的缓存，但是据我所知很多项目在生产环境甚至连<code>binlog</code>功能都没有开启[旺柴]。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库和缓存双写一致性&quot;&gt;&lt;a href=&quot;#数据库和缓存双写一致性&quot; class=&quot;headerlink&quot; title=&quot;数据库和缓存双写一致性&quot;&gt;&lt;/a&gt;数据库和缓存双写一致性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志文件</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</id>
    <published>2022-07-14T14:13:58.000Z</published>
    <updated>2022-07-29T08:02:24.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql日志文件"><a href="#mysql日志文件" class="headerlink" title="mysql日志文件"></a>mysql日志文件</h1><p>​    <code>mysql</code>在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。<span id="more"></span></p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>​    错误日志<code>error_log</code>文件对<code>MYSQL</code>的启动、允许、关闭过程进行记录，在遇到问题时可以查看该文件进行问题的定位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>​    慢查询日志<code>slow log</code>文件，可以在<code>MYSQL</code>启动时设置一个阈值，将执行时间超过该值的<code>SQL</code>语句都记录到慢查询文件中，通过查看该文件中的<code>SQL</code>语句来对系统中的慢查询进行优化处理。</p><p>默认情况下，<code>MYSQL</code>不开启慢查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启慢查询日志</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span></span><br><span class="line"><span class="comment">-- 查看慢查询的时间，多久认为是慢SQL 大于long_query_time才会认为是慢查询</span></span><br><span class="line"><span class="comment">-- 5.1版本之后long_query_time的单位改为微秒，5.1之前是秒</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_slow_queries&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果与语句没有使用到索引，都认为是慢查询</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.6.5 版本之后才有的参数，用来表示每分钟允许记录的未使用索引的SQL次数</span></span><br><span class="line"><span class="comment">-- 默认值为0，表示没有限制；在生产环境下，若过多的SQL语句没有使用索引，会导致</span></span><br><span class="line"><span class="comment">-- 频繁的将SQL记录到slow log表中，消耗性能和占用资源</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_throttle_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.1 之后允许将慢查询SQL记录到TABLE中，便于开发者查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看记录的方式，默认是FILE</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_output&#x27;</span></span><br><span class="line"><span class="comment">-- 修改为TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;TABLE&#x27;</span></span><br><span class="line"><span class="comment">-- 通过MYSQL.slow_log 查看</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MYSQL.SLOW_LOG</span><br></pre></td></tr></table></figure><p>默认情况下<code>slow_log</code>表使用的是<code>CSV</code>引擎，如果数据量的情况下，查询效率可能不高，可以将<code>slow_log</code>表的引擎修改为<code>MyISAM</code>,并且对列<code>start_time</code>上添加索引来提交查询的效率。</p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志文件<code>bin log</code>记录对数据执行的所有操作，但不包含<code>select</code>等查询操作，因为本质上查询并不会对数据本身进行修改。</p><p>但非查询语句又对数据没有产生变化，这类还是会被记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 比如：数据库中并没有名为marry的数据</span></span><br><span class="line">update user_info <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;marry&#x27;</span></span><br></pre></td></tr></table></figure><p><code>bin log</code>的主要作用为：</p><ul><li>恢复：比如对某些数据进行<code>DELETE</code>操作，可以通过使用<code>mysqlbinlog</code>工具对<code>bin log</code>文件中的的某些事件的起止节点或者时间的起止进行数据的恢复。</li><li>复制：常用的场景为主从模式下，主节点通过将<code>bin log</code>文件传递给从节点，然后从节点通过读取<code>bin log</code>文件的数据保证主从数据一致性。</li><li>审计：通过<code>bin log</code>文件中的信息进行审计，判断是否有对数据库注入的攻击。</li></ul><p>默认情况下二进制文件<code>binlog</code>是关闭的，需要手动开启，逻辑上是存在一定的性能消耗，但是根据官方测试结果数据来看，开启仅消耗使得性能下降1%左右。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看binlog存放位置</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示缓存区大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_cache_size&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用了临时文件写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_disk_use&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用缓存区写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_use&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件中相应的配置参数</strong></p><ul><li><code>max_binlog_size</code>： 指定单个二进制文件的最大值。如果操作该值则产生新的二进制文件，<code>MYSQL5.0</code>之前默认值为<code>1.1G</code>，之后版本为<code>1G</code></li><li><code>binlog_cache_size</code>：在事务未提交的二进制日志会被记录到一个缓存区中，等到事务提交之后再写入到<code>binlog</code>中，缓存区默认大小为<code>32K</code>。且该参数是基于会话，也就是说当一个线程开启一个事务时，就会分配一个<code>binlog_cache_size</code>大小的缓存区。当事务中的记录容量超过该值时，<code>MySql</code>会将缓冲区中的日志写入到一个临时文件中。</li><li><code>sync_binlog</code>：默认情况下，并不是每次写的时候都将日志内容写入到磁盘中，所以当数据库发生宕机时，可能有部分缓存区的数据还未写入到磁盘中。<code>sync_binlog</code>这个参数就是用来控制写入到缓存多少次后将缓存中的日志数据同步到磁盘中。默认值为0</li><li><code> binlog_do-db</code>：表示需要写入那些库的日志</li><li> <code>binlog-ignore-db</code>：表示需要忽略那些库的日志</li></ul><p><strong>binlog_format</strong>：这个参数比较重要，单独罗列出来，表示记录到<code>binlog</code>日志的数据格式，在<code>MySql5.1</code>版本之后才有该参数。可选参数有：</p><ul><li><p><code>STATEMENT</code>：基于<code>SQL</code>语句记录。存在两个问题：</p><ul><li><p>如果主服务器使用了一些生成函数，比如<code>uuid</code>等，这时从服务器得到主服务器的<code>binlog</code>进行回放后会导致主从数据不一致。</p></li><li><p>由于<code>MySql</code>的<code>INnoDB</code>存储引擎的默认事务隔离级别是<code>RR(REPEATABLE READ)可重复读</code>。如果事务隔离级别不是<code>RR</code>,会出现一种情况是：</p><p>假设事务隔离级别为<code>RC</code>且有一个<code>user_info（id， name）</code>表和两个字段，且有两条数据<code>(1, &#39;tom&#39;), (2, &#39;marry&#39;)</code>，下表的两个事务执行之后的数据为<code>(3, &#39;tom&#39;), (2, &#39;tom&#39;)</code>，但是从服务器获取到的<code>binlog</code>中，由于事务B先提交，那么会先回放事务B的<code>SQL</code>语句，结果就变成了<code>(3, &#39;tom&#39;), (3, &#39;marry&#39;)</code>,从而导致主从数据不一致。所以有些人说<code>MySQL</code>为了避免这种情况，将事务的隔离级别默认设置为<code>RR</code>，但<code>Oracle</code>的默认事务隔离级别为<code>RC</code></p><table><thead><tr><th>顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>update T set id=3 where name=’tom’</td><td></td></tr><tr><td>2</td><td></td><td>Update T set name=’tom’ where name=’marry’</td></tr><tr><td>3</td><td></td><td>commit</td></tr><tr><td>4</td><td>commit</td><td></td></tr></tbody></table></li></ul></li><li><p><code>ROW</code>：不是简单的<code>SQL</code>语句，而是记录表所对应行数据的变化，也就是从某某修改为某某。假设<code>name=tom</code>的数据有1w条，那么采用<code>STATEMENT</code>仅记录一条<code>DELETE</code>语句，采用<code>ROW</code>则记录1w条日志记录，显然后者需要更大的磁盘空间。</p></li><li><p><code>MIXED</code>：混合模式，默认采用<code>STATEMENT</code>格式，指定一些情况使用<code>ROW</code>格式，比如使用了<code>uuid()</code>等生成函数，在<code>innodb</code>对表的数据进行增删改操作等等。</p></li></ul><p><strong>binlog的写入机制</strong></p><ol><li><code>binlog</code>的写入是利用事件触发执行机制，根据<code>binlog_format</code>格式和操作的类型触发<code>Log Event</code>事件。</li><li>将事务在执行过程中产生的所有<code>Log Event</code>写入到缓存区中，一个执行语句不一定都只对应一个<code>Log Event</code>，每个事务线程都有独立的缓存区。</li><li>事务提交后会将缓存区中的<code>Log Event</code>写入到<code>bin log</code>文件中。事务的写入是串行的方式，也就是说一个事务在写入的中间不会穿插其他事务的<code>Log Event</code>。</li></ol><h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><blockquote><p>重做日志redo log</p></blockquote><h3 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h3><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql日志文件&quot;&gt;&lt;a href=&quot;#mysql日志文件&quot; class=&quot;headerlink&quot; title=&quot;mysql日志文件&quot;&gt;&lt;/a&gt;mysql日志文件&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;mysql&lt;/code&gt;在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记(二)</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</id>
    <published>2022-07-12T13:39:58.000Z</published>
    <updated>2022-07-20T01:28:53.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习笔记-二"><a href="#redis学习笔记-二" class="headerlink" title="redis学习笔记(二)"></a>redis学习笔记(二)</h1><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>​    主从复制是将一台<code>redis</code>服务器设置为主服务器<code>master</code>，复制到其他多台从服务<code>slave</code>上，主服务器负责读写操作，从服务器只能读。<strong>数据的复制只能是主服务器到从服务器。</strong>当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。<strong>主从服务器之间通过心跳的机制检查服务器间的连接状态</strong><span id="more"></span></p><p><strong>主从服务之间的数据复制通过全量复制和部分复制。</strong></p><ol><li><p><strong>全量复制</strong> </p><p>​    分为两步操作：①主节点接收到从节点的全量复制命令，执行<code>gbsave</code>，在后台生成<code>RDB</code>文件，同时将此刻之后的写操作命令添加到复制缓冲区中。②将<code>RDB</code>文件发送给从节点，从节点先清除本身数据后加载<code>RDB</code>文件，然后在将主节点的复制缓冲区写命令依次执行。从而保证了从节点和主节点的数据一致。</p></li><li><p><strong>部分复制</strong></p><ul><li>复制偏移量：主从节点分别维护一个<code>offset</code>偏移量，主节点每次向从节点发送多少数据，修改<code>offset</code>偏移量值；同理，从节点每次从主节点接收多少数据，也会修改<code>offset</code>偏移量值。</li><li>复制积压缓冲区：主节点内部维护一个长度固定的<code>FIFO</code>队列作为复制积压缓冲区，默认大小是<code>1M</code>，在进行命令同步时，不仅会将写命令同步到从节点，同时会将写命令写入复制积压缓冲区，由于长度固定，写入比较早的命令会被挤出缓冲区，所以当主从的<code>offset</code>差距大于缓冲区长度时，无法进行部分复制，只能执行全量复制。</li><li>服务器运行<code>ID</code>(<code>runId</code>)：每个节点都有运行<code>ID</code>，运行<code>ID</code>在节点启动时自动生成，主节点会将自己的<code>runId</code>发送给从节点，从节点保存起来，出现从节点断线重连：①若若从节点中保存的主<code>runId</code>=主<code>runId</code>则之前同步过该主节点数据，会首先尝试部分复制。②若从节点中保存的主<code>runId</code>!=现主<code>runId</code>，则只能全量复制。</li></ul></li></ol><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>​    在主从复制模式下，若出现主服务器宕机，则需要运维人员手动修改从服务器为主服务器，不能良好的支持高可用。哨兵模式从出现就是为了解决这个问题，所以哨兵模式其实就是高可用的主从复制模式。可以由至少一个哨兵(哨兵可以集群)，监听任意多个主从服务器，当主服务器出现异常，导致宕机的时候，由哨兵投票将某个从服务器选举为主服务器，这样就可以保证主从服务之间的高可用。</p><blockquote><p>启动哨兵：redis-sentinel /path/to/sentinel.conf</p></blockquote><ul><li><code>Subjectively Down(SDOWN)</code>：主观下线，单个哨兵做出下线的判断。</li><li><code>Objectively Down(ODOWN)</code>：客观下线，多个哨兵实例对同一客户端做出下线判断。</li></ul><p><strong>客观下线只适用于主服务器，其他从服务器或者哨兵只会主观下线。哨兵在判定它们为下线前不需要进行协商，所以从服务器或者哨兵永远不会达到客观下线的条件。</strong>理论上，主观下线的作用就是当主服务器出现客观下线时，哨兵进行选举的从服务器不会从主观下线的从服务器中选举。</p><p><strong><code>redis</code>集群</strong></p><p>​    集群是为了解决单机<code>redis</code>容量有限的问题，将数据按一定的规则分配到多台机器中，也叫数据分片，集群不需要哨兵。</p><p>使用<code>redis</code>分片会遇到一个问题是如果将所有数据都均匀的分布到每一台服务器上，如果仅仅只通过<code>key</code>的哈希值取服务器数量的模有可能出现两个问题：</p><ul><li><p>大量的哈希碰撞导致大量数据存储在了某一台或者某几台服务器上。</p></li><li><p>当出现服务器增加一台或者减少一台时，需要迁移大量的数据。</p></li></ul><p><strong>解决方案</strong></p><p>采用一致性哈希算法进行处理。</p><p>如下图设置一个从0~2^32-1头尾相连的环。将目前集群中的服务器的<code>ip</code>进行哈希运算后对<code>2^23</code>进行取模后，得到结果一定落在这个环上的某个位置。</p><p><img src="https://s2.loli.net/2022/07/12/fb96c7TK3knjGdv.png" alt="一致性哈希图1.png"></p><p>假设现在集群中有三台服务器，分别进行<code>hash(ip)%2^23</code>运算之后，落在环上的位置，同时对一些需要存储在服务器中的数据进行<code>hash(key)%2^23</code>运算之后的值也会落在这个环上。根据顺时针，将对应的键归于某台服务器上，比如下图中<code>key1</code>落在<code>S1</code>服务器上，<code>key4</code>落在<code>S2</code>服务器上，<code>key2</code>和<code>key3</code>落在<code>S3</code>服务器上。</p><p><img src="https://s2.loli.net/2022/07/12/BujMksDNmw5Hx9z.png" alt="一致性哈希2.png"></p><p>假设这时需要添加一台服务器<code>S4</code>，那么只需要将<code>S4</code>在这个环上左侧部分的数据迁移到<code>S4</code>服务器上，其他服务器不需要进行迁移操作，删除服务器类似，所以不论是添加或者删除服务器，仅需要集群中的两台服务器进行迁移处理。</p><p><img src="https://s2.loli.net/2022/07/12/n8CoMD6u7KBAp2O.png" alt="一致性哈希3.png"></p><p>到这实际上已经解决了使用缓存集群进行分片在扩展和收缩时牵一发而动全身的数据迁移情况，但是在上面的例子中，服务的分布过于理想化，有可能出现一种场景是集群中就两台服务器，且两台服务器在这个环上距离非常靠近。业界称为<strong>数据倾斜</strong>：在存储集群中意思为大部分数据存储在少来服务器上，在计算集群中意思为大部分数据由少量服务器进行计算。</p><p>这里可以通过为服务器创建虚拟的节点，来扩大服务器在环上的分布，比如由每台服务器仅经过一次<code>hash(ip)%2^23</code>运算修改为<code>ip#1</code>、<code>ip#2</code>进行编号后在进行运算，使得一台服务器在环上存在多个节点，达到尽可能将数据均匀分布到各个服务器上的目的。</p><h4 id="缓冲穿透、击穿、雪崩"><a href="#缓冲穿透、击穿、雪崩" class="headerlink" title="缓冲穿透、击穿、雪崩"></a>缓冲穿透、击穿、雪崩</h4><p><strong>缓存穿透</strong>：当某一个<code>key</code>对应数据在缓存中不存在同时在持久层也不存在时，如果大量的请求涌入，会造成数据库的压力，这种现象称为缓存穿透。</p><p><strong>解决方案</strong></p><ul><li>布隆过滤器：将所有数据都打入布隆过滤器中，当通过布隆过滤器查询某个值时，若返回<code>false</code>则一定不存在该数据，若返回<code>true</code>则可能存在数据(有一定误判率)，进入<code>redis</code>查询，若没有命中，在进入持久层查询。</li><li>缓存空对象：这种做法比较粗暴，当出现数据查询不到时，将空对象缓存，一般会设置一个较短的缓存时间。</li></ul><p><strong>缓存击穿</strong>：当某一时刻，某一个<code>key</code>对应的缓存时间过期导致失效，如果大量的请求涌入，导致所有的请求都到持久层，会造成数据库压力，这种现象称为缓存击穿。</p><p><strong>解决方案</strong></p><ul><li>使用互斥锁：使用<code>mutex</code>，当缓存失效时，获取锁，在进入持久层，查询到数据后再添加到缓存中，也就是说若缓存中查询不到值，需要获取锁之后，才能进入持久层。</li></ul><p><strong>缓存雪崩</strong>：在某一个时刻，多个<code>key</code>对应的缓存时间过期，导致这些<code>key</code>全部失效，如果大量的请求涌入，导致所有的请求都到达持久层，会造成数据库压力，这种现象称为缓存雪崩。</p><p><strong>解决方案</strong></p><ul><li>缓存失效随机值，尽量避免多个<code>key</code>扎堆在同一时刻失效。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis学习笔记-二&quot;&gt;&lt;a href=&quot;#redis学习笔记-二&quot; class=&quot;headerlink&quot; title=&quot;redis学习笔记(二)&quot;&gt;&lt;/a&gt;redis学习笔记(二)&lt;/h1&gt;&lt;h4 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h4&gt;&lt;p&gt;​    主从复制是将一台&lt;code&gt;redis&lt;/code&gt;服务器设置为主服务器&lt;code&gt;master&lt;/code&gt;，复制到其他多台从服务&lt;code&gt;slave&lt;/code&gt;上，主服务器负责读写操作，从服务器只能读。&lt;strong&gt;数据的复制只能是主服务器到从服务器。&lt;/strong&gt;当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。&lt;strong&gt;主从服务器之间通过心跳的机制检查服务器间的连接状态&lt;/strong&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记(一)</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2022-07-12T12:50:58.000Z</published>
    <updated>2022-07-12T13:39:30.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis学习笔记-一"><a href="#redis学习笔记-一" class="headerlink" title="redis学习笔记(一)"></a>redis学习笔记(一)</h3><h4 id="一、非关系数据库"><a href="#一、非关系数据库" class="headerlink" title="一、非关系数据库"></a>一、非关系数据库</h4><blockquote><p><code>not only Sql</code>是非关系型数据库</p></blockquote><span id="more"></span><h5 id="1-NoSQL的特点"><a href="#1-NoSQL的特点" class="headerlink" title="1.NoSQL的特点"></a>1.NoSQL的特点</h5><ul><li><p>方便扩展（数据之间没有关系，很好扩展）</p></li><li><p>大数据高性能（8w写，11w读）</p></li><li><p>数据类型多样性（无需事先设计数据库，随取随用）</p></li></ul><h5 id="2-传统RDBMS和NoSQL"><a href="#2-传统RDBMS和NoSQL" class="headerlink" title="2.传统RDBMS和NoSQL"></a>2.传统RDBMS和NoSQL</h5><p>​    传统的<code>RDBMS</code>是结构化组织、建立在<code>SQL</code>语句之上，数据和数据间的关系存储在表中，严格的一致性，事务等。</p><p>​    非关系型数据库<code>NoSQL</code>是没有固定的查询语言，有列存储、键值对存储、图像数据库、文件存储，强调最终一致性，建立在<code>CAP</code>定理和<code>BASE</code>理论，具有高性能、高可用、高可扩。</p><blockquote><p>大数据时代的3V(海量Volume，多样Variety，实时Velocity)+3高(高并发、高可用、高性能)</p></blockquote><h5 id="3-四大分类"><a href="#3-四大分类" class="headerlink" title="3.四大分类"></a>3.四大分类</h5><ol><li><p><strong>KV键值对</strong></p><p>代表性的有<code>redis</code>、<code>memecache</code></p></li><li><p><strong>文档型数据库</strong></p><p><code>MongoDB</code>一个基于分布式文件存储的数据库，<code>C++</code>编写，主要用来处理大量的文档，是一个介于关系型数据库和非关系型数据库的中间产品，<code>MongoDB</code>是非关系型数据库中功能最丰富，最像关系型数据库的。</p></li><li><p><strong>列存储数据库</strong></p><ul><li><code>Hbase</code></li><li>分布式文件系统</li></ul></li><li><p><strong>图关系数据库</strong></p><ul><li>存储拓扑图关系，比如朋友圈社交网络、广告推荐！(<code>Neo4j、infoGrid</code>)</li></ul></li></ol><h4 id="二、redis简介"><a href="#二、redis简介" class="headerlink" title="二、redis简介"></a>二、redis简介</h4><p>​    <code>Redis</code>是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串<code>String</code>， 散列<code>hashes</code>， 列表<code>lists</code>， 集合<code>sets</code>， 有序集合<code>sorted sets</code>与范围查询， <code>bitmaps</code>， <code>hyperloglogs</code>和地理空间<code>geospatial</code>索引半径查询。<code>Redis</code> 内置了复制，<code>LUA</code>脚本，<code>LRU</code>驱动事件，事务<code>transactions</code>和不同级别的磁盘持久化<code>persistence</code>， 并通过<code>Redis</code>哨兵<code>Sentinel</code>和自动分区<code>Cluster</code>提供高可用性<code>high availability</code>。</p><blockquote><p><code>Redis</code> 官方发布效率8w写，11万读 （mysql在300w数据之后需要加索引）</p></blockquote><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><ol><li>内存存储、持久化，内存是断电即失，所以持久化很重要(<code>AOP</code>、<code>RDB</code>)</li><li>效率高可用用于高速缓存。</li><li>发布订阅系统。</li><li>地图信息分析。</li><li>计时器、计数器(浏览量、点赞数、发布数)</li></ol><h5 id="2-单线程"><a href="#2-单线程" class="headerlink" title="2. 单线程"></a>2. 单线程</h5><p><code>redis</code>是单线程，官方表示<code>redis</code>是基于内存操作，<code>CPU</code>不是<code>redis</code>性能瓶颈，<code>redis</code>的性能瓶颈是根据机器的内存和网络带宽。</p><p><strong>redis是单线程为什么还这么快?</strong></p><p>两个误区：高性能服务器一定是多线程？多线程一定比单线程效率高？</p><p>核心是：<code>redis</code>是将所有数据全部存放在内存中，所以使用单线程去操作效率就是最高的，减少了<code>CPU</code>上下文切换的时间，多线程会引发上下文切换，对于内存系统来说，如果没有上下文切换效率就是最高的。而且<code>redis</code>是基于<code>reactor</code>模型，使用的是<code>I/O</code>多路复用的<code>IO</code>模型。</p><p><strong><code>I/O</code>多路复用：</strong>在<code>I/O</code>多路复用模型中，最重要的函数调用就是<code>select</code>，该方法能同时监控多个文件描述符的可读可写情况，当其中某个文件描述符可读或可写时，<code>select</code>方法就会返回可读以及可写的文件描述符个数，<code>netty</code>的底层采用的也是<code>I/O</code>多路复用的模型。</p><h4 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h4><p>​    <code>redis</code>是内存数据库，如果不将内存中的数据保存在硬盘中，若出现断电或者宕机等情况，内存中保存的数据也会丢失。</p><h5 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h5><p>​    <code>RDB</code>全称是<code>Redis DataBase</code>，在指定的时间间隔内将内存中的数据集快照<code>Shapshot</code>写入磁盘，恢复时只需要将快照加载入内存即可，默认保存的文件名为<code>dump.rdb</code>。</p><p>​    <code>redis</code>会通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有内存数据写入到一个临时文件中，待持久化结束后，会替换掉上一次持久化好的文件。整个过程，主进程不进行任何<code>I/O</code>操作，确保了极高的性能。并且<code>.rdb</code>是二进制文件，比较轻量，灾难之后的恢复会快一些。</p><p><strong>两种方式</strong></p><ul><li><code>save</code>：阻塞主线程，使得主线程不能继续对外提供请求，若数据量小，将数据写入备份文件快，则没有多大影响，若数据量大，写入备份文件时间长，则写多长时间就会停机多长时间。</li><li><code>bgsave</code>：主线程<code>fork</code>子进程，子进程进行数据的备份，主进程在<code>fork</code>子进程时阻塞，之后不会阻塞，相比于<code>save</code>方式，阻塞时间可以忽略不计。</li></ul><p><strong><code>bgsave</code>的原理</strong></p><p>​    主进程在<code>fork()</code>子进程之后，内核把主进程所有的内存页的权限都设置为<code>read-only</code>，然后将子进程的地址空间指向主进程。所以这里两个进程共享了同一块内存空间，最极端的情况当子进程在备份数据时，主进程接收到写请求，这时由于内存页的权限是<code>read-only</code>，会触发页异常中断后，会将这个数据的内存页复制一份，并且主进程指向该内存页。所以可以得出，在某一个时间节点触发了<code>bgsave</code>，则它只会备份那个时间节点的数据，那个时间节点只有的写操作，它都无法处理到。从一般设计来说，缓存中都是使用频繁且读多写少的数据，所以这一机制并不会使得在备份时频繁带来内存页数据异常导致的性能问题。</p><h5 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h5><p>​    <code>AOF</code>全称是<code>Append only file</code>，以日志的形式来记录每个写操作(默认情况是关闭)，将<code>redis</code>执行过的所有写操作命令备份下来，会把写操作命令一直追加到文件中。恢复时，默认会读取<code>appendonly.aof</code>文件中的命令，逐个执行命令，使得数据恢复。</p><p>​    <code>redis</code>通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有<code>AOF</code>缓冲区的命令同步到<code>appendonly.aof</code>文件中。</p><p><strong><code>AOF</code>的配置项</strong></p><ul><li><code>appendonly on</code>：默认是关闭状态</li><li><code>appendfilename &quot;appendonly.aof&quot;</code>：默认的持久化文件名称</li><li><code>appendfsync always</code>：同步策略，有三种<code>always</code>(每次修改都会同步)，<code>everysec</code>(每秒同步一次)，<code>no</code>由操作系统控制同步，默认是<code>everysec</code></li></ul><p><strong><code>AOF</code>重写</strong></p><p>​    <code>AOF</code>重写会在保持最终数据一致的前提下，将一些多条命令，整合成一条命令来代替多条命令。<code>AOF</code>重写是通过子进程的方式进行，使用子进程不会阻塞父进程，使得父进程还是可以处理客户端请求，并且子进程可以继承父进程资源，并且这种继承采取<code>copy-on-write</code>的策略，所以<code>AOF</code>重写无需关心由于客户端写请求导致数据不一致问题。</p><p>​    <code>AOF</code>重写的写命令不仅要写入到<code>AOF</code>缓冲区，还会写入<code>AOF</code>重写缓冲区，写入原<code>AOF</code>缓冲区是为了避免若重写失败导致数据丢失；写入<code>AOF</code>重写缓冲区是为了子进程在进行<code>AOF</code>重写期间还是在继续处理命令请求。</p><p>​    子进程在重写完毕后会发送一个信号给父进程，父进程收到信号后，会将<code>AOF</code>重写缓冲区的所有内容写入到新的<code>AOF</code>文件中，并且采用原子操作覆盖现有<code>AOF</code>文件，完成新旧文件的替换。</p><p><strong>小结</strong></p><p>​    如果需要大规模恢复数据，且对数据恢复的完整性不是非常敏感，那么<code>RDB</code>比<code>AOF</code>方式更加有效，<code>RDB</code>的缺点是最后一次持久化可能会丢失一部分数据。若从安全性来说，<code>AOF</code>会比较高一点，<code>AOF</code>最多丢失1秒的数据(采用默认配置的话)，而<code>RDB</code>丢失上一次备份与宕机时间差之间的数据。在<code>redis</code>服务器开启<code>AOF</code>持久化功能时，会采用<code>AOF</code>文件来恢复数据，若没有开启<code>AOF</code>功能时，才会使用<code>RDB</code>来恢复数据。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;redis学习笔记-一&quot;&gt;&lt;a href=&quot;#redis学习笔记-一&quot; class=&quot;headerlink&quot; title=&quot;redis学习笔记(一)&quot;&gt;&lt;/a&gt;redis学习笔记(一)&lt;/h3&gt;&lt;h4 id=&quot;一、非关系数据库&quot;&gt;&lt;a href=&quot;#一、非关系数据库&quot; class=&quot;headerlink&quot; title=&quot;一、非关系数据库&quot;&gt;&lt;/a&gt;一、非关系数据库&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;not only Sql&lt;/code&gt;是非关系型数据库&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Springboot请求响应乱码</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/10/Spring/Springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%B9%B1%E7%A0%81/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/10/Spring/Springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%B9%B1%E7%A0%81/</id>
    <published>2022-07-10T03:37:20.000Z</published>
    <updated>2022-07-22T03:34:40.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot请求响应乱码"><a href="#Springboot请求响应乱码" class="headerlink" title="Springboot请求响应乱码"></a>Springboot请求响应乱码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在一个项目中出现了一个比较棘手的问题，情况是这样的：由于项目场景的需要，引入了公司技术架构部门在<code>activiti</code>工作流的基础上进行二次开发的工作流组件，使用该组件，需要实现几个获取岗位信息、人员信息相关的接口，工作流组件通过<code>restTemplate</code>调用这些接口来获取对应的人员、岗位信息用于工作流服务的节点信息显示，在开发过程中一切正常且部署到开发环境中调试过程中也是一切正常，但是当部署到测试环境后，发现接口出现乱码。</p><span id="more"></span><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>​    由于工作流服务采用的是<code>tomcat</code>方式部署，第一反应是修改<code>tomcat</code>中的相关配置文件<code>web.xml</code>和<code>server.xml</code>的相关配置，但是修改之后发现并无效果。又尝试在测试环境使用开发环境的正常使用的镜像，还是出现乱码，到这个时候真的是一点头绪都没有了，不知从何下手。在不断的排查过程中，发现仅仅是通过<code>restTemplate</code>请求业务服务的岗位信息、人员信息接口出现了乱码问题，其他接口并无异常。</p><p>​    而后发现开发环境和测试环境的同一个接口，响应时的<code>Content-Type</code>中，测试环境少了<code>charset=UTF-8</code>，马上使用<code>@RequestMapping</code>的<code>produces = &quot;application/json;charset=UTF-8&quot;</code>指定编码方式，经测试，正常解决乱码问题！！！</p><p><img src="https://s2.loli.net/2022/07/10/7YJc9hMUXdjStWg.png" alt="测试环境工作流请求返回.png"></p><p><img src="https://s2.loli.net/2022/07/10/PWksefL5D4HZN6a.png" alt="开发环境工作流返回.png"></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>​    在解决这个乱码问题之后，其实还是很疑惑的，为什么在开发环境和测试环境出现了不同的<code>Content-Type</code>响应头信息，测试环境响应头中的<code>charset=UTF-8</code>为什么会消失？由于我们是采用指定了<code>@RequestMapping</code>注解的<code>produces</code>属性才解决问题，那么具体的情况还得从它入手，如果不指定值，那么它默认的处理逻辑是什么？</p><p>跟踪源码发现：在<code>HeaderContentNegotiationStrategy</code>进行了<code>api</code>媒体类型的相关处理，主要逻辑是获取请求头中的<code>accept</code>属性值，若为空，则指定<code>*/*</code>为结果值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MediaType&gt; <span class="title">resolveMediaTypes</span><span class="params">(NativeWebRequest request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取请求头中的accept属性</span></span><br><span class="line">    String[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT);</span><br><span class="line">    <span class="keyword">if</span> (headerValueArray == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若为空，则返回所有 -&gt; 实际值就是: */*</span></span><br><span class="line">        <span class="keyword">return</span> MEDIA_TYPE_ALL_LIST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; headerValues = Arrays.asList(headerValueArray);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues);</span><br><span class="line">        MediaType.sortBySpecificityAndQuality(mediaTypes);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(</span><br><span class="line">                <span class="string">&quot;Could not parse &#x27;Accept&#x27; header &quot;</span> + headerValues + <span class="string">&quot;: &quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着会进入<code>AbstractMessageConverterMethodProcessor#getProducibleMediaTypes</code>这个返回主要用于返回响应的媒体类型，主要会通过响应的返回值的数据类型根据具体的媒体转换器的<code>canWrite</code>方法来获取支持的媒体类型。</p><p>根据测试发现，如果在<code>accept</code>或者是<code>@RequestMapping</code>指定了<code>produces</code>属性值，那么这里直接获取到对应的值之后就返回了，而下面的通过默认的消息转换器中获取到的媒体类型都是不带具体的编码格式的，比如我的这个接口返回的主要就是<code>application/json</code>、<code>application/*+json</code>两种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;MediaType&gt; <span class="title">getProducibleMediaTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, Class&lt;?&gt; valueClass, <span class="meta">@Nullable</span> Type targetType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这里获取不到媒体的类型的情况下，进入下面的消息转换器获取，</span></span><br><span class="line">    <span class="comment">// 如果在@RequestMapping中指定了produces或者是原本请求头中的accept中指定了值，这里直接就是获取到指定的那个值    </span></span><br><span class="line">    Set&lt;MediaType&gt; mediaTypes =</span><br><span class="line">            (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(mediaTypes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(mediaTypes);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allSupportedMediaTypes.isEmpty()) &#123;</span><br><span class="line">        List&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">            <span class="comment">// 通过消息转换器获取响应结果支持的媒体类型</span></span><br><span class="line">            <span class="comment">// 比如接口的返回类型是List，则这里会获取到application/json、application/*+json</span></span><br><span class="line">            <span class="comment">// 返回类型是String，可能会有其他的媒体类型之类</span></span><br><span class="line">            <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter &amp;&amp; targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((GenericHttpMessageConverter&lt;?&gt;) converter).canWrite(targetType, valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    result.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (converter.canWrite(valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                result.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(MediaType.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    在我们公司其实研发也是获取不到开发环境、测试环境的服务器登录等相关权限，都是需要告诉运维人员要操作什么，或者获取到对应的配置文件信息，然后进行更改，所以现在尽管知道了可能是请求头中的<code>accept</code>在测试环境中存在丢失的情况，也没有办法进入测试环境进行具体问题的排查，仅通过这一问题，对请求、响应的相关细节有了进一步的了解。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Springboot请求响应乱码&quot;&gt;&lt;a href=&quot;#Springboot请求响应乱码&quot; class=&quot;headerlink&quot; title=&quot;Springboot请求响应乱码&quot;&gt;&lt;/a&gt;Springboot请求响应乱码&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在一个项目中出现了一个比较棘手的问题，情况是这样的：由于项目场景的需要，引入了公司技术架构部门在&lt;code&gt;activiti&lt;/code&gt;工作流的基础上进行二次开发的工作流组件，使用该组件，需要实现几个获取岗位信息、人员信息相关的接口，工作流组件通过&lt;code&gt;restTemplate&lt;/code&gt;调用这些接口来获取对应的人员、岗位信息用于工作流服务的节点信息显示，在开发过程中一切正常且部署到开发环境中调试过程中也是一切正常，但是当部署到测试环境后，发现接口出现乱码。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="乱码" scheme="http://xiaocainiaoya.github.io/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>webService初试</title>
    <link href="http://xiaocainiaoya.github.io/2022/03/02/java/webservice%E5%88%9D%E8%AF%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/03/02/java/webservice%E5%88%9D%E8%AF%95/</id>
    <published>2022-03-02T13:51:58.000Z</published>
    <updated>2022-03-02T07:13:45.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webService初试"><a href="#webService初试" class="headerlink" title="webService初试"></a>webService初试</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近工作上需要将一些业务数据推送到各个门户网站，而各个门户网站上接收数据的方式不一样，有<code>webservice</code>和<code>http</code>两种方式，初次使用<code>webservice</code>，记录一下踩得一些坑。<span id="more"></span></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>​    使用<code>hutool</code>中的<code>SoapClient</code>配合<code>SoapUi</code>工具进行使用。</p><ol><li><p>使用<code>SoapUi</code>工具解析<code>WSDL</code>地址，得到这个地址提供的方法，再进入相应的方法，得到请求这个方法的<code>xml</code>结构。</p><p><img src="https://s2.loli.net/2022/03/02/BTNvykhem238QDE.png" alt="Snipaste_2022-03-02_14-40-27.png"></p><p>例子中: 这个<code>WSDL</code>提供了四个调用方法，然后点击<code>Request1</code>弹出右边部分。右边部分为对这个方法发起请求的<code>xml</code>结构，这时只需要通过<code>hutool</code>工具类<code>SoapClient</code>创建一个一致的<code>xml</code>请求结构后发起请求即可。</p><ol start="2"><li><p>直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SoapClient client = SoapClient.create(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    .setCharset(Charset.forName(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    .setMethod(<span class="string">&quot;调用的方法名&quot;</span>, <span class="string">&quot;命名空间&quot;</span>)</span><br><span class="line">    .setParam(<span class="string">&quot;参数名称&quot;</span>, <span class="string">&quot;参数值&quot;</span>);</span><br><span class="line">  <span class="comment">// 打印请求数据</span></span><br><span class="line">  log.info(<span class="string">&quot;webService请求: \n&#123;&#125;&quot;</span>, client.getMsgStr(<span class="keyword">false</span>));</span><br><span class="line">  client.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上就完成了<code>webService</code>的调用，使用上还是比较简单，主要是第一次使用<code>webService</code>，到处磕磕碰碰。</p></li></ol><p><strong>1.SoapUI解析错误</strong></p><p>部分门户使用<code>SoapUI</code>直接解析对应的<code>http://xxx/xxx.asmx?wsdl</code>地址，出现以下报错：</p><p><code>     Error loading [http://htgs.ccgp.gov.cn/GS8/services/Gs8WebService?wsdl]:     org.apache.xmlbeans.XmlException: org.apache.xmlbeans.XmlException: error:     The element type &quot;hr&quot; must be terminated by the matching end-tag </code>。</p><p>解决方案为通过浏览器进入这个地址，将这个页面中的内容保存为<code>xx.wsdl</code>文件，使用<code>SoapUI</code>加载这个文件。</p><p><strong>1. 使用postman调用</strong></p><p>在通过代码进行<code>webService</code>请求之前，实际上应该通过<code>SoapUI</code>发起请求，看是否能调用成功。(请求方式为上图右部分的绿色按钮)。但是有一个接口，由于使用<code>http://xx</code>地址解析失败后采用<code>xx.wsdl</code>文件的方式解析，这个接口一直不能发起请求。</p><p>解决方案为使用<code>postman</code>发起请求。设置头信息中<code>text/xml; charset=UTF-8</code>，然后<code>body</code>请求体中的参数修改为<code>raw</code>后选择<code>XML(text/xml)</code>后就可以发起对<code>webService</code>服务的请求。</p><p><strong>3.请求数据</strong></p><p>假设发起请求要携带的参数值为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user_name</span>&gt;</span>zanshang<span class="tag">&lt;/<span class="name">user_name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user_age</span>&gt;</span>15<span class="tag">&lt;/<span class="name">user_age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么实际上是需要将这个参数值填入到对应位置，实际发起的请求中是需要将<code>&lt;</code>和<code>&gt;</code>等字符进行编码化。<code>&amp;lt;</code>和<code>&amp;gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>body<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>user_name<span class="symbol">&amp;gt;</span>zanshang<span class="symbol">&amp;lt;</span>/user_name<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>user_age<span class="symbol">&amp;gt;</span>15<span class="symbol">&amp;lt;</span>/user_age<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>/body<span class="symbol">&amp;gt;</span></span><br></pre></td></tr></table></figure><p><strong>4.请求地址中?wsdl</strong></p><p>对<code>webService</code>的请求地址中是否需要<code>?wsdl</code>，就目前而言部分接口是需要，部分接口是不需要。这就使得调用是不知道需不需要带上，遇到过一个问题是这个接口实际上是不需要携带，但我在请求时携带了，然后请求返回的内容是这个访问地址的内容，还一直以为是请求的参数或者是姿势不对，排查了好久才找到问题。</p><p><strong>5.返回处理</strong></p><p>最让我觉得难受的是<code>webService</code>请求之后处理，因为对接了好几个门户网站，每个门户都返回一种不同的结构。情况非常多：</p><p><strong>异常情况：</strong>A门户的异常返回的是重定向页面的内容还包含了图片的<code>base64</code>串。B门户调用过于频繁也是返回一个重定向页面的内容。</p><p><strong>正常情况：</strong>A门户是在一种<code>xml</code>结构中的里层嵌入一个<code>json</code>串。B门户是在<code>xml</code>中用<code>![[DATA]]</code>的方式嵌入一个<code>xml</code>结构数据。然而AB门户的外层<code>xml</code>结构都不一致。</p><p>综上基本上每个门户的请求参数和返回都需要进行定制化，无法抽象出来达到通用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;webService初试&quot;&gt;&lt;a href=&quot;#webService初试&quot; class=&quot;headerlink&quot; title=&quot;webService初试&quot;&gt;&lt;/a&gt;webService初试&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近工作上需要将一些业务数据推送到各个门户网站，而各个门户网站上接收数据的方式不一样，有&lt;code&gt;webservice&lt;/code&gt;和&lt;code&gt;http&lt;/code&gt;两种方式，初次使用&lt;code&gt;webservice&lt;/code&gt;，记录一下踩得一些坑。</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>git记录</title>
    <link href="http://xiaocainiaoya.github.io/2022/01/10/git/git%E8%AE%B0%E5%BD%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/01/10/git/git%E8%AE%B0%E5%BD%95/</id>
    <published>2022-01-10T13:51:58.000Z</published>
    <updated>2022-09-19T01:42:57.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>旨在记录在使用<code>git</code>过程中出现的一些问题和使用上的一些操作记录、或者是<code>git</code>一些概念上的理解，防止重复踩坑。</p></blockquote><span id="more"></span><h4 id="1-强制回滚远程git仓库的某个提交"><a href="#1-强制回滚远程git仓库的某个提交" class="headerlink" title="1. 强制回滚远程git仓库的某个提交"></a>1. 强制回滚远程<code>git</code>仓库的某个提交</h4><p>简单描述一下<code>git</code>的操作流程: </p><ol><li>工作区编写代码通过<code>add</code>命令添加到暂存区</li><li>暂存区通过<code>commit</code>命令添加到本地版本库</li><li>本地版本库通过<code>push</code>命令将本地代码推送到远程代码库</li></ol><p><code>git reset --soft HEAD^</code>  将本地仓库回滚为指定版本，且多余的提交回滚到暂存区</p><p><code>git reset --fixed HEAD^</code> 将本地仓库和暂存区回滚为指定版本</p><p><code>git reset --hard HEAD^</code> 将本地仓库、暂存区和工作区回滚为指定版本</p><p>强制回滚一个提交步骤:</p><ol><li>拉取需要修改的分支代码</li><li>通过<code>git reset --hard HEAD^</code>命令回滚一个提交</li><li>通过<code>git push --force</code>强制推送到远程代码库</li></ol><h4 id="2-在git中-和-的区别"><a href="#2-在git中-和-的区别" class="headerlink" title="2. 在git中~和^的区别"></a>2. 在<code>git</code>中<code>~</code>和<code>^</code>的区别</h4><p><code>HEAD^</code>, <code>HEAD^1</code>, <code>HEAD~</code>三个表达式都表示<code>HEAD</code>的父提交</p><p><code>HEAD^n</code>: 指的是<code>HEAD</code>的第<code>n</code>个父提交(有多个父提交的前提下[这里的父提交实际上是合并操作])<br><code>HEAD~n</code>: 指的是<code>HEAD</code>的第<code>n</code>个祖先提交(这里需要区分父提交和祖先提交的区别)，所以<code>HEAD~n=HEAD^^^(n个^)</code><br><img src="https://s2.loli.net/2022/01/10/q6iVtARvPXImlCZ.png" alt="git中^和~的区别.png"></p><h4 id="3-log和reflog的区别"><a href="#3-log和reflog的区别" class="headerlink" title="3. log和reflog的区别"></a>3. <code>log</code>和<code>reflog</code>的区别</h4><ul><li><code>reflog</code>: 可以查看所有分支的所有操作记录(包括已经删除的提交或者是重置的提交)</li><li><code>log</code>: 不能查看被删除的提交</li></ul><p>基于以上两个命令的区别<code>reflog</code>在一些场景下可以提供一些妙用。<br>比如:<br><strong>查看某个分支是基于那个分支迁出:</strong> <code>git reflog --date=local | grep &lt;分支名称&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 输出信息</span><br><span class="line">077b02d HEAD@&#123;Fri Jan 7 17:03:26 2022&#125;: checkout: moving from 原分支名称 to 迁出后分支名称</span><br></pre></td></tr></table></figure><h4 id="4-revert"><a href="#4-revert" class="headerlink" title="4.revert"></a>4.revert</h4><p>​    <code>revert</code>是重做的意思，可以对推送到远程仓库的提交进行撤销。假设不小心将开发分支的功能合并到基线分支，这时就可以通过<code>revert</code>命令进行撤销操作。</p><p>这里以<code>gitlab</code>为例：</p><p><img src="https://s2.loli.net/2022/09/19/UfePvIbQJg6Rsta.png" alt="revert.png"></p><p>通过使用<code>gitlab</code>进入需要撤回的<code>merge</code>记录，选择右上角<code>options-&gt;Revert</code>，这时会生成一个<code>revert-xxxx</code>的分支，同时将该分支合并到基线分支，也就是将<code>revert</code>提交合并到基线分支。</p><p>这时基线分支撤销之后，当开发分支的功能开发完毕后，将开发分支合并到基线分支，会发现部分代码丢失，而丢失的正是之前<code>revert</code>操作撤销的那部分提交。所以只需要对之前的<code>revert</code>操作再次进行<code>revert</code>操作即可。简单来说就是负负得正的逻辑。</p><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#120;&#105;&#97;&#x6f;&#x63;&#x61;&#x69;&#x6e;&#x69;&#97;&#x6f;&#x79;&#x61;&#64;&#102;&#x6f;&#120;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;">&#120;&#105;&#97;&#x6f;&#x63;&#x61;&#x69;&#x6e;&#x69;&#97;&#x6f;&#x79;&#x61;&#64;&#102;&#x6f;&#120;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;旨在记录在使用&lt;code&gt;git&lt;/code&gt;过程中出现的一些问题和使用上的一些操作记录、或者是&lt;code&gt;git&lt;/code&gt;一些概念上的理解，防止重复踩坑。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Lock4j的锁代理浅析</title>
    <link href="http://xiaocainiaoya.github.io/2021/12/29/Spring/Lock4j%E7%9A%84%E9%94%81%E4%BB%A3%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2021/12/29/Spring/Lock4j%E7%9A%84%E9%94%81%E4%BB%A3%E7%90%86%E6%B5%85%E6%9E%90/</id>
    <published>2021-12-29T05:09:33.000Z</published>
    <updated>2021-12-29T06:18:06.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lock4j的锁代理浅析"><a href="#Lock4j的锁代理浅析" class="headerlink" title="Lock4j的锁代理浅析"></a>Lock4j的锁代理浅析</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>​    工作项目中使用<code>baomidou</code>的<code>lock4j</code>来进行分布式锁相关处理。在使用中还是出现了一些状况, 不得不稍微理解下<code>lock4j</code>中的一些基本设计思路和方式。<span id="more"></span></p><h3 id="二、基本知识"><a href="#二、基本知识" class="headerlink" title="二、基本知识"></a>二、基本知识</h3><p>​    在<code>Spring</code>中使用<code>AOP</code>实际上有好几种方式: 通过@AspectJ注解方式、通过<code>xml</code>配置文件方式、通过实现开放的一些抽象接口或者具体的实现方式。不论是使用哪种方式, 都需要指定出<code>AOP</code>中一些必备的结构。<br>这里简单描述下一些必需创建的结构:</p><ul><li>增强(<code>Advice</code>): 很多地方称为通知, 但实际上理解为增强更为准确. 用于表示具体的增强逻辑, 这里以日志前置增强为例, 前置增强顾名思义就是在某个逻辑之前添加保存日志的增强逻辑, 这里的日志保存逻辑即前置增强需要处理的逻辑, 所以前置增强的逻辑实际上就是一段处理逻辑代码, 和具体的目标逻辑之间没有关系. </li><li>切入点(<code>Pointcut</code>): 用于表示具体要切入的地方, 以上述前置增强为例, 在编写好日志增强的逻辑代码之后, 要应用到多少个地方, 也就是多少个地方需要添加这个日志前置增强, 这里就需要由切入点来标记具体需要切入的地方。</li><li>切面(<code>Aspect</code>): 切面可以简单理解为增强<code>Advice</code>和切入点<code>Pointcut</code>的组合.</li><li>目标对象(<code>Target Object</code>): 用于表示具体被增强的对象, 因为在<code>Spring</code>中是通过动态代理来实现切面处理, 故被增强对象就是目标对象.</li><li>代理对象(<code>AOP Proxy</code>): 用于表示将切面应用到目标对象而创建的代理对象。</li></ul><h3 id="三、浅析"><a href="#三、浅析" class="headerlink" title="三、浅析"></a>三、浅析</h3><p>​    在<code>lock4j</code>项目中, 大致的锁代理机制为创建一个基于<code>LockInterceptor</code>环绕增强的<code>Advice</code>和<code>@Lock4j</code>注解标记的切点<code>Pointcut</code>的<code>LockAnnotationAdvisor</code>切面。 </p><ol><li><p>环绕增强<code>Advice</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LockTemplate lockTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockInterceptor</span><span class="params">(LockTemplate lockTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockTemplate = lockTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的环绕增强逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/12/29 11:31:23</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LockInfo lockInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Lock4j lock4j = invocation.getMethod().getAnnotation(Lock4j.class);</span><br><span class="line">            Lock4jConfig lock4JConfig = Lock4jConfig.builder().client(lock4j.client()).type(lock4j.type())</span><br><span class="line">                    .keys(lock4j.keys()).lockKeyBuilder(lock4j.keyBuilder()).acquireTimeout(lock4j.acquireTimeout())</span><br><span class="line">                    .expire(lock4j.expire()).lockFailureStrategy(lock4j.lockFailureStrategy()).build();</span><br><span class="line">            LockTemplate lockTemplateProxy = (LockTemplate) <span class="keyword">new</span> Lock4jProxyFactory(lockTemplate).getProxyInstance();</span><br><span class="line">            lockInfo = lockTemplateProxy.lock(invocation, lock4JConfig);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockInfo) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockInfo) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;[@Lock4j] releaseLock , current lockKey = &#123;&#125; &quot;</span>,lockInfo.getLockKey());</span><br><span class="line">                lockTemplate.releaseLock(lockInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切点<code>Pointcut</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记在方法上标记Lock4j注解的方法即为此aop的切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut = AnnotationMatchingPointcut.forMethodAnnotation(Lock4j.class);</span><br></pre></td></tr></table></figure></li><li><p>切面<code>LockAnnotationAdvisor</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记在方法上标记Lock4j注解的方法即为此aop的切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut = AnnotationMatchingPointcut.forMethodAnnotation(Lock4j.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockAnnotationAdvisor</span><span class="params">(<span class="meta">@NonNull</span> LockInterceptor lockInterceptor, <span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = lockInterceptor;</span><br><span class="line">        setOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pointcut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在增强中加入了bean工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/12/29</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advice <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) <span class="keyword">this</span>.advice).setBeanFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上就实现了若在方法上标记了<code>@Lock4j</code>注解就会进入到<code>LockInterceptor</code>的增强逻辑上进行具体的加锁逻辑。</strong><br>所以此实现采用的是<code>Advice</code>+<code>methodInterceptor</code>组合实现一个切面<code>Advisor</code>来实现<code>AOP</code>的逻辑。实际上此实现也可以通过<code>@Aspect</code>注解来实现, 在实际的工作过程中我感觉使用<code>@Aspect</code>注解的方式更为简单, 更容易让人理解。</p><p><strong>若在某个方法上同时使用<code>@Transactional</code>和<code>@Lock4j</code>那么锁对事物会不会有所影响？</strong><br>这边先下结论: 1.上锁 -&gt; 2.开启事务 -&gt; 3.执行逻辑 -&gt; 4.提交/回滚事务 -&gt; 5.释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里标记这个切面的order = HIGHEST_PRECEDENCE = Integer.MIN_VALUE;(最小值)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/12/29 11:44:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LockAnnotationAdvisor <span class="title">lockAnnotationAdvisor</span><span class="params">(LockInterceptor lockInterceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LockAnnotationAdvisor(lockInterceptor, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建锁切面对象时设置了<code>Order</code>排序号为最小值, 所以若在某个方法上同时使用<code>@Transactional</code>和<code>@Lock4j</code>, 在代理类的<code>advisors</code>列表中的第一个元素就是<code>LockAnnotationAdvisor</code>, 第二个元素才是事物处理增强。<br><img src="https://s2.loli.net/2021/12/29/8aKTRhwdom1Q37X.png" alt="锁代理.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Lock4j的锁代理浅析&quot;&gt;&lt;a href=&quot;#Lock4j的锁代理浅析&quot; class=&quot;headerlink&quot; title=&quot;Lock4j的锁代理浅析&quot;&gt;&lt;/a&gt;Lock4j的锁代理浅析&lt;/h2&gt;&lt;h3 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h3&gt;&lt;p&gt;​    工作项目中使用&lt;code&gt;baomidou&lt;/code&gt;的&lt;code&gt;lock4j&lt;/code&gt;来进行分布式锁相关处理。在使用中还是出现了一些状况, 不得不稍微理解下&lt;code&gt;lock4j&lt;/code&gt;中的一些基本设计思路和方式。</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Stream基本使用</title>
    <link href="http://xiaocainiaoya.github.io/2021/12/15/java/Stream%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/12/15/java/Stream%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-15T13:51:58.000Z</published>
    <updated>2021-12-15T08:04:27.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>​    <code>jdk8</code>中引入的函数式<code>lambda</code>表示式，同时引入了<code>Stream</code>流，这种流可以堆集合进行一些复杂查找、过滤、映射、规约等操作。一个<code>stream</code>是由三部分组成，<code>数据源流 -&gt;零个或多个中间操作 -&gt; 零个或一个终止操作</code>。中间操作是对数据的加工处理并且中间操作是懒<code>lazy</code>操作，并不会马上启动，需要等待终止操作允许到才会开始执行。<span id="more"></span></p><p><img src="https://s2.loli.net/2021/12/15/1SnxVPmy6G8sfth.png" alt="stream.png"></p><p><code>Stream</code>分为终端操作和中间操作。</p><ul><li>终端操作：也称为结束操作，即不能在继续处理数据。</li><li>中间操作：就是可以使用上一次处理的结果进行再次处理数据。</li></ul><p>终端操作又分为短路操作和非短路操作：</p><ul><li>短路操作：所有数据项不一定都需要处理完成即可结束。类似于<code>a || b</code>，这种判断语句只要某个数据项使得<code>a=true</code>即结束遍历。</li><li>非短路操作：所有数据项都需要遍历一遍方才结束。</li></ul><p>中间操作又分为有状态和无状态：</p><ul><li>有状态：表示改操作只有等待拿到所有元素后才能继续下去。</li><li>无状态：表示元素的处理不受其他元素的影响。</li></ul><p>比如：<code>sorted()</code>排序，需要获取到流中的所有元素后才能进行排序。而<code>filter()</code>只需要获取流中的一个元素就可以进行处理。</p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-终端操作"><a href="#2-1-终端操作" class="headerlink" title="2.1 终端操作"></a>2.1 终端操作</h3><h4 id="2-1-1-短路操作"><a href="#2-1-1-短路操作" class="headerlink" title="2.1.1 短路操作"></a>2.1.1 短路操作</h4><h5 id="2-1-1-1-匹配"><a href="#2-1-1-1-匹配" class="headerlink" title="2.1.1.1 匹配"></a>2.1.1.1 匹配</h5><p><strong>1.<code>find</code></strong></p><ul><li><p><code>findFirst</code>：获取数据流中的第一个元素</p></li><li><p><code>findAny</code> ：随机获取数据流中的一个元素(然而大部分情况下是返回第一个元素)</p></li></ul><p>通过<code>findFirst/findAny</code>返回的是一个<code>Optional&lt;T&gt;</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(list.stream().findFirst().get());</span><br><span class="line">    System.out.println(list.stream().findAny().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.<code>match</code></strong></p><ul><li><code>anyMatch</code>：数据流中仅有一个数据项满足<code>Predicate</code>即返回<code>true</code></li><li><code>allMatch</code>：数据流中所有数据项满足<code>Predicate</code>才返回<code>true</code></li><li><code>noneMatch</code>：数据流中所有数据项都不满足<code>Predicate</code>才返回<code>true</code></li></ul><p><strong>注意：</strong>当数据列表为空时, <code>allMatch</code>的返回值为<code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(list.stream().anyMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(list.stream().allMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(list.stream().noneMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 特殊情况, 数据列表为空</span></span><br><span class="line">    List&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(items.stream().anyMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(items.stream().allMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(items.stream().noneMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-非短路操作"><a href="#2-1-2-非短路操作" class="headerlink" title="2.1.2 非短路操作"></a>2.1.2 非短路操作</h4><h5 id="2-1-2-1-遍历"><a href="#2-1-2-1-遍历" class="headerlink" title="2.1.2.1 遍历"></a>2.1.2.1 遍历</h5><ul><li> 在<code>stream.forEach</code>中不能使用<code>break</code>和<code>continue</code>关键字, 但<code>stream.forEach</code>中<code>return</code>和 <code>continue</code>达到的效果一致。</li><li> 在<code>parallelStream.forEachOrdered</code>可以使得结果有序, 但同时牺牲了并行流的好处。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().forEach(item -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(item % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(item);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.parallelStream().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.parallelStream().forEachOrdered(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-2-聚合"><a href="#2-1-2-2-聚合" class="headerlink" title="2.1.2.2 聚合"></a>2.1.2.2 聚合</h5><blockquote><p>max/min/count</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aggregation</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自然排序</span></span><br><span class="line">    System.out.println(list.stream().max(Integer::compareTo).get());</span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    Integer max = list.stream().max(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).get();</span><br><span class="line">    System.out.println(max);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.stream().min(Integer::compareTo).get());</span><br><span class="line"></span><br><span class="line">    System.out.println(list.stream().count());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-3-规约"><a href="#2-1-2-3-规约" class="headerlink" title="2.1.2.3 规约"></a>2.1.2.3 规约</h5><p><strong><code>reduce</code></strong></p><blockquote><p>规约: 将一个流通过一些计算/逻辑规约为一个值</p></blockquote><p>第三个参数一般使用不到, 用处是在使用并行流(<code>parallelStream</code>)时, 最终将所有并行流的数据进行规约。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;求和: &quot;</span> + list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b));</span><br><span class="line">    System.out.println(<span class="string">&quot;求积: &quot;</span> + list.stream().reduce(<span class="number">1</span>, (a, b) -&gt; a * b));</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值: &quot;</span> + list.stream().reduce((a, b) -&gt; a &gt; b ? a : b).get());</span><br><span class="line">    <span class="comment">// reduce三个参数的方法</span></span><br><span class="line">    <span class="comment">// 这种情况下会输出最大值, 在stream流下并不会调用第三个参数。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;stream最大值: &quot;</span> + list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a &gt; b ? a : b,  (a, b) -&gt; <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 这种情况输出结果为null, 因为在每个并行流中计算得到每个并行流中的最大值后, 通过第三个参数将并行流的结果合并。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;parallelStream最大值: &quot;</span> + list.parallelStream().reduce(<span class="number">0</span>, (a, b) -&gt; a &gt; b ? a : b,  (a, b) -&gt; <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-4-收集"><a href="#2-2-2-4-收集" class="headerlink" title="2.2.2.4 收集"></a>2.2.2.4 收集</h5><p><code>collect</code><br>在<code>stream</code>流中<code>collect</code>是功能最多的操作，可以将流中的数据收集为一个值或者一个集合。主要是依赖于<code>java.util.stream.Collectors</code>类内置的静态方法。</p><p><code>collect(Collector&lt;? super T, A, R&gt; collector)</code>中传入的是<code>Collector</code>对象, 主要使用为实现对象<code>java.util.stream.Collectors</code>。在<code>Collectors</code>中内置了很多具体收集的静态方法<br>而这些静态方法最终也都依赖于静态内部实现类<code>CollectorImpl&lt;T, A, R&gt;</code>。这里简单理解下<code>CollectorImpl&lt;T, A, R&gt;</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (T:输入元素类型, A:累加类型, R:最后返回的对象类型)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectorImpl</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 中间收集集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;A&gt; supplier;</span><br><span class="line">    <span class="comment">// 累加算法/收集算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiConsumer&lt;A, T&gt; accumulator;</span><br><span class="line">    <span class="comment">// 规约(主要针对并行流下规约每个流中的数据)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryOperator&lt;A&gt; combiner;</span><br><span class="line">    <span class="comment">// 结果操作(比如joining操作, 是先将数据收集到StringBuilder中, 最后通过</span></span><br><span class="line">    <span class="comment">// stringBuilder.toString返回结果, 这里finisher=StringBuilder:toString)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, R&gt; finisher;</span><br><span class="line">    <span class="comment">// 收集器特性, 有三个</span></span><br><span class="line">    <span class="comment">// UNORDERED: 规约结果不受流中元素的遍历和累加的顺序影响</span></span><br><span class="line">    <span class="comment">// CONCURRENT: 该收集器可以并行规约流</span></span><br><span class="line">    <span class="comment">// IDENTITY_FINISH: 表明finisher是一个恒等函数, 可以跳过(累加器的结果就是收集的最终结果)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Characteristics&gt; characteristics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举两个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入类型为T, 累加类型为?, 最后返回对象类型为List&lt;T&gt;。</span></span><br><span class="line"><span class="comment">// 假设调用为: students.stream().map(Student::getAge).collect(Collectors.toList())</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">        <span class="comment">// 创建一个中间收集容器</span></span><br><span class="line">        (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>,</span><br><span class="line">        <span class="comment">// 数据添加到容器中的算法/规则</span></span><br><span class="line">        List::add,</span><br><span class="line">        <span class="comment">// 并行流下的规约机制</span></span><br><span class="line">        (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">        <span class="comment">// 收集器特性</span></span><br><span class="line">        CH_ID</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            <span class="comment">// 新建了一个StringBuilder容器</span></span><br><span class="line">            StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">            <span class="comment">// 设置这个数据的添加规则</span></span><br><span class="line">            StringBuilder::append,</span><br><span class="line">            <span class="comment">// 并行流下的规约规则</span></span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            <span class="comment">// 最后的输出规则</span></span><br><span class="line">            StringBuilder::toString,</span><br><span class="line">            <span class="comment">// 收集器特性</span></span><br><span class="line">            CH_NOID</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>归集: 将流中的数据收集为集合(<code>List</code>、<code>Set</code>、<code>Map</code>)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student tom = Student.builder().age(<span class="number">19</span>).name(<span class="string">&quot;tom&quot;</span>).number(<span class="number">10</span>).build();</span><br><span class="line">    Student marry = Student.builder().age(<span class="number">12</span>).name(<span class="string">&quot;marry&quot;</span>).number(<span class="number">15</span>).build();</span><br><span class="line">    Student jack = Student.builder().age(<span class="number">12</span>).name(<span class="string">&quot;jack&quot;</span>).number(<span class="number">20</span>).build();</span><br><span class="line">    List&lt;Student&gt; students = ListUtil.of(tom, marry, jack);</span><br><span class="line">    System.out.println(<span class="string">&quot;======== collect ========&quot;</span>);</span><br><span class="line">    <span class="comment">// 归集</span></span><br><span class="line">    System.out.println(students.stream().map(Student::getAge).collect(Collectors.toList()));</span><br><span class="line">    System.out.println(students.stream().map(Student::getAge).collect(Collectors.toSet()));</span><br><span class="line">    <span class="comment">// Student类的number为key, Student对象为value的Map</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getNumber, p -&gt; p)));</span><br><span class="line">    <span class="comment">// Function.identity() 是 p -&gt; p 简单写法, 表示返回对象本身</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getNumber, Function.identity())));</span><br><span class="line">    <span class="comment">// Student类的age为key, Student类的name为value(由于marry和jack的age都是12, 所以在规约为map是出现一个key对应两个值, 这时由第三个参数来处理冲突键情况)</span></span><br><span class="line">    <span class="comment">// 这里简单处理: 重复时获取第一个键所对应的值。</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getAge, Student::getName, (key1, key2) -&gt; key2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>统计: 实际上就是聚合的那些操作(最大值、最小值、平均值、数量)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.counting()));</span><br><span class="line">System.out.println(students.stream().collect(Collectors.averagingInt(Student::getAge)));</span><br><span class="line">System.out.println(students.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compareTo)));</span><br><span class="line"><span class="comment">// 获取所有值, 返回IntSummaryStatistics对象(数量, 求和, 最小值, 平均值, 最大值)</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getAge)));</span><br></pre></td></tr></table></figure><ul><li>分组/分区: 分区是将流中的数据按照一定的规则分为两组数据(Map&lt;Boolean, List<Object>&gt;), 分组是将流中的数据按照一定的规则分成多组数据(Map&lt;String/Integer/…, List&lt;Object/String/Integer/…&gt;&gt;)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回键为boolean, 值为Student对象的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.partitioningBy(item -&gt; item.getAge() &gt; <span class="number">12</span>)));</span><br><span class="line"><span class="comment">// 返回键为student.age, 值为List&lt;Student&gt;的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getAge)));</span><br><span class="line"><span class="comment">// collectors.groupingBy的第二个参数表示下游收集器, 可以对上游收集到的value值进行处理。</span></span><br><span class="line"><span class="comment">// 返回键为student.age, 值为List&lt;String&gt; names 的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.mapping(Student::getName, Collectors.toList()))));</span><br><span class="line"><span class="comment">// 返回键为student.name, 值为相同name的年龄的平均值</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingInt(Student::getAge))));</span><br></pre></td></tr></table></figure><ul><li>连接: 将流中的数据通过某个分隔符、前缀字符串、后缀字符串进行连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接连接, 没有分隔符</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining()));</span><br><span class="line"><span class="comment">// 使用|分隔</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>)));</span><br><span class="line"><span class="comment">// 添加连接前缀和后缀</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>, <span class="string">&quot;name: [&quot;</span>, <span class="string">&quot;]&quot;</span>)));</span><br></pre></td></tr></table></figure><h3 id="2-2-中间操作"><a href="#2-2-中间操作" class="headerlink" title="2.2 中间操作"></a>2.2 中间操作</h3><h4 id="2-2-1-有状态"><a href="#2-2-1-有状态" class="headerlink" title="2.2.1 有状态"></a>2.2.1 有状态</h4><h5 id="2-2-1-1-排序"><a href="#2-2-1-1-排序" class="headerlink" title="2.2.1.1 排序"></a>2.2.1.1 排序</h5><p>自定义排序仅需要实现<code>Comparator</code>中的<code>compareTo</code>方法即可。实际上一些简单的排序在<code>Comparator</code>中都有静态实现，只需要通过<code>lambda</code>调用即可，比如降序排列<code>Comparator::reversOrder()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sorted</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认是升序排列</span></span><br><span class="line">    list.stream().sorted().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(Comparator.reverseOrder()).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(Integer::compareTo).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * o1 &gt; o2 返回大于0的数表示升序</span></span><br><span class="line"><span class="comment">            * o1 &lt; o2 返回大于0的数表示降序</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> o1</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> o2</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted(Comparator.comparing(Student::getAge)).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    <span class="comment">// 多次排序</span></span><br><span class="line">    list.stream().sorted(Comparator.comparing(Student::getNumber).thenComparing(Student::getAge)).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-2-去重"><a href="#2-2-1-2-去重" class="headerlink" title="2.2.1.2 去重"></a>2.2.1.2 去重</h5><p><strong><code>distinct</code></strong></p><p>通过流中元素的 <code>hashCode()</code> 和 <code>equals() </code>去除重复元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">distinct</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().distinct().forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-3-切片"><a href="#2-2-1-3-切片" class="headerlink" title="2.2.1.3 切片"></a>2.2.1.3 切片</h5><p><code>limit(n)</code>截取前<code>n</code>个元素，<code>skip(n)</code>跳过<code>n</code>个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">limitOrSkip</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().limit(<span class="number">5</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().skip(<span class="number">5</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-无状态"><a href="#2-2-2-无状态" class="headerlink" title="2.2.2 无状态"></a>2.2.2 无状态</h4><h5 id="2-2-2-1-映射"><a href="#2-2-2-1-映射" class="headerlink" title="2.2.2.1 映射"></a>2.2.2.1 映射</h5><p>可以将一个流中的元素按照一定的规则映射到另一个流中。</p><ul><li><code>map</code>：接收一个处理函数，这个函数会作用到每个元素上，并为处理后的结果生成一个新的流。</li><li><code>flatMap</code>：接收一个处理函数，这函数会将作用到每个元素上，<strong>并为每个处理后的元素生成一个流</strong>，然后把所有流合并为流。(也就是说处理之后得到的数据是一个流，且这个流中的每个元素也是流。)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().map(item -&gt; item + <span class="number">1</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    list.stream().map(Student::getAge).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在flatMap执行完成之后, 实际上是将一个流两个元素&#123;&quot;hello World!&quot;, &quot;how are you&quot;&#125; 分解为</span></span><br><span class="line">    <span class="comment">// 两个流: 分别为 &#123;&quot;hello&quot;, &quot;World!&quot;&#125; 和 &#123;&quot;how&quot;, &quot;are&quot;, &quot;you&quot;&#125; 两个流。</span></span><br><span class="line">    <span class="comment">// 在forEach操作是对这两个流分别执行forEach操作。</span></span><br><span class="line">    List&lt;String&gt; strs = ListUtil.of(<span class="string">&quot;hello World!&quot;</span>, <span class="string">&quot;how are you&quot;</span>);</span><br><span class="line">    strs.stream().flatMap(item -&gt; &#123;</span><br><span class="line">        <span class="comment">// 返回一个新流</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(item.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;).forEach(item -&gt; System.out.println(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为<code>debug</code>模式下<code>flatMap</code>执行完成之后的结果。</p><p><img src="https://s2.loli.net/2021/12/15/dgjItYFBTOJrAvC.png" alt="image-20211214204808262.png"></p><h4 id="2-2-2-2-过滤"><a href="#2-2-2-2-过滤" class="headerlink" title="2.2.2.2 过滤"></a>2.2.2.2 过滤</h4><p><code>filter</code></p><p>在实际的开发过程中比较常用的一个操作，接收一个函数，通过改函数判断是否需要过滤到元素。(一般情况下会配合映射<code>map</code>使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n======== filter ========&quot;</span>);</span><br><span class="line">    list.stream().filter(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-3-消费"><a href="#2-2-2-3-消费" class="headerlink" title="2.2.2.3 消费"></a>2.2.2.3 消费</h5><p><code>peek</code></p><p>主要是在<code>debug</code>中使用。</p><p>先来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().peek(System.out::print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后发现并没有任何输出。回到开头的介绍中，<code>peek</code>属于中间操作，在运行到终止操作时，此中间操作是不会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.filter(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .peek(e -&gt; System.out.println(<span class="string">&quot;被2整除的数: &quot;</span> + item))</span><br><span class="line">        .map(item -&gt; item + <span class="number">1</span>)</span><br><span class="line">        .peek(item -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + item))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>被2整除的数: 2<br>结果: 3<br>被2整除的数: 4<br>结果: 5</p></blockquote><p>以上输出了流执行的中间过程，所以实际上流操作是在获取到一个元素后就会继续往下执行。</p><p>这里要注意：<code>peek(func)</code>接收的函数是一个<code>Consumer</code>，它是仅处理并不返回处理结果到流中。所以以下代码实际上执行也是没有效果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.peek(item -&gt; item + <span class="number">1</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;jdk8&lt;/code&gt;中引入的函数式&lt;code&gt;lambda&lt;/code&gt;表示式，同时引入了&lt;code&gt;Stream&lt;/code&gt;流，这种流可以堆集合进行一些复杂查找、过滤、映射、规约等操作。一个&lt;code&gt;stream&lt;/code&gt;是由三部分组成，&lt;code&gt;数据源流 -&amp;gt;零个或多个中间操作 -&amp;gt; 零个或一个终止操作&lt;/code&gt;。中间操作是对数据的加工处理并且中间操作是懒&lt;code&gt;lazy&lt;/code&gt;操作，并不会马上启动，需要等待终止操作允许到才会开始执行。</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Arthas的基本使用</title>
    <link href="http://xiaocainiaoya.github.io/2021/11/18/Springboot/Arthas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/11/18/Springboot/Arthas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-11-18T12:46:11.000Z</published>
    <updated>2021-11-18T12:26:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近正式环境出现一起事故，业务端经过一些列的业务逻辑之后，使用<code>wkhtmltopdf</code>工具进行<code>html</code>转换为<code>pdf</code>，但出现生成完成之后(正常结束，并未发生异常)业务端再次获取这个<code>pdf</code>文件时，出现文件不存在问题。<span id="more"></span></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>​    经过一系列的排查，最终锁定在<code>wkhtmltopdf</code>工具是否正常生成<code>pdf</code>文件，请看如下代码，这里通过<code>wkhtmltopdf</code>提供的工具类<code>pdf.saveAsDirect(ftpDir + &quot;/&quot; + path);</code>进行<code>pdf</code>的生成，但并未对返回的结果进行判断，所以猜测这里根本没有生成<code>pdf</code>文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadToPdfDirect</span><span class="params">(WrapperConfig config, String sourceString, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pdf pdf = <span class="keyword">new</span> Pdf(config);</span><br><span class="line">        pdf.setAllowMissingAssets();</span><br><span class="line">        pdf.addPageFromString(sourceString);</span><br><span class="line">        pdf.addParam(pageInfo);</span><br><span class="line">        pdf.saveAsDirect(ftpDir + <span class="string">&quot;/&quot;</span> + path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;wkHtmlToPdf发生异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 捕获到InterruptedException异常后恢复中断状态</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wkHtmlToPdf发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据猜测希望将代码修改为：(本想借助<code>Arthas</code>将代码修改以下代码，但由于线上一直产生数据，事故面积越来越大，来不及研究<code>Arthas</code>的使用，只能走繁琐的流程，进行发包替换正式环境的包)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadToPdfDirect</span><span class="params">(WrapperConfig config, String sourceString, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pdf pdf = <span class="keyword">new</span> Pdf(config);</span><br><span class="line">        pdf.setAllowMissingAssets();</span><br><span class="line">        pdf.addPageFromString(sourceString);</span><br><span class="line">        pdf.addParam(pageInfo);</span><br><span class="line">        <span class="comment">// 对生成的结果进行判断, 到底有没有生成对应文件</span></span><br><span class="line">        File file = pdf.saveAsDirect(ftpDir + <span class="string">&quot;/&quot;</span> + path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件生成失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;wkHtmlToPdf发生异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 捕获到InterruptedException异常后恢复中断状态</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wkHtmlToPdf发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>​    经过漫长的发版流程等待，等到正式环境替换包已经是大半夜。经过测试，确实是<code>pdf</code>文件未生成(如果会使用<code>Arthas</code>，这个时候应该就已经解决问题)。这里要说明下，到目前为止只知道这种方式会生成失败，至于在什么情况下生成失败就不得而知了，因为开发环境、测试环境、预发布环境都是正常生成。痛定思痛，决定学习一下<code>Arthas</code>的使用。</p><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><p>简单的使用流程：</p><ol><li><p>找到需要进行添加代码的类全路径后进行反编译到某个文件夹中。</p><blockquote><p>jad –source-only com.xxx.service.v3.xxxService &gt; /tmp/xxxService.java</p></blockquote><p>这里是由<code>.class</code>反编译为<code>.java</code>文件，所以阅读上没有那么友好，其实刚出现问题的时候就想到使用<code>Arthas</code>，但是被这个反编译出来的代码劝退了，反编译出来的代码甚至有指令重排，不太敢修改这个反编译文件。</p></li><li><p>修改这个反编译文件</p><blockquote><p>vim /tmp/UserController.java</p></blockquote><p>这里实际上是要先退出<code>arthas</code>，第一次使用的时候还以为<code>arthas</code>命令行可以直接操作文件，实际上应该退出<code>arthas</code>使用<code>linux</code>命令的方式进行文件修改。</p></li><li><p>查找这个类对应的类加载器</p><blockquote><p>sc -d *xxxService | grep classLoadHash</p><p>classLoadHash 6bc26251</p></blockquote><p>这里得到这个类的加载器的哈希值为<code>6bc26251</code></p></li><li><p>使用这个类加载器将修改后的文件编译为<code>.class</code>文件</p><blockquote><p>mc -c 6bc26251 /tmp/xxxService.java -d /tmp</p></blockquote><p>这时会在<code>/tmp</code>文件夹下生成一个以包结构为文件路径的<code>.class</code>文件。</p></li><li><p>进行热更新</p><blockquote><p>redefine /tmp/com/xxx/service/v3/xxxService.class</p></blockquote><p>当看到提示<code>redefine success, size: 1</code>说明替换成功，就可以进行具体的测试。</p></li></ol><p>以上这种方式，出现问题的概率极大，因为要修改反编译文件，且反编译文件好像进行了一些指令重排，导致阅读上比较困难，实际上以上的前四步骤就是为了得到修改之后的<code>.class</code>文件，那么实际上我们可以借助于<code>idea</code>进行处理。</p><ol><li>找到线上代码的标签，拉取修改文件分支。</li><li>检出这个分支，进行特定文件的修改后，直接使用<code>idea</code>工具进行文件的编译。这时就可以通过<code>target</code>文件夹获取到对应修改文件的<code>.class</code>文件。</li><li>将这个<code>.class</code>文件上传到对应服务器。</li><li>直接热更新这个文件。(也就是上述的第5步)</li></ol><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><ol><li>在某个接口的服务层添加一个日志打印信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequireFileVo <span class="title">getFiles</span><span class="params">(ParamVo ParamVo, Integer pageNum, Integer pageSize)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;pageSize:&#123;&#125;&quot;</span>, pageSize);</span><br><span class="line">        <span class="comment">// 以下为很复杂的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>通过<code>idea</code>对整个服务进行编译后，获取到该文件的<code>.class</code>文件。</p></li><li><p>上传到服务器中，由于服务是运行在<code>docker</code>中，所以上传到服务器后移动文件到<code>docker</code>与宿主机的挂载目录中。</p></li><li><p>从挂载目录移动到简单目录。(测试的时候使用的挂载目录路径比较长，就移动到简单一点的目录比如<code>/tmp</code>)</p></li><li><p>使用<code>redefine</code>命令后看到<code>redefine success, size: 1</code>表示成功</p></li><li><p>测试，通过<code>postman</code>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">30.491</span> [TraceId=92aeb19c3e8ce62b,SpanId=92aeb19c3e8ce62b,ParentSpanId=] [http-nio-<span class="number">20065</span>-exec-<span class="number">5</span>] INFO  c.b.g.b.s.v.s.xxxService-pageSize:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="其他基础功能"><a href="#其他基础功能" class="headerlink" title="其他基础功能"></a>其他基础功能</h2><ul><li><strong>reset</strong>：重置增强类，此命令会将<code>arthas</code>增强过的类都重置为增强之前的情况。</li><li><strong>quit</strong>：退出，<code>quit</code>只是退出<code>archas</code>的<code>session</code>，实际上目标进程<code>arthas server</code>还在运行中。</li><li><strong>stop</strong>：彻底退出<code>arthas</code>，使用此命令后，实际上会执行一次<code>reset</code>命令。</li></ul><p><strong>注意：</strong>要区别于<code>quit</code>和<code>stop</code>两个退出之间的区别。</p><blockquote><p> 通过线程<code>id</code>查看线程的具体信息，比如查看线程<code>id</code>为1的线程的具体信息：<code>thread 1</code></p></blockquote><p><strong>1.watch</strong>：查看类里面的某个方法的返回值和入参(实际上只能看参数类型, 是否有值, 并不能看值是多少)</p><blockquote><p>命令 + 类完全限定名 + 需要检测的方法 + 表达式 + (额外参数)</p><p>watch com.xxx.xxx.service.v3.xxxService  getFiles “{params, returnObj}” -x 2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">额外参数：</span><br><span class="line">-x 指定输出结果(默认为<span class="number">1</span>) 这里为<span class="number">2</span>层</span><br><span class="line">-b 表示在方法调用之前</span><br><span class="line">-e 表示在方法出异常时</span><br><span class="line">-s 表示在方法返回之后</span><br><span class="line">-f 表示在方法结束之后(正常返回和异常返回)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表达式核心变量列表：</span><br><span class="line">loader      本次调用类所在的 ClassLoader</span><br><span class="line">clazz       本次调用类的 Class 引用</span><br><span class="line">method      本次调用方法反射引用</span><br><span class="line">target      本次调用类的实例</span><br><span class="line">params      本次调用参数列表，这是一个数组，如果方法是无参方法则为空数组</span><br><span class="line">returnObj   本次调用返回的对象。当且仅当 isReturn==<span class="keyword">true</span> 成立时候有效，表明方法调用是以正常返回的方式结束。如果当前方法无返回值 <span class="keyword">void</span>，则值为 <span class="keyword">null</span></span><br><span class="line">throwExp    本次调用抛出的异常。当且仅当 isThrow==<span class="keyword">true</span> 成立时有效，表明方法调用是以抛出异常的方式结束。</span><br><span class="line">isBefore    辅助判断标记，当前的通知节点有可能是在方法一开始就通知，此时 isBefore==<span class="keyword">true</span> 成立，同时 isThrow==<span class="keyword">false</span> 和 isReturn==<span class="keyword">false</span>，因为在方法刚开始时，还无法确定方法调用将会如何结束。</span><br><span class="line">isThrow     辅助判断标记，当前的方法调用以抛异常的形式结束。</span><br><span class="line">isReturn    辅助判断标记，当前的方法调用以正常返回的形式结束。</span><br></pre></td></tr></table></figure><p><strong>2.trace</strong>：方法内部的调用路径，并输出方法路径上的每个节点耗时</p><blockquote><p>命令 + 类完全限定名 + 需要检测的方法</p><p>trace com.xxx.xxx.service.v3.xxxService  getFiles</p></blockquote><p><strong>3.heapdump</strong>：生成快照信息</p><blockquote><p>heapdump (–live) 生成文件路径/xxx.hprof</p></blockquote><p><strong>–live</strong>：只<code>dump</code>活着的对象</p><p>我是使用<code>jdk</code>自带的<code>jvisualvm</code>来打开<code>xx.hprof</code>文件进行分析。<code>jdk</code>自带的<code>jvisualvm</code>在<code>~/home/bin</code>目录下。顺便记录下<code>mac</code>系统查看<code>jdk home</code>所在位置的方式：执行<code>/usr/libexec/java_home -V</code></p><p><strong>4.sysprop</strong>：查看<code>Sysetm properties</code>信息</p><p>可以指定单个 </p><blockquote><p>sysprop @appId</p></blockquote><p>或者使用<code>grep</code>进行过滤</p><blockquote><p>sysprop | grep @appId </p></blockquote><p>再或者直接添加一个新的键值对</p><blockquote><p>sysprop timeout 50</p></blockquote><p><strong>5.sysenv</strong>：查看环境变量(使用上和<code>sysprop</code>一致)</p><p>注意：系统变量通过<code>System.getProperty()</code>，环境变量通过<code>System.getEnv()</code>。系统变量可以通过<code>-D</code>的方式在启动时添加，环境变量</p><p><strong>6.jvm</strong>：可以查看<code>jvm</code>虚拟机的一些信息</p><p><strong>7.sc</strong>：可以查看已经加载的类，如果类是接口，可以获取到已加载的所有实现类，通过<code>-d</code>参数可以打印类加载的具体信息。并且支持通配符查找类。</p><blockquote><p>sc -d xxx</p></blockquote><p><strong>8.sm</strong>：查找具体的函数</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文档地址[<a href="https://arthas.aliyun.com/doc/]">https://arthas.aliyun.com/doc/]</a></p><p>git地址(<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a>)</p><p>使用教程地址(<a href="https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&amp;id=arthas-advanced">https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&amp;id=arthas-advanced</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近正式环境出现一起事故，业务端经过一些列的业务逻辑之后，使用&lt;code&gt;wkhtmltopdf&lt;/code&gt;工具进行&lt;code&gt;html&lt;/code&gt;转换为&lt;code&gt;pdf&lt;/code&gt;，但出现生成完成之后(正常结束，并未发生异常)业务端再次获取这个&lt;code&gt;pdf&lt;/code&gt;文件时，出现文件不存在问题。</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
    <category term="工具" scheme="http://xiaocainiaoya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>springboot启动过程</title>
    <link href="http://xiaocainiaoya.github.io/2021/09/13/Springboot/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://xiaocainiaoya.github.io/2021/09/13/Springboot/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-09-13T14:51:58.000Z</published>
    <updated>2021-09-13T06:39:21.904Z</updated>
    
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>spring事件监听机制</title>
    <link href="http://xiaocainiaoya.github.io/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-12T05:09:33.000Z</published>
    <updated>2021-09-13T06:28:27.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring事件监听机制"><a href="#spring事件监听机制" class="headerlink" title="spring事件监听机制"></a>spring事件监听机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring</code>事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于<code>spring</code>容器进行事件的注册、发布、处理。</p><span id="more"></span><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1.创建一个类继承于顶层事件类<code>ApplicationEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendNotificationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SendNotificationVo sendNotificationVo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendNotificationEvent</span><span class="params">(ApplicationContext source, SendNotificationVo sendNotificationVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.sendNotificationVo = sendNotificationVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.监听到对应的事件后的业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.调用点发送具体的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上就是最简单的<code>spring</code>事件监听的使用。在具体的应用场景中，并不会这么简单的使用，因为若在业务逻辑上需要解耦，大部分还是希望是异步的方式进行事件的处理，然而在默认的情况下，这种模式是同步机制，也就是说待到具体的事件监听处理完成之后，才会继续执行调用点的业务逻辑。</p><h2 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h2><h3 id="1-广播器异步"><a href="#1-广播器异步" class="headerlink" title="1.广播器异步"></a>1.广播器异步</h3><p>​    在<code>spring</code>的事件监听机制中已经考虑到异步的情况，所以在事件发送器发送事件时，会判断是否存在广播器，当存在广播器时，会将具体的监听执行逻辑转移到广播器对应的线程池中。来跟踪一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        publishEvent((Object) event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体子类实现接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现在<code>AbstractApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取广播器, 并调用广播器对应的发送事件处理</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认仅有一个广播器的实现<code>SimpleApplicationEventMulticaster</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 获取对应的广播器线程池</span></span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="comment">// 获取这个event对应类型的所有监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="comment">// 若是配置了线程池, 则将监听任务转移到线程池中执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若是没有配置线程池, 执行执行监听任务, 所以在默认情况下与具体的业务逻辑是同步执行。</span></span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体事件监听的执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 具体执行监听逻辑</span></span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实际上就是ApplicationListener的onApplicationEvent方法</span></span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        String msg = ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">            Log logger = LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚上面介绍的最简单的使用方式中采用的<code>@EventListener</code>的方式来标记监听器的位置，实际上在初始化这个<code>bean</code>对象时，扫描到<code>@EventListener</code>后会将这个对应的方式转化为<code>ApplicationListenerMethodAdapter</code>类，该类中包含了<code>bean</code>名称、类名称、监听处理<code>method</code>等等，待到接收到事件时，通过反射调用对应的监听处理方法。</p><h3 id="2-Async注解异步"><a href="#2-Async注解异步" class="headerlink" title="2.@Async注解异步"></a>2.@Async注解异步</h3><p>​    虽然在事件发送器中内置了广播器线程池，但是若不进行配置，则它还是同步的方式执行，在它同步执行的基础上，若是利用<code>spring</code>的异步机制，也可以达到异步的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，在<code>spring</code>容器初始化时，扫描到这个<code>bean</code>对象并进行初始化时，会为这个<code>bean</code>创建一个代理类，由这个代理类来执行相应的异步逻辑。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>以上看似已经解决的异步的问题，但是在实际的使用过程中又发现如果事件发送点存在事务管理，就会导致事件中获取不到事件发送点的某些数据。(由于事件监听处理触发时，事件发送点还未提交事务。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪代码, 在事件监听的处理中, 通过id=123可能存在获取不到这条数据的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/09/12 13:54:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    mapper.insert(sendNotificationVo);</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是、但是、但是这种情况<code>spring</code>也考虑到了，<code>spring</code>监听机制中通过使用<code>@TransactionalEventListener</code></p><p>来解决这个问题。<code>@TransactionalEventListener</code>它的元注解为<code>@EventListener</code>，所以本质上也是个<code>@EventListener</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 事件触发阶段: 比如事务提交之前、事务提交之后等, 默认是在事务提交之后</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function">TransactionPhase <span class="title">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 若调用点无事务管理也触发, 默认情况下若调用点无事务接管, 该监听处理不会触发</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Alias for &#123;<span class="doctag">@link</span> #classes&#125;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The event classes that this listener handles.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚上面说到在<code>spring</code>扫描到对应的监听器处理<code>bean</code>时，会根据方法上标记的注解将监听器转换为对应的处理类。根据不同的两个注解<code>@TransactionalEventListener</code>和<code>EventListener</code>对应两个不同的生成监听类工厂<code>DefaultEventListenerFactory</code>和<code>TransactionalEventListenerFactory</code>，由它们来创建具体的监听处理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp; AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp; !isSpringContainerClass(targetType)) &#123;</span><br><span class="line">        Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从bean的class对象中找出含有@EventListener注解的方法, 存在Map&lt;Method, EventListener&gt;中</span></span><br><span class="line">            <span class="comment">// @TransactionListener方法也会被匹配, 因为它的元注解是@EventListener</span></span><br><span class="line">            annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">                            AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// An unresolvable type in a method signature, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Could not resolve methods for bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No @EventListener annotations found on bean class: &quot;</span> + targetType.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Non-empty set of methods</span></span><br><span class="line">            ConfigurableApplicationContext context = <span class="keyword">this</span>.applicationContext;</span><br><span class="line">            Assert.state(context != <span class="keyword">null</span>, <span class="string">&quot;No ApplicationContext set&quot;</span>);</span><br><span class="line">            List&lt;EventListenerFactory&gt; factories = <span class="keyword">this</span>.eventListenerFactories;</span><br><span class="line">            Assert.state(factories != <span class="keyword">null</span>, <span class="string">&quot;EventListenerFactory List not initialized&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取监听工厂, 这里有两个工厂:DefaultEventListenerFactory和TransactionalEventListenerFactory</span></span><br><span class="line">                <span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">                    <span class="comment">// 判断这个被标记的方法适配哪个工厂</span></span><br><span class="line">                    <span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line">                        Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                        <span class="comment">// 使用工厂创建对应的监听器对象</span></span><br><span class="line">                        ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                        <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">                            ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="keyword">this</span>.evaluator);</span><br><span class="line">                        &#125;</span><br><span class="line">                        context.addApplicationListener(applicationListener);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(annotatedMethods.size() + <span class="string">&quot; @EventListener methods processed on bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + annotatedMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这两个工厂生成出来的监听类，实际上是两个适配器，<code>ApplicationListenerMethodAdapter</code>和<code>ApplicationListenerMethodTransactionalAdapter</code>，由这两个适配器来执行相应的处理逻辑。这里要感叹下<code>spring</code>设计的精妙，一环扣一环，扩展性极强。</p><p>这里分析下<code>ApplicationListenerMethodTransactionalAdapter</code>中对应的监听触发方法<code>onApplicationEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// publish事件时: 创建一个TransactionSynchronization对象, 这个对象持有event</span></span><br><span class="line">        <span class="comment">// 创建TransactionSynchronizationEventAdapter</span></span><br><span class="line">        TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event);</span><br><span class="line">        <span class="comment">// 注册到事务管理器中</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Processing &quot;</span> + event + <span class="string">&quot; as a fallback execution on AFTER_ROLLBACK phase&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反射调用进行事件的处理</span></span><br><span class="line">        processEvent(event);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No transactional event execution at all</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No transaction is active - skipping &quot;</span> + event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为采用这种方式之后，就解决了对应的异步+调用点事务的问题。在测试中发现：若采用广播器实现异步，极大可能获取不到调用点事务内数据；而采用<code>@Async</code>实现异步百分百可以获取到调用点事务内数据。</p><p>简单跟踪发现：</p><ul><li>广播器方式实现异步，是将<code>onApplicationEvent</code>方法的触发丢入线程池。</li><li><code>@Async</code>方式实现异步，走下方<code>else</code>逻辑，在事件发送器中走同步逻辑，是直接执行<code>onApplicationEvent</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// invokeListener()返回最后的逻辑是去调用ApplicationListener.onApplicationEvent()</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的是否对<code>onApplicationEvent</code>方法执行执行起到了关键性的作用，因为在事务监听处理器适配器中会判断是否是否存在事务。第一种情况，由线程池内线程来执行该方法，这时事务是绑定在原线程上，所以会导致这个判断结果为<code>false</code>。第二种情况，由事件发送线程执行该方法，这时与事务在同一线程，则这个判断的结果为<code>true</code>，将对应的事件处理方法注册到事务管理器中，待到执行改事件监听处理方法时，是异步进行处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line"><span class="comment">// 省略以下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    整体使用下来，发现其中的道道还是很多的，这需要对所有的组合情况、问题情况、原理都掌握的情况下，否则随意组合，可能在某一场景下能达到需要的效果，但是就像是埋下了定时炸弹。当然了<code>spring</code>的事件监听机制毕竟只是基于内存，若对应的生产环境并没有升级停机钩子处理，或者是金丝雀升级等方式，需停机升级，有可能会导致部分监听未执行的情况，所以建议生产环境还是通过一些<code>mq</code>组件进行发布监听事件的处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring事件监听机制&quot;&gt;&lt;a href=&quot;#spring事件监听机制&quot; class=&quot;headerlink&quot; title=&quot;spring事件监听机制&quot;&gt;&lt;/a&gt;spring事件监听机制&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于&lt;code&gt;spring&lt;/code&gt;容器进行事件的注册、发布、处理。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-08-30T14:08:50.000Z</published>
    <updated>2021-08-30T14:55:43.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​    <code>spring</code>为了减少过多<code>xml</code>的配置，减轻开发者的配置负担，提供了通过注解的方式进行<code>bean</code>对象的加载。并且在单一注解的基础上增加了一些模式上的约定。</p><span id="more"></span><p>​    比如<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>，实际上它们的作用都是将标记的类生成对应的<code>bean</code>对象之后添加到<code>IOC</code>容器中，通过精细注解的方式，为注解带来一些语义。使得可以更直观的看出一些分层行为。再比如<code>springboot</code>中扩展了<code>spring</code>的<code>@Condition</code>注解，通过<code>@OnXXXConditon</code>的方式标记某个类是否需要进行加载到<code>IOC</code>容器。</p><h2 id="二、注解"><a href="#二、注解" class="headerlink" title="二、注解"></a>二、注解</h2><p>​    在注解上标记的注解称为元注解。比如在<code>@Service</code>注解之上标记<code>@Component</code>注解。使得<code>@Service</code>拥有将标记类加载为<code>Bean</code>对象后添加到<code>IOC</code>容器中的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment"> * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-AliasFor"><a href="#2-1-AliasFor" class="headerlink" title="2.1 AliasFor"></a>2.1 AliasFor</h3><p>别名注解，在注解创建时，有的时候为了加深语义以及向前兼容的原则，可以通过别名的方式进行创建新字段。比如以下例子，<code>value</code>和<code>path</code>互为别名。在日常使用中<code>path</code>更能体现访问路径的语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">  String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-使用"><a href="#2-1-1-使用" class="headerlink" title="2.1.1 使用"></a>2.1.1 使用</h4><p>​    在使用上基本上是标记两个注解属性互为别名，但若使用不当，仅在一方上标记为另一方的别名，这时实际上效果和互相标记一致，只是这样就降低了可读性，所以为了提高可读性和隐式别名带来的值覆盖，还是应该遵守规范，进行相互标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AliasFor</span> 别名注解测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/08/30 22:24:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AliaForAnnotation &#123;</span><br><span class="line">    <span class="meta">@AliasFor(value = &quot;path&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@AliasFor(value = &quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  AliaForAnnotation aliaForAnnotation = AnnotationUtils.getAnnotation(SpringMvcStart.class, AliaForAnnotation.class);</span><br><span class="line">  System.out.println(<span class="string">&quot;value:&quot;</span> + aliaForAnnotation.value());</span><br><span class="line">  System.out.println(<span class="string">&quot;path:&quot;</span> + aliaForAnnotation.path());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>spring</code>中除了在一个注解中相互标记互为注解之外，还可以对组合注解进行相互标记，同时别名具有传递性。</p><ol><li>显示标记：标记一个注解中的两个注解属性互为别名</li><li>隐式标记：<code>A</code>注解的<code>a</code>属性标记为<code>C</code>注解的<code>c</code>的别名，<code>B</code>注解的<code>b</code>属性标记为<code>C</code>注解的<code>c</code>的别名，那么可以得出<code>A</code>注解的<code>a</code>属性也是<code>B</code>注解的<code>b</code>属性的别名。</li></ol><p>在<code>PostMapping</code>注解中，<code>name</code>属性就是<code>RequestMapping</code>注解中<code>name</code>的别名，<code>value</code>属性就是<code>RequestMapping</code>注解中<code>value</code>的别名，所以当在声明<code>@PostMapping(value = &quot;/xx/x&quot;)</code>的时候，不论是直接获取<code>PostMapping</code>注解后获取<code>value</code>值，还是通过元注解获取<code>RequestMapping</code>后获取它的<code>value</code>值，都为<code>/xx/x</code>。在更为复杂的场景下，不会别名链有多长，若存在隐式标记都可能存在值的传递性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#name&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#value&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Conditional"><a href="#2-2-Conditional" class="headerlink" title="2.2 Conditional"></a>2.2 Conditional</h3><p>在<code>spring</code>中提供了条件注解<code>@Conditional</code>，用于判断在某种场景下是否需要加载某个类为<code>Bean</code>对象。在<code>springboot</code>中将其扩展之后，使用上更为方便。</p><h4 id="2-2-1-使用"><a href="#2-2-1-使用" class="headerlink" title="2.2.1 使用"></a>2.2.1 使用</h4><p>创建一个注解<code>ConditionalOnDev</code>，且使用<code>@Conditional</code>指定条件类为<code>DevCondition</code>。当<code>ConditionalOnEnviroment</code>配置类被加载，要创建<code>enviroment</code>对象之前，会进入条件类的<code>matches</code>方法，若该方法返回<code>true</code>则表示允许将这个<code>bean</code>对象添加到<code>IOC</code>容器中，反之不处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(DevCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnDev &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单演示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalOnEnviroment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnDev(value = &quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Environment <span class="title">enviroment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dev();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上示例，若对<code>springboot</code>有所了解，应该知道<code>springboot</code>中存在大量的<code>@OnXxxCondition</code>，它就是利用<code>spring</code>提供的条件控制注解的方式。比如在<code>springboot</code>中有<code>@OnBeanCondition</code>、<code>@OnClassCondition</code>、<code>@OnResourceCondition</code>等等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring注解&quot;&gt;&lt;a href=&quot;#Spring注解&quot; class=&quot;headerlink&quot; title=&quot;Spring注解&quot;&gt;&lt;/a&gt;Spring注解&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;为了减少过多&lt;code&gt;xml&lt;/code&gt;的配置，减轻开发者的配置负担，提供了通过注解的方式进行&lt;code&gt;bean&lt;/code&gt;对象的加载。并且在单一注解的基础上增加了一些模式上的约定。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>HandlerMethod</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/19/SpringMvc/Handler/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/19/SpringMvc/Handler/</id>
    <published>2021-08-19T13:24:33.000Z</published>
    <updated>2021-08-23T14:53:16.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMethod</code>是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMethod顶层接口"><a href="#1-HandlerMethod顶层接口" class="headerlink" title="1. HandlerMethod顶层接口"></a>1. HandlerMethod顶层接口</h4><p><img src="https://i.loli.net/2021/08/19/7ITf8eNah9YEn4c.png" alt="HandlerMethod类图.png"></p><p>​    <code>HandlerMethod</code>整体的结构比较简单，但是<code>HandlerMethod</code>并不是设计成接口，直接设计为类，主要用于封装对应的处理方法信息<code>method</code>和这个处理器方法所对应的类信息、这个方法上的所有注解信息等。而真正的处理器方法的处理交由子类<code>InvocableHandlerMethod</code>，这里类包含了参数解析器和参数名称解析器的处理，用于在真正方法调用前进行参数解析。最后底层实现类<code>ServletInvocableHandlerMethod</code>包含了返回值处理器链，用于处理执行处理器方法之后的返回值。</p><h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h4><p>​    在顶层类<code>HandlerMethod</code>中，主要的实现就是一些构造函数，为了应对不同场景下使用不同的参数对具体的的执行方法进行包装，比如记录具体执行方法的参数、对应的类、对应类的类型、<code>bean</code>工厂、桥接方法等。</p><p>​    在次顶层类<code>InvocableHandlerMethod</code>中，主要添加了参数解析器列表和参数名称解析器列表，用于在支持<code>support()=true</code>的情况下，对参数进行一些个性化处理。并且包含了具体执行方法的反射调用处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 参数处理</span></span><br><span class="line">    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际处理请求的方法</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体的执行方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行该方法</span></span><br><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">        String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(text, args), ex);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">        Throwable targetException = ex.getTargetException();</span><br><span class="line">        <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>ServletInvocableHandlerMethod</code>类中，主要的当处理器方法执行结束后，对返回值的进行一些定制化的特殊处理。<code>springmvc</code>在异步调用的处理上就是通过返回值处理器，当返回值类型为<code>Callable</code>时，进行一些特殊的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 选择具体的返回值处理器(获取首次匹配成功的返回值处理器)</span></span><br><span class="line">    <span class="comment">// 举个异步处理的方式Callable, 由CallableMethodReturnValueHandler进行处理</span></span><br><span class="line">    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体的执行逻辑</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>参数解析器和返回值处理器在获取时，是获取列表中第一个匹配成功的那个解析器或者处理器，也就是说如果希望定制化的解析器或者处理器被执行到，需要确保它所在的位置之前没有其他的解析器或者处理器会被命中。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerMethod&quot;&gt;&lt;a href=&quot;#HandlerMethod&quot; class=&quot;headerlink&quot; title=&quot;HandlerMethod&quot;&gt;&lt;/a&gt;HandlerMethod&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerMethod&lt;/code&gt;是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
</feed>
