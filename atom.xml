<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2021-04-24T15:40:41.265Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>认识SpEL</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/</id>
    <published>2021-04-20T14:51:58.000Z</published>
    <updated>2021-04-24T15:40:41.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识SpEL表达式"><a href="#认识SpEL表达式" class="headerlink" title="认识SpEL表达式"></a>认识SpEL表达式</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>最近项目接入苞米豆的<code>lock4j</code>用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个<code>@Lock4j</code>注解并添加相应的参数即可，在使用中发现其中有一个属性<code>keys = &#123;&quot;#userId&quot;, &quot;#user.sex&quot;&#125;</code>，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过<code>SpEL</code>的方式解析参数信息。</p></blockquote><span id="more"></span><h4 id="SpEL概述"><a href="#SpEL概述" class="headerlink" title="SpEL概述"></a>SpEL概述</h4><p><code>Spring</code>表达式语言的全拼为<code>Spring Expression Language</code>，缩写为<code>SpEL</code>。并且<code>SpEL</code>属于<code>spring-core</code>模块，不直接与<code>Spring</code>绑定，是一个独立模块，不依赖于其他模块，可以单独使用。</p><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol><li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li><li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li><li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li></ol><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  Expression expression = parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>);</span><br><span class="line">  <span class="comment">// 计算求值</span></span><br><span class="line">  System.out.println(expression.getValue(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行一些简单的运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  <span class="comment">// 进行字符串的拼接</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>).getValue(String.class));</span><br><span class="line">  <span class="comment">// 简单的运算</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1+2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 简单的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1&gt;2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 稍微复杂一点的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;2&gt;1 and (!true)&quot;</span>).getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>ParseContext</code>对象设置自定义的解析规则</strong>：这里设置表达式的解析前缀为<code>#&#123;</code>解析后缀为<code>&#125;</code>，最后通过表达式对象<code>expression.getValue()</code>获取到表达式中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;#&#123;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  String template = <span class="string">&quot;#&#123;&#x27;Hello&#x27;&#125;#&#123;&#x27;World!&#x27;&#125;&quot;</span>;</span><br><span class="line">  Expression expression = parser.parseExpression(template, parserContext);</span><br><span class="line">  System.out.println(expression.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多不同的取值方式，比如参数(上下文)是个对象，获取这个对象中的某个属性；或者参数是一个<code>List</code>获取某一个索引值；又或者是一个<code>Map</code>对象，根据某个<code>Key</code>获取对应的值等等。</p><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>​    如果平时有使用<code>Spring</code>框架应该都会有用到比如<code>@Value</code>注解，就是通过<code>SpEL</code>方式进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取字符串tom </span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;tom&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取bean对象的属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;user.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在比如接触过<code>Spring Security</code>或者<code>Shiro</code>等身份验证和授权的框架中，对不同的角色有不同的接口权限，会使用到如下场景，其中对<code>@PreAuthorize(&quot;hasAuthority(&#39;ROLE_DMIN&#39;))</code>中<code>hasAuthority(&#39;ROLE_ADMIN&#39;)</code>就是通过<code>SpEL</code>进行参数解析后，对当前用户的角色进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拥有管理员权限可查看任何用户信息,否则只能查看自己的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;))</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/getUserById/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;SysUser&gt;&gt; getUserById(String userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(userFacade.getUserById(userId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>​    之前在项目中记录系统中一些敏感接口的请求日志信息，采用的是<code>AOP</code>的方式，在请求进入控制层之前拦截进入<code>AOP</code>的切面方法，但是记录的日志部分关键信息需要从请求的参数中获取，在之前的实现中是通过约定一种表达式，对应列表<code>List</code>、<code>Map</code>、<code>bean</code>对象的取值是自实现，且仅仅支持二级取值，确实在使用上有很大的缺陷。这种场景下，就可以使用<code>SpEL</code>进行方法参数解析，省了重复造轮子的过程，且使用上更为灵活。</p><p><strong><code>SpEL</code>结合<code>AOP</code>重构请求日志保存</strong>，这边只做简单的通过<code>SpEL</code>方式进行对象等取值处理，不考虑具体实际场景中的复杂业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:06:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;basic&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicVersionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;测试&quot;,notes=&quot;测试&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@ControllerMethodLog(name = &quot;测试保存请求日志&quot;, description = &quot;测试保存请求日志&quot;)</span></span><br><span class="line">    <span class="meta">@LogAssistParams(value=&#123;</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;projectName&quot;,objField=&quot;#bidProjectInfo.id&quot;),</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;id&quot;,objField=&quot;#bidProjectInfo.projectName&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestResponse&lt;BidPackageInvitationVo&gt; <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> ProjectInfo projectInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AOP</code>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:08:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTestLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OperationLogFacade operationLogFacade;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 此处的切点是注解的方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Pointcut(&quot;@annotation(cn.com.xiaocainiaoya.annotation.ControllerMethodLog)&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;operationLog()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      OperationLog operationLog = <span class="keyword">new</span> OperationLog();</span><br><span class="line">      operationLog.setStatus(<span class="number">1</span>);<span class="comment">// 默认调用成功，异常时修改为调用失败</span></span><br><span class="line"></span><br><span class="line">      Object thing = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行切入方法内容</span></span><br><span class="line">         thing = joinPoint.proceed();</span><br><span class="line">         operationLog.setOperEndTime(DateTime.now().toJdkDate());</span><br><span class="line">         <span class="keyword">return</span> thing;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         log.error(e.getMessage(), e);</span><br><span class="line">         operationLog.setStatus(<span class="number">0</span>);<span class="comment">//发生异常时定义为调用失败</span></span><br><span class="line">         operationLog.setResultContext(e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         insertOperationLog(operationLog, joinPoint, thing);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ParameterNameDiscoverer NAME_DISCOVERER = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *   插入操作日志</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span>: 2021/04/20 23:11:28</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> operationLog 日志基础信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> joinPoint 拦截切入点信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> thing 拦截函数返回值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertOperationLog</span><span class="params">(OperationLog operationLog, ProceedingJoinPoint joinPoint, Object thing)</span> </span>&#123;</span><br><span class="line">      MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">      ControllerMethodLog methodAnnotation = signature.getMethod().getAnnotation(ControllerMethodLog.class);</span><br><span class="line">      Api typeAnnotation = (Api) signature.getDeclaringType().getAnnotation(Api.class);</span><br><span class="line">      <span class="comment">//注释不完整不进行日志记录操作</span></span><br><span class="line">      <span class="keyword">if</span> (methodAnnotation == <span class="keyword">null</span> || typeAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParams logAssistParams = signature.getMethod().getAnnotation(LogAssistParams.class);</span><br><span class="line">      <span class="keyword">if</span>(methodAnnotation == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParam[] assistParams = logAssistParams.value();</span><br><span class="line">      <span class="keyword">if</span>(ObjectUtil.isNull(assistParams) || assistParams.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; assistParams.length; i++)&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 重点在这，通过MethodBasedEvaluationContext构建解析器ExpressionParser的上下文, 底层逻辑也是通过ParameterNameDiscoverer反射获取对应的属性值</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         EvaluationContext context = <span class="keyword">new</span> MethodBasedEvaluationContext((Object) <span class="keyword">null</span>, signature.getMethod(), joinPoint.getArgs(), NAME_DISCOVERER);</span><br><span class="line">         String value = (String)PARSER.parseExpression(assistParams[i].objField()).getValue(context);</span><br><span class="line">         ReflectUtil.setFieldValue(operationLog, assistParams[i].logField(), value);</span><br><span class="line">      &#125;</span><br><span class="line">      operationLogFacade.insertSelective(operationLog);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#120;&#x69;&#x61;&#x6f;&#99;&#x61;&#105;&#110;&#105;&#97;&#111;&#x79;&#x61;&#x40;&#102;&#111;&#x78;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#x69;&#x61;&#x6f;&#99;&#x61;&#105;&#110;&#105;&#97;&#111;&#x79;&#x61;&#x40;&#102;&#111;&#x78;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识SpEL表达式&quot;&gt;&lt;a href=&quot;#认识SpEL表达式&quot; class=&quot;headerlink&quot; title=&quot;认识SpEL表达式&quot;&gt;&lt;/a&gt;认识SpEL表达式&lt;/h3&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;最近项目接入苞米豆的&lt;code&gt;lock4j&lt;/code&gt;用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个&lt;code&gt;@Lock4j&lt;/code&gt;注解并添加相应的参数即可，在使用中发现其中有一个属性&lt;code&gt;keys = &amp;#123;&amp;quot;#userId&amp;quot;, &amp;quot;#user.sex&amp;quot;&amp;#125;&lt;/code&gt;，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过&lt;code&gt;SpEL&lt;/code&gt;的方式解析参数信息。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="SpEL" scheme="http://xiaocainiaoya.github.io/tags/SpEL/"/>
    
  </entry>
  
  <entry>
    <title>this调用导致注解未生效问题</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/</id>
    <published>2021-04-16T15:04:58.000Z</published>
    <updated>2021-04-23T11:42:56.332Z</updated>
    
    <content type="html"><![CDATA[<h4 id="动态代理导致注解未生效"><a href="#动态代理导致注解未生效" class="headerlink" title="动态代理导致注解未生效"></a>动态代理导致注解未生效</h4><p>​    今天在使用<code>mybatis-plus</code>作者苞米豆的另一个项目<code>lock4j</code>用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。</p><p>​    <code>lock4j</code>和<code>mybatis-plus</code>差不多，秉承着人性化使用的初衷，<code>lock4j</code>使用上还是非常简单的，只需要在需要上锁的接口方法上使用<code>@Lock4j</code>进行标记并设置一些简单的超时参数即可。</p><p>​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用<code>ReentrantLock</code>)，所以改造时仅仅只是对改接口上添加<code>@Lock4j</code>注解。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveInfo</span><span class="params">(String userId)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 很多业务逻辑的处理 </span></span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">this</span>.finalSaveEffective(userId);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Lock4j(keys = &#123;&quot;#userId&quot;&#125;, expire = &quot;18000&quot;, acquireTimeout = &quot;10000&quot;,</span></span><br><span class="line"><span class="meta">        keyBuilder = DefaultKeyBuilder.class)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finalSaveEffective</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//reentrantLock.lock();</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    checkInfo(..);</span><br><span class="line">    mapper.insert(..);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    log.error(e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(e.getMessage());</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//reentrantLock.unlock();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    跑起来测试后发现根本没有进入到对<code>@Lock4j</code>处理的代理方法中，马上反应到这不是和常见<code>@Transaction</code>的坑一样，不能使用<code>this.xxx</code>的方式调用，修改代码后启动，果然正常上锁，那么为什么<code>this.xxx</code>会导致异常？</p><p>​    为了知其所以然，不再盲猜硬记，我决定结合<code>@Transaction</code>注解去了解底层的机制。</p><p>​    在<code>spring</code>中的<code>aop</code>说白了就是通过动态代理实现，而动态代理有两种实现方式(<code>jdk</code>动态代理和<code>cglib</code>动态代理)。这里简单模拟一下两种动态代理的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶层接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:30:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 10:28 下午</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserFacade</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUserInfo();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入用户信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockAnnotation</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询图书信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:32:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MockAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-jdk动态代理"><a href="#1-jdk动态代理" class="headerlink" title="1. jdk动态代理"></a>1. jdk动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理的形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:33:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass()</span><br><span class="line">          .getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">            .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeJdkProxy proxy = <span class="keyword">new</span> UserFacadeJdkProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade) proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeJdkProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure><h5 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2.cglib动态代理"></a>2.cglib动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cglib方式代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:34:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">                .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">//return methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invoke(target, args);</span><br><span class="line">        <span class="comment">//Object result = methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeCglibProxy proxy = <span class="keyword">new</span> UserFacadeCglibProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade)proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeCglibProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure><p>由以上可得出结论：不论是通过哪一种动态代理实现<code>AOP</code>，使用<code>this.xxx</code>的写法都无法使得注解生效。且如果注解标记的方法为<code>final</code>或者是<code>private</code>方法也是不能进入代理方法，原因是<code>jdk</code>动态代理是基于接口代理、<code>cglib</code>动态代理是基于继承的方式，不论是那种方式的动态代理的代理对象其实都是无法进入<code>target</code>的私有方法和<code>final</code>方法。所以根据以上动态代理可以得出结论，通过<code>this.xxx</code>的方式调用本类接口是通过被代理对象直接调用本类接口，而不是通过代理对象，也就无法进入对应的<code>invoke</code>方法或者是<code>intercept</code>方法，从而无法解析到对应的注解，如果觉得将<code>this.xxx</code>修改为<code>A</code>类调用<code>B</code>类，代码需要被迫转移到其他类影响理解，在实际中可以通过<code>ApplicationContextUtil</code>的方式获取一次代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.getUserInfo(); 修改为一下写法</span></span><br><span class="line">UserFacade userFacade = ApplicationContextUtil.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userFacade.getUserInfo();</span><br></pre></td></tr></table></figure><p>但是，好玩的来了，注意看<code>UserFacadeCglibProxy</code>类中有两行注释，采用的是<code>methodProxy.invokeSuper(o, args);</code>的方式调用，运行之后可以发现通过<code>this.xxx</code>的方式竟然可以进入<code>invoice()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :UserFacadeCglibProxy.main()</span><br><span class="line">进入调用方法</span><br><span class="line">进入调用方法</span><br><span class="line">aop某方法的前置处理</span><br><span class="line">查询图书信息</span><br><span class="line">aop某方法的后置处理</span><br><span class="line">插入用户信息</span><br></pre></td></tr></table></figure><p>这边简单对这两个调用进行一个区别：</p><p><code>methodProxy.invoke(target, args)</code>的整个执行过程为：</p><ol><li>客户端调用了代理对象的<code>insertUserInfo()</code>方法</li><li>进入代理对象的<code>intercept</code>方法</li><li>通过<code>methodProxy.invoke(target, args)</code>执行被代理对象的<code>insertUserInfo()</code></li><li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是被代理对象，所以调用时不会触发<code>intercept</code>方法</li><li>调用结束</li></ol><p><code>methodProxy.invokeSuper(o, args)</code>的整个执行过程为：</p><ol><li>客户端调用了代理对象<code>insertUserInfo()</code>方法</li><li>进入代理对象的<code>intercept</code>方法</li><li>通过<code>methodProxy.invokeSuper(o, args)</code>进入被代理对象的<code>insertUserInfo()</code></li><li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是代理对象，所以<code>getUserInfo()</code>会再次触发<code>intercept()</code></li><li>进入被代理对象的<code>getUserInfo()</code></li><li>调用结束</li></ol><p>所以最终作怪的是<code>this</code>，这个<code>this</code>代表的是代理对象(<code>proxy</code>)还是被代理对象(<code>target</code>)。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;动态代理导致注解未生效&quot;&gt;&lt;a href=&quot;#动态代理导致注解未生效&quot; class=&quot;headerlink&quot; title=&quot;动态代理导致注解未生效&quot;&gt;&lt;/a&gt;动态代理导致注解未生效&lt;/h4&gt;&lt;p&gt;​    今天在使用&lt;code&gt;mybatis-plus&lt;/code&gt;作者苞米豆的另一个项目&lt;code&gt;lock4j&lt;/code&gt;用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;lock4j&lt;/code&gt;和&lt;code&gt;mybatis-plus&lt;/code&gt;差不多，秉承着人性化使用的初衷，&lt;code&gt;lock4j&lt;/code&gt;使用上还是非常简单的，只需要在需要上锁的接口方法上使用&lt;code&gt;@Lock4j&lt;/code&gt;进行标记并设置一些简单的超时参数即可。&lt;/p&gt;
&lt;p&gt;​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用&lt;code&gt;ReentrantLock&lt;/code&gt;)，所以改造时仅仅只是对改接口上添加&lt;code&gt;@Lock4j&lt;/code&gt;注解。&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title>rabbitmq交换机类型不同导致异常</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/14/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/mq%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/14/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/mq%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8/</id>
    <published>2021-04-14T14:20:58.000Z</published>
    <updated>2021-04-14T14:39:46.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="rabbitmq交换机类型不同导致异常"><a href="#rabbitmq交换机类型不同导致异常" class="headerlink" title="rabbitmq交换机类型不同导致异常"></a>rabbitmq交换机类型不同导致异常</h4><p>​    今天收到预生产环境测试人员的消息说项目启动失败，看了一下错误是<code>rabbitmq</code>的队列监听抛出找不到该队列，没有道理，逻辑上已经经过了测试环境的测试没有理由犯这么低级的错误。吓得我赶紧看去看了一下预生产环境的<code>apollo</code>配置信息(我们使用的<code>mq</code>厂商随环境的不同可能不同)，配置信息也是对的；赶紧再次核对一下错误日志，发启动时创建交换机还有另外的报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-04-14 16:58:23.014 [AMQP Connection 192.168.2.16:5672] ERROR o.s.a.r.c.CachingConnectionFactory-Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &#x27;type&#x27; for exchange &#x27;xxxxx&#x27; in vhost &#x27;/&#x27;: received &#x27;topic&#x27; but current is &#x27;fanout&#x27;, class-id=40, method-id=10)</span><br></pre></td></tr></table></figure><p>大概的意思是已经存在该名称为<code>fanout</code>类型交换机不允许改变为<code>topic</code>类型交换机。</p><span id="more"></span><p>为什么会导致这个问题？</p><p>由于数据之间的解耦传输是由两个团队处理，A团队负责发送消息，B团队负责接收消息。沟通中没有交流清楚细节导致。</p><blockquote><p>A团队创建<code>fanout</code>类型且名称为<code>PUSH_INFO_EXCHANGE</code>的交换机</p><p>B团队创建<code>topic</code>类型且名称为<code>PUSH_INFO_EXCHANGE</code>的交换机，<code>routeKey</code>为空串，队列名称为<code>RECEIVE_INFO_QUEUE</code>。</p></blockquote><p>这就导致，AB团队同时提测，如果先启动了B服务，则<code>rabbitmq</code>创建了一个名为<code>PUSH_INFO_EXCHANGE</code>类型为广播的交换机，并绑定在<code>RECEIVE_INFO_QUEUE</code>队列上；这时如果启动A服务，在<code>RabbitMq</code>中，一旦创建了交换机是不允许改变的，所以A服务的创建是不会成功，但有意思的是，A服务推送数据时，是可以找到这个交换机，且通过空串路由键B服务可以接收到相应的数据，这样也就是导致在测试环境中没有发现这个异常的原因。而在预生产环境中，严格按照先启动A服务后再启动B服务进行就抛出了开头的异常信息。</p><p>不要问为什么AB团队都创建了同名的交换机，如果这时A的业务场景有需要将某个队列绑定到这个交换机呢？</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;rabbitmq交换机类型不同导致异常&quot;&gt;&lt;a href=&quot;#rabbitmq交换机类型不同导致异常&quot; class=&quot;headerlink&quot; title=&quot;rabbitmq交换机类型不同导致异常&quot;&gt;&lt;/a&gt;rabbitmq交换机类型不同导致异常&lt;/h4&gt;&lt;p&gt;​    今天收到预生产环境测试人员的消息说项目启动失败，看了一下错误是&lt;code&gt;rabbitmq&lt;/code&gt;的队列监听抛出找不到该队列，没有道理，逻辑上已经经过了测试环境的测试没有理由犯这么低级的错误。吓得我赶紧看去看了一下预生产环境的&lt;code&gt;apollo&lt;/code&gt;配置信息(我们使用的&lt;code&gt;mq&lt;/code&gt;厂商随环境的不同可能不同)，配置信息也是对的；赶紧再次核对一下错误日志，发启动时创建交换机还有另外的报错：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2021-04-14 16:58:23.014 [AMQP Connection 192.168.2.16:5672] ERROR o.s.a.r.c.CachingConnectionFactory-Channel shutdown: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &amp;#x27;type&amp;#x27; for exchange &amp;#x27;xxxxx&amp;#x27; in vhost &amp;#x27;/&amp;#x27;: received &amp;#x27;topic&amp;#x27; but current is &amp;#x27;fanout&amp;#x27;, class-id=40, method-id=10)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;大概的意思是已经存在该名称为&lt;code&gt;fanout&lt;/code&gt;类型交换机不允许改变为&lt;code&gt;topic&lt;/code&gt;类型交换机。&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="rabbitmq" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot的jar包如何启动</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/Spring/SpringBoot%E7%9A%84jar%E5%8C%85%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/Spring/SpringBoot%E7%9A%84jar%E5%8C%85%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T07:38:35.109Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SpringBoot的jar包如何启动"><a href="#SpringBoot的jar包如何启动" class="headerlink" title="SpringBoot的jar包如何启动"></a>SpringBoot的jar包如何启动</h4><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>​    使用过<code>SprongBoot</code>打过<code>jar</code>包的都应该知道，目标文件一般都会生成两个文件，一个是以<code>.jar</code>的包，一个是<code>.jar.original</code>文件。那么使用<code>SpringBoot</code>会打出两个包，而<code>.jar.original</code>的作用是什么呢？还有就是<code>java -jar</code>是如何将一个<code>SpringBoot</code>项目启动，之间都进行了那些的操作？</p><p>​    其实<code>.jar.original</code>是<code>maven</code>在<code>SpringBoot</code>重新打包之前的原始<code>jar</code>包，内部只包含了项目的用户类，不包含其他的依赖<code>jar</code>包，生成之后，<code>SpringBoot</code>重新打包之后，最后生成<code>.jar</code>包，内部包含了原始<code>jar</code>包以及其他的引用依赖。以下提及的<code>jar</code>包都是<code>SpringBoot</code>二次加工打的包。</p><span id="more"></span><h4 id="二、jar包的内部结构"><a href="#二、jar包的内部结构" class="headerlink" title="二、jar包的内部结构"></a>二、jar包的内部结构</h4><blockquote><p><code>SpringBoot</code>打出的<code>jar</code>包，可以直接通过解压的方式查看内部的构造。一般情况下有三个目录。</p></blockquote><ul><li><code>BOOT-INF</code>：这个文件夹下有两个文件夹<code>classes</code>用来存放用户类，也就是原始<code>jar.original</code>里的类；还有一个是<code>lib</code>，就是这个原始<code>jar.original</code>引用的依赖。</li><li><code>META-INF</code>：这里是通过<code>java -jar</code>启动的入口信息，记录了入口类的位置等信息。</li><li><code>org</code>:<code>Springboot loader</code>的代码，通过它来启动。</li></ul><p><strong>这里主要介绍一下<code>/BOOT-INF/MANIFEST.MF</code>文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="meta">Implementation-Title</span>: <span class="string">springboot-server</span></span><br><span class="line"><span class="meta">Implementation-Version</span>: <span class="string">0.0.1-SNAPSHOT</span></span><br><span class="line"><span class="meta">Archiver-Version</span>: <span class="string">Plexus Archiver</span></span><br><span class="line"><span class="meta">Built-By</span>: <span class="string">Administrator</span></span><br><span class="line"><span class="meta">Implementation-Vendor-Id</span>: <span class="string">cn.com.springboot</span></span><br><span class="line"><span class="meta">Spring-Boot-Version</span>: <span class="string">1.5.13.RELEASE</span></span><br><span class="line"><span class="meta">Implementation-Vendor</span>: <span class="string">Pivotal Software, Inc.</span></span><br><span class="line"><span class="meta">Main-Class</span>: <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"><span class="meta">Start-Class</span>: <span class="string">cn.com.springboot.center.AuthEenterBootstrap</span></span><br><span class="line"><span class="meta">Spring-Boot-Classes</span>: <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="meta">Spring-Boot-Lib</span>: <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="meta">Created-By</span>: <span class="string">Apache Maven 3.6.1</span></span><br><span class="line"><span class="meta">Build-Jdk</span>: <span class="string">1.8.0_241</span></span><br><span class="line"><span class="meta">Implementation-URL</span>: <span class="string">http://projects.spring.io/spring-boot/auth-server/</span></span><br></pre></td></tr></table></figure><p>**<code>Main-Class</code>**：记录了<code>java -jar</code>的启动入口，当使用该命令启动时就会调用这个入口类的<code>main</code>方法，显然可以看出，<code>Springboot</code>转移了启动的入口，不是用户编写的<code>xxx.xxx.BootStrap</code>的那个入口类。</p><p>**<code>Start-Class</code>**：记录了用户编写的<code>xxx.xxx.BootStrap</code>的那个入口类，当内嵌的<code>jar</code>包加载完成之后，会使用<code>LaunchedURLClassLoader</code>线程加载类来加载这个用户编写的入口类。</p><h4 id="三、加载过程"><a href="#三、加载过程" class="headerlink" title="三、加载过程"></a>三、加载过程</h4><h5 id="1-使用到的一些类"><a href="#1-使用到的一些类" class="headerlink" title="1.使用到的一些类"></a>1.使用到的一些类</h5><p><strong>3.1.1 Archive</strong></p><p>​    归档文件接口，实现迭代器接口，它有两个子类，一个是<code>JarFileArchive</code>对<code>jar</code>包文件使用，提供了返回这个<code>jar</code>文件对应的<code>url</code>、或者这个<code>jar</code>文件的<code>MANIFEST</code>文件数据信息等操作。是<code>ExplodedArchive</code>是文件目录的使用也有获取这个目录<code>url</code>的方法，以及获取这个目录下的所有<code>Archive</code>文件方法。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1faa8d1fb220b5b1b466cd0b27d62e30.png"></p><p><strong>3.1.2 Launcher</strong></p><p>​    启动程序的基类，这边最后是通过<code>JarLauncher#main()</code>来启动。<code>ExecutableArchiveLauncher</code>是抽象类，提供了获取<code>Start-Class</code>类路径的方法，以及是否还有内嵌对应文件的判断方法和获取到内嵌对应文件集合的后置处理方法的抽象，由子类<code>JarLauncher</code>和<code>WarLauncher</code>自行实现。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d5ef4fccc5146602dccccc0c53b4e074.png"></p><p><strong>3.1.3 Spring.loader下的JarFile和JarEntry</strong></p><p>​    <code>jarFile</code>继承于<code>jar.util.jar.JarFile</code>，<code>JarEntry</code>继承于<code>java.util.jar.JarEntry</code>，对原始的一些方法进行重写覆盖。每一个<code>JarFileArchive</code>都拥有一个<code>JarFile</code>方法，用于存储这个<code>jar</code>包对应的文件，而每一个<code>JarFile</code>都有一个<code>JarFileEntries</code>,<code>JarFileEntries</code>是一个迭代器。总的来说，在解析<code>jar</code>包时，会将<code>jar</code>包内的文件封装成<code>JarEntry</code>对象后由<code>JarFile</code>对象保存文件列表的迭代器。所以<code>JarFileArchive</code>和<code>JarFileEntries</code>之间是通过<code>JarFile</code>连接，二者都可以获取到<code>JarFile</code>对象。</p><h5 id="2-过程分析"><a href="#2-过程分析" class="headerlink" title="2.过程分析"></a>2.过程分析</h5><p>从<code>MANIFEST.MF</code>文件中的<code>Main-class</code>指向入口开始。</p><p>创建<code>JarLauncher</code>并且通过它的<code>launch()</code>方法开始加载<code>jar</code>包内部信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarLauncher</code>的空构造方法时一个空实现，刚开始看的时候还懵了一下，以为是在后续的操作中去加载的文件，其实不然，在创建时由父类<code>ExecutableArchiveLauncher</code>的构造方法去加载的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutableArchiveLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载为归档文件对象</span></span><br><span class="line">    <span class="keyword">this</span>.archive = createArchive();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的加载方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">  CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">  URI location = (codeSource == <span class="keyword">null</span> ? <span class="keyword">null</span> : codeSource.getLocation().toURI());</span><br><span class="line">  String path = (location == <span class="keyword">null</span> ? <span class="keyword">null</span> : location.getSchemeSpecificPart());</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to determine code source archive&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  File root = <span class="keyword">new</span> File(path);</span><br><span class="line">  <span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;Unable to determine code source archive from &quot;</span> + root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断路径是否是一个文件夹，是则返回ExplodedArchive对象，否则返回JarFileArchive</span></span><br><span class="line">  <span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root): <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== JarFileArchive =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFileArchive</span> <span class="keyword">implements</span> <span class="title">Archive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFileArchive</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(file, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFileArchive</span><span class="params">(File file, URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过这个new方法创建JarFile对象</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> JarFile(file));</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== JarFile =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFile</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">jar</span>.<span class="title">JarFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RandomAccessDataFile读取文件信息</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> RandomAccessDataFile(file));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jarLauncher#launch()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 注册URL协议的处理器，没有指定时，默认指向org.springframework.boot.loader包路径</span></span><br><span class="line">  JarFile.registerUrlProtocolHandler();</span><br><span class="line">  <span class="comment">// 获取类路径下的归档文件Archive并通过这些归档文件的URL，创建线程上下文类加载器LaunchedURLClassLoader</span></span><br><span class="line">  ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">  <span class="comment">// 使用类加载器和用户编写的启动入口类，通过反射调用它的main方法。</span></span><br><span class="line">  launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarLauncher</code>的<code>getClassPathArchives()</code>是在<code>ExecutableArchiveLauncher</code>中实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Archive&gt; <span class="title">getClassPathArchives</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  List&lt;Archive&gt; archives = <span class="keyword">new</span> ArrayList&lt;Archive&gt;(</span><br><span class="line">    <span class="comment">// 获取归档文件中满足EntryFilterg过滤器的项，isNestedArchive()方法由具体</span></span><br><span class="line">    <span class="comment">// 的之类实现。</span></span><br><span class="line">    <span class="keyword">this</span>.archive.getNestedArchives(<span class="keyword">new</span> EntryFilter() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isNestedArchive(entry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;));</span><br><span class="line">  <span class="comment">// 获取到当前归档文件下的所有子归档文件之后的后置操作，是一个扩展点。在JarLauncher</span></span><br><span class="line">  <span class="comment">// 中是一个空实现。</span></span><br><span class="line">  postProcessClassPathArchives(archives);</span><br><span class="line">  <span class="keyword">return</span> archives;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JarLauncher的具体实现，这里通过判断是否在BOOT-INF/lib/包下返回true</span></span><br><span class="line"><span class="comment"> * 也就是说只会把jar包下的BOOT-INF/lib/下的文件加载为Archive对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarFileArchive</code>的<code>getNestedArchives</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Archive&gt; <span class="title">getNestedArchives</span><span class="params">(EntryFilter filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">List&lt;Archive&gt; nestedArchives = <span class="keyword">new</span> ArrayList&lt;Archive&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry entry : <span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">// 若匹配器匹配获取内嵌归档文件</span></span><br><span class="line"><span class="keyword">if</span> (filter.matches(entry)) &#123;</span><br><span class="line">nestedArchives.add(getNestedArchive(entry));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Collections.unmodifiableList(nestedArchives);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Archive <span class="title">getNestedArchive</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">JarEntry jarEntry = ((JarFileEntry) entry).getJarEntry();</span><br><span class="line"><span class="keyword">if</span> (jarEntry.getComment().startsWith(UNPACK_MARKER)) &#123;</span><br><span class="line"><span class="keyword">return</span> getUnpackedNestedArchive(jarEntry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 根据具体的Entry对象，创建JarFile对象</span></span><br><span class="line">JarFile jarFile = <span class="keyword">this</span>.jarFile.getNestedJarFile(jarEntry);</span><br><span class="line"><span class="comment">// 封装成归档文件对象后返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JarFileArchive(jarFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get nested  entry&quot;</span>+entry.getName(),ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> JarFile <span class="title">getNestedJarFile</span><span class="params">(<span class="keyword">final</span> ZipEntry entry)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getNestedJarFile((JarEntry) entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> JarFile <span class="title">getNestedJarFile</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 根据具体的Entry对象，创建JarFile对象</span></span><br><span class="line"> <span class="keyword">return</span> createJarFileFromEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException( <span class="string">&quot;Unable to open nested jar file&#x27;&quot;</span>+entry.getName()+<span class="string">&quot;&#x27;&quot;</span>,ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JarFile <span class="title">createJarFileFromEntry</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span> createJarFileFromDirectoryEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createJarFileFromFileEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JarFile <span class="title">createJarFileFromFileEntry</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getMethod() != ZipEntry.STORED) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to open nested entry &#x27;&quot;</span></span><br><span class="line">  + entry.getName() + <span class="string">&quot;&#x27;. It has been compressed and nested &quot;</span></span><br><span class="line">  + <span class="string">&quot;jar files must be stored without compression. Please check the &quot;</span></span><br><span class="line">   + <span class="string">&quot;mechanism used to create your executable jar file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到参数entry对应的RandomAccessData对象</span></span><br><span class="line">RandomAccessData entryData = <span class="keyword">this</span>.entries.getEntryData(entry.getName());</span><br><span class="line"><span class="comment">// 这里根据springboot扩展的url协议，在父路径的基础上添加!/来标记子包</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JarFile(<span class="keyword">this</span>.rootFile, <span class="keyword">this</span>.pathFromRoot + <span class="string">&quot;!/&quot;</span> + entry.getName(),</span><br><span class="line">                   entryData, JarFileType.NESTED_JAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这基本上读取<code>jar</code>内部信息，加载为对应归档文件对象的大概过程已经讲完了，接下来分析一下在获取到了整个<code>jar</code>的归档文件对象后的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过归档文件对象列表，获取对应的url信息，并通过url信息创建LaunchedURLClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(List&lt;Archive&gt; archives)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;(archives.size());</span><br><span class="line"><span class="keyword">for</span> (Archive archive : archives) &#123;</span><br><span class="line">urls.add(archive.getUrl());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createClassLoader(urls.toArray(<span class="keyword">new</span> URL[urls.size()]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(URL[] urls)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LaunchedURLClassLoader(urls, getClass().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到对应的<code>LaunchedUrlClassLoader</code>类加载器之后，设置线程的上下文类加载器为该加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line"><span class="comment">// 根据MANIFI.MF文件中的start-classs信息创建项目启动入口主类对象，并通过run方法启动</span></span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== MainMethodRunner ================</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mainClassName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainMethodRunner</span><span class="params">(String mainClass, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mainClassName = mainClass;</span><br><span class="line"><span class="keyword">this</span>.args = (args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args.clone());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">.loadClass(<span class="keyword">this</span>.mainClassName);</span><br><span class="line">    <span class="comment">// 通过反射调用启动项目启动类的main方法</span></span><br><span class="line">Method mainMethod = mainClass.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来说一下这个<code>LaunchedURLClassLoader</code>，它继承于<code>URLClassLoader</code>，并重写了<code>loadClass</code>方法</p><p><code>LaunchedClassLoader</code>的<code>loadClass</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   Handler.setUseFastConnectionExceptions(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         definePackageIfNecessary(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (getPackage(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Package &quot;</span> + name + <span class="string">&quot; has already been &quot;</span></span><br><span class="line">                  + <span class="string">&quot;defined but it could not be found&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 调用父类loadClass方法，走正常委派流程，最终会被LaunchURLClassLoader</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      Handler.setUseFastConnectionExceptions(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============URLClassLoader =====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)<span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = AccessController.doPrivileged(</span><br><span class="line">      <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">          <span class="comment">// 根据name，将路径转化为以.class结尾的/分隔的格式。</span></span><br><span class="line">          String path = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">          <span class="comment">// 通过UrlClassPath对象根据路径获取资源类文件</span></span><br><span class="line">          Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, acc);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    <code>Springboot</code>主要实现了对<code>URL</code>加载方式进行了扩展，并且对一些对象<code>Archive</code>、<code>JarFile</code>、<code>Entry</code>等进行了抽象和扩展，最后使用<code>LaunchedUrlClassLoader</code>来进行处理。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;SpringBoot的jar包如何启动&quot;&gt;&lt;a href=&quot;#SpringBoot的jar包如何启动&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot的jar包如何启动&quot;&gt;&lt;/a&gt;SpringBoot的jar包如何启动&lt;/h4&gt;&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;​    使用过&lt;code&gt;SprongBoot&lt;/code&gt;打过&lt;code&gt;jar&lt;/code&gt;包的都应该知道，目标文件一般都会生成两个文件，一个是以&lt;code&gt;.jar&lt;/code&gt;的包，一个是&lt;code&gt;.jar.original&lt;/code&gt;文件。那么使用&lt;code&gt;SpringBoot&lt;/code&gt;会打出两个包，而&lt;code&gt;.jar.original&lt;/code&gt;的作用是什么呢？还有就是&lt;code&gt;java -jar&lt;/code&gt;是如何将一个&lt;code&gt;SpringBoot&lt;/code&gt;项目启动，之间都进行了那些的操作？&lt;/p&gt;
&lt;p&gt;​    其实&lt;code&gt;.jar.original&lt;/code&gt;是&lt;code&gt;maven&lt;/code&gt;在&lt;code&gt;SpringBoot&lt;/code&gt;重新打包之前的原始&lt;code&gt;jar&lt;/code&gt;包，内部只包含了项目的用户类，不包含其他的依赖&lt;code&gt;jar&lt;/code&gt;包，生成之后，&lt;code&gt;SpringBoot&lt;/code&gt;重新打包之后，最后生成&lt;code&gt;.jar&lt;/code&gt;包，内部包含了原始&lt;code&gt;jar&lt;/code&gt;包以及其他的引用依赖。以下提及的&lt;code&gt;jar&lt;/code&gt;包都是&lt;code&gt;SpringBoot&lt;/code&gt;二次加工打的包。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Lombok的@SneakyThrows详解</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/Spring/lombok%E7%9A%84@SneakyThrows%E8%AF%A6%E8%A7%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/Spring/lombok%E7%9A%84@SneakyThrows%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:09:17.706Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Lombok的-SneakyThrows详解"><a href="#Lombok的-SneakyThrows详解" class="headerlink" title="Lombok的@SneakyThrows详解"></a>Lombok的@SneakyThrows详解</h4><p>[TOC]</p><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>​    在<code>java</code>的异常体系中<code>Exception</code>异常有两个分支，一个是运行时异常<code>RuntimeException</code>，一个是编译时异常，在<code>Exception</code>下的所有非<code>RuntimeException</code>异常，比如<code>IOException</code>、<code>SQLException</code>等；所有的运行时异常不捕获，编译时异常是一定要捕获，否则编译会报错。<code>@SneakyThrows</code>就是利用了这一机制，将当前方法抛出的异常，包装成<code>RuntimeException</code>，骗过编译器，使得调用点可以不用显示处理异常信息。</p><span id="more"></span><h4 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若不使用@SneakyThrows注解，newInsstance方法会要求抛出InstantiationException, </span></span><br><span class="line"><span class="comment"> * IllegalAccessException异常，且调用sneakyThrowsTest()的地方需要捕获这些异常，</span></span><br><span class="line"><span class="comment"> * 加上@SneakyThrows注解之后就不需要捕获异常信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SneakyThrowsDemo.class.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如下为反编译之后的结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HelloController.class.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="comment">// 调用Lombok方法转化为RuntimeException</span></span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== ombok =========</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">sneakyThrow</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Lombok.&lt;RuntimeException&gt;sneakyThrow0(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个方法是关键，这里对入参类型的约束为&lt;T extends Throwable&gt;，而调用点将异常强转为</span></span><br><span class="line"><span class="comment"> * RuntimeException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function">T <span class="title">sneakyThrow0</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> (T)t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，为什么这个地方可以对原来的异常进行强转为<code>RuntimeExcption</code>？以下为直接强转的代码，显然运行之后报类型转换异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="comment">// 直接将e强转为RuntimeException，运行到这里会报类型转换异常。</span></span><br><span class="line">    <span class="keyword">throw</span> (RuntimeException)e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这种做法是一种通过泛型欺骗了编译器，让编译器在编译期不报错(报警告)，而最后在<code>JVM</code>虚拟机中执行的字节码的并没有区别编译时异常和运行时异常，只有是不是和抛不抛异常而已。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Lombok的-SneakyThrows详解&quot;&gt;&lt;a href=&quot;#Lombok的-SneakyThrows详解&quot; class=&quot;headerlink&quot; title=&quot;Lombok的@SneakyThrows详解&quot;&gt;&lt;/a&gt;Lombok的@SneakyThrows详解&lt;/h4&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;​    在&lt;code&gt;java&lt;/code&gt;的异常体系中&lt;code&gt;Exception&lt;/code&gt;异常有两个分支，一个是运行时异常&lt;code&gt;RuntimeException&lt;/code&gt;，一个是编译时异常，在&lt;code&gt;Exception&lt;/code&gt;下的所有非&lt;code&gt;RuntimeException&lt;/code&gt;异常，比如&lt;code&gt;IOException&lt;/code&gt;、&lt;code&gt;SQLException&lt;/code&gt;等；所有的运行时异常不捕获，编译时异常是一定要捕获，否则编译会报错。&lt;code&gt;@SneakyThrows&lt;/code&gt;就是利用了这一机制，将当前方法抛出的异常，包装成&lt;code&gt;RuntimeException&lt;/code&gt;，骗过编译器，使得调用点可以不用显示处理异常信息。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>java的泛型</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/java%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/java%E7%9A%84%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-23T12:04:45.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java的泛型"><a href="#java的泛型" class="headerlink" title="java的泛型"></a>java的泛型</h3><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    泛型实现了参数化类型的概念，使代码可以应用于多种类型，设计的初衷应该是希望类或者方法能够具备最广泛的表达能力。在引入泛型之前，一般都是依赖于<code>Object</code>顶层对象实现类似泛型的功能，但是使用<code>Object</code>有一个缺陷是如果类型转换异常，编译器在编译期无法检测这种异常，只有在字节码的运行时期才会抛出类型转换异常。而<code>JDK 1.5</code>之后引入的泛型，在编译期就会对类型进行检查，使得问题可以及早发现。</p><span id="more"></span><h4 id="二、泛型方式"><a href="#二、泛型方式" class="headerlink" title="二、泛型方式"></a>二、泛型方式</h4><h5 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h5><blockquote><p>泛型类的写法是在类上指明参数，并在属性或者方法中使用。</p></blockquote><p>先来看一下在没有泛型之前的操作方式，采用<code>Object</code>的方式，使得调用点获取到这个对象，如果需要获取到对象自身实现的某个方法，就需要进行强制类型装换，所以可能会出现类型装换异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object animal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再泛型引入之后采用如下方式，调用点在通过<code>get</code>方法获取到对象时，直接是调用点设置的参数类型，所以无需进行强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T animal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2.泛型接口"></a>2.泛型接口</h5><blockquote><p>泛型也可以应用于接口，使用上与泛型类类似。</p></blockquote><p>泛型接口对调用点来说有两种方式，一种是实现类指定了参数类型，则调用点无需再参数化类型；另一种是实现类依旧采用泛型的方式继承，则调用点就需要参数化类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">implements</span> <span class="title">People</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;display: &quot;</span>+ str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;display:&quot;</span>+t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3.泛型方法"></a>3.泛型方法</h5><blockquote><p>泛型也可以应用于方法上，并且这个方法对应的类可以是泛型类也可以不是泛型类。定义泛型方法只需要将泛型列表置于返回值之前。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt;  <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式的类型说明：</strong>对泛型方法的调用，可以显式的指明类型，语法是在点操作符与方法名之间插入尖括号，然后将类型置于尖括号中，这种方式广泛用于静态方法，使用<code>tk.mybatis</code>过都知道<code>Example</code>中创建的静态泛型方法，笔者刚开始进入公司写的时候都是按部就班，不知道泛型方法的具体逻辑，学了泛型才知道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ========= WeekendSqls ============</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeekendSqls</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SqlsCriteria</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">WeekendSqls&lt;T&gt; <span class="title">custom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeekendSqls();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  WeekendSqls&lt;People&gt; weekendSql = WeekendSqls.&lt;People&gt;custom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、泛型擦除"><a href="#三、泛型擦除" class="headerlink" title="三、泛型擦除"></a>三、泛型擦除</h4><blockquote><p>java的泛型是使用擦除来实现的，所以在真正运行的时候，任何具体的类型都会被擦除，唯一知道的是，在使用某一对象，所以对以下例子而言，最后的输出结果为<code>true</code>，类型都为<code>java.util.ArrayList</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">  Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">  System.out.println(<span class="string">&quot;c1的类型为:&quot;</span> + c1 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;c2的类型为&quot;</span> + c2);</span><br><span class="line">  System.out.println( c1 == c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-泛型数组"><a href="#1-泛型数组" class="headerlink" title="1. 泛型数组"></a>1. 泛型数组</h5><p>由于<code>Class&lt;T&gt;</code>在运行时已经被擦除，实际的结果为<code>Class</code>，而通过这个没有指定类型<code>Class</code>的<code>newInstance</code>方法不会产生具体的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.kind = kind;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T[] create(<span class="keyword">int</span> size)&#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayMaker&lt;String&gt; stringArrayMaker =  <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">    String[] stringArray = stringArrayMaker.create(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// 这里的输出结果为 [null, null, null, null, null, null, null, null, null]  </span></span><br><span class="line">    System.out.println(Arrays.toString(stringArray));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 在编译时期是Generic&lt;Integer&gt;[]，在运行时期可以理解为Object[]</span></span><br><span class="line">  <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时只会报警告，运行时会抛出类型装换异常，因为从Object[]转Generic&lt;Integer&gt;[]</span></span><br><span class="line">    <span class="comment">// gia = (Generic&lt;Integer&gt;[]) new Object[SIZE];</span></span><br><span class="line">    <span class="comment">// 由于是Generic&lt;Integer&gt;[]强转Object[]，所以运行正常。</span></span><br><span class="line">    gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个更复杂一点的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从编译器层面来说，创建数组强制装换为T[]，只会报警告</span></span><br><span class="line">    <span class="comment">// 从运行层面来说，Object[]强制装换为Object[]，正常行为</span></span><br><span class="line">    array = (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span></span>&#123;</span><br><span class="line">    array[index] = item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从编译器层面来说，获取到T[]赋值为Object[],正常行为</span></span><br><span class="line">    <span class="comment">// 从运行层面来说，Object[]赋值为Object[]，正常行为</span></span><br><span class="line">    Object[] oa = gai.rep();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的例子，在实际的编写代码中要考虑到编译器层面和运行层面，对编译器来说，需要保证类型的异常转换都在编译时期通过警告或者编译不通过的方式提示用户；对运行层面来说，由于参数化类型已经被擦除，有可能会导致出现类型转换异常。总之一句话，编译器在编译时就是尽可能的做类型检查，前置了异常的抛出时机，避免所有的类型转换异常都在运行时期抛出。</p><h5 id="2-边界"><a href="#2-边界" class="headerlink" title="2.边界"></a>2.边界</h5><p><strong>2.1上界</strong></p><blockquote><p>泛型上界采用<code>&lt;? extends T&gt;</code>表示当前泛型参数只能由<code>T</code>类型的子类构成。</p></blockquote><p><code>&lt;? extends T&gt;</code>指明了这个泛型类参数化类型的参数的只能是<code>T</code>的子类，且会影响到泛型类中<strong>入参</strong>为参数化类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="title">extend</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T item;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Plate&lt;? extends Fruit&gt; plate = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  <span class="comment">// 两个set方法均报错，由于限定了参数化类型的上界，而对于Fruit来说有很多子类</span></span><br><span class="line">  <span class="comment">// 编译器在这时不知道应该使用哪个类来创建引用。</span></span><br><span class="line">  plate.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  plate.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">  </span><br><span class="line">  Fruit f = plate.get();</span><br><span class="line">  <span class="comment">// 报错，只能通过上界类获取引用</span></span><br><span class="line">  Apple a = plate.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2下界</strong></p><blockquote><p>泛型下界采用<code>&lt;? super T&gt;</code>表示当前泛型的参数只能有<code>T</code>类型的父类构成。</p></blockquote><p><code>&lt;? super T&gt;</code>指明了这个泛型类参数化类型的参数的只能是<code>T</code>的父类，且会影响到泛型类中<strong>返回值</strong>为参数化类型的方法。还是上面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Plate&lt;? <span class="keyword">super</span> Fruit&gt; pf = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Fruit());</span><br><span class="line">  <span class="comment">// 由于限定参数类型为Fruit的超类，所以添加的元素只要是Fruit以及Fruit的</span></span><br><span class="line">  <span class="comment">// 子类都会成功</span></span><br><span class="line">  pf.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Fruit());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错，由于限定参数为Fruit的超类，不能用Fruit来引用，当然了就算是Food也不行</span></span><br><span class="line">  Fruit ff = pf.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3无界(<code>?</code>通配符)</strong></p><blockquote><p><code>?</code>称为无界通配符，表示的是一种未知类型，所以一般如果采用了<code>?</code>定义一个泛型，对其调用的是与具体类型无关的方法。最常用的应该是<code>Class&lt;?&gt;</code>，因为就算是使用泛型<code>Class&lt;T&gt;</code>也并没有依赖于<code>T</code></p></blockquote><p>如果看过<code>jdk</code>容器相关的源码，都应该知道在容器中有很多的方法都采用这种写法，即无需关心具体的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c.isEmpty(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?</code>表示的未知类型，相比于<code>Object</code>应该来说是一个更大的概念，所以<code>List&lt;?&gt; != List&lt;Object&gt;</code>，并且<code>List&lt;Object&gt;</code>不能指向<code>List&lt;?&gt;</code>的引用；而<code>List&lt;?&gt;</code>可以指向<code>List&lt;Object&gt;</code>的引用。</p><p>但是有一点需要注意若<code>List&lt;?&gt;</code>指向<code>List&lt;Object&gt;</code>之后，由于类型是未知的，所以<code>List</code>中使用泛型的方法都不能使用，也就是<code>add(E e)</code>不能使用，编译器报错；而<code>remove(Object o)</code>参数没有使用泛型，则可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objects = list;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;?&gt; list = objects;</span><br></pre></td></tr></table></figure><p><strong>2.4 小结</strong></p><p>​    不论使用哪种边界，对于存在<code>?</code>来说，表示的都是未知类型，所以在使用上下界处理时要精准的知道类型之间的继承关系，上下界对<strong>入参</strong>参数化类型和<strong>返回值</strong>参数类型行为上的区别，并且在合适的场景可以进行添加操作，合适的场景可以进行获取操作。根据<code>PECS(Producer Extends Consumer Super)</code>原则，频繁读取操作，适合使用上界<code>extends</code>，频繁插入操作，适合使用下界<code>Super</code>。</p><p><strong>2.5 不使用通过符<code>?</code>的上下界</strong></p><blockquote><p>形如<T extends Fruit>或者是<T Super Fruit>，这种方式在声明处就指定了参数化类型的值。</p></blockquote><p>修改<code>Plate</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T item;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在声明处指定参数化类型的值</span></span><br><span class="line">  Plate&lt;Fruit&gt; pf = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Fruit());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处声明参数化类型的值为Apple</span></span><br><span class="line">  Plate&lt;Apple&gt; pa = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  pa.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  <span class="comment">// 编译报错，指定只能传入Apple对象</span></span><br><span class="line">  pa.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h4><h5 id="1-基本数据类型不能作为类型参数"><a href="#1-基本数据类型不能作为类型参数" class="headerlink" title="1. 基本数据类型不能作为类型参数"></a>1. 基本数据类型不能作为类型参数</h5><p>​    在泛型中不能使用基本数据类型作为类型的参数，也就是不允许<code>ArrayList&lt;int&gt;</code>的方式，只能通过<code>java</code>的自动装箱拆箱机制，使用<code>ArrayList&lt;Integer&gt;</code>来实现。</p><h5 id="2-重载问题"><a href="#2-重载问题" class="headerlink" title="2.重载问题"></a>2.重载问题</h5><p>​    当出现多个参数化类型时，由于类型擦除的原因，重载的方法实际产生的是一样类型签名，所以不能产生不同类型的参数列表，必须提供明显有区别的方法名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">    <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k)</span></span>&#123;key = k;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-自限定的泛型"><a href="#3-自限定的泛型" class="headerlink" title="3. 自限定的泛型"></a>3. 自限定的泛型</h5><p>自限定泛型强调的是创建这个类所使用的参数与这个类具有相同的类型。感觉有点绕，下面看一下<code>java</code>编程思想中的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自限定声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; </span><br><span class="line">  T element;</span><br><span class="line">  <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自限定类型的使用就两种方式，就是以下两种方式。</span></span><br><span class="line"><span class="comment"> * 1. 这边为了引入概念来说明，标记class之后的A为A1，尖括号中的A为A2</span></span><br><span class="line"><span class="comment"> *    创建的这个类A1所使用的参数A2与这个类A1具有相同的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2. 由于A已经继承了SelfBounded&lt;A&gt;，所以B可以直接继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// It&#x27;s OK.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; set(arg); <span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125; // [Compile error]: Type parameter D is not within its bound</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.set(<span class="keyword">new</span> A());</span><br><span class="line">    a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">    a = a.get();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Enum</code>的设计正是采用泛型自限定的方式。<code>Enum</code>的泛型限定了<code>E</code>的上界为<code>Enum</code>自身，确保了<code>Enum</code>的子类才能作为泛型参数，而在枚举中<code>compareTo(E o)</code>，在比较时，希望的是传入的参数类型就是<code>Enum</code>类型。所以这种设计使得方法中传入参数和返回的方法是与创建的类型保持继承关系，也就是说<code>E extends Enum&lt;E&gt;</code>保证<code>Enum&lt;E&gt;</code>的子类，比如<code>StatusEnum</code>枚举类都能够接收或者返回其本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;java的泛型&quot;&gt;&lt;a href=&quot;#java的泛型&quot; class=&quot;headerlink&quot; title=&quot;java的泛型&quot;&gt;&lt;/a&gt;java的泛型&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h4&gt;&lt;p&gt;​    泛型实现了参数化类型的概念，使代码可以应用于多种类型，设计的初衷应该是希望类或者方法能够具备最广泛的表达能力。在引入泛型之前，一般都是依赖于&lt;code&gt;Object&lt;/code&gt;顶层对象实现类似泛型的功能，但是使用&lt;code&gt;Object&lt;/code&gt;有一个缺陷是如果类型转换异常，编译器在编译期无法检测这种异常，只有在字节码的运行时期才会抛出类型转换异常。而&lt;code&gt;JDK 1.5&lt;/code&gt;之后引入的泛型，在编译期就会对类型进行检查，使得问题可以及早发现。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC中的过滤器和拦截器</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/spring%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/spring%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:06:54.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringMVC中的过滤器和拦截器"><a href="#SpringMVC中的过滤器和拦截器" class="headerlink" title="SpringMVC中的过滤器和拦截器"></a>SpringMVC中的过滤器和拦截器</h3><p>[TOC]</p><h4 id="一、过滤器"><a href="#一、过滤器" class="headerlink" title="一、过滤器"></a>一、过滤器</h4><blockquote><p>​    过滤器<code>Filter</code>是通过实现<code>java.servlet.filter</code>接口实现过滤器功能，作用是用于对传入的<code>request</code>和响应的<code>response</code>进行一些处理，比如对请求参数进行校验，或者设置、检验头部信息，再或者对一些非法行为进行校验。由实现的接口可知，过滤器是依赖于<code>servlet</code>容器。<strong>所以由于过滤器不依赖于<code>spring</code>容器，它也就无法获取到容器中的对象。</strong></p></blockquote><span id="more"></span><p>创建一个过滤器类继承<code>java.servlet.filter</code>接口，实现<code>filter</code>中的拦截方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="comment">// 过滤器的具体执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>把创建的过滤器类加入过滤器链中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个过滤器myFilter和myFilter2，并且分别添加到FilterRegistrationBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> </span><br><span class="line">            FilterRegistrationBean();</span><br><span class="line">filterRegistrationBean.setFilter(myFilter());</span><br><span class="line">filterRegistrationBean.setName(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line">filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">filterRegistrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//filterRegistrationBean.setInitParameters();</span></span><br><span class="line"><span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter2RegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span></span><br><span class="line">            FilterRegistrationBean();</span><br><span class="line">filterRegistrationBean.setFilter(myFilter2());</span><br><span class="line">filterRegistrationBean.setName(<span class="string">&quot;myFilter2&quot;</span>);</span><br><span class="line">filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">filterRegistrationBean.setOrder(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//filterRegistrationBean.setInitParameters();</span></span><br><span class="line"><span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">myFilter2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、拦截器"><a href="#二、拦截器" class="headerlink" title="二、拦截器"></a>二、拦截器</h4><blockquote><p>拦截器<code>Interceptor</code>是通过实现<code>org.springframework.web.servlet</code>包的<code>HandlerInterceptor</code>接口实现，这个接口是<code>spring</code>容器的接口，所以它是依赖于<code>spring</code>容器的。主要作用是<code>AOP</code>的思想，可以对某一个方法进行横切，做一些业务逻辑。</p></blockquote><p><strong>1.编写自定义拦截器类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;请求调用之前&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;请求调用之后&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;afterCompletion:请求调用完成后回调方法，即在视图渲染完成后回调&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.注册自定义拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在spring2.0中WebMvcConfigurerAdapter已经过时，这里只是为了演示效果，</span></span><br><span class="line"><span class="comment"> * 有兴趣可以看下spring2.0中的WebMvcConfigurer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">registry.addInterceptor(getHandlerInterceptor()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HandlerInterceptor <span class="title">getHandlerInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomHandlerInterceptor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>过滤器和拦截器执行过程图</strong></p><p>​    在请求到达容器前，进入<code>Filter</code>过滤器链，执行完过滤器链上每个<code>Filter#doFilter()</code>方法后，进入<code>Servlet#service()</code>方法，然后由<code>dispatcher</code>分发器将请求方法给对应映射成功的处理器<code>controller</code>，在进入<code>controller</code>具体方法之前，会被先进入<code>Interceptor#preHandler()</code>方法，然后再进入<code>controller</code>的具体返回，执行之后进入<code>Interceptor#postHandler()</code>这里主要是拦截了<code>controller</code>方法执行之后到返回的数据模型到达视图解析器之前，接着进入<code>Interceptor#afterCompletion()</code>方法，主要可以操作返回客户端之前的逻辑，最后返回到过滤链中各个<code>Filter</code>的调用点，可以处理返回到客户端的跳转等逻辑。</p><p><img src="https://gitee.com/jiangjiamin/image-bed/raw/master/upic/2020-11/GvwS1P.png"></p><h4 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h4><p>​    过滤器是<code>servlet</code>中的接口，主要可以用于在请求进入到<code>servlet</code>之前拦截请求<code>HttpServletRequest</code>并根据需要进行一些检查等逻辑操作，也可以在<code>HttpServletResponse</code>返回到客户端之前进行一些逻辑操作。</p><p>​    拦截器是<code>spring</code>中的接口，所以它可以获取到<code>spring</code>中的一些<code>bean</code>和其他的一些资源，在面向切面编程中应用比较广，拦截其实就是一种<code>AOP</code>策略。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;SpringMVC中的过滤器和拦截器&quot;&gt;&lt;a href=&quot;#SpringMVC中的过滤器和拦截器&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC中的过滤器和拦截器&quot;&gt;&lt;/a&gt;SpringMVC中的过滤器和拦截器&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、过滤器&quot;&gt;&lt;a href=&quot;#一、过滤器&quot; class=&quot;headerlink&quot; title=&quot;一、过滤器&quot;&gt;&lt;/a&gt;一、过滤器&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;​    过滤器&lt;code&gt;Filter&lt;/code&gt;是通过实现&lt;code&gt;java.servlet.filter&lt;/code&gt;接口实现过滤器功能，作用是用于对传入的&lt;code&gt;request&lt;/code&gt;和响应的&lt;code&gt;response&lt;/code&gt;进行一些处理，比如对请求参数进行校验，或者设置、检验头部信息，再或者对一些非法行为进行校验。由实现的接口可知，过滤器是依赖于&lt;code&gt;servlet&lt;/code&gt;容器。&lt;strong&gt;所以由于过滤器不依赖于&lt;code&gt;spring&lt;/code&gt;容器，它也就无法获取到容器中的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从myBatis Plugin看责任链模式</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:07:05.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从myBatis-Plugin看责任链模式"><a href="#从myBatis-Plugin看责任链模式" class="headerlink" title="从myBatis Plugin看责任链模式"></a>从myBatis Plugin看责任链模式</h3><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    在<code>mybatis</code>中从<code>sql</code>的解析到最后结果集的返回，经过了一系列的内部组件，比如参数处理器<code>parameterHandler</code>，语句处理器<code>StatementHandler</code>，结果集处理器<code>ResultSetHandler</code>等。若开发者需要对<code>SQL</code>执行的某一环节进行一些特定的处理，比如参数类型的转换，数据分页功能，打印执行的<code>SQL</code>语句等都可以通过<code>mybatis</code>的插件机制实现。</p><span id="more"></span><h4 id="二、mybatis的责任链"><a href="#二、mybatis的责任链" class="headerlink" title="二、mybatis的责任链"></a>二、mybatis的责任链</h4><p>​    <code>mybatis</code>中就是对内部的一个<code>List</code>数组做拦截，业务方通过实现<code>Interceptor</code>接口后，将具体的实现类通过<code>InterceptorChain#addInterceptor</code>添加到责任链中，当<code>mybatis</code>初始化资源时，会调用<code>InterceptorChain#pluginAll</code>通过代理的方式，将所有的插件通过逐层代理的方式将内部核心组件(比如<code>ParameterHandler</code>)包裹返回一个代理对象。</p><p>​    真正执行的地方是由于将内部核心组件都包装成了代理类，所以在调用执行方法时，会被代理对象拦截进入<code>invoke</code>方法，根据执行方法所属类以及注解等判断是否执行拦截器或者是执行原方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截执行该方法</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部就是一个拦截器的List</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环调用每个Interceptor.plugin方法</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、过滤器相关责任链"><a href="#三、过滤器相关责任链" class="headerlink" title="三、过滤器相关责任链"></a>三、过滤器相关责任链</h4><p>​    在权限校验等一些拦截器中，通常的做法是有多层拦截，比如简单的登录过程，先校验用户名密码是否正确，在校验是否拥有某项操作的操作权限之后才会使得用户获取到资源，但是如果用户名密码校验失败，就没有必要进入第二部的操作权限校验，所以这种场景下使用<code>mybatis</code>那种方式的责任链有所不妥。以下是基于在多层拦截下，若某层校验失败，直接拒绝继续往下校验的责任链模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截执行方法</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function">Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现A拦截</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterA</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="comment">// 在这里选择是否继续往下走，这种方式会往下走</span></span><br><span class="line">    <span class="keyword">return</span> filterChain.doFilter(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现B拦截</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterB</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="comment">// 这种方式会直接返回，不会继续执行其他拦截器(当然了在我的例子中也没有其他拦截器了)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部维护一个数组，存储各个拦截器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Iterator iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iterator == <span class="keyword">null</span>)&#123;</span><br><span class="line">      iterator = filters.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iterator.hasNext())&#123;</span><br><span class="line">      Filter filter = (Filter) iterator.next();</span><br><span class="line">      filter.doFilter(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">  FilterA filterA = <span class="keyword">new</span> FilterA();</span><br><span class="line">  FilterB filterB = <span class="keyword">new</span> FilterB();</span><br><span class="line">  filterChain.addFilter(filterA);</span><br><span class="line">  filterChain.addFilter(filterB);</span><br><span class="line">  filterChain.doFilter(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    以上两种责任链的不同形式，其实是应对于不同的业务场景，当需要所有的拦截都走一轮，则采用第一种；当在某个拦截器失败后不继续进行，则采用第二种。在实际的场景中需要综合考虑，采取最符合业务场景的形式进行编码。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;从myBatis-Plugin看责任链模式&quot;&gt;&lt;a href=&quot;#从myBatis-Plugin看责任链模式&quot; class=&quot;headerlink&quot; title=&quot;从myBatis Plugin看责任链模式&quot;&gt;&lt;/a&gt;从myBatis Plugin看责任链模式&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h4&gt;&lt;p&gt;​    在&lt;code&gt;mybatis&lt;/code&gt;中从&lt;code&gt;sql&lt;/code&gt;的解析到最后结果集的返回，经过了一系列的内部组件，比如参数处理器&lt;code&gt;parameterHandler&lt;/code&gt;，语句处理器&lt;code&gt;StatementHandler&lt;/code&gt;，结果集处理器&lt;code&gt;ResultSetHandler&lt;/code&gt;等。若开发者需要对&lt;code&gt;SQL&lt;/code&gt;执行的某一环节进行一些特定的处理，比如参数类型的转换，数据分页功能，打印执行的&lt;code&gt;SQL&lt;/code&gt;语句等都可以通过&lt;code&gt;mybatis&lt;/code&gt;的插件机制实现。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>FastThreadLocal</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/FastThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/FastThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:07.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h3><p>[TOC]</p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    因为需要，研究了可以通过<code>InheritableThreadLocal</code>进行父子线程中如何传递本地线程变量，通过阿里开源项目<code>TransmitableThreadLocal</code>进行进行线程池传递本地线程变量(详解可查看以往博客)。在查找资料的过程中无意发现了<code>Dobbo</code>的<code>InternalThreadLocal</code>，其实<code>Dobbo</code>的<code>InternalThreadLocal</code>和<code>netty</code>的<code>FastThreadLocal</code>有异曲同工之妙。之前学<code>netty</code>的时候有了解一点，为了加深一下<code>ThreadLocal</code>种群的了解，使用本博客记录一下。</p><span id="more"></span><h4 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 原生线程调用方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      username.set(<span class="string">&quot;zhangSang&quot;</span>);</span><br><span class="line">      password.set(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      password.remove();</span><br><span class="line"></span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * FastThreadLocalThread线程调用方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> FastThreadLocalThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      username.set(<span class="string">&quot;zhangSang&quot;</span>);</span><br><span class="line">      password.set(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从运行结果看，都能获取到对应设置的值，二者没有任何输出区别，但是跟踪一下，可以看到调用的逻辑是有所区别的。</p><h4 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h4><p>​    熟悉<code>ThreadLocal</code>的应该知道，<code>Threadlocal</code>其实内部逻辑是一个以<code>ThreadLocal</code>对象为<code>key</code>，需要存储的值为<code>value</code>的<code>map</code>结构。而<code>FastThreadLocal</code>的内部实现是一个数组，实现上是直接通过下标定位元素，所以单纯从取、存的角度看，<code>FastThreadLocal</code>是比<code>ThreadLocal</code>高效。</p><p>​    对于使用原生线程<code>Thread</code>来说，其实最后是将数据存<code>Thread.threadLocals(ThreadLocal.ThreadLocalMap)</code>中,也就是说在这个线程所使用的所有<code>FastThreadLocal</code>最后都以 <code>key=ThreadLocal&lt;InternalThreadLocalMap&gt;</code><br>对象,<code>value=InternalThreadLocalMap</code>的方式存在线程<code>ThreadLocal</code>的一个节点中。而若使用的是<code>netty</code>封装的<code>FastThreadLocalThread</code>,则<code>FastThreadLocalThread</code>对象的属性<code>threadLocalMap</code>中。</p><p>​    <code>FastThreadLocalThread</code>是直接继承于线程类<code>Thread</code>，并且内部维护一个<code>InternalThreadLocalMap</code>，用于存储变量。虽然这个类命名为<code>Map</code>，结构上其实是一个数组。并且下标为0的元素是一个<code>Set&lt;FastThreadLocal&lt;?&gt;&gt;</code>的结构，存储着当前有效的<code>FastThreadLocal</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>InternalThreadLocalMap</code>中提供了一些静态方法，通过当前线程的不同类型，以不同的方式获取对应所需要的<code>InternalThreadlocalMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread thread = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 根据不同的线程类型，以不同的方式获取对应的InternalThreadLocalMap</span></span><br><span class="line">  <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">    <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> slowGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FastThreadLocalThred获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 直接从FastThreadLocalThread对象中获取InternalThreadLocalMap</span></span><br><span class="line">  InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">  <span class="comment">// 若为空,初始化一个InternalThreadLocalMap</span></span><br><span class="line">  <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原生线程的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从UnpaddedInternalThreadLocalMap中获取到ThreadLocal&lt;InternalThreadLocalMap&gt;</span></span><br><span class="line"><span class="comment">  * 在从ThreadLocal中获取InternalThreadLocalMap,若为空初始化一个。所以由此可知，原生线程</span></span><br><span class="line"><span class="comment">  * 的FasstThreadLocal具体值，是以InternalThreadLocalMap为值，存储在ThreadLocal中。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = </span><br><span class="line">    UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">  InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">    slowThreadLocalMap.set(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-set值"><a href="#1-set值" class="headerlink" title="1.set值"></a>1.set值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="comment">// 根据不同的线程类型，获取到的InternalThreadLocalMap进行设置值。</span></span><br><span class="line">    set(InternalThreadLocalMap.get(), value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="comment">// 将需要存储的值添加到InternalThreadLocalMap对应的下标位置。</span></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line">      addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove(threadLocalMap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据下标获取对应的元素</span></span><br><span class="line">  Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">  Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line">  <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若为空，创建set结构并将值添加到对应的下标位置</span></span><br><span class="line">    variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">    threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接应用取出的值</span></span><br><span class="line">    variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 添加元素到set集合中</span></span><br><span class="line">  variablesToRemove.add(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-get值"><a href="#2-get值" class="headerlink" title="2.get值"></a>2.get值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(InternalThreadLocalMap.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * get操作比较简单，直接从threadLocalMap获取对应的下标元素返回。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">  <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="keyword">return</span> (V) v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是一个默认值操作，可以通过最后的initValue()会调用FastThreadLocal#initialValue</span></span><br><span class="line"><span class="comment">  * 做一个初始化的操作。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  V v = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = initialValue();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    PlatformDependent.throwException(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">  addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-remove"><a href="#3-remove" class="headerlink" title="3.remove"></a>3.remove</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 删除对应下标值，赋值为UNSET占位符</span></span><br><span class="line">  Object v = threadLocalMap.removeIndexedVariable(index);</span><br><span class="line">  <span class="comment">//删除InternalThreadLocalMap[0]的Set&lt;FastThreadLocal&lt;?&gt;&gt;中的当前FastThreadLocal对象</span></span><br><span class="line">  removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 是一个增强，删除之后的业务逻辑，由子类实现，默认是空实现</span></span><br><span class="line">      onRemoval((V) v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    <code>FastThreadLocal</code>实际上采用的是数组的方式进行存储数据，在数据的获取、赋值都是通过下标的方式进行，而<code>ThreadLocal</code>是通过<code>map</code>结构，先计算哈希值，在进行线性探测的方式进行定位。所以在高并发下，<code>FastThreadLocal</code>应该相对高效，但是<code>FastThread</code>有一个弊端就是<code>index</code>是一直累加，也就是说如果移除了某个变量是通过将对应下标的元素标记为<code>UNSET</code>占位，而不进行回收，会无限制增大，会触发扩容等一些问题。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;FastThreadLocal&quot;&gt;&lt;a href=&quot;#FastThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;FastThreadLocal&quot;&gt;&lt;/a&gt;FastThreadLocal&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;​    因为需要，研究了可以通过&lt;code&gt;InheritableThreadLocal&lt;/code&gt;进行父子线程中如何传递本地线程变量，通过阿里开源项目&lt;code&gt;TransmitableThreadLocal&lt;/code&gt;进行进行线程池传递本地线程变量(详解可查看以往博客)。在查找资料的过程中无意发现了&lt;code&gt;Dobbo&lt;/code&gt;的&lt;code&gt;InternalThreadLocal&lt;/code&gt;，其实&lt;code&gt;Dobbo&lt;/code&gt;的&lt;code&gt;InternalThreadLocal&lt;/code&gt;和&lt;code&gt;netty&lt;/code&gt;的&lt;code&gt;FastThreadLocal&lt;/code&gt;有异曲同工之妙。之前学&lt;code&gt;netty&lt;/code&gt;的时候有了解一点，为了加深一下&lt;code&gt;ThreadLocal&lt;/code&gt;种群的了解，使用本博客记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>InheritableThreadLocal</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/InheritableThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/InheritableThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:20.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>[TOC]</p><h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>​    在<code>Thread</code>中除了有属性<code>threadLocals</code>引用<code>ThreadLocal.ThreadLocalMap</code>，其实还有一个属性，也就是<code>inheritableThreadLocals</code>，<code>threadLocals</code>的作用是保存本地线程变量，而<code>inneritableThreadLocals</code>的作用是传递当前线程本地变量<code>InheritableThreadLocal</code>到子线程的本地变量<code>InheritableThreadLocal</code>中。</p><span id="more"></span><h5 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  InheritableThreadLocal&lt;String&gt; username = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">  ThreadLocal&lt;String&gt; password = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">  username.set(<span class="string">&quot;zhangShang&quot;</span>);</span><br><span class="line">  password.set(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangShang</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>所以基本上可以得出结论：<code>InheritableThreadLocal</code>是具有父子线程传递的，而<code>ThreadLocal</code>不具有父子线程传递的功能。</p><h5 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h5><h6 id="1-InheritableThreadLocal的实现"><a href="#1-InheritableThreadLocal的实现" class="headerlink" title="1. InheritableThreadLocal的实现"></a>1. <code>InheritableThreadLocal</code>的实现</h6><p><code>InheritableThreadLocal</code>继承于<code>ThreadLocal</code>，并重写了<code>ThreadLocal</code>中的三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个接口是ThreadLocal的开放接口，默认实现是抛出UnsupportedOperationException异常。</span></span><br><span class="line"><span class="comment">     * 实现上仅返回入参，调用上是在创建子线程时使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写getMap,操作InheritableThreadLocal时，将只会影响到线程对象Thread的</span></span><br><span class="line"><span class="comment">     * inheritableThread属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与上面的获取方法getMap情况一致，创建时同理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-线程的创建过程"><a href="#2-线程的创建过程" class="headerlink" title="2.线程的创建过程"></a>2.线程的创建过程</h6><p>跟踪<code>new Thread()</code>方法。</p><blockquote><p>1.进入初始化方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.调用<code>init</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">  init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后实际调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">// parent线程为创建子线程的当前线程，也就是父线程。</span></span><br><span class="line">  Thread parent = currentThread();</span><br><span class="line">  </span><br><span class="line">... 省略一些与本章无关代码</span><br><span class="line">  <span class="comment">// inheritThreadLocals=true,默认值是true,且父线程的inheritableThreadLocal对象不为空</span></span><br><span class="line">  <span class="comment">// 创建当前线程的inheritableThreadLocals对象。    </span></span><br><span class="line">  <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">  <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">  <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set thread ID */</span></span><br><span class="line">  tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.进入创建方法<code>createInheritedMap</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 以父线程的inheritableThreadLocals为实例创建一个ThreadLocalMap对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以父线程的inheritableThreadLocals为实例创建子线程的inheritableThreadLocals对象</span></span><br><span class="line"><span class="comment"> * 实现上比较简单，将父线程的inheritableThreadLocals循环拷贝给子线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  Entry[] parentTable = parentMap.table;</span><br><span class="line">  <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">  setThreshold(len);</span><br><span class="line">  table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    Entry e = parentTable[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">      <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 至于这个地方为什么采用key.childValue(),内层的逻辑也仅仅是返回入参。</span></span><br><span class="line">        <span class="comment">// 网上有些人说是为了减轻代码的阅读难度，笔者觉得有点牵强。感觉是为了在获取</span></span><br><span class="line">        <span class="comment">// 过程中做一些小转换之类的？</span></span><br><span class="line">        Object value = key.childValue(e.value);</span><br><span class="line">        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        table[h] = c;</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h5><p>​    上面说父子进程通过<code>inheritableThreadLocals</code>属性来传递本地变量，在实际的应用场景中，一般不会出现父进程直接创建子进程的情况，一般都是采用线程池的方式，如果采用线程池那么<code>inheritableThreadLocal</code>还会有效吗？读者可以考虑一下，写个<code>demo</code>跑一下，看看具体的情况，下一篇文章将进行解答。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;InheritableThreadLocal&quot;&gt;&lt;a href=&quot;#InheritableThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;InheritableThreadLocal&quot;&gt;&lt;/a&gt;InheritableThreadLocal&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h5 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h5&gt;&lt;p&gt;​    在&lt;code&gt;Thread&lt;/code&gt;中除了有属性&lt;code&gt;threadLocals&lt;/code&gt;引用&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;，其实还有一个属性，也就是&lt;code&gt;inheritableThreadLocals&lt;/code&gt;，&lt;code&gt;threadLocals&lt;/code&gt;的作用是保存本地线程变量，而&lt;code&gt;inneritableThreadLocals&lt;/code&gt;的作用是传递当前线程本地变量&lt;code&gt;InheritableThreadLocal&lt;/code&gt;到子线程的本地变量&lt;code&gt;InheritableThreadLocal&lt;/code&gt;中。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal初探</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/ThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/ThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:35.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal初探"><a href="#ThreadLocal初探" class="headerlink" title="ThreadLocal初探"></a>ThreadLocal初探</h3><p>[TOC]</p><h4 id="一、ThreadLocal的实现原理"><a href="#一、ThreadLocal的实现原理" class="headerlink" title="一、ThreadLocal的实现原理"></a>一、ThreadLocal的实现原理</h4><p>​    <code>Thread</code>有一个内部变量<code>ThreadLocal.ThreadLocalMap</code>,这个类是<code>ThreadLocal</code>的静态内部类，它的实现与<code>HashMap</code>类似，当线程第一次调用<code>ThreadLocal</code>的<code>get/set</code>方法时会初始化它。它的键是这个<code>ThreadLocal</code>对象本身，值是需要存储的变量。也就是说<code>ThreadLocal</code>类型的本地变量是存放在具体的线程空间里。当不断的使用<code>get</code>方法获取时，是到线程独有线程空间中获取变量，使得其他线程无法访问到，也就达到了线程安全的目的。在使用完成之后，可以通过<code>remove</code>方法，移除不使用的本地变量。</p><span id="more"></span><p><strong>ThreadLocal和同步机制的比较</strong></p><p>​    如果说同步机制是一种以时间换空间的做法，那么<code>ThreadLocal</code>就是一种以空间换时间的做法，在同步机制下，当访问共享变量时，同步机制保证了同一个时刻只能有一个线程访问到，其他线程进入阻塞。<code>ThreadLocal</code>下，为每个线程都复制了共享变量的副本，也就不存在共享变量的说法。</p><h4 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h4><h5 id="1-set"><a href="#1-set" class="headerlink" title="1.set()"></a>1.set()</h5><blockquote><p>通过<code>ThreadLocal</code>的set方法调用到<code>ThreadLocal.ThreadLocalMap</code>静态内部类的set方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">          Thread t = Thread.currentThread();</span><br><span class="line">          ThreadLocalMap map = getMap(t);</span><br><span class="line">          <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">              map.set(<span class="keyword">this</span>, value);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若对象为空，则初始化threadLocalMap对象</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 先通过hashcode作为下标取数组对应位置的值，若为空，设置值。</span></span><br><span class="line">      <span class="comment">// 若不为空，往后移动一个位置，如果获取到的长度等于数组长度，从0位置查找。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">// 清除Entry对象还在，但是Entry的值为空的位置 &amp;&amp; 当前数量是否大于容量</span></span><br><span class="line">      <span class="comment">// 扩容</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这边的扩容有两个步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1. 重新排列table数组里的值，根据hashcode获取下标，若对应下标为空，则移动到该位置</span></span><br><span class="line">      <span class="comment">// 若下标位置不为空，往后移动位置，直到找到空位置。</span></span><br><span class="line">      expungeStaleEntries();</span><br><span class="line">      <span class="comment">// 2.排列的同时如果是空位置，会相应减少size，若排列之后的size仍然大于容量的3/4则扩容</span></span><br><span class="line">      <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 两倍原长度扩容</span></span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-get"><a href="#2-get" class="headerlink" title="2.get()"></a>2.get()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        T result = (T)e.value;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">      Entry e = table[i];</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取不到值有两种情况，e=null, e.get() == null,如果e=null直接返回null,</span></span><br><span class="line">    <span class="comment">// 如果e.get()=null，清除这个位置的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">          expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、继承性"><a href="#三、继承性" class="headerlink" title="三、继承性"></a>三、继承性</h4><blockquote><p><code>ThreadLocal</code>对父子线程也是一样，同样是不可相互访问。但是，在特殊情况下或许还是存在父子线程需要相互访问<code>ThreadLocal</code>中的值的业务需求。可以使用<code>ThreadLocal</code>的子类<code>InheritableThreadLocal</code>,它可以实现父子进程之间的变量获取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">InheritableThreadLocal继承ThreadLocal方法，并重写了三个方法，getMap、createMap方法</span></span><br><span class="line"><span class="comment">是为了让创建map和获取map的时候使用thread中的inheritableThreadLoca变量。而childValue</span></span><br><span class="line"><span class="comment">是为了在thread父进程调用init创建子进程时，创建子进程的inheritableThreadLocal的时候，逐</span></span><br><span class="line"><span class="comment">个拷贝父进程的nheritableThreadLocal值。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="comment">// 在这里拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// threalLocal中根据threadLocalMap创建threadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  Entry[] parentTable = parentMap.table;</span><br><span class="line">  <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">  setThreshold(len);</span><br><span class="line">  table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    Entry e = parentTable[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">      <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重写childChild方法</span></span><br><span class="line">        Object value = key.childValue(e.value);</span><br><span class="line">        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        table[h] = c;</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、内存泄漏"><a href="#四、内存泄漏" class="headerlink" title="四、内存泄漏"></a>四、内存泄漏</h4><p><img src="https://gitee.com/jiangjiamin/image-bed/raw/master/upic/2020-10/xCD8sO.png"></p><p>​    <code>ThreadLcal</code>的引用关系如上如所示，虚线是使用软引用的地方。如果这个地方使用的是强引用，在业务代码中使用<code>threadlocalInstance==null</code>将<code>ThreadLocalRef</code>和<code>ThreadLocal</code>之间的强引用置空，<code>value</code>还是会通过另一条引用链<code>currentThread-&gt;currentThread-&gt;map-&gt;entry-&gt;value</code>到达，也是不会被GC掉。而若采用软引用，在系统将要发生内存溢出时会回收掉，也就是会断掉<code>key</code>与<code>ThreadLocal</code>之间的引用，使得<code>key=null</code>。</p><p>​    在<code>ThreadLocal</code>的实现中，为了避免内存泄漏已经做了很多安全性的控制，在<code>get()</code>和<code>set()</code>方法中都有相应的处理，通过特定的方式对存在<code>key=null</code>的脏<code>Entry</code>进行<code>value=null</code>的处理，使得<code>value</code>的引用链不可达。</p><p> <strong>为什么使用弱引用？</strong></p><p>一是尽管使用强引用也会出现内存泄漏，二是在<code>ThreadLocal</code>的生命周期中<code>set、getEntry、remove</code>里，都针对键为空的脏<code>Entry</code>进行处理。但是尽管如此，在编程过程中，形成一种良好的规范，在使用完<code>ThreadLocal</code>后都应该手动调用<code>remove</code>方法进行清理。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;ThreadLocal初探&quot;&gt;&lt;a href=&quot;#ThreadLocal初探&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal初探&quot;&gt;&lt;/a&gt;ThreadLocal初探&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、ThreadLocal的实现原理&quot;&gt;&lt;a href=&quot;#一、ThreadLocal的实现原理&quot; class=&quot;headerlink&quot; title=&quot;一、ThreadLocal的实现原理&quot;&gt;&lt;/a&gt;一、ThreadLocal的实现原理&lt;/h4&gt;&lt;p&gt;​    &lt;code&gt;Thread&lt;/code&gt;有一个内部变量&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;,这个类是&lt;code&gt;ThreadLocal&lt;/code&gt;的静态内部类，它的实现与&lt;code&gt;HashMap&lt;/code&gt;类似，当线程第一次调用&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;get/set&lt;/code&gt;方法时会初始化它。它的键是这个&lt;code&gt;ThreadLocal&lt;/code&gt;对象本身，值是需要存储的变量。也就是说&lt;code&gt;ThreadLocal&lt;/code&gt;类型的本地变量是存放在具体的线程空间里。当不断的使用&lt;code&gt;get&lt;/code&gt;方法获取时，是到线程独有线程空间中获取变量，使得其他线程无法访问到，也就达到了线程安全的目的。在使用完成之后，可以通过&lt;code&gt;remove&lt;/code&gt;方法，移除不使用的本地变量。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>TransmittableThreadLocal</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/TransmittableThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/TransmittableThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:50.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><p>[TOC]</p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    上文说到父子线程传递本地变量可以通过<code>InheritableThreadlocoal</code>进行传递，但是如果采用线程池，不一定能传递，因为在线程在线程池中的存在不是每次使用都会进行创建，<code>InheritableThreadlocal</code>是在线程初始化时<code>intertableThreadLocals=true</code>才会进行拷贝传递。所以若本次使用的子线程是已经被池化的线程，从线程池中取出线下进行使用，是没有经过初始化的过程，也就不会进行父子线程的本地变量拷贝。</p><p>​    由于在日常应用场景中，绝大多数都是会采用线程池的方式进行资源的有效管理。目前知道的阿里有一个开源项目就是为了解决这个问题<code>ThansmittableThreadLocal</code>。</p><span id="more"></span><h4 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h4><p>​    在使用线程池等会池化复用线程的执行组件情况下，提供<code>ThreadLocal</code>值的传递功能，解决异步执行时上下文传递的问题。</p><p>​    <code>JDK</code>的<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html"><code>InheritableThreadLocal</code></a>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p><p>​    本章主要介绍使用线程池场景下的问题，<code>TransmittableThreadLocal</code>还有很多其他的应用场景。<a href="https://github.com/alibaba/transmittable-thread-local">传送门</a></p><h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><blockquote><p>1.引入<code>TransimittableThreadLocal</code>依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>2.简单使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建线程池</span></span><br><span class="line">  ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="comment">// 线程池经过TtlExecutors工具类包装，返回包装类ExecutorServiceTtlWrapper</span></span><br><span class="line">  executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line"><span class="comment">// 创建需要传递给线程池本地变量</span></span><br><span class="line">  TransmittableThreadLocal&lt;String&gt; username = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次调用,这时候线程池中还未有线程，就算不使用TTL也可以通过InheritableThreadLocal获取到</span></span><br><span class="line">  <span class="comment">// 父线程的本地变量。</span></span><br><span class="line">  username.set(<span class="string">&quot;zhangShang&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二次调用，由于使用的是单一线程的线程池，这时候是复用了上面创建的线程，所以这时通过</span></span><br><span class="line">  <span class="comment">// inheritableThreadLocal是获取不到本地变量的。</span></span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">  username.set(<span class="string">&quot;liSi&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">  username.set(<span class="string">&quot;wangWu&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangShang</span><br><span class="line">liSi</span><br><span class="line">wangWu</span><br></pre></td></tr></table></figure><h4 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h4><blockquote><p>从定义来看，<code>TransimittableThreadLocal</code>继承于<code>InheritableThreadLocal</code>，并实现<code>TtlCopier</code>接口，它里面只有一个<code>copy</code>方法。所以主要是对<code>InheritableThreadLocal</code>的扩展。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">TtlCopier</span>&lt;<span class="title">T</span>&gt; </span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>TransimittableThreadLocal</code>中添加<code>holder</code>属性。这个属性的作用就是被标记为具备线程传递资格的对象都会被添加到这个对象中。<strong>要标记一个类，比较容易想到的方式，就是给这个类新增一个<code>Type</code>字段，还有一个方法就是将具备这种类型的的对象都添加到一个静态全局集合中。之后使用时，这个集合里的所有值都具备这个标记。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. holder本身是一个InheritableThreadLocal对象</span></span><br><span class="line"><span class="comment">// 2. 这个holder对象的value是WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;</span></span><br><span class="line"><span class="comment">// 2.1 WeekHashMap的value总是null,且不可能被使用。</span></span><br><span class="line"><span class="comment">//    2.2 WeekHasshMap支持value=null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder = <span class="keyword">new</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写了childValue方法，实现上直接将父线程的属性作为子线程的本地变量对象。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>应用代码是通过<code>TtlExecutors</code>工具类对线程池对象进行包装。工具类只是简单的判断，输入的线程池是否已经被包装过、非空校验等，然后返回包装类<code>ExecutorServiceTtlWrapper</code>。根据不同的线程池类型，有不同和的包装类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">getTtlExecutorService</span><span class="params">(<span class="meta">@Nullable</span> ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (TtlAgent.isTtlAgentLoaded() || executorService == <span class="keyword">null</span> || executorService <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceTtlWrapper(executorService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进入包装类<code>ExecutorServiceTtlWrapper</code>。可以注意到不论是通过<code>ExecutorServiceTtlWrapper#submit</code>方法或者是<code>ExecutorTtlWrapper#execute</code>方法，都会将线程对象包装成<code>TtlCallable</code>或者<code>TtlRunnable</code>，用于在真正执行<code>run</code>方法前做一些业务逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在ExecutorServiceTtlWrapper实现submit方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="meta">@NonNull</span> Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> executorService.submit(TtlCallable.get(task));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在ExecutorTtlWrapper实现execute方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">  executor.execute(TtlRunnable.get(command));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所以，重点的核心逻辑应该是在<code>TtlCallable#call()</code>或者<code>TtlRunnable#run()</code>中。以下以<code>TtlCallable</code>为例，<code>TtlRunnable</code>同理类似。在分析<code>call()</code>方法之前，先看一个类<code>Transmitter</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获当前线程中的是所有TransimittableThreadLocal和注册ThreadLocal的值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(captureTtlValues(), captureThreadLocalValues());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获TransimittableThreadLocal的值,将holder中的所有值都添加到HashMap后返回。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captureTtlValues() &#123;</span><br><span class="line">    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;Object&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">      ttl2Value.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ttl2Value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获注册的ThreadLocal的值,也就是原本线程中的ThreadLocal,可以注册到TTL中，在</span></span><br><span class="line"><span class="comment">    * 进行线程池本地变量传递时也会被传递。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; captureThreadLocalValues() &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;ThreadLocal&lt;Object&gt;,TtlCopier&lt;Object&gt;&gt;entry:threadLocalHolder.entrySet())&#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      <span class="keyword">final</span> TtlCopier&lt;Object&gt; copier = entry.getValue();</span><br><span class="line">      threadLocal2Value.put(threadLocal, copier.copy(threadLocal.get()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadLocal2Value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将捕获到的本地变量进行替换子线程的本地变量，并且返回子线程现有的本地变量副本backup。</span></span><br><span class="line"><span class="comment">    * 用于在执行run/call方法之后，将本地变量副本恢复。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(<span class="meta">@NonNull</span> Object captured)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Snapshot capturedSnapshot = (Snapshot) captured;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(replayTtlValues(capturedSnapshot.ttl2Value), </span><br><span class="line">                        replayThreadLocalValues(capturedSnapshot.threadLocal2Value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换TransmittableThreadLocal</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; replayTtlValues(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured) &#123;</span><br><span class="line">    <span class="comment">// 创建副本backup</span></span><br><span class="line">    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line">      <span class="comment">// 对当前线程的本地变量进行副本拷贝</span></span><br><span class="line">      backup.put(threadLocal, threadLocal.get());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若出现调用线程中不存在某个线程变量，而线程池中线程有，则删除线程池中对应的本地变量</span></span><br><span class="line">      <span class="keyword">if</span> (!captured.containsKey(threadLocal)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        threadLocal.superRemove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将捕获的TTL值打入线程池获取到的线程TTL中。</span></span><br><span class="line">    setTtlValuesTo(captured);</span><br><span class="line">    <span class="comment">// 是一个扩展点，调用TTL的beforeExecute方法。默认实现为空</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; replayThreadLocalValues(<span class="meta">@NonNull</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; captured) &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; backup = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ThreadLocal&lt;Object&gt;, Object&gt; entry : captured.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      backup.put(threadLocal, threadLocal.get());</span><br><span class="line">      <span class="keyword">final</span> Object value = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (value == threadLocalClearMark) threadLocal.remove();</span><br><span class="line">      <span class="keyword">else</span> threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清除单线线程的所有TTL和TL，并返回清除之气的backup</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;ThreadLocal&lt;Object&gt;,TtlCopier&lt;Object&gt;&gt;entry:threadLocalHolder.entrySet())&#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal2Value.put(threadLocal, threadLocalClearMark);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> replay(<span class="keyword">new</span> Snapshot(ttl2Value, threadLocal2Value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 还原</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="meta">@NonNull</span> Object backup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Snapshot backupSnapshot = (Snapshot) backup;</span><br><span class="line">    restoreTtlValues(backupSnapshot.ttl2Value);</span><br><span class="line">    restoreThreadLocalValues(backupSnapshot.threadLocal2Value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreTtlValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展点，调用TTL的afterExecute</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!backup.containsKey(threadLocal)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        threadLocal.superRemove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本地变量恢复成备份版本</span></span><br><span class="line">    setTtlValuesTo(backup);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTtlValuesTo</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttlValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; entry : ttlValues.entrySet()) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; backup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ThreadLocal&lt;Object&gt;, Object&gt; entry : backup.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 快照类，保存TTL和TL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Snapshot</span><span class="params">(HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value,</span></span></span><br><span class="line"><span class="function"><span class="params">                     HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ttl2Value = ttl2Value;</span><br><span class="line">      <span class="keyword">this</span>.threadLocal2Value = threadLocal2Value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>进入<code>TtlCallable#call()</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object captured = capturedRef.get();</span><br><span class="line">  <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterCall &amp;&amp; </span><br><span class="line">      !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;TTL value reference is released after call!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用replay方法将捕获到的当前线程的本地变量，传递给线程池线程的本地变量，</span></span><br><span class="line">  <span class="comment">// 并且获取到线程池线程覆盖之前的本地变量副本。</span></span><br><span class="line">  Object backup = replay(captured);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 线程方法调用</span></span><br><span class="line">    <span class="keyword">return</span> callable.call();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 使用副本进行恢复。</span></span><br><span class="line">    restore(backup);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到这基本上线程池方式传递本地变量的核心代码已经大概看完了。总的来说在创建<code>TtlCallable</code>对象是，调用<code>capture()</code>方法捕获调用方的本地线程变量，在<code>call()</code>执行时，将捕获到的线程变量，替换到线程池所对应获取到的线程的本地变量中，并且在执行完成之后，将其本地变量恢复到调用之前。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;TransmittableThreadLocal&quot;&gt;&lt;a href=&quot;#TransmittableThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;TransmittableThreadLocal&quot;&gt;&lt;/a&gt;TransmittableThreadLocal&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;​    上文说到父子线程传递本地变量可以通过&lt;code&gt;InheritableThreadlocoal&lt;/code&gt;进行传递，但是如果采用线程池，不一定能传递，因为在线程在线程池中的存在不是每次使用都会进行创建，&lt;code&gt;InheritableThreadlocal&lt;/code&gt;是在线程初始化时&lt;code&gt;intertableThreadLocals=true&lt;/code&gt;才会进行拷贝传递。所以若本次使用的子线程是已经被池化的线程，从线程池中取出线下进行使用，是没有经过初始化的过程，也就不会进行父子线程的本地变量拷贝。&lt;/p&gt;
&lt;p&gt;​    由于在日常应用场景中，绝大多数都是会采用线程池的方式进行资源的有效管理。目前知道的阿里有一个开源项目就是为了解决这个问题&lt;code&gt;ThansmittableThreadLocal&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>扫包路径引发项目启动失败</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E6%89%AB%E5%8C%85%E8%B7%AF%E5%BE%84%E5%BC%95%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E6%89%AB%E5%8C%85%E8%B7%AF%E5%BE%84%E5%BC%95%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:04:35.806Z</updated>
    
    <content type="html"><![CDATA[<h5 id="指定扫包路径的坑"><a href="#指定扫包路径的坑" class="headerlink" title="指定扫包路径的坑"></a>指定扫包路径的坑</h5><p>​    由于项目包结构的修改对<code>feign</code>调用的类的编写修改了路径，原来的路径为<code>cn.com.projectname.feign</code>包下，新的<code>feign</code>需添加到<code>cn.com.projectname.common.feign</code>下。首次添加到该包下发现，新的<code>feign</code>类没有被加载到<code>spring</code>容器中，所以推测是扫包路径的问题，故通过<code>@EnableFeignClients(basePackages = &#123;&quot;cn.com.projectname.feign&quot;, &quot;cn.com.projectname.common.feign&quot;&#125;)</code>指定扫包路径，神奇的事情发生了，启动之后报错，内容为<code>cn.com.projectname.common.feign</code>下新增的那个<code>feign</code>类已经被加载到<code>spring</code>容器中，不允许二次加载！找了许久并没有找到什么问题。还尝试通过<code>@FeignClient(contextId = &quot;xxx&quot;)</code>的方式指定创建类名称，也还是失败了，最后发现玄机是在<code>@EnableFeignClients</code>的<code>basePackages</code>上，由于指定的两个包路径出现重叠部分，导致在扫包过程中重复添加某对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;指定扫包路径的坑&quot;&gt;&lt;a href=&quot;#指定扫包路径的坑&quot; class=&quot;headerlink&quot; title=&quot;指定扫包路径的坑&quot;&gt;&lt;/a&gt;指定扫包路径的坑&lt;/h5&gt;&lt;p&gt;​    由于项目包结构的修改对&lt;code&gt;feign&lt;/code&gt;调用的类的编写修改了路径</summary>
      
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/"/>
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>由拆箱引发NPE</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%B1%E6%8B%86%E7%AE%B1%E5%BC%95%E5%8F%91bug/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%B1%E6%8B%86%E7%AE%B1%E5%BC%95%E5%8F%91bug/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:06:06.436Z</updated>
    
    <content type="html"><![CDATA[<h5 id="由拆箱引发bug"><a href="#由拆箱引发bug" class="headerlink" title="由拆箱引发bug"></a>由拆箱引发bug</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  Integer b = <span class="keyword">null</span>;</span><br><span class="line">  System.out.println(a == b); <span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>b</code>是包装类型，而<code>a</code>是基本数据类型，在比较时对<code>b</code>进行拆箱，所以会通过<code>((Integer)null).intValue()</code>进行拆箱，从而引发<code>NPE</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;由拆箱引发bug&quot;&gt;&lt;a href=&quot;#由拆箱引发bug&quot; class=&quot;headerlink&quot; title=&quot;由拆箱引发bug&quot;&gt;&lt;/a&gt;由拆箱引发bug&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库索引字段过长</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E8%BF%87%E9%95%BF/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E8%BF%87%E9%95%BF/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:07:44.459Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数据库索引字段过长"><a href="#数据库索引字段过长" class="headerlink" title="数据库索引字段过长"></a>数据库索引字段过长</h5><p>​    <strong>问题</strong>：在业务场景中，某些敏感数据需加密之后保存到数据库，而加密字段刚好又是频繁触发查询的字段。在一次插入数据时引发唯一索引异常。原因是索引长度小于数据库字段长度，在比对数据唯一性时截取了该字段的前面部分长度，导致匹配成功，抛出唯一索引异常。</p><p>​    <strong>方案</strong>：这种情况下不能随意调整索引的长度，这涉及到全局的修改。故通过新增一个字段保存改加密字段<code>MD5</code>值，并将索引挂在这个新增字段上，这样既保证了索引的唯一性，又可以不用修改索引长度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;数据库索引字段过长&quot;&gt;&lt;a href=&quot;#数据库索引字段过长&quot; class=&quot;headerlink&quot; title=&quot;数据库索引字段过长&quot;&gt;&lt;/a&gt;数据库索引字段过长&lt;/h5&gt;&lt;p&gt;​    &lt;strong&gt;问题&lt;/strong&gt;：在业务场景中，某些敏感数据需加密之</summary>
      
    
    
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/categories/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="数据库" scheme="http://xiaocainiaoya.github.io/categories/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://xiaocainiaoya.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
</feed>
