<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2024-07-29T13:26:27.648Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s入门</title>
    <link href="http://xiaocainiaoya.github.io/2024/07/29/k8s/k8s%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2024/07/29/k8s/k8s%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-29T13:43:58.000Z</published>
    <updated>2024-07-29T13:26:27.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s入门"><a href="#k8s入门" class="headerlink" title="k8s入门"></a>k8s入门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><span id="more"></span><p><b>1.私有网络VPC</b></p><p>​    在集群内通过设置VPC来进行私有网络（专有网络）配置。</p><p><img src="https://s2.loli.net/2024/07/14/xGjEFrJ8U4Tb69K.png" alt="VPC.png"></p><p>集群内的机器通过私有IP进行访问，这样不需要走公网IP的流量，访问时也不会因为公网的带宽限制。一般云服务器都会默认分配对应的专有网络，也可以自己配置专有网络。</p><p>若自己配置专有网络，需要配置IP网段，这个网段标志着这个专有网络最多能容纳多少台服务器。</p><p>比如配置的网段是：192.168.0.1/16(192.168.0.0 ~ 192.168.255.255)其中头尾IP被占用，剩下的IP就可以分配给对应的服务器，之后就可以通过私有网络进行访问。</p><p>在一些云产商，在配置了专用VPC之后，还可以配置交换机。再一级的细分网段。</p><p>所以比如这时可以加两个交换机（192.168.0.1/24）（192.168.10.1/24）。</p><p><b>如果创建了多个VPC，VPC与VPC之间是相互隔离的，相互VPC之下的机器是无法互通。</b></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Pod：是<code>K8s</code>调度的基本单位，一个<code>Pod</code>中支持多个容器，其中多个容器共享网络和文件系统，可以通过进程通信和文件共享这种简单高效的方式组合完成服务。每个<code>Pod</code>都有一个特殊的根容器<code>Pause</code>容器，以及一个或多个的业务容器组成。<code>Pause</code>容器作为根容器，以它的状态来代表这个<code>Pod</code>的运行状态，每个<code>Pod</code>都分配了一个唯一的<code>IP</code>地址（<code>Pod IP</code>)。<code>Pod</code>内的所有业务容器都共享根容器的<code>Ip</code>，以及共享根容器挂载的<code>Volume</code>。</li><li>Node：是<code>Pod</code>真正运行的主机，可以是物理机也可以是虚拟机，为了更好的管理<code>Pod</code>，在每个<code>Node</code>节点上至少要容器引擎（<code>docker</code>）、<code>kubelet</code>、<code>kubelet-proxy</code>服务。</li><li>Namespace：命名空间，是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或者用户组。</li><li>Label：是<code>k8s</code>对象的标签，以键值的方式附加到各种资源上，一个资源对象可以定义任意数量的<code>Label</code>，同一个<code>Label</code>也可以被添加到任意数量的资源上，<code>k8s</code>通过<code>Label Selector</code>（标签选择器）来查询和筛选某些<code>Label</code>资源对象。</li><li>Service：是一个服务的访问入口，通过标签选择器<code>Label Selector</code>与<code>Pod</code>副本集群之间进行对接，定义了一组的<code>Pod</code>访问策略（<code>iptable</code>），防止<code>Pod</code>失联。在创建<code>Service</code>时会自动为它分配一个虚拟的<code>IP</code>地址，即<code>Cluster IP</code>，服务发现就是通过<code>Service</code>的<code>Name</code>和<code>ClusterIP</code>地址做了一个<code>DNS</code>域名映射来解决。</li><li>RepllcaSet(RC)：用来确保预期的<code>Pod</code>副本数量，如果有过多的<code>Pod</code>副本运行，则会停止一些，反之则再启动一些。一般很少主动操作<code>RC</code>，都是通过<code>Deployment</code>这个更高层次的资源对象使用，从而形成一整套<code>Pod</code>创建、删除、更新的编排机制。</li><li>Deployment：用于部署无状态应用，只需要在<code>Deployment</code>上描述想要的目标状态，它就会将<code>Pod</code>和<code>RC</code>的实际状态改变到目标状态。</li></ul><h2 id="架构组件"><a href="#架构组件" class="headerlink" title="架构组件"></a>架构组件</h2><p><img src="https://s2.loli.net/2024/06/13/dZ17RHOM3BuYVFp.png" alt="k8s.png"></p><p><b>k8s主要由以下核心组件组成：</b>在<code>k8s</code>集群中分为<code>master</code>主节点和<code>node</code>工作节点。</p><p><b>在主节点中：（控制平面）</b></p><ul><li>kube-apiserver：提供了资源操作的唯一入口，各组件的协调者，以<code>Http Rest</code>方式提供接口服务，所有对象资源的增、删、改、查和监听都交给它处理后再提交到<code>etcd</code>中存储。</li><li>etcd：键值数据库，保存了整个集群的一些信息。比如<code>Pod</code>、<code>Service</code>等对象信息。</li><li>kube-scheduler：调度器，根据调度算法为新创建的<code>Pod</code>选择一个<code>node</code>工作节点，可以任意部署，可以部署在同一个工作节点上，也可以部署在不同的工作节点上。</li><li>kube-controller-manager：是所有资源对象的自动化控制中心，一个资源对应一个控制器，而它就是负责管理这些控制器。比如有：<ul><li>节点控制器</li><li>任务控制器</li><li>端点控制器</li><li>副本控制器</li><li>服务账户与令牌控制器</li></ul></li></ul><p><b>在工作节点中：</b></p><ul><li>kubelet：它是<code>master</code>主节点在<code>node</code>工作节点上的<code>agent</code>(代理），主节点通过它来管理当前工作节点的运行容器的生命周期，负责<code>Pod</code>对应容器的创建、启停等，实现集群管理的基本功能。</li><li>kube-proxy：在工作节点上实现<code>Pod</code>网络代理，实现<code>kubernets Service</code>的通信，维护网络规则和四层负责均衡工作。</li><li>docker engine：容器引擎，负责本机的容器创建和管理工作。</li></ul><h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><p><b>环境部署前遇到的一些问题</b></p><ul><li>由于需要使用到<code>yum</code>来下载一些包，但是<code>yum</code>需要访问镜像仓库，始终无法访问到<code> mirrorlist.centos.org</code>，所以需要更换为国内的的一些镜像源。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos7的镜像源文件的目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment"># 将原本的CentOS-Base.repo备份后</span></span><br><span class="line"><span class="comment"># 使用阿里云镜像站，如果能使用wget，则直接下载，如果不能，可以先下载文件后贴进去</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用网易镜像站</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.<span class="built_in">help</span>/CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure><p>添加安装<code>docker</code>镜像源，这个命令执行之后，会在<code>/etc/yum.repos.d</code>目录下生成<code>docker-ce.repo</code>文件。是专门针对<code>docker</code>的软件包镜像源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装<code>docker</code>，安装<code>docker</code>要注意需要和<code>k8s</code>版本匹配。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置加速镜像源</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://gr4yxx0x.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><b>接着就可以开始安装K8S</b></p><ul><li>设置<code>hostname</code>，每台服务器的主机名不可重复。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主机名</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure><ul><li>关闭交互区，一些安全配置</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 交换分区</span></span><br><span class="line">  free -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）  第一行是临时禁用，第二行是永久禁用</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap；第一行是临时禁用，第二行是永久禁用</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 iptables 检查桥接流量 （K8s 官方要求）</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让配置生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><ul><li>安装k8s三大件（<code>kubelet</code>、<code>kubeadm</code>、<code>kubectl</code>）版本使用<code>1.20.9</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置k8s的yum源</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装三大件</span></span><br><span class="line">yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动kubelet</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubelet 状态：一会停止 一会运行。 这个状态是对的，kubelet 等待 kubeadm 发号指令。</span></span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p>在<code>k8s</code>组件中，除了<code>kubelet</code>，其他组件都是通过容器的方式下载运行。</p><ul><li>安装其他组件的容器</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置镜像，生成 images.sh</span></span><br><span class="line"><span class="comment"># 逻辑上只需要在master节点上下载所有的容器镜像，在work节点上只需要下载kube-proxy</span></span><br><span class="line">sudo tee ./images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure><ul><li>初始化主节点</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个要在每个节点上都配置对主节点的本地路由映射</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;10.211.55.15  cluster-endpoint&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主节点初始化 （只在 master 服务器执行， 其他 node 不用）</span></span><br><span class="line"><span class="comment"># --apiserver-advertise-address: master 的 IP</span></span><br><span class="line"><span class="comment"># --control-plane-endpoint: master 的域名</span></span><br><span class="line"><span class="comment"># --image-repository docker镜像仓库</span></span><br><span class="line"><span class="comment"># --service-cidr 和 --pod-network-cidr 是网络范围，建议不要改。要改的话 2 个cidr 和 vps（172.31.x.x） 的，3 个网络互相不能重叠；还要修改 calico.yaml的 IP（下图有写）。</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.211.55.15 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure><p>如果使用的是云服务器要注意，至少要允许在<code>2c</code>的服务器上。</p><p>安装成功后会得到以下提示信息，需要根据以下信息进行操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and <span class="keyword">then</span> running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c </span><br></pre></td></tr></table></figure><ul><li>这时通过<code>kubectl get nodes</code>可以看到当前的节点状态，但是此时的主节点状态还是<code>NotReady</code>，是因为还需要下载一个网络组件。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用calico网络组件，在主节点下载 calico.yaml</span></span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">curl https://docs.projectcalico.org/v3.20/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><p>这里有一个问题：我使用的是阿里云的镜像加速器，但是好像一直无法下载<code>calico</code>镜像。所以只能通过一些非常规手段下载。创建<code>calico.sh</code>，之后<code>chmod +x calico.sh &amp;&amp; ./calico.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/projectcalico/calico/releases/tag/v3.20.6 通过这个地址下载release-v3.20.6.tgz包，然后上传到服务器中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后创建cailco.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf release-v3.20.6.tgz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> release-v3.20.6</span><br><span class="line"><span class="built_in">cd</span> images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环加载 image</span></span><br><span class="line">sudo tee load-images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">tars=(</span><br><span class="line">calico-kube-controllers.tar</span><br><span class="line">calico-node.tar</span><br><span class="line">calico-typha.tar</span><br><span class="line">calico-cni.tar</span><br><span class="line">calico-pod2daemon-flexvol.tar</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> tar <span class="keyword">in</span> <span class="variable">$&#123;tars[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker load &lt; <span class="variable">$tar</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod +x load-images.sh &amp;&amp; ./load-images.sh</span><br></pre></td></tr></table></figure><p>同时需要修改下载的<code>calico.yaml</code>中的镜像地址。(<b>注意：如果是通过这种方式，则工作节点也需要同样操作，因为工作节点也需要这个镜像。</b>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本 calico.yaml 中所规定的 image 资源都是长这样的 docker.io/calico/cni:v3.20.6， 由于这个 docker.io/ 前缀会导致 k8s 去 DockerHub 上找 image (前面已解释了走不了阿里加速器的原因)，而不是使用刚才我们导入进本地的 images。所以我们用 sed -i 来全局查找替换，去掉它们。</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/image: docker.io\//image: /g&#x27;</span> calico.yaml</span><br></pre></td></tr></table></figure><ul><li>工作节点运行命令，使得工作节点加入集群</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果使用虚拟机部署，要注意服务器之间的防火墙有没有关闭，可能出现无法访问的情况。    </span></span><br></pre></td></tr></table></figure><p>加入集群的令牌的有效期是24小时，重新获取令牌。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新获取令牌</span></span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure><p>在k8s中一般都是通过<code>.yaml</code>来进行一些操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml</span><br><span class="line">kubectl delete -f xxx.yaml</span><br></pre></td></tr></table></figure><p>我在测试时候使用的是云服务器，后面转到虚拟机上，部署了同样的环境。(不行，这个修改方式有问题，虽然乍一看修改之后是没有什么问题，通过<code>kubectl get nodes</code>查看的状态也是对的，但是我在创建<code>pod</code>的时候一直创建不起来，甚至连<code>pod</code>都没有去创建，也不知道是因为什么，通过<code>systemctl status kubelet</code>查看日志，其中有打印出还是通过旧的地址访问<code>serverapi</code>接口，说明哪里改漏了，没有改到，但是具体哪里就不知道了。)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 但是由于我部署的时候是和我后面用的时候不是同一个wifi网络环境，导致我在重启虚拟机之后ip变了。</span></span><br><span class="line"><span class="comment"># 重启虚拟机之后要先启动docker，再启动k8s</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/kubernetes/manifests</span><br><span class="line">vi etcd.yaml</span><br><span class="line">vi kube-apiserver.yaml</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 k8s 集群 所有节点</span></span><br><span class="line">kubectl get nodex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 k8s 集群 部署了 哪些应用运行的应用在 docker 中叫 container（容器），在 k8s 中叫 pod</span></span><br><span class="line">kubectl get pods -A对应 docker 中 的docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 默认命名空间（default）部署的应用</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 完整的信息，有 部署的 节点、节点IP 等。</span></span><br><span class="line">kubectl get pod -A -owide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 整个状态变化过程</span></span><br><span class="line">kubectl get pod -w</span><br></pre></td></tr></table></figure><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 某个命名空间（kubernetes-dashboard）部署的应用</span></span><br><span class="line">kubectl get pod -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建命名空间 hello</span></span><br><span class="line">kubectl create ns hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命名空间 hello</span></span><br><span class="line">kubectl delete ns hello</span><br></pre></td></tr></table></figure><h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为 mynginx-k8s 的 Pod （默认命名空间）</span></span><br><span class="line">kubectl run mynginx-k8s --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到 Pod 里面（和 docker exec -it 一样的）</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it Pod名字 -- /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod mynginx-k8s 的描述</span></span><br><span class="line">kubectl describe pod mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 在默认命名空间的 mynginx-k8s</span></span><br><span class="line">kubectl delete pod mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 在 xxx 命名空间的 mynginx-k8s</span></span><br><span class="line">kubectl delete pod mynginx-k8s -n xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod mynginx-k8s 的运行日志（默认的命名空间）</span></span><br><span class="line">kubectl logs mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 运行日志（-n 就是 namespace 命名空间）</span></span><br><span class="line">kubectl logs -f -n xxx命名空间 xxxPodName</span><br></pre></td></tr></table></figure><h4 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 Deployment 部署 Pod，deploy 名为 mytomcat，使用镜像 tomcat:8.5.68</span></span><br><span class="line">kubectl create deployment mytomcat --image=tomcat:8.5.68</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Deployment 创建的资源</span></span><br><span class="line">kubectl get deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Deployment 创建的资源，用 delete 是删不掉的</span></span><br><span class="line">kubectl delete deploy mytomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># --replicas=3，部署 3个 Pod my-dep</span></span><br><span class="line">kubectl create deployment my-dep --image=nginx --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Deployment my-dep 扩容 成 5 个 Pod</span></span><br><span class="line">kubectl scale deploy/my-dep --relicas=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Deployment my-dep 缩容 成 2 个 Pod</span></span><br><span class="line">kubectl scale deploy/my-dep --relicas=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前用的镜像（spec.container.image）</span></span><br><span class="line">kubectl get deploy/my-dep -oyaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前用的镜像</span></span><br><span class="line">kubectl get deploy/my-dep -oyaml | grep image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变 my-dep 中 nginx 版本（nginx 最新版 -&gt; 1.16.1）滚动更新</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/my-dep nginx=nginx:1.16.1 --recordkubectl rollout status deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史记录</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 my-dep 某个历史详情</span></span><br><span class="line">kubectl rollout histroy deployment/my-dep --revision=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># my-dep 回滚（回到上个版本）</span></span><br><span class="line">kubectl rollout undo deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># my-dep 回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment/my-dep --to-revision=2</span><br></pre></td></tr></table></figure><p>在<code>deployment</code>中还有一些细分：</p><ul><li>Deployment：无状态应用部署，比如微服务，提供多副本等功能。</li><li>StatefulSet：有状态应用部署，比如redis，提供稳定的存储、网络等功能</li><li>DeamonSet：守护型应用部署，比如日志收集组件，在每个机器都运行一份。</li><li>Job/CronJob:定时任务部署，比如垃圾清理组件，可以在指定时间运行。</li></ul><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><code>Pod</code>的服务发现与负责均衡，将一组<code>Pods</code>公开为网络服务的抽象方法。如果访问是通过直接<code>IP</code>的方式，当其中的一个<code>Pod</code>或者是服务器宕了之后，就直接无法访问了，所以在<code>k8s</code>中，<code>Pod</code>的网络控制由<code>Service</code>管理，请求访问到<code>Service</code>上，由<code>Service</code>转到对应的<code>Pod</code>上，当然它也有负载均衡的能力。</p><p><b>Service有两种创建方式，或者说有两种创建类型</b></p><ul><li>ClusterIP：默认的访问方式（创建的时候不写就是使用这种方式），只能集群内访问。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl expose 暴露端口，只能在集群内部 ClusterIP 访问。--type=ClusterIP 不传默认就是ClusterP</span></span><br><span class="line"><span class="comment"># target-port 目标Pod的端口（源端口） </span></span><br><span class="line"><span class="comment"># port service的端口</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在集群内通过域名访问：服务名.命名空间.svc ; 比如 my-dep-02.default.svc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 service，里面有 CLUSTER-IP</span></span><br><span class="line"><span class="comment"># kubectl get service 或者 kubectl get svc</span></span><br><span class="line">kubectl get service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pod 标签</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">kubectl delete svc my-dep-02</span><br></pre></td></tr></table></figure><ul><li>NodePort：在公网上可以访问，但是这种方式暴露的端口是随机的。这种模式可以访问每一台服务器的暴露端口，比如创建之后生成的端口是30999，那么每一台服务器的IP:30999,都能访问到，且具备负责均衡。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只能集群内部访问（--type不写 默认 ClusterIP）</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80 --<span class="built_in">type</span>=ClusterIP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群外部也可以访问</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure><p><b>小Tip:</b>使用<code>ClusterIP</code>类型分配的IP地址，在初始化时其实配置了IP地址的范围。下方的<code>--service-cidr</code>。同样的下方的<code>--pod-network-cidr</code>是所有的<code>pod</code>的<code>IP</code>范围。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=172.31.0.2 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure><h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>它是<code>Service</code>的统一网关入口，底层是<code>nginx</code>。所有的请求都是先到<code>ingress</code>，由<code>ingress</code>来打理这些请求，类似微服务中的网关层。</p><p><img src="https://s2.loli.net/2024/07/17/NS2nabyhVDUkWZF.png" alt="k8s.png"></p><p>安装<code>ingress</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line">vi deploy.yaml</span><br><span class="line"><span class="comment"># 将 image 的值改为如下值</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装资源</span></span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装的结果</span></span><br><span class="line">kubectl get pod,svc -n ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后别忘记把 svc 暴露的端口 在安全组放行</span></span><br></pre></td></tr></table></figure><p>删除<code>ingress</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不知道为啥会删不干净</span></span><br><span class="line">kubectl get ns ingress-nginx -o json &gt; tmp.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启本地访问</span></span><br><span class="line">kubectl proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再开一个窗口</span></span><br><span class="line">curl -k -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X PUT --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/ingress-nginx/finalize</span><br></pre></td></tr></table></figure><p>安装之后查看安装结果，可以看到<code>ingress-nginx-controller</code>通过<code>NodePort</code>方式暴露了两个端。</p><p><code>31276</code>这个是<code>http</code>的访问端口，<code>31267</code>这个是<code>https</code>的访问端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master home]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME                                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.96.2.61     &lt;none&gt;        80:31276/TCP,443:31267/TCP   2m44s</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.96.31.252   &lt;none&gt;        443/TCP                      2m44s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问<code>http://10.211.55.15:31067/</code>出现了<code>nginx</code>的404页面。</p><p>这里就简单的做个<code>ingress</code>的测试：如果访问的是<code>user.xiaocainiao.com</code>那么显示”Hello World!“。如果访问的是<code>pay.xiaocainiaoya.com</code>那么显示的是<code>nginx</code>的欢迎页面。</p><p>创建两个<code>Deployment</code>和两个<code>Service</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在<code>k8s</code>中执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi test.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f test.yaml</span><br></pre></td></tr></table></figure><p>接着创建路由规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-host-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;user.xiaocainiao.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span> <span class="comment"># hello-server （service） 的端口是 8000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;pay.xiaocainiaoya.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span>  <span class="comment">#java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>然后在<code>k8s</code>中执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ingress-rule.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f ingress-rule.yaml</span><br></pre></td></tr></table></figure><p>刚执行完命令，可能在<code>ADDRESS</code>一栏为空，稍微等一等之后会分配这个<code>ingress</code>的访问地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master home]<span class="comment"># kubectl get ingress -A</span></span><br><span class="line">NAMESPACE   NAME               CLASS   HOSTS                                        ADDRESS        PORTS   AGE</span><br><span class="line">default     ingress-host-bar   nginx   user.xiaocainiao.com,pay.xiaocainiaoya.com   10.211.55.16   80      12m</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我是用虚拟机做测试，需要进行本机的路由代理。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.211.55.16 user.xiaocainiao.com</span><br><span class="line">10.211.55.16 pay.xiaocainiaoya.com</span><br></pre></td></tr></table></figure><p>用这个访问地址+刚刚安装的<code>ingress-manager</code>暴露的端口进行访问。</p><p><img src="https://s2.loli.net/2024/07/24/e5HU4rxQOaPpsyS.png" alt="ingress.png"></p><h4 id="存储挂载"><a href="#存储挂载" class="headerlink" title="存储挂载"></a>存储挂载</h4><p>在<code>k8s</code>的场景中，<code>pod</code>在集群中部署的节点机是由<code>deployment</code>决定，假设说某一个<code>pod</code>挂了之后，可能<code>deployment</code>在识别到之后通过故障恢复，会将在其他机器上重新部署一个该<code>pod</code>。所以这时会存在一种情况，重新部署的<code>pod</code>理应能读取到之前<code>pod</code>故障之前写入到磁盘的一些持久性数据，所以在<code>k8s</code>体系中，引入了存储层框架。</p><p>在<code>k8s</code>中可以使用的一些存储层框架：Glusterfs、NFS、CephFS。</p><p>这里以NFS为例，需要在每一台节点机上安装<code>NFS</code>。每个机器上安装一个NFS存储层框架，然后相互之间进行数据同步，假设某一个<code>pod</code>故障之后，被转移到了其他的机器上，也能通过相同的挂载目录读取到之前持久化数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在主节点上运行</span></span><br><span class="line"><span class="comment"># 只在 mster 机器执行：nfs主节点，rw 读写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure><p>到此就表示，在master机器上开放了<code>/nfs/data/</code>目录，用来做成存储空间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查，下面的 IP 是master IP</span></span><br><span class="line">showmount -e 192.168.27.251</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器 执行，执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器执行，将远程 和本地的 文件夹 挂载</span></span><br><span class="line">mount -t nfs 192.168.27.251:/nfs/data /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 master 服务器，写入一个测试文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello nfs server&quot;</span> &gt; /nfs/data/test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器查看</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/data</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><b>原生方式 数据挂载</b></p><p>在 /nfs/data/nginx-pv 挂载，然后 修改， 里面 两个 Pod 也会 同步修改。</p><p>问题：①如果某个Pod不需要了，删掉Pod之后，文件还在，内容也在，②空间受机器空间管理，创建之后逻辑上是无限大的空间，除非达到机器上限，是没法管理大小的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 挂载目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="comment"># 和 volumeMounts.name 一样</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="comment"># master IP</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data/nginx-pv</span> <span class="comment"># 要提前创建好文件夹，否则挂载失败</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /nfs/data</span><br><span class="line">mkdir -p nginx-pv</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">vi deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制上面配置</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod -owide</span><br></pre></td></tr></table></figure><p><b>6.3 PV 和 PVC</b></p><p><strong>PV</strong>：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置</p><p><strong>PVC</strong>：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格</p><p>静态供应：在主节点上的<code>nfs/data/</code>目录下创建三个文件夹，并且通过yaml文件对其进行配置。</p><ul><li><code>01</code>：挂载名称为<code>pv01-10m</code>，且持久卷池的名称为<code>nfs</code>，空间为10M，多节点可读写</li><li><code>02</code>：挂载名称为<code>pv02-1gi</code>，且持久卷池的名称为<code>nfs</code>，空间为1G，多节点可读写</li><li><code>03</code>：挂载名称为<code>pv03-3gi</code>，且持久卷池的名称为<code>nfs</code>，空间为3G，多节点可读写</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 nfs主节点（master服务器） 执行</span></span><br><span class="line">mkdir -p /nfs/data/01</span><br><span class="line">mkdir -p /nfs/data/02</span><br><span class="line">mkdir -p /nfs/data/03</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv01-10m</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 限制容量</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10M</span></span><br><span class="line">  <span class="comment"># 读写模式：可读可写</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 表示持久卷池子的名称</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="comment"># 挂载 上面创建过的文件夹</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/01</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 这个name 要小写，如 Gi 大写就不行</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv02-1gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/02</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv03-3gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/03</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制上面文件</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pv， kubectl get pv</span></span><br><span class="line">kubectl get persistentvolume</span><br></pre></td></tr></table></figure><p><b>创建、绑定 PCV</b></p><p>创建一个持久卷声明：从持久卷池子名为<code>nfs</code>的池子中申请一个至少有200M大小的空间。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="comment"># 需要 200M的 PV</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="comment"># 上面 PV 写的什么 这里就写什么    </span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure><p>绑定到<code>pod</code>上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="comment"># 之前是 nfs，这里用 pvc</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span> </span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">nginx-pvc</span> <span class="comment"># 绑定持久卷声明</span></span><br></pre></td></tr></table></figure><p>既然有静态供应那么也就会有动态供应，在静态供应商中，是创建好了一个个不同大小的PV,并把这些PV进行分组命名（池子名称），等需要使用时，通过这个分组名称（池子名称）去这个组里获取到最适合的空间大小的PV。这种方式比较麻烦的是，需要手动创建一个个PV,且空间大小上无法相对准确的预估，容易存在浪费。比如我只需要20M的空间，但是池子里的PV分别为1G，2G，3G，那么这时至少会给我1G的那个PV。</p><p>动态供应：就是可以动态的创建具体的PV，那么这种方式创建的PV的空间大小就会相对符合需要，不会造成过多的浪费。</p><h4 id="配置集ConfigMap"><a href="#配置集ConfigMap" class="headerlink" title="配置集ConfigMap"></a>配置集ConfigMap</h4><p>在<code>k8s</code>中部署<code>POD</code>，比如<code>redis</code>的启用，需要依赖于一些配置（配置一些服务器地址等），这时可以将这个配置内容添加到<code>k8s</code>的配置集中，那么所有的<code>pod</code>就可以都引用到这份配置文件，并且当需要修改配置时，只需要对这个配置集进行修改，<code>POD</code>中指定的配置文件也会相应的同步新的配置（一小段时间之后）。</p><p>假设我有配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 设置Redis监听的端口，默认为6379</span><br><span class="line">port 6379</span><br><span class="line"> </span><br><span class="line"># 设置Redis监听的网络接口的IP地址</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"> </span><br><span class="line"># 设置Redis是否以守护进程方式运行</span><br><span class="line">daemonize no</span><br><span class="line"> </span><br><span class="line"># 设置Redis的日志文件路径</span><br><span class="line">logfile &quot;&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log&quot;</span><br><span class="line"> </span><br><span class="line"># 设置数据库的数量，默认16个数据库（0...15），可以通过select &lt;dbid&gt;命令选择数据库</span><br><span class="line">databases 16</span><br><span class="line"> </span><br><span class="line"># 设置密码认证</span><br><span class="line"># requirepass yourpassword</span><br><span class="line"> </span><br><span class="line"># 设置快照功能，即持久化</span><br><span class="line">#  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#  save 900 1</span><br><span class="line">#  save 300 10</span><br><span class="line">#  save 60 10000</span><br><span class="line"> </span><br><span class="line"># 设置持久化的文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"> </span><br><span class="line"># 设置当主服务器失效时，从服务器是否仍然可读</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"># 设置是否在每个命令后进行日志记录</span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># 设置更新日志的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"> </span><br><span class="line"># 设置更新日志写入策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># 设置Redis最大内存容量</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"> </span><br><span class="line"># 设置内存淘汰策略</span><br><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vi redis.conf</span><br><span class="line"><span class="comment"># 写</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置，redis保存到k8s的etcd；</span></span><br><span class="line">kubectl create cm redis-conf --from-file=redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get cm</span><br><span class="line"></span><br><span class="line">rm -rf redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ConfigMap 的 yaml 配置咋写的</span></span><br><span class="line">kubectl get cm redis-conf -oyaml</span><br></pre></td></tr></table></figure><p>显示这个配置集的内容如下。（它是存储在<code>tecd</code>中）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># key为redis.conf 值为具体的redis启动配置值</span></span><br><span class="line">  <span class="attr">redis.conf:</span> <span class="string">&quot;# 设置Redis监听的端口，默认为6379\nport 6379\n \n# 设置Redis监听的网络接口的IP地址\n# bind 127.0.0.1\n</span></span><br><span class="line"><span class="string">    \n# 设置Redis是否以守护进程方式运行\ndaemonize no\n \n# 设置Redis的日志文件路径\nlogfile \&quot;/var/log/redis/redis-server.log\&quot;\n</span></span><br><span class="line"><span class="string">    \n# 设置数据库的数量，默认16个数据库（0...15），可以通过select &lt;dbid&gt;命令选择数据库\ndatabases 16\n \n# 设置密码认证\n#</span></span><br><span class="line"><span class="string">    requirepass yourpassword\n \n# 设置快照功能，即持久化\n#  save &lt;seconds&gt; &lt;changes&gt;\n#  save</span></span><br><span class="line"><span class="string">    900 1\n#  save 300 10\n#  save 60 10000\n \n# 设置持久化的文件\ndbfilename dump.rdb\ndir</span></span><br><span class="line"><span class="string">    /var/lib/redis\n \n# 设置当主服务器失效时，从服务器是否仍然可读\nslave-serve-stale-data yes\n \n# 设置是否在每个命令后进行日志记录\nappendonly</span></span><br><span class="line"><span class="string">    no\n \n# 设置更新日志的文件名\nappendfilename \&quot;appendonly.aof\&quot;\n \n# 设置更新日志写入策略\n# appendfsync</span></span><br><span class="line"><span class="string">    always\nappendfsync everysec\n# appendfsync no\n \n# 设置Redis最大内存容量\n# maxmemory</span></span><br><span class="line"><span class="string">    &lt;bytes&gt;\n \n# 设置内存淘汰策略\n# maxmemory-policy volatile-lru\n&quot;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2024-07-24T16:02:55Z&quot;</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:data:</span></span><br><span class="line">        <span class="string">.:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:redis.conf:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2024-07-24T16:02:55Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-conf</span> <span class="comment"># 创建了一个名为redis-conf的配置集</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;14777&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">a626dec1-6e28-4ed0-a5ce-0aaeafffe12f</span></span><br></pre></td></tr></table></figure><p>创建<code>pod</code>来引用这个配置集</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="comment"># 启动命令 如果是直接启动redis，一般写为 redis-server /path/to/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-server</span></span><br><span class="line">      <span class="comment"># 指的是redis容器内部的位置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/redis-master/redis.conf&quot;</span>  </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span> <span class="comment"># 引用名称是叫dada的卷</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/redis-master</span> <span class="comment"># 这里表示挂载pod的这个位置</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 引用名称叫config的卷</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span> <span class="comment"># 创建一个名称叫data的卷</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 创建一个名称叫config的卷</span></span><br><span class="line">      <span class="attr">configMap:</span> <span class="comment"># 它是一个configMap配置集类型</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">redis-conf</span> <span class="comment"># 找到配置集中的这个cm</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">redis.conf</span> <span class="comment"># 获取到key为redis.conf的配置</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">redis.conf</span> <span class="comment"># 把key为redis.conf的配置的值写入到这个地址</span></span><br></pre></td></tr></table></figure><p>注：配置集是具备了热更新的能力，修改了配置集中的配置值的内容，它会同步到<code>pod</code>中配置的制定文件上，但是如果<code>pod</code>中的应用想要获取到配置热更新之后的值，应用本身得拥有热更新的能力。（所以这时可能需要重启<code>pod</code>来读取最新的配置值）</p><h4 id="密钥集Secret"><a href="#密钥集Secret" class="headerlink" title="密钥集Secret"></a>密钥集Secret</h4><p>用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod的定义或者容器镜像中来说更加安全和灵活。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##命令格式</span></span><br><span class="line">kubectl create secret docker-registry regcred \</span><br><span class="line">  --docker-server=&lt;你的镜像仓库服务器&gt; \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br><span class="line">  </span><br><span class="line">kubectl create secret docker-registry cgxin-docker-secret \</span><br><span class="line">--docker-username=leifengyang \</span><br><span class="line">--docker-password=Lfy123456 \</span><br><span class="line">--docker-email=534096094@qq.com</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">private-cgxin-docker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">private-cgxin-docker</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cgxin/cgxin_docker:1.0</span></span><br><span class="line">  <span class="comment"># 加上 Secret  </span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cgxin-docker-secret</span> <span class="comment"># 使用密钥集Secret</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;k8s入门&quot;&gt;&lt;a href=&quot;#k8s入门&quot; class=&quot;headerlink&quot; title=&quot;k8s入门&quot;&gt;&lt;/a&gt;k8s入门&lt;/h1&gt;&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;</summary>
    
    
    
    <category term="k8s" scheme="http://xiaocainiaoya.github.io/categories/k8s/"/>
    
    
    <category term="k8s" scheme="http://xiaocainiaoya.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Type接口</title>
    <link href="http://xiaocainiaoya.github.io/2024/06/24/java/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://xiaocainiaoya.github.io/2024/06/24/java/%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-06-24T13:43:58.000Z</published>
    <updated>2024-06-25T14:06:06.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>​    序列化是将数据对象转换为可传输格式的过程。是一种数据持久化的手段，一般广泛应用于网络传输、RPC、RMI等场景中。</p><span id="more"></span><p>常见的序列化框架：</p><table><thead><tr><th>java</th><th>jdk自带，使用方便，可序列化所有类，速度慢，占空间</th></tr></thead><tbody><tr><td>protobuf</td><td>速度快，但需要先进行静态编译</td></tr><tr><td>kryo</td><td>速度快，序列化后体积小；跨语言支持较复杂</td></tr></tbody></table><p>在<code>java</code>的序列化机制中，需要进行序列化的对象需要实现<code>Serializable</code>接口，这个接口没有方法或者字段，单纯是为了表示可序列化语义。自定义的类通过实现<code>Serializable</code>接口，进而在<code>IO</code>过程中实现序列化和反序列化。</p><p>在序列化过程中，会对将要序列化/方序列化的类进行检查，要求操作对象必须是字符串、枚举类、数组类型或者是实现了<code>Serializable</code>的类。</p><p>创建一个继承于<code>Serializable</code>接口的类，然后通过流处理将这个类写入到<code>1.txt</code>中，注意，这里写入之后，如果直接打开文件，会发现这是个乱码文件，这是因为序列化写入的是二进制文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend friend = <span class="keyword">new</span> Friend();</span><br><span class="line">        friend.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">            objectOutputStream.writeObject(friend);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义序列化逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的序列化调用链：<code>objectOutputStream.writeObject()</code> &rarr;<code>writeObject0(obj, false);</code> &rarr; <code>writeOrdinaryObject(obj, desc, unshared);</code>(区分是<code>Serializable</code>还是<code>Externalizable</code>)&rarr;如果没有实现自定义的序列化策略则调用<code>defaultWriteFields(obj, slotDesc);</code>，如果实现了自定义序列化策略，则通过反射调用到自定义序列化策略<code>slotDesc.invokeWriteObject(obj, this);</code>。</p><p>但是需要注意，就算是自定义了序列化接口<code>writeObject()</code>，且不进行写入动作，最终的输出文件依然不会是空文件，为了反序列化，包含了一些格式信息，不单纯只有数据，比如有字段类型等信息。</p><p><b>Externalizable</b>的作用是什么？</p><p>它相比于<code>Serializable</code>更为灵活，比如一个类有一个父类，在序列化时，如果也想序列化父类中的属性，则这个父类也需要实现<code>Serializable</code>接口；另一种做法是是子类实现<code>Externalizable</code>接口，但是实现该接口需要重写<code>writeExternal()</code>和<code>readExternal()</code>方法，这种情况下就可以指定需要序列化的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        name = in.readUTF();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>serialVersionUID的作用？</b></p><p>一般一个类在继承<code>Serializable</code>接口后，都会定义一个字段<code>private static final long serialVersionUID = 1L;</code>，那么它的作用是什么？</p><p>它主要是用来校验是否允许进行反序列化的，当将某个类进行序列化后，比如是存储到文件中，会将这个值也序列化到文件中，当进行反序列化时，将这个<code>serialVerionUID</code>进行比对，如果不一致，则抛出<code>InvalidCastException</code>异常。</p><p>如果类发生了改变（比如新增字段、删除字段、改变字段类型等），这时如果进行反序列化，可能出现不匹配的情况，如果没有显示声明这个字段值，<code>java</code>会生成一个默认的<code>serialVersionUID</code>，这个值是基于类的结构生成的，当类的结构发生变化的时候，再次序列化时这个值也会发生变化，就会导致使用变更之前的数据进行反序列化会抛出异常。但是我们在使用时，通常为了确保即使类发生了变化，也要序列化成功，会显示的声明这个值。</p><p><b>数组的序列化</b></p><p>在序列化的过程中，如果被序列化对象自定义实现了<code>writeObject()</code>和<code>readObject()</code>方法，则会尝试使用自定义的方法进行序列化和方序列化。</p><p>在<code>ArrayList</code>中，它的存储是<code>transient Object[] elementData</code>，但是这个对象数组又被声明为<code>transient</code>，所以在默认的序列化策略中，并不会对它进行序列化，这是因为<code>ArrayList</code>是动态数组，每次在放满之后会进行动态的扩容，那么就会出现一个数组中有多个<code>null</code>元素，为了保证<code>null</code>元素不被序列化，所以将数组设置为<code>transient</code>后，通过自定义序列化策略进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span><span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 写入固定格式</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入容器大小</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入元素值，只循环size次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span><span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 也只读出size值的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h1&gt;&lt;p&gt;​    序列化是将数据对象转换为可传输格式的过程。是一种数据持久化的手段，一般广泛应用于网络传输、RPC、RMI等场景中。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring日志系统</title>
    <link href="http://xiaocainiaoya.github.io/2024/05/22/Spring/spring%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://xiaocainiaoya.github.io/2024/05/22/Spring/spring%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-05-22T12:53:58.000Z</published>
    <updated>2024-06-04T07:50:07.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring日志系统"><a href="#spring日志系统" class="headerlink" title="spring日志系统"></a>spring日志系统</h1><p>​    <code>spring</code>通过门面模式来应对项目中依赖不同的组件时，各组件使用不同的日志框架，有<code>log4j</code>、<code>log4j2</code>、<code>lockback</code>等，门面有<code>sl4j</code>和<code>commons-logging</code>。</p><span id="more"></span><p><img src="https://s2.loli.net/2024/05/22/KxUy7luX86DkjCB.png" alt=".png"></p><p>在开发的过程中，经常需要使用到日志框架来打印一些信息，来帮助开发者定位产生的相关问题等，在使用时只需要通过<code>log.info()</code>等方式就可以打印出一条日志信息，但是这条日志是如何打印出来，理清日志框架的工作过程及原理，能有效帮助开发者扩展日志功能以及优雅的进行日志打印等级切换等等。</p><h2 id="springboot日志框架"><a href="#springboot日志框架" class="headerlink" title="springboot日志框架"></a>springboot日志框架</h2><p><code>springboot</code>的默认日志框架是<code>logback</code>。具官网介绍<code>logback</code>的性能高于<code>log4j</code>，而<code>log4j2</code>是在<code>logback</code>之后诞生的，性能高于<code>logback</code>。<code>springboot</code>中默认引入的是<code>logback</code>日志框架，如果需要在<code>springboot</code>项目中使用<code>sl4j2</code>作为日志框架，需要将原生框架中的<code>logback</code>依赖排除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--排除lockback的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入log4j2依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    然后就可以在<code>resource</code>下创建<code>sl4j2.xml</code>配置文件，配置一些打印相关操作，比如指定多个打印器，指定打印路径，指定打印格式、打印等级等等。当然，也可以不创建这个配置文件，在<code>springboot</code>有兜底配置。</p><p>​    接着一步步来了解一下，以及<code>springboot</code>是如果设计，达到可以自由切换日志框架的目的。以及<code>sl4j2</code>的一些工作原理。</p><p>​    如果项目中结合了<code>lombok</code>可以发现，在实体上标记了<code>@Slf4j</code>之后，就可以通过<code>log</code>对象来打印日志，而这个打印日志的<code>log</code>对象就是<code>org.slf4j.Logger</code>类对象，它仅仅是定义了一系列的日志打印接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object arg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String msg, Throwable t)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果工程是使用<code>sl4j2</code>，那么此时就会进入到<code>org.apache.logging.slf4j.Log4jLogger</code>，它是<code>org.slf4j.Logger</code>门面接口的实现，它是在依赖<code>org.apache.logging.log4j:log4j-slf4j-impl</code>中。</p><p>如果工程是使用<code>logback</code>，那么此时就会进入到<code>ch.qos.logback.classic.Logger</code>，它也是<code>org.slf4j.Logger</code>门面对象的实现，他是在依赖<code>ch.qos.logback:logback-classis</code>中，这里要注意，<code>loback</code>对门面接口类的实现的类的名称也是叫<code>Logger</code>。</p><h2 id="log4j2的简单工作原理"><a href="#log4j2的简单工作原理" class="headerlink" title="log4j2的简单工作原理"></a>log4j2的简单工作原理</h2><p>从上述可以知道，其实打印日志都是获取<code>Logger</code>对象，通过它来进行日志打印操作。在<code>log4j2</code>中的<code>Logger</code>对象有两个属性<code>PrivateConfig</code>和<code>LoggerContext</code>。</p><ul><li><code>PrivateConfig</code>中包含了通过<code>log4j2.xml</code>文件解析出来的<code>appender</code>和具体的<code>logger</code>。</li><li><code>LoggerContext</code>是根据配置规则，缓存了每个类打印时需要使用到的<code>logger</code>和<code>appender</code>的关系。</li></ul><p><img src="https://s2.loli.net/2024/06/03/sJRqwL2lvr1TkGO.png" alt="logger.png"></p><p>在配置文件中的&lt;Appenders&gt;标签下每增加一项，解析得到的<code>Configuration</code>中的<code>Appenders</code>就多一个<code>Appender</code>。在&lt;Loggers&gt;标签下每增加一项，解析得到的<code>Configuration</code>中的<code>loggerConfigs</code>就多一项。</p><p>在<code>LoggerConfig</code>中持有所有<code>Appender</code>的引用，而解析后的<code>Configuration</code>中的<code>loggerConfigs</code>表示的是某一个<code>logger</code>持有的<code>Appender</code>引用。</p><p>如果需要使用到打印，都会先到<code>LoggerContext</code>的注册器<code>LoggerRegistry</code>中获取，如果没有，则会创建出一个<code>Logger</code>并注册到<code>LoggerRegistry</code>中。</p><p><img src="https://s2.loli.net/2024/06/03/f7j52o8GTA6bdFM.png" alt="loggerRegistry.png"></p><p>比方说我这个工程中的这个类<code>cn.com.xiaocainiaoya.common.CustomizeConfiguration</code>，如果需要打印就会从这个注册器中获取到这个<code>Logger</code>，然后通过这个<code>Logger</code>的日志等级配置以及<code>Appender</code>等等进行打印操作。</p><h2 id="Springboot日志启动机制"><a href="#Springboot日志启动机制" class="headerlink" title="Springboot日志启动机制"></a>Springboot日志启动机制</h2><p><code>Springboot</code>的日志启动依赖于<code>springboot</code>的事件监听机制，在<code>spring</code>的启动过程中，需要进行一系列的准备、加载等动作，所以<code>Spring</code>在对容器最终加载完成的整个生命周期中，设置了很多监听事件，比如刚刚启动容器、<code>Enviroment</code>准备完成、<code>ApplicatonContext</code>准备完成等等。日志启动是依赖于<code>LoggingApplicationListener</code>类，它实现了<code>ApplicationListener</code>的封装类<code>GenericApplicationListener</code>，所以它能接收到多种消息事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在启动SpringApplicatioin之后就发布了事件，先于Environment和ApplicationContext可用之前发布</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationStartingEvent) &#123;</span><br><span class="line">        onApplicationStartingEvent((ApplicationStartingEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Environment加载完成之后立即发布</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">        onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ApplicationContext准备好后但是刷新容器之前发布</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">        onApplicationPreparedEvent((ApplicationPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent</span><br><span class="line">            &amp;&amp; ((ContextClosedEvent) event).getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onContextClosedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationFailedEvent) &#123;</span><br><span class="line">        onApplicationFailedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>1.监听到<code>ApplicationStartingEvent</code>事件</b></p><p>在<code>Springboot</code>中操作日志最关键的一个对象就是<code>LoggingSystem</code>，这个对象在整个生命周期中掌握着日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationStartingEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem.beforeInitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在接收到这个事件通知之后，就到系统属性中去读取<code>LoggingSystem</code>具体的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; systems = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    systems.put(<span class="string">&quot;ch.qos.logback.core.Appender&quot;</span>, <span class="string">&quot;org.springframework.boot.logging.logback.LogbackLoggingSystem&quot;</span>);</span><br><span class="line">    systems.put(<span class="string">&quot;org.apache.logging.log4j.core.impl.Log4jContextFactory&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.springframework.boot.logging.log4j2.Log4J2LoggingSystem&quot;</span>);</span><br><span class="line">    systems.put(<span class="string">&quot;java.util.logging.LogManager&quot;</span>, <span class="string">&quot;org.springframework.boot.logging.java.JavaLoggingSystem&quot;</span>);</span><br><span class="line">    SYSTEMS = Collections.unmodifiableMap(systems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次加载的时候会从以上的SYSTEMS的map中去找，通过类加载器，逐个查找，看哪一个类是在类路径中，就启用哪一个LoggingSystem。我这里使用的是Log4j日志框架，那么这里就会找到并加载Log4J2LoggingSystem。如果使用的是logback，那么加载的就是LogbackLoggingSystem。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggingSystem <span class="title">get</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String loggingSystem = System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(loggingSystem)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NONE.equals(loggingSystem)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NoOpLoggingSystem();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(classLoader, loggingSystem);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 通过类加载器来找有没有引入对应的类，第一个匹配到谁就是谁</span></span><br><span class="line">    <span class="keyword">return</span> SYSTEMS.entrySet().stream().filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))</span><br><span class="line">            .map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No suitable logging system located&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到<code>LogginSystem</code>之后，就会调用它的<code>beforeInitialize()</code>，这个方法的主要作用就是进行一些事前初始化动作，这里添加了一个日志过滤器，但实际上是一个阻断器，这个阻断器拒绝了所有的日志打印。所以到达这一步，仍然是无法打印出日志的，就算日志框架接收到需要打印日志的请求，也会被阻断器拒绝。这样的设计是为了防止日志系统在完成初始化之前打印出不可控的日志信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.beforeInitialize();</span><br><span class="line">    loggerContext.getConfiguration().addFilter(FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.监听到<code>ApplicationEnvironmentPreparedEvent</code>事件</b></p><p>当<code>Environment</code>准备完成之后，继续进行日志框架的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggingSystem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用enviroment中配置的信息对日志框架进行初始化</span></span><br><span class="line">    initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableEnvironment environment, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把在enviroment中的配置信息读取出来，并设置到system中，比如有打印文件的路径</span></span><br><span class="line">    <span class="comment">// 文件大小、打印格式等等</span></span><br><span class="line">    <span class="keyword">new</span> LoggingSystemProperties(environment).apply();</span><br><span class="line">    <span class="keyword">this</span>.logFile = LogFile.get(environment);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logFile.applyToSystemProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将预制的web和sql日志打印初始化LoggerGroups</span></span><br><span class="line">    <span class="keyword">this</span>.loggerGroups = <span class="keyword">new</span> LoggerGroups(DEFAULT_GROUP_LOGGERS);</span><br><span class="line">    <span class="comment">// 读取系统级别的debug或者trace是否设置为true</span></span><br><span class="line">    <span class="comment">// 哪个类型为true就将springbootLogging的级别设置为那个</span></span><br><span class="line">    <span class="comment">// trace的优先级高于debug</span></span><br><span class="line">    initializeEarlyLoggingLevel(environment);</span><br><span class="line">    <span class="comment">// 执行loggingSystem.initialize()初始化方法</span></span><br><span class="line">    initializeSystem(environment, <span class="keyword">this</span>.loggingSystem, <span class="keyword">this</span>.logFile);</span><br><span class="line">    <span class="comment">// 完成日志打印组和日志打印器的级别的设置</span></span><br><span class="line">    initializeFinalLoggingLevels(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">    registerShutdownHookIfNecessary(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来看下<code>LoggingSystem</code>的初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeSystem</span><span class="params">(ConfigurableEnvironment environment, LoggingSystem system, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    LoggingInitializationContext initializationContext = <span class="keyword">new</span> LoggingInitializationContext(environment);</span><br><span class="line">    <span class="comment">// 从系统变量中获取logging.config</span></span><br><span class="line">    String logConfig = environment.getProperty(CONFIG_PROPERTY);</span><br><span class="line">    <span class="comment">// 如果没有就根据规则从类路径中找</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreLogConfig(logConfig)) &#123;</span><br><span class="line">        system.initialize(initializationContext, <span class="keyword">null</span>, logFile);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果有，就直接加载指定的文件。所以如果通过yaml直接配置，或者通过jar启动命令指定</span></span><br><span class="line">        <span class="comment">// 就直接走到这里</span></span><br><span class="line">        <span class="comment">// ... 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达Log4J2LoggingSystem的初始化方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里移除了前面设置的日志阻断器</span></span><br><span class="line">    loggerContext.getConfiguration().removeFilter(FILTER);</span><br><span class="line">    <span class="comment">// 调用父类方法找到log4j2的配置文件，并进行初始化</span></span><br><span class="line">    <span class="keyword">super</span>.initialize(initializationContext, configLocation, logFile);</span><br><span class="line">    <span class="comment">// 标记初始化完成</span></span><br><span class="line">    markAsInitialized(loggerContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类方法最终会走到这里，按类路径查找，</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithConventions</span><span class="params">(LoggingInitializationContext initializationContext, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑上是要找到一个 classpath:xxxx的地址</span></span><br><span class="line">    String config = getSelfInitializationConfig();</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; logFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把这个配置文件中的东西解析出来为Configuration</span></span><br><span class="line">        reinitialize(initializationContext);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">        config = getSpringInitializationConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadConfiguration(initializationContext, config, logFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadDefaults(initializationContext, logFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就会将日志打印器<code>logger</code>进行分组。这样做的好处是便于管理，分组之后，如果需要对某个组改日志级别，只需要将这个组的日志级别进行修改，就不需要逐个去找打印器并进行修改。</p><p><img src="https://s2.loli.net/2024/06/03/M6NR7afJlAHk5Xn.png" alt="loggerGroups.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 可以通过yaml进行设置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">common:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line">    <span class="attr">common:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cn.com.xiaocainiaoya.common</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">com.lee.xiaocainiaoya.user</span></span><br></pre></td></tr></table></figure><p>如果设置了<code>trace=true</code>或者是<code>bebud=true</code>，那么<code>springboot</code>会将自己的某些类的打印开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeFinalLoggingLevels</span><span class="params">(ConfigurableEnvironment environment, LoggingSystem system)</span> </span>&#123;</span><br><span class="line">    bindLoggerGroups(environment);</span><br><span class="line">    <span class="comment">// 只要trace=true 或者是 debug=true就开启springbootlogging</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.springBootLogging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        initializeLogLevel(system, <span class="keyword">this</span>.springBootLogging);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置用户自定义的打印器的日志级别</span></span><br><span class="line">    setLogLevels(system, environment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeLogLevel</span><span class="params">(LoggingSystem system, LogLevel springBootLogging)</span> </span>&#123;</span><br><span class="line">    initializeSpringBootLogging(system, springBootLogging);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeSpringBootLogging</span><span class="params">(LoggingSystem system, LogLevel springBootLogging)</span> </span>&#123;</span><br><span class="line">    BiConsumer&lt;String, LogLevel&gt; configurer = getLogLevelConfigurer(system);</span><br><span class="line">    SPRING_BOOT_LOGGING_LOGGERS.getOrDefault(springBootLogging, Collections.emptyList())</span><br><span class="line">            .forEach((name) -&gt; configureLogLevel(name, springBootLogging, configurer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    MultiValueMap&lt;LogLevel, String&gt; loggers = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 如果是debug就开这些</span></span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;web&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;org.springframework.boot&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果是trace 就开这些</span></span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.springframework&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.apache.tomcat&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.apache.catalina&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.eclipse.jetty&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.hibernate.tool.hbm2ddl&quot;</span>);</span><br><span class="line">    SPRING_BOOT_LOGGING_LOGGERS = Collections.unmodifiableMap(loggers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能按组设置就按组设置，不能按组设置就单独设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureLogLevel</span><span class="params">(String name, LogLevel level, BiConsumer&lt;String, LogLevel&gt; configurer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggerGroups != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LoggerGroup group = <span class="keyword">this</span>.loggerGroups.get(name);</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.hasMembers()) &#123;</span><br><span class="line">            group.configureLogLevel(level, configurer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    configurer.accept(name, level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>3.监听到<code>ApplicationPreparedEvent</code>事件</b></p><h3 id="日志级别热更新"><a href="#日志级别热更新" class="headerlink" title="日志级别热更新"></a>日志级别热更新</h3><p>其实对应的日志框架都已经提供了对应的日志级别更新方法，只需要获取到<code>LoggingSystem</code>类，并调用<code>setLogLevel</code>方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingSystem.setLogLevel(<span class="string">&quot;cn.com.xiaocainiaoya.BootStrap&quot;</span>, LogLevel.DEBUG);</span><br></pre></td></tr></table></figure><p>这里简单分析一下过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogLevel</span><span class="params">(String loggerName, LogLevel logLevel)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 转换为log4j对应的日志级别枚举类</span></span><br><span class="line">Level level = LEVELS.convertSystemToNative(logLevel);</span><br><span class="line"><span class="comment">// 到Configuration中去找这个loggerName的LoggerConfig(初始化之后所有的LoggerConfig都在这里)</span></span><br><span class="line">LoggerConfig loggerConfig = getLoggerConfig(loggerName);</span><br><span class="line"><span class="comment">// 如果不存在，则需要创建这个LoggerConfig，并添加到Configuration的ConcurrentMap&lt;String, LoggerConfig&gt; loggerConfigs中。</span></span><br><span class="line"><span class="keyword">if</span> (loggerConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">loggerConfig = <span class="keyword">new</span> LoggerConfig(loggerName, level, <span class="keyword">true</span>);</span><br><span class="line">getLoggerContext().getConfiguration().addLogger(loggerName, loggerConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果存在，则直接更新这个loggerConfig的日志级别</span></span><br><span class="line">loggerConfig.setLevel(level);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⭐️逐个更新loagger</span></span><br><span class="line">getLoggerContext().updateLoggers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateLoggers</span><span class="params">(<span class="keyword">final</span> Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Configuration old = <span class="keyword">this</span>.configuration;</span><br><span class="line">    <span class="comment">// 逐个更新loagger</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Logger logger : loggerRegistry.getLoggers()) &#123;</span><br><span class="line">        logger.updateConfiguration(config);</span><br><span class="line">    &#125;</span><br><span class="line">    firePropertyChangeEvent(<span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>, PROPERTY_CONFIG, old, config));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateConfiguration</span><span class="params">(<span class="keyword">final</span> Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.privateConfig = <span class="keyword">new</span> PrivateConfig(newConfig, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我刚看到这个地方时候，我是有点困惑的，在我标记⭐️的地方。在更新完<code>loggerConfig</code>的的日志级别之后，尽然需要将所有的<code>loggerRegistry</code>都取出来进行重新创建<code>PrivateConfig</code>。难道不是<code>loggerConfig</code>的日志级别修改了之后持有这个对象的引用获取到信息也是更新之后的值。但是其实这里是有可能获取不到<code>loggerConfig</code>，那么就需要创建一个新的<code>loggerConfig</code>到<code>Configuration</code>池子里。根据日志名称匹配规则，新增了一个<code>loggerConfig</code>那么其实对缓存中的所有信息有所影响，比如某个类的全限定类名是<code>cn.com.xiaocainiao.FeignUtil</code>，原本它是使用名称为<code>root</code>的打印器，但是我调用<code>setLogLevel(&quot;cn.com.xiaocainiao&quot;, &quot;DEBUG&quot;)</code>那么这时会创建一个新的打印器器，也就导致了<code>cn.com.xiaocainiao.FeignUtil</code>应该使用新创建的这个打印器，而不是根打印器，所以这里的将所有的<code>logger</code>进行了更新。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring日志系统&quot;&gt;&lt;a href=&quot;#spring日志系统&quot; class=&quot;headerlink&quot; title=&quot;spring日志系统&quot;&gt;&lt;/a&gt;spring日志系统&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;通过门面模式来应对项目中依赖不同的组件时，各组件使用不同的日志框架，有&lt;code&gt;log4j&lt;/code&gt;、&lt;code&gt;log4j2&lt;/code&gt;、&lt;code&gt;lockback&lt;/code&gt;等，门面有&lt;code&gt;sl4j&lt;/code&gt;和&lt;code&gt;commons-logging&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事务的aop浅析</title>
    <link href="http://xiaocainiaoya.github.io/2024/04/15/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84aop%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2024/04/15/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84aop%E6%B5%85%E6%9E%90/</id>
    <published>2024-04-15T13:49:00.000Z</published>
    <updated>2024-04-16T13:55:49.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring事务的aop浅析"><a href="#Spring事务的aop浅析" class="headerlink" title="Spring事务的aop浅析"></a>Spring事务的aop浅析</h1><p>​    结合之前说到的<a href="https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/" target="_blank">SpringAop浅析（二）</a>本篇将从事务的角度，来看下<code>spring</code>或者说<code>springboot</code>是如何通过一些简单的配置就可以将一些方法进行事务的管理，并了解一些事务在管理过程中的一些简单<code>api</code>。</p><span id="more"></span><h2 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h2><p>​    在没有<code>spring</code>之前，或者说在不引入<code>spring</code>的时候，在获取数据库访问的时候，通常是通过<code>Connection</code>来进行。通过<code>Connection</code>类来进行<code>sql</code>的执行操作，然后在<code>sql</code>执行完毕之后调用<code>commit()</code>方法，将事务提交，当然了，在借助<code>spring</code>框架之后，在编码过程中，再也没有通过这种方式来进行事务的提交。但是大差不差，这些事情是一定要做的，既然我们在编码过程中没有做，那么这件事情就一定被<code>spring</code>做了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = getConnection();</span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//执行一系列的sql</span></span><br><span class="line">conn.commit();</span><br></pre></td></tr></table></figure><p>​    根据上篇文章<code>springAop</code>，不难猜测，<code>spring</code>肯定是借助于<code>aop</code>，对标记了<code>@Transactional</code>的方法进行拦截并进行事务的增强。那么它是怎么实现的呢？</p><p>在<code>spring</code>中开启事务需要通过<code>EnableTransactionManagement</code>注解，实际上就是通过它来进行一些开箱即用的处理。这个注解的实现上引入了<code>@Import</code>注解，这个注解的作用是为了将某些类引入到<code>Spring</code>容器中。这样做有一个好处是，在启用这个注解的情况下，才引入某些类到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到<code>TransactionManagementConfigurationSelector</code>类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableTransactionManagement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过selectImports方法将某些类加载到容器中，这个方法返回一个字符串数组</span></span><br><span class="line"><span class="comment"> * 这个字符串是类的全限定类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line"><span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line"><span class="keyword">case</span> PROXY:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line"><span class="keyword">case</span> ASPECTJ:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来了，这里引入了两个类：</p><ol><li><code>AutoProxyRegistrar</code></li><li><code>ProxyTransactionManagementConfiguration</code></li></ol><h3 id="1-AutoProxyRegistar"><a href="#1-AutoProxyRegistar" class="headerlink" title="1.AutoProxyRegistar"></a>1.AutoProxyRegistar</h3><p>它实现了<code>ImportBeanDefinitionRegistrar</code>接口。所以它的主要作用是将<code>InfrastructureAdvisorAutoProxyCreator</code>这个后置处理器类注入到容器中，那么容器在进行每一个<code>bean</code>对象初始化时都会将这个后置处理作用在对应的<code>bean</code>上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 它的主要作用在AopConfigUtils.registerAutoProxyCreatorIfNecessary中，为了将org.springframework.aop.framework.autoproxy.InfrastructureAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment"> * 类注册到spring中，这个类实现了spring的后置处理器，主要作用是在spring的bean初始化的过程中，对bean进行检查，如果符合一定的条件</span></span><br><span class="line"><span class="comment"> * 则把这个bean的aop代理对象注入到spring容器中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line"><span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line"><span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object mode = candidate.get(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">Object proxyTargetClass = candidate.get(<span class="string">&quot;proxyTargetClass&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;</span><br><span class="line">Boolean.class == proxyTargetClass.getClass()) &#123;</span><br><span class="line">candidateFound = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"><span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下<code>InfrastructureAdvisorAutoProxyCreator</code>类。它自己本身没有什么太多的实现，它继承与<code>AbstractAdvisorAutoProxyCreator</code>抽象类，这个抽象类实现了一些查询那些增强可以作用在目标<code>bean</code>对象上处理。本篇想聊的后置处理的实现是在它的父类<code>AbstractAutoProxyCreator</code>上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfrastructureAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AbstractAutoProxyCreator</code>中，实现了具体的后置处理的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里获取到需要的增强链，这里会获取到刚刚最早提到的，通过@EnableTransactionManagement</span></span><br><span class="line">  <span class="comment">// 的import注解注入了两个类的第二个类，第二个配置类的作用是引入事务增强类。</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-ProxyTransactionManagementConfiguration"><a href="#1-ProxyTransactionManagementConfiguration" class="headerlink" title="1.ProxyTransactionManagementConfiguration"></a>1.ProxyTransactionManagementConfiguration</h3><p>上面已经给出了结论，这个类的作用是引入了事务处理需要使用到的增强类。使得<code>springBean</code>对象在初始化时进入到后置处理器中，后置处理器再获取到这个类通过<code>@Bean</code>注解注入到容器中的增强类，从而实现将需要进行事务处理的类进行代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入到容器中的事务增强类，它是Advisor接口的实现。它有两个参数，这两个参数也是通过容器来获取</span></span><br><span class="line"><span class="comment"> * 也是在下方进行声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">TransactionAttributeSource transactionAttributeSource,</span></span></span><br><span class="line"><span class="function"><span class="params">TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line">BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">advisor.setAdvice(transactionInterceptor);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面增强类的第一个参数，这个bean的作用主要是用来获取事务属性的；比如配置的传播机制，异常信息等等；</span></span><br><span class="line"><span class="comment"> * 这个bean当中提供了一个方法来获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面增强类的第二个参数，这个bean的作用主要是用来拦截，拦截目标方法之后进行事务的开启、提交、回滚等动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下<code>BeanFactoryTransactionAttributeSourceAdvisor</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义了切点的查找规则，也就是说bean进入了前面提到的后置处理器之后，会取出容器中的所有增强通知，然后逐个进行匹配</span></span><br><span class="line"><span class="comment">// 看遍历的到的通知是否需要作用到bean对象中，当遍历到这个增强时，就会通过TransactionAttributeSource类来进行匹配</span></span><br><span class="line"><span class="comment">// 也就是导入的配置类ProxyTransactionManagementConfiguration中定义的第二个bean对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里具体的匹配规则在类<code>AnnotationTransactionAttributeSource</code>中。</p><p>具体的匹配规则在它的父类<code>AbstractFallbackTransactionAttributeSource#getTransactionAttribute()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 计算是否匹配</span></span><br><span class="line">TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line"><span class="comment">// ...省略代码，主要是推入缓存</span></span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..省略代码，主要是前置校验，是不是已经是代理类等等的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点在这，通过这个方法获取到TransactionAttribute对象</span></span><br><span class="line"><span class="comment">// 这个方法的实现由AnnotationTransactionAttributeSource自己实现</span></span><br><span class="line">TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到<code>AnnotationTransactionAttributeSource</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">findTransactionAttribute</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line"><span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> attr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终走到SpringTransactionAnnotationParser中，通过这个方法获取被@Transactional标记的方法或者类的信息</span></span><br><span class="line"><span class="comment">// 将@Transactional中定制化配置的信息读取到AnnotationAttributes对象中。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <code>spring</code>事务的代理是通过<code>@EnableTransactionManagement</code>注解来开启，这个注解通过<code>@Import</code>注解来导入两个类，一个类是后置处理器，它的作用是在每个<code>bean</code>对象创建之后将第二个导入类中定义的增强作用在这个对象上，并形成代理对象。第二个导入类的作用是定义了一个增强，这个增强包含了如何确定切面、切点、连接点等信息，也包含了拦截的逻辑，也就是事务的开启、提交和回滚等处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring事务的aop浅析&quot;&gt;&lt;a href=&quot;#Spring事务的aop浅析&quot; class=&quot;headerlink&quot; title=&quot;Spring事务的aop浅析&quot;&gt;&lt;/a&gt;Spring事务的aop浅析&lt;/h1&gt;&lt;p&gt;​    结合之前说到的&lt;a href=&quot;https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/&quot; target=&quot;_blank&quot;&gt;SpringAop浅析（二）&lt;/a&gt;本篇将从事务的角度，来看下&lt;code&gt;spring&lt;/code&gt;或者说&lt;code&gt;springboot&lt;/code&gt;是如何通过一些简单的配置就可以将一些方法进行事务的管理，并了解一些事务在管理过程中的一些简单&lt;code&gt;api&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringAop浅析（二）</title>
    <link href="http://xiaocainiaoya.github.io/2024/04/11/Spring/SpringAop%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2024/04/11/Spring/SpringAop%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2024-04-11T14:22:00.000Z</published>
    <updated>2024-04-15T13:48:06.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringAop浅析（二）"><a href="#SpringAop浅析（二）" class="headerlink" title="SpringAop浅析（二）"></a>SpringAop浅析（二）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    接两年前的旧文<a href="https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/" target="_blank">SpringAop浅析</a>，时隔两年再一次对<code>SpringAop</code>相关源码进行分析，只能说之前阅读的不够透彻，理解的不扎实，再加上工作上常年忙于业务的处理，现在已经少有看源码的时间，不过最近不知道是因为什么打了鸡血，还是想再沉淀沉淀。</p><span id="more"></span><h2 id="上篇回顾"><a href="#上篇回顾" class="headerlink" title="上篇回顾"></a>上篇回顾</h2><p>​    前面说到<code>SpringAop</code>的大致创建时机、创建流程和基本的调用流程。<code>SpringAop</code>是采用动态代理的方式实现，通过<code>@EnableAspectJAutoProxy</code>的方式开启，开启的原理为添加<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanDefinitionMap</code>中；在<code>Bean</code>对象实例化之前可以通过用户自定义的方式进行提前生成代理对象。或者是在<code>Bean</code>对象初始化之后，通过上述后置处理器的<code>postProcessAfterInitialization</code>方法，将<code>Bean</code>对象转为代理对象。</p><p>本篇想说明一个问题：被<code>SpringAop</code>代理之后的对象是什么对象？在调用被代理方法时，它具体的执行过程？</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>​    直接<code>debug</code>可以得知，被<code>SpringAop</code>代理之后的对象是<code>CglibAopProxy#DynamicAdvisedInterceptor</code>类的实现。（使用<code>cglib</code>代理的前提）</p><p>这个类是<code>CglibAopProxy</code>的内部类，它实现了<code>MethodInterceptor</code>接口，学过<code>cglib</code>动态代理的知道<code>MethodInterceptor</code>是它的代理类的增强，所以<code>DynamicAdvisedInterceptor</code>这个类就是为了<code>aop</code>来做增强的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ...代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它定义了<code>AdvisedSupport</code>增强支持类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个类记录了被代理对象、被代理方法等等一系列的动态代理需要的参数等</span></span><br><span class="line">    <span class="comment">// 这个是一个重要的参数，它记录了这个被代理对象需要被执行增强的列表</span></span><br><span class="line">    <span class="comment">// 比如说你定义了一个方法，需要在这个方法上做</span></span><br><span class="line">    <span class="comment">// 1.打印访问时长的增强A，</span></span><br><span class="line">    <span class="comment">// 2.记录方法执行前后参数、返回值的增强B</span></span><br><span class="line">    <span class="comment">// 都会被记录在这个列表里</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以到这里可以知道，在项目中我们通过<code>SpringAop</code>得到的代理对象的增强是<code>DynamicAdvisedInterceptor</code>。故在执行被代理方法时，会直接进入到它的拦截方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在被代理类初始化时，会根据一些匹配规则，将符合条件的增强放置在列表中，这里把这个列表里的增强取出</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">        <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建CglibMethodInvocation类，并执行processd()方法</span></span><br><span class="line">            <span class="comment">// CglibMethodInvocation类实际上是一个调用链对象，也就是说这里将目标类、代理对象、代理方法、调用参数、以及最关键的增强列表&lt;chain&gt;</span></span><br><span class="line">            <span class="comment">// 记录到这个对象中，还包含了当前索引下标等等信息。也就是调用它的process()方法之后，它就会遍历这个增强列表，执行每一个增强。</span></span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到<code>process()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 到达链尾时进入被代理对象的目标方法中，至此递归结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历下标，取出对应的增强</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// 根据对应的信息进行匹配器的匹配，若匹配成功则执行增强的拦截方法</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 匹配失败，则进入到下一个链节点</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上便是<code>springAop</code>的大致过程，这里还要提到一个问题，如果对<code>aop</code>的这个执行过程进行过<code>debug</code>的会发现，假设我只设置了一个<code>aop</code>的注解拦截，对于上面提到的增强拦截链的<code>List&lt;Advisor&gt; advisors</code>实际上会有两个对象，如果设置了两个<code>aop</code>的注解拦截，那么这个列表中会有3个对象。</p><p>​    通过观察不难发现，是<code>springAop</code>在创建实例对象，如果需要被<code>aop</code>代理时，它会将<code>ExposeInvocationInterceptor</code>类，固定放置在这个列表的下标为0的位置。</p><p><code>AbstractAdvisorAutoProxyCreator</code>它实现了<code>spring</code>后置处理器接口，就是它在创建具体的代理对象时，将<code>ExposeInvocationInterceptor</code>放置在增强链的头部位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出满足这个将要创建的bean对象的增强，做法是从容器中首先找出所有Advisor.class的实现类</span></span><br><span class="line"><span class="comment">// 再根据一定的逻辑进行匹配，这里在获取之后会进行缓存，下次在获取Advisor.class的实现时直接</span></span><br><span class="line"><span class="comment">// 通过缓存就能获取到。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">   <span class="comment">// 最后会走到下面的那个方法中，在列表的头部加一个增强。</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">makeAdvisorChainAspectJCapableIfNecessary</span><span class="params">(List&lt;Advisor&gt; advisors)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对获取到的增强列表进行遍历，这里来了一个二次核查，如果存在aop的增强，则在列表下标为0的位置，添加</span></span><br><span class="line">    <span class="comment">// ExposeInvocationInterceptor类。</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> foundAspectJAdvice = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// Be careful not to get the Advice without a guard, as this might eagerly</span></span><br><span class="line">            <span class="comment">// instantiate a non-singleton AspectJ aspect...</span></span><br><span class="line">            <span class="keyword">if</span> (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">                foundAspectJAdvice = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">            advisors.add(<span class="number">0</span>, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这个被加到增强列表头部的增强，有什么特殊的作用？</p><p>直接看它的拦截方法，他的拦截方法也比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 这里接收到的参数MethodInvocation实际上是aop代理类（链对象）</span></span><br><span class="line">    <span class="comment">// 重新来捋一下这个过程，在执行到对应aop的代理类之时：</span></span><br><span class="line">    <span class="comment">// 1.进入到了CglibAopProxy#intercept拦截方法</span></span><br><span class="line">    <span class="comment">// 2.用匹配的增强列表、代理类、被代理目标类（方法）的信息、具体方法、参数等创建CglibMethodInvocation</span></span><br><span class="line">    <span class="comment">//    注意这个类实现了MethodInvocation，然后调用了它的process()方法。</span></span><br><span class="line">    <span class="comment">// 3.这个process()拦截方法的实现上，主要是要遍历增强列表，进行增强的播放，当进入到首个增强时</span></span><br><span class="line">    <span class="comment">//    进入到ExposeInvocationInterceptor#invoke()方法中，来执行以下这段代码。</span></span><br><span class="line">    <span class="comment">// 4.这段代码的作用是将这个aop代理类对象放置到线程上下文中，以便于后续的增强获取。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从线程上下文中获取旧methodInvocation对象</span></span><br><span class="line">    MethodInvocation oldInvocation = invocation.get();</span><br><span class="line">    <span class="comment">// 将线程上下文替换为这个aop代理类对象，在后面的遍历增强类的过程中，</span></span><br><span class="line">    <span class="comment">// 通过线程上下文来获取这个aop代理类对象。</span></span><br><span class="line">    invocation.set(mi);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 还原现场</span></span><br><span class="line">        invocation.set(oldInvocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    <code>springAop</code>在初始化对象之后的代理类是<code>CglibAopProxy#DynamicAdvisedInterceptor</code>的实现（使用<code>cglib</code>代理的情况下），当执行到这个代理类进入到了<code>CglibAopProxy#intercept</code>拦截方法，这个方法中用匹配的增强列表、代理类、被代理目标类（方法）的信息、具体方法、参数等创建<code>CglibMethodInvocation</code>，注意这个类实现了<code>MethodInvocation</code>，然后调用了它的<code>process()</code>方法。这个<code>process()</code>拦截方法的实现上，主要是要遍历增强列表，进行增强的播放，当进入到首个增强时，进入到<code>ExposeInvocationInterceptor#invoke()</code>方法中，将这个<code>aop</code>代理类对象(<code>CglibAopProxy#DynamicAdvisedInterceptor</code>)放置到线程上下文中，以便于后续的增强获取。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringAop浅析（二）&quot;&gt;&lt;a href=&quot;#SpringAop浅析（二）&quot; class=&quot;headerlink&quot; title=&quot;SpringAop浅析（二）&quot;&gt;&lt;/a&gt;SpringAop浅析（二）&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    接两年前的旧文&lt;a href=&quot;https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/&quot; target=&quot;_blank&quot;&gt;SpringAop浅析&lt;/a&gt;，时隔两年再一次对&lt;code&gt;SpringAop&lt;/code&gt;相关源码进行分析，只能说之前阅读的不够透彻，理解的不扎实，再加上工作上常年忙于业务的处理，现在已经少有看源码的时间，不过最近不知道是因为什么打了鸡血，还是想再沉淀沉淀。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Filter无法进入全局异常捕获</title>
    <link href="http://xiaocainiaoya.github.io/2023/10/09/Spring/Filter%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <id>http://xiaocainiaoya.github.io/2023/10/09/Spring/Filter%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</id>
    <published>2023-10-09T14:20:58.000Z</published>
    <updated>2023-10-09T03:37:19.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Filter无法进入全局异常捕获"><a href="#Filter无法进入全局异常捕获" class="headerlink" title="Filter无法进入全局异常捕获"></a>Filter无法进入全局异常捕获</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    我接手的一个服务没有依赖于公司建设项目一体化体系中的认证中心，导致这个服务自身需要支持认证授权模块，由于需求上只需要一个简单的登录模块，所以引入了<code>spring-security</code>模块来进行认证授权相关处理。早上收到一个测试提出的<code>bug</code>，服务在使用一段时间不使用后，再操作，会出现警告异常提示。定位问题发现是由于<code>token</code>失效导致后端校验报错，由于这个校验是在<code>filter</code>中处理，导致全局异常无法捕获，前端获取的异常结构与标准结构（约定异常体结构&lt;msg,code,info&gt;等）不符，导致前端也无法解析具体异常信息，所以界面上显示的是直接抛出的异常信息。</p><span id="more"></span><p>​    为什么<code>filter</code>中抛出的异常无法被全局异常处理器捕获？这是因为安全校验模块，不论是<code>spring-security</code>或者<code>shiro</code>这类，都是基于<code>javax.servlet.filter</code>过滤器来拦截请求，进行认证处理。而全局异常处理器<code>@ControllerAdvice</code>是对<code>Controller</code>控制层进行拦截，也就是说请求都还没有到达控制层已经抛出异常了，所以全局异常处理器无法捕获。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    我查询了一些资料，大多数人都从两个解决方案出发解决这个问题。</p><p><b>方案一：</b>在<code>filter</code>中直接将异常信息写到<code>response</code>流中。这里有一个小细节，我个人建议具体的异常信息还是由全局异常处理器生成，而不是自己通过<code>map</code>或者异常类手动生成一个异常对象，虽然说一般情况下，异常结构与前端有约定不会随意更改，但是如果出现非一般情况，变更了异常结构，但<code>filter</code>中的异常没有相应更改，出现的问题往往是致命的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseErrorHandle</span><span class="params">(HttpServletResponse response, BusinessException businessException)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ErrorResponse&lt;?&gt; result = globalDefaultExceptionHandler.processBusinessException(businessException, response);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(result);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>方案二 ：</b>通过转发到控制层，再由控制层抛出具体的异常信息。（这个方案我个人不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在filter中如果出现异常，通过getRequestDispatcher转发到抛出异常的控制层接口中。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/common/throwException&quot;</span>).forward(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getThrowException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getThrowException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/postThrowException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">postThrowException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/throwException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">throwException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不推荐这个方案的原因是：</p><ol><li>通过<code>getRequestDispatcher().forward()</code>这个是请求转发，在<code>filter</code>中无法设置请求参数，而一般应用系统自定义的异常信息不只是只有提示信息，有时也伴随着一下其他参数，比如异常编码、异常等级、告警方式等等，这些内容由于无法通过<code>parameter</code>传递，所以只能通过<code>restful</code>风格，通过地址栏参数来进行传递，比如<code>/common/throwException/&#123;code&#125;</code>，这种方式传参比较有限，且后期可能不容易扩展。</li><li>由于是转发请求，所以请求方式取决于原请求，也就是假设浏览器（客户端）发起的请求是<code>post</code>，那么转发的请求就是<code>post</code>；如果浏览器发起的请求是<code>get</code>，那么转发的请求就是<code>get</code>。这就转发的目标控制层接口，不能使用<code>@PostMapping</code>或者<code>GetMapping</code>单一接口来标记，而必须使用<code>RequestMapping</code>，且设置<code>method</code>属性值为<code>get</code>、<code>post</code>数组。</li></ol><p>综上，我比较推荐方案一的方式进行<code>filter</code>中的异常信息抛出，并且尽可能通过全局异常处理器来生成对应的异常结构，便于扩展。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Filter无法进入全局异常捕获&quot;&gt;&lt;a href=&quot;#Filter无法进入全局异常捕获&quot; class=&quot;headerlink&quot; title=&quot;Filter无法进入全局异常捕获&quot;&gt;&lt;/a&gt;Filter无法进入全局异常捕获&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;​    我接手的一个服务没有依赖于公司建设项目一体化体系中的认证中心，导致这个服务自身需要支持认证授权模块，由于需求上只需要一个简单的登录模块，所以引入了&lt;code&gt;spring-security&lt;/code&gt;模块来进行认证授权相关处理。早上收到一个测试提出的&lt;code&gt;bug&lt;/code&gt;，服务在使用一段时间不使用后，再操作，会出现警告异常提示。定位问题发现是由于&lt;code&gt;token&lt;/code&gt;失效导致后端校验报错，由于这个校验是在&lt;code&gt;filter&lt;/code&gt;中处理，导致全局异常无法捕获，前端获取的异常结构与标准结构（约定异常体结构&amp;lt;msg,code,info&amp;gt;等）不符，导致前端也无法解析具体异常信息，所以界面上显示的是直接抛出的异常信息。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx之proxy_pass</title>
    <link href="http://xiaocainiaoya.github.io/2023/09/13/nginx/nginx%E4%B9%8Bproxy_pass/"/>
    <id>http://xiaocainiaoya.github.io/2023/09/13/nginx/nginx%E4%B9%8Bproxy_pass/</id>
    <published>2023-09-13T13:51:58.000Z</published>
    <updated>2023-10-09T07:45:09.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx之proxy-pass"><a href="#nginx之proxy-pass" class="headerlink" title="nginx之proxy_pass"></a>nginx之proxy_pass</h1><ul><li>往期回顾：<a href="https://xiaocainiaoya.github.io/2020/04/13/nginx/nginx/">nginx</a></li></ul><p><code>proxy_pass</code>是<code>nginx</code>中常见的反向代理指令。</p><blockquote><p>格式：proxy_pass {传输协议}{主机名}{URI}</p></blockquote><ul><li>传输协议：<code>http://</code>或者<code>https://</code></li><li>主机名：<code>IP:PORT</code></li><li><code>URI</code>：具体的访问地址</li></ul><span id="more"></span><p>先下结论：</p><p>当<code>URI</code>是<code>\</code>时，表示是绝对路径，则不会将<code>location</code>后的匹配规则路径携带到转发目标路径中。</p><p>当<code>URI</code>为空时，表示是相对路径，则会将<code>location</code>后的匹配规则路径携带到转发目标路径中。</p><p>假设访问地址是：<code>http:test.nginx.com/proxy/getUserName</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.URI=/,表示是绝对路径。所以最终的访问地址是: http://127.0.0.1:81/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.URI=空,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/proxy/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.URI=/v1,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/v1getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81/v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.URI=/v1/,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/v1/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:81/v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上所述：只有当<code>URI</code>为空时，才会将<code>location</code>后的匹配字符串带到最终的转发目标路径上。</p><h2 id="proxy-set-header-排坑"><a href="#proxy-set-header-排坑" class="headerlink" title="proxy_set_header 排坑"></a>proxy_set_header 排坑</h2><p>​    这里简单描述一下我遇到的场景，在排查过程中耗费了较多的精力。这里我们需要对接外部服务，但是外部服务有一些安全策略，互联网无法直接访问，需要通过跳板机进行访问，同样”外部服务“也只能通过跳板机访问”服务集群“，这里在跳板机上部署了<code>nginx2</code>。<code>nginx1</code>是原本环境中的反向代理。</p><p><img src="https://s2.loli.net/2023/09/18/GubszUkKHY8TRMW.png" alt="pass_header.png"></p><p>​    在<code>nginx</code>中配置了这样一段，用于”外部服务“请求”服务集群“。用于</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> https://test.service.cn/;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host $host:$server_port;</span><br><span class="line">  <span class="attribute">proxy_hide_header</span> <span class="string">&quot;X-Frame-Options&quot;</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-Ip $remote_addr;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-For $remote_addr;</span><br><span class="line">  <span class="attribute">client_max_body_size</span>  <span class="number">100m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在测试中发现，”外部服务“始终无法调用到”服务集群“的接口，而在<code>nginx2</code>的访问日志中显示<code>404</code>，一直以为是”服务集群“中部署有问题，但是通过<code>curl</code>又能正常访问。</p><p>​    在折腾一段时间之后，发现是<code>proxy_set_header</code>这个变量设置的有问题导致请求到达<code>nginx1</code>时出现问题。在了解这个具体问题之前，先来简单解释一下<code>nginx</code>的工作方式。</p><p><code>nginx</code>作为反向代理时，它是需要监听<code>service_name</code>和端口的。</p><ul><li><p>第一步根据请求中的<code>IP</code>和端口先匹配到具体的代理<code>server</code>。</p></li><li><p>第二步才是进行路径的匹配，根据<code>location</code>的路径规则，进行具体的代理逻辑。</p></li></ul><p>​    然而第一步中的匹配不是根据<b>请求的地址中的IP和端口</b>，而是通过请求头中的<code>Host</code>属性进行匹配。再回到最开始出现问题的地方，由于我设置了<code>proxy_set_header Host $host:$server_port;</code>，导致到达<code>nginx1</code>的请求的请求头中的<code>Host</code>是<code>nginx2</code>本机地址，从而导致<code>nginx1</code>代理规则匹配失败，所以这里出现的<code>404</code>是由于<code>nginx1</code>无法匹配到具体的代理<code>server</code>导致。</p><p>​    若没有配置则默认是：<code>proxy_set_header Host $proxy_host;</code>，表示代理的地址。</p><table><thead><tr><th>变量名</th><th>端口</th><th>值</th></tr></thead><tbody><tr><td>$host</td><td>没有端口</td><td>本机地址</td></tr><tr><td>$pass_host</td><td>80不显示，其他显示</td><td>被代理服务的ip和端口</td></tr><tr><td>$http_host</td><td>端口存在则显示</td><td>请求时的ip和端口</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nginx之proxy-pass&quot;&gt;&lt;a href=&quot;#nginx之proxy-pass&quot; class=&quot;headerlink&quot; title=&quot;nginx之proxy_pass&quot;&gt;&lt;/a&gt;nginx之proxy_pass&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;往期回顾：&lt;a href=&quot;https://xiaocainiaoya.github.io/2020/04/13/nginx/nginx/&quot;&gt;nginx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;proxy_pass&lt;/code&gt;是&lt;code&gt;nginx&lt;/code&gt;中常见的反向代理指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;格式：proxy_pass {传输协议}{主机名}{URI}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;传输协议：&lt;code&gt;http://&lt;/code&gt;或者&lt;code&gt;https://&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主机名：&lt;code&gt;IP:PORT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URI&lt;/code&gt;：具体的访问地址&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://xiaocainiaoya.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="http://xiaocainiaoya.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>java参数命令</title>
    <link href="http://xiaocainiaoya.github.io/2023/08/18/java/java%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/"/>
    <id>http://xiaocainiaoya.github.io/2023/08/18/java/java%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/</id>
    <published>2023-08-18T13:51:58.000Z</published>
    <updated>2023-10-09T07:25:53.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java参数命令"><a href="#java参数命令" class="headerlink" title="java参数命令"></a>java参数命令</h1><h3 id="java启动命令中-D和–的区别"><a href="#java启动命令中-D和–的区别" class="headerlink" title="java启动命令中-D和–的区别"></a>java启动命令中-D和–的区别</h3><p>两种方式都可以<b>直接覆盖</b><code>yaml</code>或者<code>properties</code>配置中的同名配置项。</p><ul><li><code>-D</code>（包括<code>-X</code>）表示添加的参数是<code>jvm</code>虚拟机变量。<code>java</code>应用中通过<code>System.getProperties(&quot;&quot;)</code>获取。</li><li><code>--</code>表示添加的参数是操作系统的环境变量。<code>java</code>应用中通过<code>System.getEnv(&quot;&quot;)</code>获取。</li></ul><p><code>-D</code>参数要放置在<code>-jar</code>命令之前，<code>--</code>参数要放置在<code>-jar</code>命令之后。</p><blockquote><p>java -Dserver.port=8080 -Xms128m <b>-jar</b> –server.name=myApp</p></blockquote><p>可通过<code>jps</code>命令查看<code>java</code>应用具体的参数值。</p><ul><li><code>jps -v</code>：可以查看<code>-D</code>、<code>-X</code>参数</li></ul><p>示例：<code>1 jar -Djava.util.Arrays.useLegacyMergeSort=true -Djava.security.egd=file:/dev/./urandom -Xms128m -Xmx512m</code></p><ul><li><code>jps -m</code>：可以查看<code>--</code>参数</li></ul><p>示例：<code>1 jar --spring.profiles.active=dev --logging.config=logback-spring.xml</code></p><h3 id="crf反编译工具"><a href="#crf反编译工具" class="headerlink" title="crf反编译工具"></a>crf反编译工具</h3><blockquote><p><a href="http://www.benf.org/other/cfr/">http://www.benf.org/other/cfr/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java参数命令&quot;&gt;&lt;a href=&quot;#java参数命令&quot; class=&quot;headerlink&quot; title=&quot;java参数命令&quot;&gt;&lt;/a&gt;java参数命令&lt;/h1&gt;&lt;h3 id=&quot;java启动命令中-D和–的区别&quot;&gt;&lt;a href=&quot;#java启动命令中-D和–</summary>
      
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息投递确认</title>
    <link href="http://xiaocainiaoya.github.io/2023/08/16/mq/RabbitMQ%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E7%A1%AE%E8%AE%A4/"/>
    <id>http://xiaocainiaoya.github.io/2023/08/16/mq/RabbitMQ%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E7%A1%AE%E8%AE%A4/</id>
    <published>2023-08-16T14:13:58.000Z</published>
    <updated>2023-08-16T08:27:11.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ消息投递确认"><a href="#RabbitMQ消息投递确认" class="headerlink" title="RabbitMQ消息投递确认"></a>RabbitMQ消息投递确认</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    在项目中引入了<code>RabbitMQ</code>用于服务间一些解耦操作，在运行了一段时间之后，突然在某个环境中出现了一些异常情况。</p><span id="more"></span>    <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    从投递者日志来看，确实投递者有将对应的数据投递出去；从消费者日志来看，一直未监听到对应的消息，并且从<code>RabbitMQ</code>后台来看，对应队列上是存在监听，并且通过<code>RabbitMQ</code>控制台通过<code>Publish message</code>发出的消息，在消费者服务的日志中可以看到对应的消费信息。</p><p>​    经过反复的查看，确定投递者服务投递的消息对应的交换机和路由器应该是没有问题的。排查到这里实际上我已经没有任何排查思路了，我猜测既然消费者的日志中并没有出现消费的相关日志，那么大概率问题应该是在投递端。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    在<code>RabbitMQ</code>中是有消息投递确认的回调处理，当投递失败时，可以通过回调接口在投递者服务中打印出对应的信息，这样至少排查问题时可以知道，是投递出现了问题。</p><p>这里先简单解释两个概念：</p><p>消息是由投递者投递到<b>交换机</b>，再由交换机根据指定路由键投递到对应的<b>队列</b>。</p><ul><li><p><code>publisher-confirm</code>：发送者确认，消息成功投递到交换机返回<code>ack</code>，消息未投递到交换机返回<code>nack</code>。<b>注意，这里的维度是交换机，也就是交换机接收了，就认为你投递成功。</b></p></li><li><p><code>publisher-return</code>：发送者回执，消息发送队列失败会回调这个方法。<b>注意，这里的维度是队列，就是交换机有没有将消息投递到具体的队列上，若投递不到具体的队列，则回调这个方法。</b></p></li></ul><p>1.在<code>spring</code>配置项中开启投递确认</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple 同步等待confirm结果，直到超时</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated </span></span><br><span class="line"><span class="comment"># 开始publish-return功能，同样基于callback机制，不过是定义ReturnCallback</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 定义消息路由失败时的策略，true则调用ReturnCallback; false则丢弃</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>2.设置投递确认和投递回执监听</p><p>我这里为了快捷测试，就通过<code>@PostConstruct</code>设置对应的回调信息，实际项目中，应通过<code>@Configuration</code>或者<code>@Bean</code>抽取到对应的配置类中，因为<code>setReturnsCallback</code>等方法对应每一个<code>rabbitTemplate</code>实例只能设置一次，第二次赋值，将会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> RabbitTemplate.ReturnsCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由key&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                    returnedMessage.getReplyCode(), returnedMessage.getReplyText(), returnedMessage.getExchange(),</span><br><span class="line">                    returnedMessage.getRoutingKey(), returnedMessage.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息投递异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/testMq&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;测试发送消息&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title">testMq</span><span class="params">(<span class="meta">@RequestParam(&quot;exchange&quot;)</span> String exchange, <span class="meta">@RequestParam(&quot;route&quot;)</span> String route)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchange, route, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.&lt;Boolean&gt;builder().data(<span class="keyword">null</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>测试结论：</b></p><p>1.若投递一个不存在的交换机，<code>setConfirmCallback()</code>中返回<code>false</code>。<b>不会进入<code>returnCallback</code>监听方法。</b>这里还是要老生常谈一下，一定要注意，若交换机投递失败，<code>returnCallback</code>是不会接受到监听回调。</p><p>2.若投递一个存在的交换机且存在的路由键，<code>setConfirmCallback()</code>中返回<code>true</code>，<b>不会进入<code>returnCallback</code>监听方法。</b>因为只有投递队列失败才会进入到这个方法中。</p><p>3.若投递一个存在的交换机且不存在的路由键，<code>setConfirmCallback()</code>中返回<code>true</code>，<b>会进入<code>returnCallback</code>监听方法。</b></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RabbitMQ消息投递确认&quot;&gt;&lt;a href=&quot;#RabbitMQ消息投递确认&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消息投递确认&quot;&gt;&lt;/a&gt;RabbitMQ消息投递确认&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    在项目中引入了&lt;code&gt;RabbitMQ&lt;/code&gt;用于服务间一些解耦操作，在运行了一段时间之后，突然在某个环境中出现了一些异常情况。&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://xiaocainiaoya.github.io/categories/MQ/"/>
    
    
    <category term="MQ" scheme="http://xiaocainiaoya.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>maven插件整理</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/26/maven/maven%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/26/maven/maven%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</id>
    <published>2023-07-26T14:13:58.000Z</published>
    <updated>2023-10-09T07:47:01.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven插件整理"><a href="#maven插件整理" class="headerlink" title="maven插件整理"></a>maven插件整理</h1><p>​    常用<code>maven</code>插件整理，<code>maven</code>本质上是一个插件框架，它的核心并不具备执行任何构建任务的能力，所有的任务都是交由插件完成。</p><span id="more"></span>    <p>​    <code>maven</code>插件<a href="https://maven.apache.org/plugins/index.html">官网</a>，里面有一个<code>Supported By The Maven Project</code>标题下的列表中的插件，是由<code>maven</code>官方支持的插件。还有一个<code>Outside The Maven Land</code>下的<code>At MojoHaus (formerly known as codehaus.org)</code>这个不是官网的插件列表，但其中的部分插件也是比较常用的。</p><h2 id="1-maven-antrun-plugin"><a href="#1-maven-antrun-plugin" class="headerlink" title="1.maven-antrun-plugin"></a>1.maven-antrun-plugin</h2><p>​    主要作用是能让用户在<code>maven</code>项目中运行<code>Ant</code>任务。</p><h2 id="2-maven-archetype-plugin"><a href="#2-maven-archetype-plugin" class="headerlink" title="2.maven-archetype-plugin"></a>2.maven-archetype-plugin</h2><p>​    <code>Archtype</code>指项目的骨架，主要作用是创建项目骨架原型。</p><ul><li><code>archetype:generate</code>：使用交互式的方式提示用户输入必要的信息以创建项目</li></ul><h2 id="3-maven-assembly-plugin"><a href="#3-maven-assembly-plugin" class="headerlink" title="3.maven-assembly-plugin"></a>3.maven-assembly-plugin</h2><p>​    这个插件就比较常用，用来对项目制作一些压缩包，定制压缩包中的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/config/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-maven-dependency-plugin"><a href="#4-maven-dependency-plugin" class="headerlink" title="4.maven-dependency-plugin"></a>4.maven-dependency-plugin</h2><p>​    主要作用是分析项目中的依赖。</p><ul><li><code>dependency:list</code>：项目最终解析到的依赖列表</li><li><code>dependency:tree</code>：进一步的描绘项目依赖树</li><li><code>dependency:analyze</code>：项目依赖潜在的问题</li><li><code>dependency:copy-dependencies</code>：能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面</li></ul><h2 id="5-maven-enforcer-plugin"><a href="#5-maven-enforcer-plugin" class="headerlink" title="5.maven-enforcer-plugin"></a>5.maven-enforcer-plugin</h2><p>​    设置约束项目的一系列规则并强制遵守，比如<code>maven</code>的版本，<code>java</code>的版本，禁止某些依赖，某些依赖的版本最低版本，在父<code>pom</code>中配置规则，当不符合规则时，会报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>display-info<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--规则检查不通过就构建失败;Default:false. --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;failFast&gt;true&lt;/failFast&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--maven的版本要大于3.0.4--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requireMavenVersion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">requireMavenVersion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--java的版本要大于1.6--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requireJavaVersion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">requireJavaVersion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--bannedDependencies表示禁止使用的依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bannedDependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否检查传递性依赖(间接依赖)--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">searchTransitive</span>&gt;</span>true<span class="tag">&lt;/<span class="name">searchTransitive</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--禁止的依赖列表--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>junit:junit<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">message</span>&gt;</span>must use TestNG<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bannedDependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>exclude</code>标签中，可以通过通配符的方式设置一些依赖规则，其他详见<a href="http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html">内置版本范围规则</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--groupId[:artifactId][:version][:type][:scope][:classifier]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:log4j<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:log4j:1.0<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:1.2<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span><span class="comment">&lt;!--排除1.2及其以上版本,等价于[1.2,)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:[1.2]<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span><span class="comment">&lt;!--明确排除1.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:*:jar:test<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*:*:*:jar:compile:tests<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-maven-help-plugin"><a href="#6-maven-help-plugin" class="headerlink" title="6.maven-help-plugin"></a>6.maven-help-plugin</h2><p>​    一个辅助工具，用来获取一些详细使用信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看`versions-maven-plugin`这个插件的详细描述，会输出这个插件的所有`goal`</span></span></span><br><span class="line">mvn help:describe -Dplugin=org.codehaus.mojo:versions-maven-plugin:2.7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看指定的某个goal</span></span></span><br><span class="line">mvn help:describe -Dplugin=org.codehaus.mojo:versions-maven-plugin:2.7 -Dgoal=set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看有效settings</span></span></span><br><span class="line">mvn help:effective-settings</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;maven插件整理&quot;&gt;&lt;a href=&quot;#maven插件整理&quot; class=&quot;headerlink&quot; title=&quot;maven插件整理&quot;&gt;&lt;/a&gt;maven插件整理&lt;/h1&gt;&lt;p&gt;​    常用&lt;code&gt;maven&lt;/code&gt;插件整理，&lt;code&gt;maven&lt;/code&gt;本质上是一个插件框架，它的核心并不具备执行任何构建任务的能力，所有的任务都是交由插件完成。&lt;/p&gt;</summary>
    
    
    
    <category term="maven" scheme="http://xiaocainiaoya.github.io/categories/maven/"/>
    
    
    <category term="maven" scheme="http://xiaocainiaoya.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>spring-statemachine入门</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/</id>
    <published>2023-07-15T14:20:58.000Z</published>
    <updated>2023-10-09T07:49:30.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-statemachine入门"><a href="#spring-statemachine入门" class="headerlink" title="spring-statemachine入门"></a>spring-statemachine入门</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring-statemachine</code>是<code>spring</code>设计于处理状态的变化，以及定义状态之间的转换规则。</p><span id="more"></span><p><strong>状态机的基本组成</strong></p><p>状态机主要由4要素组成：</p><ul><li>现态：当前所处的状态。</li><li>条件：或者称为“事件”，在状态转换图中使用箭头标识，当满足某个条件（触发某个事件）之后，由一个状态转移到另一个状态。比如下图中“支付”这个箭头。</li><li>动作：表示由现态转换到次态之后，需要执行的动作，不是必须的，可以是转换转换后不执行任何动作。比如下图中从[待收货]转换到[已收货]是否设置某个动作。</li><li>次态：下一环状态。</li></ul><p>​    比如一个支付下单流程的状态转换图：</p><p><img src="https://s2.loli.net/2023/07/15/a71AErSKG2TLFNw.png" alt="状态装换图.png"></p><p>​    订单的开始状态为[待支付]，当用户支付之后状态流转为[已支付]，这个地方是个分支节点，当状态流转到[已支付]后，根据一些业务规则，将状态流转到[待收货]或者[待开票]，若是[待收货]，通过收货行为，使状态流转到[结束];若是[待开票]状态，通过投递行为，使状态流转到[结束]。</p><h2 id="Spring-stateMachine"><a href="#Spring-stateMachine" class="headerlink" title="Spring stateMachine"></a>Spring stateMachine</h2><p><code>Spring StateMachine</code>是一个基于 <code>Spring</code>框架的状态机框架，使用<code>Spring StateMachine</code>可以方便地在 <code>Java</code>应用中实现状态机功能，并可以与<code>Spring</code>框架的其他功能结合使用。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><b>1.添加依赖</b></p><p>我这里使用的是<code>springboot</code>工程，最好先引入官方提供的<code>spring-statemachine-bom</code>，这样基本上不会出现与<code>spring framework</code>版本不对应，出现的一些无法解释的坑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>2.订单状态枚举类</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UNPAID(<span class="string">&quot;unpaid&quot;</span>,<span class="string">&quot;待支付&quot;</span>),</span><br><span class="line">    PAID(<span class="string">&quot;paid&quot;</span>,<span class="string">&quot;已支付&quot;</span>),</span><br><span class="line">    WAITING_FOR_RECEIVE(<span class="string">&quot;waitingForReceive&quot;</span>,<span class="string">&quot;待收货&quot;</span>),</span><br><span class="line">    DONE(<span class="string">&quot;done&quot;</span>,<span class="string">&quot;结束&quot;</span>),</span><br><span class="line">    INVOICE(<span class="string">&quot;invoice&quot;</span>, <span class="string">&quot;开票&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    StateEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StateEnum <span class="title">getByState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (StateEnum stateEnum : StateEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stateEnum.getType().equals(state)) &#123;</span><br><span class="line">                <span class="keyword">return</span> stateEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.事件枚举类</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EventEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PAY(<span class="string">&quot;pay&quot;</span>,<span class="string">&quot;支付&quot;</span>),</span><br><span class="line">    RECEIVE(<span class="string">&quot;receive&quot;</span>,<span class="string">&quot;收货&quot;</span>),</span><br><span class="line">    DELIVERY(<span class="string">&quot;delivery&quot;</span>,<span class="string">&quot;发货&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    EventEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.状态机配置</b></p><p>状态机配置类中包含状态配置、状态转换事件关系配置、监听器配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 这里最好手动设置name， 如果不设置, 默认使用stateMachineFactory这个名字, 由于这个类</span></span><br><span class="line"><span class="comment">// 需要注入到spring容器中, 如果需要创建两个不一样的状态机会出现重名的冲突。</span></span><br><span class="line"><span class="meta">@EnableStateMachineFactory(name = &quot;feeStateMachineFactory&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeeStateMachineConfig</span> <span class="keyword">extends</span> <span class="title">StateMachineConfigurerAdapter</span>&lt;<span class="title">StateEnum</span>, <span class="title">EventEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态: 初始状态、</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineStateConfigurer&lt;StateEnum, EventEnum&gt; states)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        states.withStates()</span><br><span class="line">            <span class="comment">// 初始状态</span></span><br><span class="line">            .initial(StateEnum.UNPAID)</span><br><span class="line">            <span class="comment">// 分支节点, 如果存在分支节点, 必须要在这里声明</span></span><br><span class="line">            .choice(StateEnum.PAID)</span><br><span class="line">            <span class="comment">// 状态的所有值</span></span><br><span class="line">            .states(EnumSet.allOf(StateEnum.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态机监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2023/7/14 16:04:34</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineConfigurationConfigurer&lt;StateEnum, EventEnum&gt; config)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        config.withConfiguration()</span><br><span class="line">            <span class="comment">// 设置全局监听器</span></span><br><span class="line">            .listener(listener())</span><br><span class="line">            <span class="comment">// 设置状态机的ID, 可以认为是状态机的名称，在通过StateMachineFactory.getStateMachine()需要通过这个名称获取</span></span><br><span class="line">            <span class="comment">// 在测试的过程中发现, 有些人写的文章里没有设置这个名称, 然后在使用StateMachineFactory.getStateMachine(machineId)</span></span><br><span class="line">            <span class="comment">// 中的machineId使用的是数据库中查出的订单ID, 这样的写法在不使用OnTransition相关监听注解是不会有问题，但是如果</span></span><br><span class="line">            <span class="comment">// 需要使用到@OnTransition相关注解就会导致无法进入到这个注解标记的方法中。</span></span><br><span class="line">            .machineId(<span class="string">&quot;stateMachine&quot;</span>)</span><br><span class="line">            .autoStartup(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态转换和事件的转换关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transitions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineTransitionConfigurer&lt;StateEnum, EventEnum&gt; transitions)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        transitions</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.UNPAID)</span><br><span class="line">            .target(StateEnum.PAID)</span><br><span class="line">            .event(EventEnum.PAY)</span><br><span class="line">            <span class="comment">// guard()守卫函数，状态转移后进入, 如果返回的是true, 才进入到action方法中。</span></span><br><span class="line">            .guard(<span class="keyword">new</span> Guard&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(StateContext&lt;StateEnum, EventEnum&gt; context)</span> </span>&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;进入订单守卫函数&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.UNPAID.getValue(), StateEnum.PAID.getValue()))</span><br><span class="line">        .and()</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">            .target(StateEnum.DONE)</span><br><span class="line">            .event(EventEnum.RECEIVE)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.WAITING_FOR_RECEIVE.getValue(), StateEnum.DONE.getValue()))</span><br><span class="line">        .and()</span><br><span class="line">            <span class="comment">// 表示分支</span></span><br><span class="line">            .withChoice()</span><br><span class="line">            .source(StateEnum.PAID)</span><br><span class="line">            <span class="comment">// 类似于 if(first的第二个参数的方法如果是true)则进入到first第一个参数的状态，并进入first第三个参数的action</span></span><br><span class="line">            <span class="comment">// 如果first的第二个参数返回的是false，则进入到last的第一个参数状态，并进入到first第二个参数的atction</span></span><br><span class="line">            .first(StateEnum.INVOICE, ctx -&gt; (<span class="keyword">boolean</span>) Optional.ofNullable(ctx.getMessage().getHeaders().get(<span class="string">&quot;invoice&quot;</span>)).orElse(<span class="keyword">true</span>), ctx -&gt; log.info(<span class="string">&quot;进入发票分支&quot;</span>))</span><br><span class="line">            .last(StateEnum.WAITING_FOR_RECEIVE, ctx -&gt; log.info(<span class="string">&quot;进入收货分支&quot;</span>))</span><br><span class="line">        .and()</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.INVOICE)</span><br><span class="line">            .target(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">            .event(EventEnum.DELIVERY)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.INVOICE.getValue(), StateEnum.WAITING_FOR_RECEIVE.getValue()))</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StateMachineListener&lt;StateEnum, EventEnum&gt; <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StateMachineListenerAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当状态的转移在configure方法配置中时，会走到该方法。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;StateEnum, EventEnum&gt; transition)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;listener[&#123;&#125;]状态变更:&#123;&#125; -&gt; &#123;&#125;&quot;</span>, transition.getKind().name(),</span><br><span class="line">                    transition.getSource() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getSource().getId()),</span><br><span class="line">                    transition.getTarget() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getTarget().getId()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当发生的状态转移不在configure方法配置中时，会走到该方法，此处打印error日志，方便排查状态转移问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;EventEnum&gt; event)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;事件未收到: &#123;&#125;&quot;</span>, event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> Object <span class="title">ofNullableState</span><span class="params">(StateEnum s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.ofNullable(s)</span><br><span class="line">                    .map(StateEnum::getValue)</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>4.测试调用</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.sendEvent(MessageBuilder.withPayload(EventEnum.PAY)</span><br><span class="line">                    .setHeader(JSON_STR, JSON.toJSONString(feeOrder))</span><br><span class="line">                    .build())</span><br></pre></td></tr></table></figure><h3 id="使用注解方式配置监听器"><a href="#使用注解方式配置监听器" class="headerlink" title="使用注解方式配置监听器"></a>使用注解方式配置监听器</h3><p>​    前面说到，如果需要使用注解方式配置监听器，一定一定要注意<code>machineId</code>的赋值。因为可以通过多种方式来处理状态转移之后的监听，所以并不一定所有人在使用时都会使用这种方式，但是使用这种方式就是一定要注意<code>machineId</code>的赋值问题。(可以在定义配置时就设置<code>action</code>也可以达到状态转移后进入某个函数进行相关处理。)</p><p>​    <code>spring stateMachine</code>中设置的监听，这些监听都有设置对应的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateMachineListener</span>&lt;<span class="title">S</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(State&lt;S,E&gt; from, State&lt;S,E&gt; to)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateEntered</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateExited</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;E&gt; event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transitionStarted</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transitionEnded</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineStarted</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineStopped</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineError</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine, Exception exception)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extendedStateChanged</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateContext</span><span class="params">(StateContext&lt;S, E&gt; stateContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过注解的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/7/15 09:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@WithStateMachine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnTransition(target = &quot;UNPAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@StatesOnTransition</span></span><br><span class="line">    <span class="meta">@OnTransition(source = &quot;UNPAID&quot;, target = &quot;PAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Message&lt;EventEnum&gt; obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取消息中的订单对象</span></span><br><span class="line">        <span class="comment">//Order order = (Order) message.getHeaders().get(&quot;order&quot;);</span></span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        <span class="comment">//order.setStates(States.WAITING_FOR_RECEIVE);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户支付完毕，状态机反馈信息：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>​    一般来说，我们的处理逻辑为从状态机工程中获取到一个状态机，但是不一定说每一台状态机都是从初始状态开始走，有可能订单目前处在某个状态，但是由于一些原因重启了服务，那么这是如果重新创建状态机那么状态需要从头开始走，这显然不符合逻辑，所以在获取到状态机之后，需要为这台状态机重新赋状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从状态机工厂获取一个状态机</span></span><br><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.stop();</span><br><span class="line">stateMachine.getStateMachineAccessor().doWithAllRegions(sma -&gt; &#123;</span><br><span class="line">    <span class="comment">//配置状态机拦截器，当状态发生转移时，会走到该拦截器中</span></span><br><span class="line">    sma.addStateMachineInterceptor(<span class="keyword">new</span> StateMachineInterceptorAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStateChange</span><span class="params">(State&lt;StateEnum, EventEnum&gt; state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Message&lt;EventEnum&gt; message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Transition&lt;StateEnum, EventEnum&gt; transition,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; stateMachine,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; rootStateMachine)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;preStateChange&quot;</span>);</span><br><span class="line">            FeeOrder result = JSON.parseObject(String.class.cast(message.getHeaders().get(JSON_STR)), FeeOrder.class);</span><br><span class="line">            <span class="comment">//更新状态机转移后的状态</span></span><br><span class="line">            result.setOrderStatus(state.getId().getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//将状态机的初始状态配置为DB中对应状态</span></span><br><span class="line">    sma.resetStateMachine(<span class="keyword">new</span> DefaultStateMachineContext&lt;&gt;(stateEnum, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;stateMachine&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动状态机</span></span><br><span class="line">stateMachine.start();</span><br></pre></td></tr></table></figure><p>​    尽管可以手动对状态机赋状态，但是这种方式也解决不了根本问题，以订单为例子，如果用户在发起创建订单之后，订单处在待支付状态，然后用户一直没有去支付，这时出现需要重启服务器的情况；或者如果部署了多个实例，某一台实例中状态机处在待支付状态，而用户去支付时请求走到了另一台服务器，这时在另一台服务器上状态走到了待开票，如果开票的请求又走到了原本处在待支付状态的服务器上呢？所以这里就变成必须与数据库中的订单状态实时校验？</p><p>所以这里引入的持久化。主要针对于故障恢复、可恢复性、长时间运行等情况。</p><p>持久化有多种方式，基于内存、基于<code>db</code>、基于<code>redis</code>、基于<code>MongoDB</code>等，这里以<code>redis</code>为例。</p><p><b>1.引入依赖</b></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>2.redis配置</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachinePersisterConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Redis持久化配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisStateMachinePersister&lt;StateEnum, EventEnum&gt; <span class="title">persister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt; repository</span><br><span class="line">            = <span class="keyword">new</span> RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt;(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisStateMachinePersister&lt;&gt;(<span class="keyword">new</span> RepositoryStateMachinePersist&lt;&gt;(repository));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.使用redis进行持久化</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sendEvent</span><span class="params">(Events changeEvent, Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      stateMachine.start();</span><br><span class="line">      <span class="comment">//尝试恢复状态机状态</span></span><br><span class="line">      stateMachineMemPersister.restore(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">      Message message = MessageBuilder.withPayload(changeEvent)</span><br><span class="line">              .setHeader(<span class="string">&quot;order&quot;</span>, order).build();</span><br><span class="line">      result = stateMachine.sendEvent(message);</span><br><span class="line">      <span class="comment">//持久化状态机状态</span></span><br><span class="line">      stateMachineMemPersister.persist(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;操作失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      stateMachine.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    <code>spring stateMachine</code>在简单实用之后感觉虽然在一定层度上对状态装换过程的代码编写风格进行了解耦，但是感觉由于<code>spring stateMachine</code>有点过于重量化，导致如果使用不当容易出现一些不可预判、出乎意料之外的问题。就比如之前提到的版本不对应监听注解失效的问题，在使用过程中它也不会报错，仅仅是始终无法进入到对应的注解中；还比如<code>choice</code>分支的问题、状态机不持久化带来的问题、若使用了持久化，持久化带来的问题等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring-statemachine入门&quot;&gt;&lt;a href=&quot;#spring-statemachine入门&quot; class=&quot;headerlink&quot; title=&quot;spring-statemachine入门&quot;&gt;&lt;/a&gt;spring-statemachine入门&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring-statemachine&lt;/code&gt;是&lt;code&gt;spring&lt;/code&gt;设计于处理状态的变化，以及定义状态之间的转换规则。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK9特性</title>
    <link href="http://xiaocainiaoya.github.io/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/</id>
    <published>2023-07-12T13:51:58.000Z</published>
    <updated>2023-10-09T07:51:45.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK9特性"><a href="#JDK9特性" class="headerlink" title="JDK9特性"></a>JDK9特性</h1><span id="more"></span><h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><p>​    模块是代码、数据和资源的集合。它是一组相关的包和类型（类、抽象类、接口等），包含代码、数据文件和一些静态资源。说人话就是，<code>JDK9</code>在<code>JDK8</code>之上对<code>package</code>再进行了一层包装，以往的<code>JDK</code>中在<code>.jar</code>包中就是<code>package</code>包了，也就是说如果你在工程中引入了一个<code>.jar</code>，这么这整个<code>.jar</code>下的包都被引入到你的工程，在你的工程中就可以使用引入的这个<code>.jar</code>文件的所有包下的类。但是在<code>JDK9</code>模块化之后，在<code>.jar</code>下，<code>package</code>上，添加了一层<code>module</code>，也就是说，如果你在工程中引入一个<code>.jar</code>，这时也不能访问到<code>.jar</code>下的所有包，要看两个条件，一个条件是这个<code>.jar</code>是否将这个包开放访问，二是当前模块是否需要访问<code>.jar</code>中的某个包。</p><p><b>示例：</b></p><p>在工程中引入<code>lombok</code>，显然根据上面说的，如果在<code>JDK9</code>之前，这样就可以访问到<code>lombok</code>中的相关类资源。但是这里是访问不到的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.18.26&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>想要访问到<code>lombok</code>中的类资源，这时需要两个条件都满足，当前工程才可以使用<code>lombok</code>相关类。</p><ol><li><p><code>lombok</code>将自身的某些允许访问的包暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lombok &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.compiler;</span><br><span class="line">    <span class="keyword">requires</span> java.instrument;</span><br><span class="line">    <span class="keyword">requires</span> jdk.unsupported;</span><br><span class="line">    <span class="comment">// lombok中暴露 lombok 这个包</span></span><br><span class="line">    <span class="keyword">exports</span> lombok;</span><br><span class="line">    <span class="keyword">exports</span> lombok.experimental;</span><br><span class="line">    ... 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当前工程需要<code>lombok</code>中的某些包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="keyword">requires</span> common;</span><br><span class="line">    <span class="comment">// 当前工程中引入 lombok 包</span></span><br><span class="line">    <span class="keyword">requires</span> lombok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><b>这两个条件都需要在对应的<code>module-info.java</code>显示声明。</b></p><p>根据上面的例子可以看出，<code>JDK9</code>是通过在顶层类路径下添加<code>module-info.java</code>来控制模块化。这个文件称为<b>模块描述符</b>。可以通过反向的域名来定义模块名。</p><h3 id="1-模块描述符"><a href="#1-模块描述符" class="headerlink" title="1.模块描述符"></a>1.模块描述符</h3><p>1.需要引入某些模块，使用<code>requires</code>引入模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况是不支持透传, 也就是A -&gt; B, B -&gt; C, 下面这种写法A是不引用C的。</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传，也就是A -&gt; B, B -&gt; C, 下面这种写法A也是依赖于C</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> transitive <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态引入：编译的时候必须要包含这些类的jar包才能够编译通过。但是在运行的时候我们可能不会用到这些类</span></span><br><span class="line"><span class="comment">// 表示在编译时的依赖是强制的，但在运行时是可选的</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">static</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.需要暴露某些模块，供其他模块引入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将某个包暴露, 其他引用模块才可以通过requires关键字引入</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">   <span class="keyword">exports</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点对点暴露</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">exports</span> <span class="keyword">module</span>.nameA to <span class="keyword">module</span>.nameB, <span class="keyword">module</span>.nameC, <span class="keyword">module</span>.nameD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><p>A模块中有两个包路径：<code>xiaocainiao.common.entity</code>和<code>xiaocainiao.common.vo</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="comment">// 暴露A模块的其中一个包路径</span></span><br><span class="line">    <span class="keyword">exports</span> xiaocainiao.common.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B模块中有两个包路径：<code>xiaocainiao.user.entity</code>和<code>xiaocainiao.user.vo</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="comment">// B模块引用整个A模块</span></span><br><span class="line">    <span class="keyword">requires</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，B模块仍然也只能引用到A模块暴露出来的一个包，另一个没有暴露出来的包，B模块无法访问。这个时候对于B来说，是引用了整个A模块，当然也可以点对点引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将A模块修改为仅对B模块暴露, 其他模块引入A模块后将无法访问到cn.com.xiaocainiaoya.common.facade</span></span><br><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.facade to user_center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我在学习<code>jdk9</code>模块化时，这里有一个小插曲，我先引入了<code>hutool5.7.20</code>的依赖，然后通过<code>requires cn.hutool; </code>发现无法引入，而在<code>idea</code>的<code>pom.xml</code>有个小提示，提示我引入最新版本的<code>hutool</code>，所以我尝试引入<code>hutool5.8.18</code>后，发现<code>requires cn.hutool;</code>生效了，但是我又观察了一下，<code>hutool5.8.18</code>中并没有<code>module-info.class</code>文件，这个时候我就很疑惑了，对比观察了下，发现两者的<code>MANIFEST.MF</code>中存在一点差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hutool 5.7.20</span></span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Built-By: looll</span><br><span class="line">Created-By: Apache Maven <span class="number">3.8</span><span class="number">.1</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_261</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hutool 5.8.18</span></span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Implementation-Title: hutool-all</span><br><span class="line">Automatic-Module-Name: cn.hutool</span><br><span class="line">Implementation-Version: <span class="number">5.8</span><span class="number">.18</span></span><br><span class="line">Build-Timestamp: <span class="number">2023</span>-<span class="number">04</span>-16T15:<span class="number">40</span>:28Z</span><br><span class="line">Built-By: looll</span><br><span class="line">Build-OS: Windows <span class="number">11</span></span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Created-By: Maven JAR Plugin <span class="number">3.3</span><span class="number">.0</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_333</span></span><br></pre></td></tr></table></figure><p>到这你应该有所发现，在高版本中有一个参数<code>Automatic-Module-Name</code>，属性是用来为自动模块指定一个模块名称的。通过声明这个属性，就可以为没有显式模块信息的 JAR 文件赋予一个模块名称，使其成为一个合法的模块。</p><p>然后进入<code>git</code>看了下源码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Automatic-Module-Name</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">Automatic-Module-Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">index</span>&gt;</span>true<span class="tag">&lt;/<span class="name">index</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-OS</span>&gt;</span>$&#123;os.name&#125;<span class="tag">&lt;/<span class="name">Build-OS</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>$&#123;user.name&#125;<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-Jdk</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">Build-Jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-Timestamp</span>&gt;</span>$&#123;maven.build.timestamp&#125;<span class="tag">&lt;/<span class="name">Build-Timestamp</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--通过maven打包工具，将这个属性添加到MANIFEST.MF中--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Automatic-Module-Name</span>&gt;</span>$&#123;Automatic-Module-Name&#125;<span class="tag">&lt;/<span class="name">Automatic-Module-Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.开放更高访问权限，使用<code>open</code>关键字。</p><p>​    在模块化系统中，模块会隔离其内部的包，只有 <code>public</code> 修饰的包才能在模块外部访问。然而，有时候我们希望允许其他模块访问模块中的所有非 <code>public</code> 类型，而不用逐个包或类型地进行声明。这时可以使用 <code>open</code> 关键字来声明一个模块为 “开放模块”，这样其他模块就可以访问该模块中的所有非 <code>public</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用open只是为了提高访问权限, 改exports暴露的还是要暴露</span></span><br><span class="line"><span class="comment">// 整个模块open</span></span><br><span class="line">open <span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.entity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="comment">// 单独暴露这个包</span></span><br><span class="line">    opens cn.com.xiaocainiaoya.common.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>open</code>是运行时用于控制反射访问的权限，如果仅仅使用<code>open</code>声明，那么类是无法被引用到，也就是编译器都无法通过，所以还需要使用<code>exports</code>或者使用<code>require static</code>配合使用。</p><p>通过<code>open</code>引入模块后，使用反射操作是不需要<code>.setAccessible(true)</code>操作授权。</p><p>在<code>git</code>上看到一些<code>JDK9</code>的示例工程中出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.web &#123;</span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开放权限给spring的部分模块, 由于目前我还没有引入spirng, 可能是在spring中对其进行</span></span><br><span class="line">    <span class="comment">// 反射之类的操作, 这里先记录下, 日后若遇到问题, 再进行详细的记录。</span></span><br><span class="line">    opens pers.darren to spring.beans, spring.core, spring.context;</span><br><span class="line">    opens pers.darren.controller.role to spring.beans, spring.core, spring.web;</span><br><span class="line">    opens pers.darren.controller.user to spring.beans, spring.core, spring.web;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<code>uses</code> 和 <code>provides</code> 是模块化系统中用于服务（Service）的关键字。</p><p><code>uses</code> 关键字用于声明一个模块使用某个服务。服务是一种提供特定功能的接口或抽象类，它可以由一个或多个模块实现。通过 <code>uses</code> 关键字，我们可以在模块中声明对特定服务的依赖，以便在运行时获取该服务的实现。这样，模块就可以在不依赖具体实现类的情况下使用服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common模块: 在facade包下有一个FeeFacade接口，在service包下有一个FeeService实现</span></span><br><span class="line"><span class="keyword">module</span> xiaocainiao.common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.facade;</span><br><span class="line">    <span class="keyword">requires</span> transitive lombok;</span><br><span class="line"></span><br><span class="line">    provides cn.com.xiaocainiaoya.common.facade.FeeFacade with cn.com.xiaocainiaoya.common.service.FeeService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// userCenter模块, 通过uses可以使用ServiceLoader进行加载</span></span><br><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="comment">// 引入common模块</span></span><br><span class="line">    <span class="keyword">requires</span> xiaocainiao.common;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> lombok;</span><br><span class="line"></span><br><span class="line">    uses cn.com.xiaocainiaoya.common.facade.FeeFacade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>user-center</code>模块中使用<code>ServiceLoader</code>进行加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;FeeFacade&gt; moduleServices = ServiceLoader</span><br><span class="line">    .load(FeeFacade.class).stream()</span><br><span class="line">    .map(ServiceLoader.Provider::get)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>​    接上面的<code>open</code>关键字说到，看到一些实例工程中使用<code>open</code>将包的权限开放给<code>spring</code>中的部分模块。许多库依赖于反射来发挥它们的魔力，默认情况下，在<code>JDK9</code>中只能访问到暴露包中的公共类、方法和字段，即使通过反射来访问非公共成员并调用<code>setAccessible(true)</code>，<b>也是无法访问到。</b>只能通过<code>open</code>、<code>opens</code>、<code>opens..to</code>的方式授予运行时访问权限。</p><h3 id="3-模块路径"><a href="#3-模块路径" class="headerlink" title="3.模块路径"></a>3.模块路径</h3><p>​    模块是从<code>modulePath</code>加载的，就像<code>jdk8</code>及之前的<code>jdk</code>的类是从类路径加载。所以你一定知道什么是类路径地狱，有时可能会出现在本地环境中可以成功启动项目，在其他环境无法启动成功，这是由于<code>java</code>对引用类的解析规则为第一次遇见策略，所以未知的排序依赖关系，可能会出现一些未知的问题。</p><p>​    从<code>java9</code>开始，将进入另一种地狱：<code>modulepath</code>地狱。</p><p>模块路径是一系列的模块：以文件夹或者<code>JAR</code>方式呈现，如果模块是文件夹格式，则表示该模块是分解模块的格式；如果是<code>jar</code>则是模块化的<code>jar</code>.模块和模块描述符提供的可靠配置有助于消除许多此类运行时类路径问题。每个模块都显式地声明其依赖项，这些依赖项作为应用程序启动来解析。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDK9特性&quot;&gt;&lt;a href=&quot;#JDK9特性&quot; class=&quot;headerlink&quot; title=&quot;JDK9特性&quot;&gt;&lt;/a&gt;JDK9特性&lt;/h1&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Rancher入门（一）</title>
    <link href="http://xiaocainiaoya.github.io/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-06-12T13:51:58.000Z</published>
    <updated>2023-06-13T02:15:19.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rancher入门（一）"><a href="#Rancher入门（一）" class="headerlink" title="Rancher入门（一）"></a>Rancher入门（一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    公司内网的服务是通过<code>Rancher</code>进行编排，<code>Rancher</code>有<code>V1</code>和<code>V2</code>两个版本，都是提供容器调度与编排，在<code>V1</code>版本中可选不同的编排模式，比如<code>cattle</code>、<code>swarm</code>、<code>kubernetes</code>。所以<code>V1</code>时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于<code>k8s</code>后来发展势不可挡，所以<code>V2</code>版本诞生，移除了其他类型的编排工具，只剩下<code>k8s</code>，所以<code>Rancher</code>的底层是采用<code>k8s</code>编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个<code>k8s</code>集群等。</p><span id="more"></span><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>我这里是在<code>docker.hub</code>上搜索了一个<code>rancher/rancher</code>容器，直接在本机部署拉取这个容器。</p><blockquote><p>docker pull rancher/rancher</p></blockquote><p>启动这个容器：</p><blockquote><p> sudo docker run -d –restart=unless-stopped -p 80:80 -p 443:443 –privileged rancher/rancher</p></blockquote><ul><li><code>--restar</code>：表示指定容器的重启策略，可选值为<code>no</code>、<code>on-failure</code>、<code>always</code>、<code>unless-stopped</code><ul><li><code>no</code>：默认值，表示容器退出时，<code>docker</code>不自动重启容器</li><li><code>on-failure</code>：若容器的退出状态非0，则docker自动重启容器，还可以指定重启次数，若超过指定次数未能启动容器则放弃</li><li><code>always</code>：容器退出时总是重启</li><li><code>unless-stopped</code>：容器退出时总是重启，但不考虑<code>docker</code>守护进程启动时就已经停止的容器</li></ul></li><li><code>--privileged</code>：表示容器内的<code>root</code>拥有的权限，如果<code>=true</code>表示容器内的<code>root</code>拥有真正的<code>root</code>权限，否则容器内的<code>root</code>只是外部的一个普通用户权限，通过<code>--privileged</code>启动的容器，可以看到很多<code>host</code>宿主机上的设备，并且可以执行<code>mount</code>，甚至允许在这个容器中启动新的容器等等。(<code>rancher/rancher</code>这个镜像必须添加这个命令才可以启动)</li></ul><p>默认映射了<code>80</code>和<code>443</code>端口，通过<code>127.0.0.1:80</code>实际上是<code>127.0.0.1</code>就可以直接访问<code>rancher</code>。由于未使用授信证书，会有报警，忽略即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rancher入门（一）&quot;&gt;&lt;a href=&quot;#Rancher入门（一）&quot; class=&quot;headerlink&quot; title=&quot;Rancher入门（一）&quot;&gt;&lt;/a&gt;Rancher入门（一）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;​    公司内网的服务是通过&lt;code&gt;Rancher&lt;/code&gt;进行编排，&lt;code&gt;Rancher&lt;/code&gt;有&lt;code&gt;V1&lt;/code&gt;和&lt;code&gt;V2&lt;/code&gt;两个版本，都是提供容器调度与编排，在&lt;code&gt;V1&lt;/code&gt;版本中可选不同的编排模式，比如&lt;code&gt;cattle&lt;/code&gt;、&lt;code&gt;swarm&lt;/code&gt;、&lt;code&gt;kubernetes&lt;/code&gt;。所以&lt;code&gt;V1&lt;/code&gt;时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于&lt;code&gt;k8s&lt;/code&gt;后来发展势不可挡，所以&lt;code&gt;V2&lt;/code&gt;版本诞生，移除了其他类型的编排工具，只剩下&lt;code&gt;k8s&lt;/code&gt;，所以&lt;code&gt;Rancher&lt;/code&gt;的底层是采用&lt;code&gt;k8s&lt;/code&gt;编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个&lt;code&gt;k8s&lt;/code&gt;集群等。&lt;/p&gt;</summary>
    
    
    
    <category term="rancher" scheme="http://xiaocainiaoya.github.io/categories/rancher/"/>
    
    
    <category term="rancher" scheme="http://xiaocainiaoya.github.io/tags/rancher/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture任务编排</title>
    <link href="http://xiaocainiaoya.github.io/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/"/>
    <id>http://xiaocainiaoya.github.io/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/</id>
    <published>2023-06-02T13:51:58.000Z</published>
    <updated>2023-06-02T06:21:59.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture任务编排"><a href="#CompletableFuture任务编排" class="headerlink" title="CompletableFuture任务编排"></a>CompletableFuture任务编排</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    <code>CompletableFuture</code>是对<code>Future</code>的扩展，弥补了<code>Future</code>的局限性，同时又实现了对任务进行编排的能力。    </p><span id="more"></span><p>​    <code>CompletableFuture</code>实现于<code>Future</code>和<code>CompletionStage</code>，对于<code>Future</code>的扩展内容，都在<code>CompletionStage</code>接口中。在这个接口中定义了任务编排的方法，执行某个任务完成或者进行并行执行等操作的方法。</p><p><img src="https://s2.loli.net/2023/06/02/9GnaLSmQPoBFt3I.png" alt="CompletableFuture类图.png"></p><p>​    <code>CompletableFutrue</code>在对任务编排的基础上，结合<code>Futrue</code>的特性，做到可以将某个任务异步到其他线程执行，内部通过<code>Futrue</code>的阻塞相关接口来等待任务的完成，再执行编排的接下来任务。默认使用<code>ForkJoinPool</code>。</p><p><b>任务编排主要分为4大类</b></p><h3 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1.依赖关系"></a>1.依赖关系</h3><ul><li><code>thenApply()</code>：入参为以上一个任务的执行结果为入参的<code>Function</code>方法，也就是<code>thenApply()</code>中的<code>Function</code>方法的返回值是上一个任务执行结果的类型。</li><li><code>thenCompose()</code>：入参为以上一个任务的执行结果为<code>Function</code>方法的入参类型，以<code>CompletableFuture</code>为出参类型。也就是<code>thenCompose()</code>中的<code>Function</code>方法的返回值是<code>CompletableFuture</code>类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 结果转换，thenApply使用上一轮结果进行计算</span></span><br><span class="line">    <span class="comment">// thenApply 加不加async仅表示是否使用异步线程来完成任务(可指定线程池)</span></span><br><span class="line">    CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenApply(value -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenComposeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// thenCompose 与 thenApply 类似，但是thenCompose的返回值必须是CompletableFuture</span></span><br><span class="line">     <span class="comment">// thenCompose是将上一次计算的结果作为参数传进来，然后需要返回一个新的CompletableFuture</span></span><br><span class="line">     CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCompose(param -&gt; CompletableFuture.supplyAsync(() -&gt; param + <span class="string">&quot;d&quot;</span>));</span><br><span class="line">     System.out.println(result.join());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-合并关系"><a href="#2-合并关系" class="headerlink" title="2.合并关系"></a>2.合并关系</h3><p>合并A、B任务，当A、B任务完成之后执行C任务。</p><ul><li><code>thenCombine</code>：合并A、B任务，当A、B任务完成之后执行<code>thenCombine()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiFunction</code>方法，接收A、B任务的返回值作为入参，且有返回值。</li><li><code>thenAccepetBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>thenAccepetBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiConsumer</code>方法，接收A、B任务的返回值作为入参，且无返回值。</li><li><code>runAfterBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>runAfterBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>Runnable</code>，不接收参数，且无返回值。</li></ul><p>综上：其实三个方法的主要却别在于第二个参数所使用的的是<code>BiFunction</code>、<code>BiConsumer</code>、<code>Runnable</code>来控制是否需要接收前面任务的参数、是否需要有返回值。其他核心逻辑并无二至。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombineTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 联合</span></span><br><span class="line">     CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">1000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">         System.out.println(s1 + s2);</span><br><span class="line">         System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hij&quot;</span>;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.println(s1 + s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), () -&gt; &#123;</span><br><span class="line">        <span class="comment">//System.out.println(s1 + s2);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-并联关系"><a href="#3-并联关系" class="headerlink" title="3.并联关系"></a>3.并联关系</h3><p>A、B两个任务，只要有一个完成，就执行C任务。</p><ul><li><code>applyToEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>applyToEither()</code>的第二个参数是<code>Function</code>，表示使用前一个任务的返回值为入口参数，且有返回值。</li><li><code>acceptEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Consumer</code>，表示使用前一个任务的返回值为入口参数，无返回值。</li><li><code>runAfterEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Runnable</code>，表示AB任意一个任务完成后，就执行一个任务，这个任务无入参无返回值。</li></ul><p>综上：与<b>合并关系</b>其实差不多，三个方法上都是在对第二个函数式接口参数上做文章，主要为了用户在根据任务的参数需要和返回值需要选择特定的方法。</p><h3 id="4-并行关系"><a href="#4-并行关系" class="headerlink" title="4.并行关系"></a>4.并行关系</h3><p>多个任务时，多个任务都完成或者其中一个任务完成时，进行下一个任务的执行，返回的是新的<code>CompletableFuture</code>。</p><ul><li><code>allOf()</code>:当所有给定的<code>CompletableFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li><li><code>anyOf()</code>:当任何一个给定的<code>CompletablFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 只要有一个有结果就得到result, 但是存在一种情况，如果future1先完成，那么future2还是在执行，</span></span><br><span class="line">    <span class="comment">// 如果在future1执行完成后，future2执行完成前获取result的值，那么result的值就是future1的值</span></span><br><span class="line">    <span class="comment">// 获取值时如果都完成，那么由前往后取，也就是都完成的情况下，根据anyOf()方法参数定义的顺序获取。</span></span><br><span class="line">    CompletableFuture&lt;Object&gt; result = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 两个都完成了</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; result = CompletableFuture.allOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-结果处理"><a href="#5-结果处理" class="headerlink" title="5.结果处理"></a>5.结果处理</h3><p>当任务执行结束可以对任务执行的结果或者任务抛出的异常进行处理。</p><ul><li><p><code>whenComplete</code>:当任务完成时，将使用结果(或<code>null</code>)和此阶段的异常(或<code>null</code>)执行给定操作</p></li><li><p><code>exceptionally</code>:为了捕获任务中抛出的异常进行处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当某个任务完成之后，进行下一个任务</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="comment">// 上一个任务若有异常则这里的s=null, throwable=异常; 若正常执行完成则s=上一个任务的返回值, throwable=null</span></span><br><span class="line">    <span class="comment">// async表示使用可能会去使用其他线程如果使用同一线程池也可能被同一个线程执行</span></span><br><span class="line">    <span class="comment">// 不指定线程池的情况下使用的是ForkJoinPool.commonPool()</span></span><br><span class="line">    .whenComplete((s, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionallyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;).thenApply(result -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply接收到的参数 = &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常：&quot;</span> + throwable.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终返回的结果 = &quot;</span> + future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>​    在<code>CompletableFuture</code>中针对<b>每个方法</b>都定义了两个<code>xxxAsync</code>接口，以<code>whenComplete</code>方法为了，如下所示，两个<code>xxxAsync</code>接口的区别在于是否显示指定使用的线程池。如果不使用<code>xxxAsync</code>接口，则使用当前线程执行任务，如果使用<code>xxxAysnc</code>没有显示指定线程池，则使用默认的<code>ForkJoinPool</code>提供的线程池。但<code>ForkJoinPool</code>是公共线程池，如果所有的<code>CompletableFuture</code>都共享一个线程池，如果某一些任务执行较慢，会导致线程池中的所有线程阻塞，造成线程饥饿，从而影响整个系统的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在京东的开源框架<code>AsyncTool</code>，主要就是对<code>CompletableFuture</code>进行了组装和包装，使得任务的编排和回调在使用上变更更加方便。并对任务回调相关内容做了一个优化。比如在<code>CompletableFuture</code>中，如果你编排了多个任务，当前执行到那个任务，每一个任务的执行结果实际上是不知道的，只有等任务都执行完毕，最总汇总结果。<code>AysncTool</code>认为这种方式不是友好的，一个并行框架需要对每一步的执行有能进行监控，每一步无论执行成功与失败，都应该有一个回调，才算完整。比如在某些场景中，某些任务单元是需要被跳过不执行的，但是不执行的这个任务是不是也需要一个回调，进行类似于一些通知之类的动作？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CompletableFuture任务编排&quot;&gt;&lt;a href=&quot;#CompletableFuture任务编排&quot; class=&quot;headerlink&quot; title=&quot;CompletableFuture任务编排&quot;&gt;&lt;/a&gt;CompletableFuture任务编排&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;CompletableFuture&lt;/code&gt;是对&lt;code&gt;Future&lt;/code&gt;的扩展，弥补了&lt;code&gt;Future&lt;/code&gt;的局限性，同时又实现了对任务进行编排的能力。    &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>德鲁伊简单使用</title>
    <link href="http://xiaocainiaoya.github.io/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaocainiaoya.github.io/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-11T14:13:58.000Z</published>
    <updated>2023-05-12T09:14:30.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="德鲁伊简单使用"><a href="#德鲁伊简单使用" class="headerlink" title="德鲁伊简单使用"></a>德鲁伊简单使用</h1><p>​    在翻阅项目底层代码时发现，在底层的<code>framework</code>模块中有引入<code>druid</code>监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下<code>druid</code>的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。</p><span id="more"></span><p><b>注：我使用的版本是<code>1.1.22</code>，如果不是这版本请绕道，避免引起不适，不同版本中修改了部分配置的前缀！！</b></p><h2 id="启用德鲁伊管理页"><a href="#启用德鲁伊管理页" class="headerlink" title="启用德鲁伊管理页"></a>启用德鲁伊管理页</h2><p>1.根据配置项加载这个管理页<code>bean</code>。前缀为<code>my.druid.monitor.enable</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建德鲁伊数据源</span></span><br><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="title">druidServlet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-password:admin&#125;&quot;)</span> String password,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-username:admin&#125;&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.reset-enable:true&#125;&quot;)</span> String reset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.url-pattern:/druid/*&#125;&quot;)</span> String urlPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.allow:&#125;&quot;)</span> String allow,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.deny:&#125;&quot;)</span> String deny</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; reg = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">    reg.setServlet(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">    reg.addUrlMappings(urlPattern);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, reset);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, userName);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, password);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;allow&quot;</span>,deny );</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;deny&quot;</span>,allow);</span><br><span class="line">    <span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>yaml</code>或者<code>properties</code>配置文件中添加相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 忽略默认自动注入druid,避免走默认druid配置</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure</span></span><br><span class="line">  <span class="comment">#数据库连接池配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">        <span class="attr">allow:</span></span><br><span class="line">        <span class="attr">deny:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局druid参数，单独数据源配置为空取全局配置</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 声明默认的主数据源</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">druid:</span></span><br><span class="line">        <span class="comment"># 连接池的配置信息</span></span><br><span class="line">        <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">        <span class="attr">initial-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">        <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line">        <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">        <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">        <span class="attr">validation-query:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">        <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">        <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span></span><br></pre></td></tr></table></figure><p>到此在本地启动项目，访问<code>http://127.0.0.1:8064/xxxx/druid/login.html</code>进入管理页，登录之后，虽然进入了管理页，但是其实只是一个空壳，执行对应的<code>SQL</code>发现，并不会在监控页面上显示出来，后经过查询资料发现，这里的<code>filter</code>为空。</p><p><img src="https://s2.loli.net/2023/05/12/YQLoPJjbdrHqm3W.png" alt="druid中filter为空.png"></p><p>在配置文件中明明在<code>spring.datasource.druid.filters</code>设置了<code>stat,wall</code>等过滤器，但是实际上没有读到，排查发现，在<code>1.1.22</code>上，并不是这个配置，修改了配置前缀为<code>spring.datasource.druid.filter.stat.enabled</code></p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(FILTER_STAT_PREFIX)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = FILTER_STAT_PREFIX, name = &quot;enabled&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatFilter <span class="title">statFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 主要是为了创建这个filter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置后，在启动项目，在管理页上就显示出了执行的<code>SQL</code>语句。</p><h2 id="开发环境启用"><a href="#开发环境启用" class="headerlink" title="开发环境启用"></a>开发环境启用</h2><p>​    本以为到这里基本上已经万事大吉了，开发环境只需要复刻本地环境的配置即可。但是操作之后发现，在开发环境上访问<code>login.html</code>之后原本应该跳转到<code>druid/index.html</code>，但是<code>404</code>，看样子是<code>nginx</code>拦截处理了。</p><p>​    在<code>nginx</code>中，对于<code>/index.html</code>的路径直接转发到本地的某个文件夹中，所以修改<code>nginx.conf</code>相关配置信息，是的对<code>/druid/index.html</code>不进行这个拦截处理。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ (?!.*druid/index.html$).*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启<code>nginx</code>之后，发现还是有问题，观察发送的请求，在<code>login.html</code>提交表单之后，发起了一个<code>submitLogin</code>请求，如果用户名密码校验正确，会直接跳转到<code>druid/index.html</code>，但是这个<code>druid/index.html</code>的请求居然进行了<code>302</code>跳转，又跳回<code>druid/login.html</code>页面。通过和本地的工程发起的请求对比发现，在<code>submitLogin</code>登录之后会返回一个<code>JSESSIONID</code>的<code>cookies</code>，发起<code>druid/index.html</code>请求需要携带这个<code>cookies</code>值，但是在开发环境中不知道是<code>nginx</code>还是哪里给弄丢了，由于时间紧迫我没有细看在那个环节丢调了这个<code>cookies</code>值，我手动将这个<code>cookies</code>值打入浏览器的<code>cookies</code>中，正常访问。</p><h2 id="关闭广告"><a href="#关闭广告" class="headerlink" title="关闭广告"></a>关闭广告</h2><p>​    在开源项目若依中看到，感觉挺好玩的，便记录一下，用过<code>druid</code>管理页都知道，在面板的最下方有一个阿里的横幅广告，这个广告是请求服务器的<code>common.js</code>中会添加到页脚，请求公网的<code>banner</code>连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildFooter : function() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;&lt;a href=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner_click&quot; target=&quot;new&quot;&gt;&lt;img src=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner&quot;&gt;&lt;/a&gt;&lt;br/&gt;&#x27;</span> +</span><br><span class="line">              <span class="string">&#x27; powered by &lt;a href=&quot;https://github.com/alibaba/&quot; target=&quot;_blank&quot;&gt;Alibaba&lt;/a&gt; &amp; sandzhang &amp; &lt;a href=&quot;http://melin.iteye.com/&quot; target=&quot;_blank&quot;&gt;melin&lt;/a&gt; &amp; &lt;a href=&quot;https://github.com/shrekwang&quot; target=&quot;_blank&quot;&gt;shrek.wang&lt;/a&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br><span class="line">    $(document.body).append(html);</span><br></pre></td></tr></table></figure><p>​    所以思路上，通过对获取<code>common.js</code>进行拦截，并将这段页脚的<code>html</code>代码重写，即可达到关闭广告的目的。</p><p>1.设置一个过滤器，对<code>js/common.js</code>的请求进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DruidAdRemoveFilter 过滤器，过滤 common.js 的广告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; <span class="title">druidAdRemoveFilterFilter</span><span class="params">(DruidStatProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 druid web 监控页面的参数</span></span><br><span class="line">        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();</span><br><span class="line">        <span class="comment">// 提取 common.js 的配置路径</span></span><br><span class="line">        String pattern = config.getUrlPattern() != <span class="keyword">null</span> ? config.getUrlPattern() : <span class="string">&quot;/druid/*&quot;</span>;</span><br><span class="line">        String commonJsPattern = pattern.replaceAll(<span class="string">&quot;\\*&quot;</span>, <span class="string">&quot;js/common.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 DruidAdRemoveFilter Bean</span></span><br><span class="line">        FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; registrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> DruidAdRemoveFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.拦截过滤器中替换这段<code>html</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidAdRemoveFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * common.js 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_JS_ILE_PATH = <span class="string">&quot;support/http/resources/js/common.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="comment">// 重置缓冲区，响应头不会被重置</span></span><br><span class="line">        response.resetBuffer();</span><br><span class="line">        <span class="comment">// 获取 common.js</span></span><br><span class="line">        String text = Utils.readFromResource(COMMON_JS_ILE_PATH);</span><br><span class="line">        <span class="comment">// 正则替换 banner, 除去底部的广告信息</span></span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;&lt;a.*?banner\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;powered.*?shrek.wang&lt;/a&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        response.getWriter().write(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>替换之后的<code>html</code>变量值为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;&#x27;</span> +</span><br><span class="line">                      <span class="string">&#x27; &#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;德鲁伊简单使用&quot;&gt;&lt;a href=&quot;#德鲁伊简单使用&quot; class=&quot;headerlink&quot; title=&quot;德鲁伊简单使用&quot;&gt;&lt;/a&gt;德鲁伊简单使用&lt;/h1&gt;&lt;p&gt;​    在翻阅项目底层代码时发现，在底层的&lt;code&gt;framework&lt;/code&gt;模块中有引入&lt;code&gt;druid&lt;/code&gt;监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下&lt;code&gt;druid&lt;/code&gt;的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
    <category term="druid" scheme="http://xiaocainiaoya.github.io/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>redis序列化配置</title>
    <link href="http://xiaocainiaoya.github.io/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://xiaocainiaoya.github.io/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-05T12:50:58.000Z</published>
    <updated>2023-10-09T07:53:52.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis序列化配置"><a href="#redis序列化配置" class="headerlink" title="redis序列化配置"></a>redis序列化配置</h1><blockquote><p>使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。</p></blockquote><span id="more"></span><h2 id="模板类RedisTemplate"><a href="#模板类RedisTemplate" class="headerlink" title="模板类RedisTemplate"></a>模板类RedisTemplate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplate</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">RedisAccessor</span> <span class="keyword">implements</span> <span class="title">RedisOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enableTransactionSupport = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> exposeConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enableDefaultSerializer = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> ClassLoader classLoader;</span><br><span class="line">    <span class="comment">//序列化器</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> RedisSerializer&lt;String&gt; stringSerializer = RedisSerializer.string();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> ScriptExecutor&lt;K&gt; scriptExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用数据结构操作类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValueOperations&lt;K, V&gt; valueOps = <span class="keyword">new</span> DefaultValueOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListOperations&lt;K, V&gt; listOps = <span class="keyword">new</span> DefaultListOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SetOperations&lt;K, V&gt; setOps = <span class="keyword">new</span> DefaultSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamOperations&lt;K, ?, ?&gt; streamOps = <span class="keyword">new</span> DefaultStreamOperations&lt;&gt;(<span class="keyword">this</span>,</span><br><span class="line">            ObjectHashMapper.getSharedInstance());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZSetOperations&lt;K, V&gt; zSetOps = <span class="keyword">new</span> DefaultZSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GeoOperations&lt;K, V&gt; geoOps = <span class="keyword">new</span> DefaultGeoOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HyperLogLogOperations&lt;K, V&gt; hllOps = <span class="keyword">new</span> DefaultHyperLogLogOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterOperations&lt;K, V&gt; clusterOps = <span class="keyword">new</span> DefaultClusterOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有5个序列化器：</p><ul><li><code>keySerializer</code>：对存入<code>redis</code>中的<code>key</code>的序列化器</li><li><code>valueSerializer</code>：对存入<code>redis</code>中的<code>value</code>的序列化器</li><li><code>hashKeySerializer</code>：对以<code>hash</code>结构数据存入的<code>hashkey</code>序列化器</li><li><code>hashValueSerializer</code>：对以<code>hash</code>结构数据存入的<code>hashvalue</code>序列化器</li><li><code>stringSerializer</code>：字符串方式序列化器</li></ul><p>序列化器具体的实现：</p><ol><li><code>FastJsonRedisSerializer</code>由阿里巴巴的<code>fastjson</code>提供的转为<code>JSON</code>格式进行序列化。</li><li><code>Jackson2JsonRedisSerializer</code>在<code>spring</code>中已经集成，采用<code>Jackson</code>的方式转换为<code>JSON</code>格式进行序列化。</li><li><code>JdkSerializationRedisSerializer</code>jdk默认提供的序列化方式，如果是<code>POJO</code>需要实现<code>Serializable</code>接口。</li><li><code>StringRedisSerializer</code>字符方式序列化，如果是<code>POJO</code>，相当于调用了<code>toString</code>进行序列化。</li></ol><p><b>默认情况下使用的是<code>jdk</code>方式进行键和值的序列化，如果需要修改默认方式，在接入<code>spring</code>的情况下需要设置这些序列化器之后添加到<code>spring</code>容器中。你可以仅仅修改你想要修改的序列化器，其他的保持默认，模板类提供了一个后置接口。</b></p><p>它会逐个进行判断处理，如果某个序列化器为空，则设置对应的默认序列化器。所以一般在设置完成之后会调用一次这个后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</span><br><span class="line">                classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableDefaultSerializer) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            keySerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            valueSerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hashKeySerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hashValueSerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h2><p>对<code>RedisTemplate</code>进行配置，设置<code>value</code>的序列化器为<code>jdk</code>提供的序列化器，<b><code>POJO</code>需要实现<code>Serializable</code>接口。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用jdk序列化方式进行序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式进行序列化之后，在<code>redis-cli</code>上查看时，默认获取的值会被转换为<b>十六进制</b>，导致在排查问题时可读性较差。</p><blockquote><p>\xAC\xED\x00\x05sr\x00\x1Ecn.com.xiaocainiaoya.vo.Person\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x04L\x00\x03aget\x00\x13Ljava/lang/Integer;L\x00\x06housest\x00\x10Ljava/util/List;L\x00\x08passwordt\x00\x12Ljava/lang/String;L\x00\x08userNameq\x00<del>\x00\x03xpsr\x00\x11java.lang.Integer\x12\xE2\xA0\xA4\xF7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xAC\x95\x1D\x0B\x94\xE0\x8B\x02\x00\x00xp\x00\x00\x00\x0Csr\x00\x13java.util.ArrayListx\x81\xD2\x1D\x99\xC7a\x9D\x03\x00\x01I\x00\x04sizexp\x00\x00\x00\x01w\x04\x00\x00\x00\x01sr\x00\x1Dcn.com.xiaocainiaoya.vo.House\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x02L\x00\x07addressq\x00</del>\x00\x03L\x00\x04areat\x00\x16Ljava/math/BigDecimal;xpt\x00\x06\xE5\x8C\x97\xE4\xBA\xACsr\x00\x14java.math.BigDecimalT\xC7\x15W\xF9\x81(O\x03\x00\x02I\x00\x05scaleL\x00\x06intValt\x00\x16Ljava/math/BigInteger;xq\x00<del>\x00\x06\x00\x00\x00\x01sr\x00\x14java.math.BigInteger\x8C\xFC\x9F\x1F\xA9;\xFB\x1D\x03\x00\x06I\x00\x08bitCountI\x00\x09bitLengthI\x00\x13firstNonzeroByteNumI\x00\x0ClowestSetBitI\x00\x06signum[\x00\x09magnitudet\x00\x02[Bxq\x00</del>\x00\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFE\x00\x00\x00\x01ur\x00\x02[B\xAC\xF3\x17\xF8\x06\x08T\xE0\x02\x00\x00xp\x00\x00\x00\x02\x03\xE9xxxt\x00\x03123t\x00\x03tom</p></blockquote><p>根据比对调用反序列化时的二进制流，发现这一串乱码中“\xAC”表示的十六进制，“\x05sr”中的“\x05”表示一个十六进制，“sr”需要按位解析为二进制，按这个逻辑进行解析之后，得到的结果就是反序列化字节流，所以根据这个逻辑就可以简单通过一段代码将这串乱码反序列化为原始对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String value = <span class="string">&quot;\\xAC\\xED\\x00\\x05t\\x00\\x18Pj/1x/ZLXkvm0q6bNZiOYw==&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] hexValues = value.split(<span class="string">&quot;\\\\x&quot;</span>);</span><br><span class="line">    <span class="comment">// 结果字节流长度，适当调整长度，如果类过大，可能长度不够会报数组长度越界</span></span><br><span class="line">    <span class="keyword">byte</span>[] resultValue = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> resultIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hexValues.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 切割之后可能出现首个或者末个是空串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isEmpty(hexValues[i]))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// AC/ED/00等表示为单个十六进制</span></span><br><span class="line">        <span class="keyword">if</span>(hexValues[i].length() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(hexValues[i], <span class="number">16</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 05t等认为前两位为十六进制，后面按字符逐个转换为字节</span></span><br><span class="line">            String str = hexValues[i];</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(str.substring(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 后面的按字符转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; str.length(); j++)&#123;</span><br><span class="line">                resultValue[resultIndex++] = (<span class="keyword">byte</span>) str.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对转换的字节流进行反序列化解析为对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> JdkSerializationRedisSerializer().deserialize(resultValue);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在排查问题时，可以尝试使用这种方式对乱码串进行解析，得到原始对象。(<b>前提是你的工程存在这个类！！</b>)</p><h2 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h2><p>字符序列化器，一般对于存入的<code>key</code>和非<code>POJO</code>都会采用这种方式进行序列化，在<code>redis-cli</code>上也能直观的看到对应的键和值是什么。</p><p>在<code>Spring</code>中已经提供了对键和值都采用字符序列化器的方式进行操作的模板类<code>StringRedisTemplate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setKeySerializer(RedisSerializer.string());</span><br><span class="line">        setValueSerializer(RedisSerializer.string());</span><br><span class="line">        setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RedisSerializer&lt;String&gt; <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringRedisSerializer.UTF_8;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置为编码为UTF-8的字符序列化器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer UTF_8 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jackson2JsonRedisSerializer"><a href="#Jackson2JsonRedisSerializer" class="headerlink" title="Jackson2JsonRedisSerializer"></a>Jackson2JsonRedisSerializer</h2><p><code>jackson</code>机制进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>jackson</code>方式进行序列化之后的值，如下所示，对于复杂对象会表示它的类型，这种存储方式会导致占用的序列化串长度过长，占用一定的存储空间。</p><blockquote><p>[“cn.com.xiaocainiaoya.vo.Person”,{“userName”:”tom”,”password”:”123”,”age”:12,”houses”:[“java.util.ArrayList”,[[“cn.com.xiaocainiaoya.vo.House”,{“address”:”北京”,”area”:[“java.math.BigDecimal”,100.1]}]]]}]</p></blockquote><h2 id="FastJsonRedisSerializer"><a href="#FastJsonRedisSerializer" class="headerlink" title="FastJsonRedisSerializer"></a>FastJsonRedisSerializer</h2><p>阿里巴巴提供的<code>fastjson</code>序列化器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer = <span class="keyword">new</span> FastJsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        <span class="comment">// 全局开启AutoType，不建议使用</span></span><br><span class="line">        <span class="comment">// ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span></span><br><span class="line">        <span class="comment">// 建议使用这种方式，小范围指定白名单</span></span><br><span class="line">        <span class="comment">//ParserConfig.getGlobalInstance().addAccept(&quot;cn.com.xiaocainiao&quot;);</span></span><br><span class="line">        template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式生成的<code>JSON</code>串结果如下所示，对比<code>jackson</code>序列化器生成的结果串，发现复杂对象的所在类不会生成，减少一定的空间占用。</p><blockquote><p>{“age”:12,”houses”:[{“address”:”北京”,”area”:100.1}],”password”:”123”,”userName”:”tom”}</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis序列化配置&quot;&gt;&lt;a href=&quot;#redis序列化配置&quot; class=&quot;headerlink&quot; title=&quot;redis序列化配置&quot;&gt;&lt;/a&gt;redis序列化配置&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot部分功能浅析</title>
    <link href="http://xiaocainiaoya.github.io/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/</id>
    <published>2023-04-26T14:51:58.000Z</published>
    <updated>2023-10-09T07:54:42.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot部分功能浅析"><a href="#springboot部分功能浅析" class="headerlink" title="springboot部分功能浅析"></a>springboot部分功能浅析</h1><span id="more"></span><h2 id="1-绑定器"><a href="#1-绑定器" class="headerlink" title="1.绑定器"></a>1.绑定器</h2><p><code>org.springframework.boot.context.properties.bind.Binder</code>是<code>springboot</code>从<code>environment</code>对象中获取配置信息的绑定器，可以很方便的就获取到对应的配置值信息。</p><p>1.创建配置类(必须要提供<code>set</code>方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DtpProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.配置文件中的配置项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.dynamic.enabledBanner</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.dynamic.apollo.namespace</span>=<span class="string">aaa</span></span><br></pre></td></tr></table></figure><p>2.通过<code>Binder</code>获取配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binder.get(environment).bind(<span class="string">&quot;spring.dynamic&quot;</span>, Bindable.ofInstance(dtpProperties));</span><br></pre></td></tr></table></figure><h2 id="2-Import引入"><a href="#2-Import引入" class="headerlink" title="2.@Import引入"></a>2.@Import引入</h2><p>通过<code>@Import</code>引入将某些配置类或者扩展点接口添加到容器中。</p><p><b>示例：</b></p><p>1.创建一个注解<code>EnableMyConfig</code>，该注解使用<code>@Import</code>标记，并添加<code>MyConfigurationSelector.class</code>，这个类实现了<code>ImportSelector</code>顶层接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MyConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现<code>DeferredImportSelector#selectImports</code>接口，那么在<code>Spring</code>加载到这个引入类<code>MyConfigurationSelector</code>时就会将<code>MyBeanDefinitionRegistrar</code>类添加到<code>Spring</code>容器中，作用等同于为<code>MyBeanDefinitionRegistrar</code>添加<code>@Component</code>等自动注入注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;MyBeanDefinitionRegistrar.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.这个引入类一般以注册类居多，如果是配置类一般通过<code>@Component</code>或者<code>@Configuration</code>等注解就可自动注入，我这里的示例是一个注册类。实现于<code>ImportBeanDefinitionRegistrar</code>接口，<code>MyBeanDefinitionRegistrar</code>这个<code>spring</code>生命周期中会执行到<code>registerBeanDefinitions</code>，即为<code>MyProperties</code>类创建<code>BeanDefinition</code>对象，并将这个对象注入到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BeanDefinition对象构建器</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(DtpProperties.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注入属性键和属性值</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;enabledBanner&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里手动注册bean对象</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myProperties&quot;</span>, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：<code>@EnableMyConfig</code>注解需要标记到某个类上，且这个类在扫描范围之内才会生效，我曾经深深陷入于这个注解已经是在扫描范围之内，为什么需要标记到某个类上，扫描到这个注解后这个注解不是被<code>@Import</code>标记吗，难道不能直接获取到<code>@Import</code>中的值。实际上还是需要通过标记的这个类上拥有<code>@Component</code>等自动注入的注解。</b></p><p>整个过程大致为：由<code>Spring</code>容器MapperScan入口<code>refresh</code>方法 &rArr;执行容器中实现<code>BeanDefinitionRegistryPostProcessor</code>的<code>bean</code>对象&rArr;<code>ConfigurationClassPostProcessor</code>是对<code>BeanDefinitionRegistryPostProcessor</code>的实现，主要处理逻辑在这个类中。&rArr;之后会执行实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>，也就是这时会执行<code>MyBeanDefinitionRegistrar</code>这个自定义类，在这个自定义类中又注册了新的<code>BeanDefinition</code>&rArr;之后<code>Spring</code>容器会创建这个<code>Bean</code>对象。</p><p>综上：从<code>Spring</code>容器的角度来说，<code>MyBeanDefinitionRegistrar</code>是在<code>ConfigurationClassPostProcessor</code>执行时加载的，<code>MyProperties</code>是在<code>MyBeanDefinitionRegistrar</code>加载之后加载。</p><p>​    目前在<code>Spring</code>的生态中一般都是通过<code>@EnableXX</code>注解标记<code>@Import</code>注解来引入某些配置的方式，进行动态的引入某些配置类。比如<code>EnableScheduling</code>，只有将这个注解标记在扫描配置类之上，才会通过<code>@Import</code>引入配置<code>SchedulingConfiguration</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Import</code>也可以配合<code>ImportSelector</code>实现类，进行动态创建类。比如<code>MapperScan</code>。在<code>MapperScannerRegistrar</code>中动态的创建 <code>MapperScannerConfigurer</code>对象并注册到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置类加载"><a href="#3-配置类加载" class="headerlink" title="3.配置类加载"></a>3.配置类加载</h2><p><code>EnableConfigurationProperties</code>注解配合<code>ConfigurationProperties</code>注解进行使用。</p><p>假设说创建了一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个类没有标记<code>@Configuration</code>注解，那么这个容器中不会有这个类的<code>Bean</code>对象。</p><p>所以将此配置类添加到容器中有两种方式，一种是直接添加注入容器注解<code>@Configuration</code>。第二种是通过<code>@EnableConfigurationProperties</code>注解指向这个配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRegistry <span class="title">myRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当加载<code>DtpBaseBeanConfiguration</code>这个类时，会读取到<code>EnableConfigurationProperties</code>注解，这里又是一个<code>@Import</code>的应用，引入了<code>EnableConfigurationPropertiesRegistrar</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnableConfigurationPropertiesRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        registerInfrastructureBeans(registry);</span><br><span class="line">        registerMethodValidationExcludeFilter(registry);</span><br><span class="line">        ConfigurationPropertiesBeanRegistrar beanRegistrar = <span class="keyword">new</span> ConfigurationPropertiesBeanRegistrar(registry);</span><br><span class="line">        <span class="comment">// 获取到指向的配置类(这里是MyProperties),这里会将MyProperties转换为</span></span><br><span class="line">        <span class="comment">// BeanDefinition对象注册到容器中, 等到根据BeanDefinition创建具体的bean</span></span><br><span class="line">        <span class="comment">// 对象的时候，会读取到ConfigurationProperties注解进行配置属性值的绑定</span></span><br><span class="line">        getTypes(metadata).forEach(beanRegistrar::register);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：这个<code>EnableConfigurationProperties</code>注解的作用仅仅是将某个配置类转换为<code>BeanDefinition</code>注册到<code>Spring</code>容器中，结合<code>@ConditionXXX</code>可以减少无用<code>bean</code>对象的创建。</b></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot部分功能浅析&quot;&gt;&lt;a href=&quot;#springboot部分功能浅析&quot; class=&quot;headerlink&quot; title=&quot;springboot部分功能浅析&quot;&gt;&lt;/a&gt;springboot部分功能浅析&lt;/h1&gt;</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>springboot的Spi机制</title>
    <link href="http://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/</id>
    <published>2023-04-10T14:51:58.000Z</published>
    <updated>2023-10-09T07:56:43.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot的Spi机制"><a href="#springboot的Spi机制" class="headerlink" title="springboot的Spi机制"></a>springboot的Spi机制</h1><p>​    在与<code>Springboot</code>打交道的过程中，应该大家对<code>starter</code>都不会陌生，<code>springboot</code>中的各种<code>starter</code>其实就是利用了<code>springboot</code>的<code>SPI</code>机制。</p><span id="more"></span><p>​    在<code>springboot</code>中，会默认扫描<code>Applicatoin</code>启用类及其子包里面的配置类<code>Bean</code>(比如标记<code>@Configuration</code>，<code>@Component</code>，<code>@Server</code>等)然后进行初始化，那么如果你是为别人提供二方包，三方包的库，如果你的需要加载的类路径跟他的不一样，那么根据<code>Springboot</code>的<code>bean</code>加载机制是不会加载到的。</p><p><b>主工程：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── Application.java</span><br></pre></td></tr></table></figure><p><b>二方库A：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure><p><b>二方库B：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure><p>这时只有<b>二方库A</b>可以正确加载<code>MybatisXmlReloadConfig</code>这个<code>bean</code>，因为它的路径在<b>主工程</b>的<code>Application</code>的包以及子包下，那么就出现所有的二方库、三方库都需要与主工程的类路径一致？</p><p>这里<code>Springboot</code>就提供了<code>Spi</code>的机制用来获取二方库，三方库中需要加载的<code>Bean</code>对象。</p><p><code>注意</code>：一定要确保二方库、三方库的类路径不在主工程<code>Application</code>下的情况，在考虑<code>SPI</code>逻辑，我之前就掉入一个陷阱，因为我的二方库的类路径与主工程一致，但是那个时候我的<code>spring.factories</code>指向的路径是错的，导致一度怀疑自己理解的<code>SPI</code>有出入。</p><p><b>二方库、三方库类路径与主工程启动类路径不一致的情况下！！！(再次强调！)</b>如果使得主工程可以加载到对应库中的<code>bean</code>对象。</p><ol><li><p>创建<code>META-INF/spring.factories</code>文件。这个文件中是<code>k-v</code>的结构，一个<code>key</code>对应多个逗号分隔的<code>value</code>。对于这个文件来说，可以配置的<code>key</code>有很多，比如有<code>EnableAutoConfiguration</code>，<code>ApplicationContextInitializer</code>，<code>ApplicationListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li><li><p>在主工程启动时，会加载<code>META-INF/spring.factories</code>文件，对这个文件内指向的<code>bean</code>对象进行逐个加载。</p></li></ol><p>主要源码在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：在<code>Springboot2.7</code>之后引入了新的<code>SPI</code>配置方式。</b></p><ol><li><p>创建<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件。这个文件的文件名是固定，文件内容是<code>value</code>，各个<code>value</code>之间通过回车分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.bosssoft.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li></ol><p>主要源码同样是在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中进行了兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 兼容</span></span><br><span class="line">    ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="@AutoConfiguration"></a>@AutoConfiguration</h3><p>​    在<code>Springboot</code>中可以直接使用<code>@AutoConfiguration</code>来启用<code>SPI</code>机制，这是一个组合注解，通过<code>@AliasFor</code>注解将值传递给<code>@Configuration</code>、<code>@AutoConfigureBefore</code>、<code>@AutoConfigureAfter</code>三个注解。</p><p><b>注：使用这个注解需要配合<code>META-INF/spring</code>中设置<code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件中配置全限定类名。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureBefore.class, attribute = &quot;value&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureBefore.class, attribute = &quot;name&quot;)</span></span><br><span class="line">    String[] beforeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureAfter.class, attribute = &quot;value&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureAfter.class, attribute = &quot;name&quot;)</span></span><br><span class="line">    String[] afterName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cn.com.xiaocainiaoya.config.MyAutoConfiguration</span></span><br></pre></td></tr></table></figure><p><b>注：我之前进入一个误区，以为组合注解标记在某个类上就表明这个类拥有组合注解中的相关能力，其实这是错误的。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AutoConfiguration测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaocainiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/10 10:11:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AutoConfiguration()</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">house</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> House();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里我创建了类<code>MyAutoConfiguration</code>，标记了<code>@AutoConfiguration</code>注解，虽然这个注解是组合注解，也就是说实际上这个类也被<code>@AutoConfiguration</code>注解中的<code>@Configuration</code>标记，但是启动之后发现，在没有写<code>META-INF/spring</code>文件的情况下是不会加载，所以这里要解释一下，注解仅仅是标记了某个类，注解要起到什么作用取决于获取这个注解的动作的代码逻辑是如何。换句话说，标记了<code>@AutoConfiguration</code>实际上是可以具备<code>@Configuration</code>能力(不写<code>META-INF/spring</code>文件就可以被加载到容器中)，但是获取这个注解的处理端可以选择不赋予这种能力。<b>感觉还是没有说情况，文字表述不能很清楚的表达，上代码！</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当扫描到MyAutoConfiguration类需要进行容器化处理时肯定是需要进入某个处理器来进行处理</span></span><br><span class="line"><span class="comment">// 通过类对象来获取到对应标记的注解(这时其实只获取到@AutoConfiguration)</span></span><br><span class="line">Annotation[] annotations = MyAutoConfiguration.class.getAnnotations();</span><br><span class="line"><span class="comment">// 1.如果我的处理代码，仅仅是判断这个annotations中存不存在@Configuration来进行容器化，那么这个类就不会进行容器化。</span></span><br><span class="line"><span class="comment">// 2.如果我的处理代码，是如下代码，获取到当前类上的注解之后，逐个获取对应的组合注解中是否存在Configuration注解，再进行对应的处理，那么这个注解就会具备@Configuration的能力</span></span><br><span class="line"><span class="comment">// 所以在使用组合注解的情况下，主要是看处理注解的地方的判断方式，而不是组合注解上是否存在某注解！！</span></span><br><span class="line">Annotation[] annotations = MyAutoConfiguration.class.getAnnotations();</span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    Configuration configuration = annotation.annotationType().getAnnotation(Configuration.class);</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtils.isNotEmpty(configuration))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hutool中有提供方法可以快速获取组合注解中的注解</span></span><br><span class="line">Configuration[] candidates = AnnotationUtil.getCombinationAnnotations(field, Configuration.class);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springboot的Spi机制&quot;&gt;&lt;a href=&quot;#springboot的Spi机制&quot; class=&quot;headerlink&quot; title=&quot;springboot的Spi机制&quot;&gt;&lt;/a&gt;springboot的Spi机制&lt;/h1&gt;&lt;p&gt;​    在与&lt;code&gt;Springboot&lt;/code&gt;打交道的过程中，应该大家对&lt;code&gt;starter&lt;/code&gt;都不会陌生，&lt;code&gt;springboot&lt;/code&gt;中的各种&lt;code&gt;starter&lt;/code&gt;其实就是利用了&lt;code&gt;springboot&lt;/code&gt;的&lt;code&gt;SPI&lt;/code&gt;机制。&lt;/p&gt;</summary>
    
    
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/categories/springboot/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用zip4j打包文件</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/</id>
    <published>2023-03-24T13:51:58.000Z</published>
    <updated>2023-03-27T09:37:54.099Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近接到需求需要为打包后的<code>zip</code>文件设置压缩密码，而我们之前使用的<code>ZipOutputStream</code>结合<code>hutool</code>的<code>NoiUtil</code>进行打包生成<code>zip</code>文件，但是<code>ZipOutputStream</code>没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问<code>chatGPT</code>)，它的回答是<code>Zip4j</code>。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Zip4j</code>是一个用于处理<code>ZIP</code>文件格式的<code>Java</code>库，它提供了一个易于使用的<code>API</code>，可以方便地创建、提取和修改<code>ZIP</code>文件，以及支持密码保护的ZIP文件。</p><p><code>Zip4j</code>的主要特点包括：</p><ol><li>支持标准<code>ZIP</code>文件格式以及<code>ZIP64</code>扩展格式，可以处理包含数百万文件的<code>ZIP</code>文件。</li><li>支持密码保护的<code>ZIP</code>文件，包括标准密码和<code>AES</code>加密密码。</li><li>支持<code>ZIP</code>文件的分卷（spanned）和自解压缩（self-extracting）功能。</li><li>支持<code>ZIP</code>文件的压缩级别、注释和<code>UTF-8</code>编码文件名等属性的设置。</li><li>提供了方便的<code>API</code>，可以方便地添加、提取和修改<code>ZIP</code>文件中的文件和文件夹，以及获取<code>ZIP</code>文件中的文件列表和属性信息。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我使用的是<code>2.1.6</code>版本，新版本对旧版本中的一些常量和接口有调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstDemo</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    List&lt;File&gt; fileToAdds = Arrays.asList(file1, file2);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    zipFile.addFiles(fileToAdds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    String filePath1 = <span class="string">&quot;/xxx/demo1.txt&quot;</span>;</span><br><span class="line">    String filePath2 = <span class="string">&quot;/xxx/demo2.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(filePath1);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(filePath2);</span><br><span class="line"></span><br><span class="line">    ZipDemo zipDemo = <span class="keyword">new</span> ZipDemo();</span><br><span class="line">    zipDemo.firstDemo(file1, file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>fileToAdds</code>列表打包为目标地址为<code>/xxx/result.zip</code>的压缩文件。这种写法是最简单的打包方式，将需要打包的源文件都打包在目标<code>zip</code>文件的顶层目录下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├─────── demo1.txt</span><br><span class="line">  └─────── demo2.txt</span><br></pre></td></tr></table></figure><p>但是有时候，甚至大部分时候都是需要将打包源文件进行分级(压缩包内文件夹)的方式进行打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├───── dir1</span><br><span class="line">  │       └─ demo1.txt</span><br><span class="line">  └───── demo2.txt</span><br></pre></td></tr></table></figure><p><b>1.设置目标<code>zip</code>文件内文件夹结构示例代码：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customInnerFilePath</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化压缩参数</span></span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 将设置的压缩参数作用在某个文件上</span></span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置文件夹加密：</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptZip</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line">    zipParameters.setEncryptFiles(<span class="keyword">true</span>);</span><br><span class="line">    zipParameters.setEncryptionMethod(EncryptionMethod.AES);</span><br><span class="line">    zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>注意：</b>上述代码中仅仅是对<code>file1</code>设置了<code>zipParameters</code>参数，也就是说现在有两个被打包文件，但是压缩参数只设置到了其中的一个文件上，打开压缩后的文件会发现，是需要解压密码才能解压，但是如果你有一些不需要解压可以查看<code>zip</code>包内部情况的工具可以发现，可以<code>file2</code>所对应的文件是无需密码就可以查看，也就是说，如果要对压缩包内所有文件在没有解压密码之前都不能访问，需要每个文件添加时设置<code>zipParameters</code>参数，设置为加密开启。</p><p><img src="https://s2.loli.net/2023/03/27/qbauo5fZCevzDUS.png" alt="zip文件内部分文件加密.png"></p><p>还有一点：踩过一个坑，由于我在打包文件的时候，可能出现某一个压缩包已经打包过了，但是业务上并不知道已经打包过了，所以会出现重复打包的情况，而我在针对重复打包的情况，会先将目标<code>zip</code>设置为一个空文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过java标准库中的方法，这时这个目标文件存在，但是内容被清除，结果是0B</span></span><br><span class="line">Files.newByteChannel(result, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE).close();</span><br></pre></td></tr></table></figure><p>但是这种情况下运行会报错：</p><blockquote><p>Zip file size less than minimum expected zip file size. Probably not a zip file or a corrupted zip file</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zip4jRaf.length() &lt; ENDHDR) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ZipException(<span class="string">&quot;Zip file size less than minimum expected zip file size. &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;Probably not a zip file or a corrupted zip file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思是目标文件是一个空文件，校验了目标文件头部的一个什么长度。没有细究这个问题，我的做法是改成直接删除旧文件，然后再生成文件。</p><p><b>3.打包分卷</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">zip</span><span class="params">(List&lt;String&gt; srcFiles, String destFile, <span class="keyword">long</span> fileSize)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(destFile);</span><br><span class="line">    List&lt;File&gt; filesToAdd = srcFiles.stream().map(File::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    ZipParameters parameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    parameters.setCompressionMethod(CompressionMethod.DEFLATE);</span><br><span class="line">    parameters.setCompressionLevel(CompressionLevel.NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未指定则设置为512KB</span></span><br><span class="line">    <span class="keyword">if</span>(fileSize==<span class="number">0</span>)&#123;</span><br><span class="line">        fileSize = <span class="number">65536</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置压缩分卷</span></span><br><span class="line">    zipFile.createSplitZipFile(filesToAdd, parameters, <span class="keyword">true</span>, fileSize);</span><br><span class="line">    <span class="keyword">return</span> zipFile.getSplitZipFiles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分卷生成的文件结构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标文件目录</span><br><span class="line">  ├─────── result.z01</span><br><span class="line">  └─────── result.z02</span><br></pre></td></tr></table></figure><p>这里会生成<code>.z</code>+<code>数字排列</code>的压缩包，要提取或打开这样的分卷<code>ZIP</code>文件，必须将所有的<code>ZIP</code>文件都放在同一个目录下。这种场景就可以用于大文件分卷为多个小文件后，传输小文件到目标地址。</p><p><b>4.提取</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> ZipException</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个ZipFile对象，用于打开要提取的ZIP文件</span></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置解压缩密码（如果需要）</span></span><br><span class="line">    <span class="keyword">if</span> (zipFile.isEncrypted()) &#123;</span><br><span class="line">        zipFile.setPassword(<span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.将所有文件都提取到当前目录下</span></span><br><span class="line">    zipFile.extractAll(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.仅提取一个文件</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;demo1.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.提取的这个文件不是在顶层目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/demo3.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.提取整个内部目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<code>Zip4j</code>是一个非常实用的<code>Java</code>库，可以帮助程序员方便地处理<code>ZIP</code>文件格式，节省大量的开发时间和工作量。还包含其他的一些，比如添加某个文件到<code>zip</code>文件中，修改<code>zip</code>中的某个文件等等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近接到需求需要为打包后的&lt;code&gt;zip&lt;/code&gt;文件设置压缩密码，而我们之前使用的&lt;code&gt;ZipOutputStream&lt;/code&gt;结合&lt;code&gt;hutool&lt;/code&gt;的&lt;code&gt;NoiUtil&lt;/code&gt;进行打包生成&lt;code&gt;zip&lt;/code&gt;文件，但是&lt;code&gt;ZipOutputStream&lt;/code&gt;没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问&lt;code&gt;chatGPT&lt;/code&gt;)，它的回答是&lt;code&gt;Zip4j&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（六）---锁（第二弹）</title>
    <link href="http://xiaocainiaoya.github.io/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/</id>
    <published>2023-03-02T14:13:58.000Z</published>
    <updated>2023-03-03T07:31:25.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（六）—锁（第二弹）"><a href="#mysql45讲学习总结（六）—锁（第二弹）" class="headerlink" title="mysql45讲学习总结（六）—锁（第二弹）"></a>mysql45讲学习总结（六）—锁（第二弹）</h1><p>​    本篇主要为了记录间隙锁和<code>next-key lock</code>相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。</p><span id="more"></span><p>这里简单回顾一下：</p><p>表锁：如果查询条件中不包含索引字段，则是表锁。</p><p>行锁：行锁只能锁住行，跟行锁有冲突的是“另外一个行锁”</p><p>间隙锁：间隙锁是锁住两个值之间的空隙，跟间隙锁有冲突的是“往这个间隙插入一个记录”这个动作，所以某一个间隙可以被多个线程上间隙锁。</p><p><code>Next-Key Lock</code>是行锁和间隙锁的结合体。</p><p><b>无论任何锁的释放，都不是在执行完事务内的某条语句之后，是整个事务提交之后才会释放锁。</b></p><h2 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `USER_INFO` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_NAME` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`),</span><br><span class="line">  KEY `IDX_USER_ID` (`USER_ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br></pre></td></tr></table></figure><p>可以看到上面示例中有一张<code>USER_INFO</code>表，在<code>ID</code>上有主键索引，在<code>USER_ID</code>上有非唯一索引。这时有两个事务并发，事务1是删除，事务2是插入。</p><p><strong>分析一下上锁过程：</strong></p><p>因为<code>USER_ID</code>是有非唯一索引，那么对<code>USER_ID</code>索引上<code>Next-Key Lock</code>。(假设事务1比事务2快一点点到达)</p><ol><li>上锁的基本单位是<code>Next-Key Lock</code>，上<code>Next-Key Lock</code>为(前一个<code>USER_ID</code>, 10]，前开后闭。</li><li>由于<code>USER_ID</code>是非唯一索引，这时还需要向后扫描到第一个不等值才返回(不等于10)，但是由于目前这张表中的最大<code>USER_ID=10</code>，所以这时会变成<code>mysql</code>预设的最大值(+suprenum)。</li><li>所以最后锁的范围为(前一个formId， +suprenum)</li></ol><p><font color="red">在步骤2中，由于间隙锁需要锁住一个空间，但是在<code>USER_ID=10</code>之后没有其他数据，才会导致锁住了<code>USER_ID=10</code>之后的所有空间，这也不能理解，由于是非唯一索引，所以无法保证不会在<code>USER=10</code>之后再插入一条<code>USER_ID=10</code>的数据。</font></p><p>所以这个时候的事务2进来是就需要等待事务1提交事务之后才能进行数据插入。</p><p>可以自己通过脚本测试一下，验证结论是否正确。开两个<code>SQL</code>窗口，进行两个线程测试。</p><p>线程1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">-- 延迟 提交事务</span></span><br><span class="line"><span class="keyword">SELECT</span> sleep(<span class="number">10</span>) <span class="keyword">FROM</span> USER_INFO limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>线程2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h2 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h2><ol><li>原则1：加锁的基本单位就是<code>Next-Key Lock</code>，<code>Next-Key Lock</code>是前开后闭区间。</li><li>原则2：在加锁过程中访问到的对象(记录)才会被锁。</li><li>优化1：对唯一索引的等值查询，<code>Next-Key Lock</code>退化为行锁。</li><li>优化2：索引上的等值查询，从第一个满足等值条件的索引记录开始向右遍历到第一个不满足等值条件记录，并将第一个不满足等值条件记录上的<code>Next-Key Lock</code>退化为间隙锁</li></ol><p>下文通过这个脚本中的表和数据为例，进行加锁规则的一些解释。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这时对于主键索引来说，具有的值为<code>0、5、10、15、20、25</code>，以及7个间隙。</p><p><img src="https://s2.loli.net/2023/03/02/IqU9dRAu2c6VCYz.png" alt="间隙锁2.png"></p><h3 id="1-等值查询间隙锁"><a href="#1-等值查询间隙锁" class="headerlink" title="1.等值查询间隙锁"></a>1.等值查询间隙锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>update t set d=d+1 where id=7</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>Insert into t values(8, 8, 8)<br>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update set d=d+1 where id=10;<br/>(<font color='green'>Query OK</font>)</td><td>T3</td></tr></tbody></table><ol><li>在<code>T1</code>时刻，由于没有<code>id=7</code>这条记录，根据加锁规则，锁住<code>B</code>这个间隙，由于<code>Next-Key Lock</code>是前开后闭，所以锁住空间为<code>(5,10]</code></li><li><font color="red">若表中存在<code>id=7</code>这条记录，则根据优化1，锁住的仅仅为<code>id=7</code>这条记录。但是由于没有这条记录，故进入优化2的加锁规则。</font>根据优化2，等值查询<code>where id=7</code>向右遍历时，遇到的最后一个不满足等值条件的记录时，<code>Next-Key Lock</code>退化为间隙锁，所以<code>T1</code>时刻后最终加锁的范围为<code>(5,10)</code></li></ol><p>所以<code>T2</code>时刻的<code>SessionB</code>操作被阻塞，<code>T3</code>时刻的<code>SessionC</code>操作没有被阻塞。</p><h3 id="2-非唯一索引等值锁"><a href="#2-非唯一索引等值锁" class="headerlink" title="2.非唯一索引等值锁"></a>2.非唯一索引等值锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select id form t where c=5 lock in share mode;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where id=5;<br>(<font color='green'>Query OK</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(7, 7,7)<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li>根据原则1，加锁单位是<code>Next-Key Lock</code>,所以会给<code>(0,5]</code>上<code>Next-Key Lock</code>锁。</li><li>由于<code>c</code>是非唯一索引，当访问到<code>c=5</code>这条记录后不会停下来，会继续向后遍历，当遍历到<code>c=10</code>这条记录后停止，所以这时要对<code>(5,10]</code>上<code>Next-Key Lock</code>，但根据优化2，这时<code>Next-Key Lock</code>退化为间隙锁<code>(5,10)</code></li></ol><p>所以最终，在<code>T1</code>时刻，上锁的范围是<code>(0, 5]</code>的<code>Next-Key Lock</code>和<code>(5,10)</code>的间隙锁，故<code>T3</code>时刻，<code>SessionC</code>插入<code>c=7</code>的数据被阻塞。</p><p><font color="red">这里为什么<code>T2</code>时刻的<code>SessionB</code>执行成功？</font>这是因为加锁规则中的原则2，只有访问到的对象才会加锁，因为这条<code>SQL</code>采用的是索引覆盖，所以并不需要访问主键索引，所以也就没有对主键索引上锁，所以<code>sessionB</code>才会执行成功。</p><p><b>注意:<code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>不一样，<code>Mysql</code>这时认为接下来要更新数据，会顺便为主键索引上锁。</b>所以如果你要用<code>lock in share mode</code>来给行添加读锁避免数据被更新，就必须绕过覆盖索引的优化，在查询字段中添加索引中不存在的字段，让它必须进行一次回表。</p><h3 id="3-主键范围索引锁"><a href="#3-主键范围索引锁" class="headerlink" title="3.主键范围索引锁"></a>3.主键范围索引锁</h3><p>这两条<code>SQL</code>虽然在查询结果是一致的，但是它们的加锁规则不太一样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;=10 and id&lt;11 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(8, 8,8);<br>(<font color='green'>Query OK</font>)<br>insert into t values(13, 13,13);<br/>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update t set d=d+1 where id=15;<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li>开始执行时，从<code>id=10</code>开始查询，这里本来应该是<code>(5,10]</code>的<code>Next-Key Lock</code>，由于<code>id</code>是唯一索引，退化为行锁，这时只加了<code>id=10</code>这一行的行锁。</li><li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code>，这里要扫到<code>id=15</code>是正常的，只有扫到了这条记录，才会知道需不需要继续往后找。</li></ol><p><b>注意：</b><code>sessionA</code>的步骤一首次定位<code>id=10</code>是用等值查询来判断的，步骤二继续向右遍历用的是范围查询判断(范围查询并没有在两个优化中，所以这里的<code>(10, 15]</code>不会退化为间隙锁！！！这个要注意，优化只有在等值查询的时候才会发生，我在第一次看的时候当时也突然卡住，没有想明白为什么没有退化为间隙锁！)</p><h3 id="4-非唯一索引范围锁"><a href="#4-非唯一索引范围锁" class="headerlink" title="4.非唯一索引范围锁"></a>4.非唯一索引范围锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;=10 and c&lt;11 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(8, 8,8);<br>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>update t set d=d+1 where c=15;<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><p>这个与案例3的区别在于通过字段<code>c</code>来进行查询，字段<code>c</code>是非唯一索引。</p><ol><li>根据<code>c=10</code>找到了<code>c=10</code>这条记录，所以添加对<code>(5,10]</code>添加<code>Next-Key Lock</code>，由于是非唯一索引，所以不会退化为间隙锁。</li><li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code></li></ol><p>综上：这里对索引<code>c</code>上了<code>(5,10]</code>和<code>(10, 15]</code>两个<code>Next-Key Lock</code>。</p><h3 id="5-唯一索引范围锁bug"><a href="#5-唯一索引范围锁bug" class="headerlink" title="5.唯一索引范围锁bug"></a>5.唯一索引范围锁bug</h3><p>在开头叙述的两个原则，两个优化的加锁原则之外，还有一个加锁<code>bug</code>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where id&gt;10 and id&lt;=15 for update;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where id=20;<br/>(<font color='red'>blocked</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(16, 16,16);<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><p><code>sessionA</code>是一个范围查询，根据原则1，这时为<code>(10,15]</code>上<code>Next-Key Lock</code>，并且<code>id</code>是唯一键，所以判断到<code>id=15</code>这一行就应该停止了，但实际上<code>InnoDB</code>会继续向后遍历到第一个不满足条件的行为止，也就是<code>id=20</code>这条记录，所以<code>(15,20]</code>也会上<code>Next-Key Lock</code>。所以这时<code>SessionB</code>和<code>SessionC</code>也会被锁住。</p><p>照理来说，扫描到<code>id=15</code>这行后，就可以不用继续往后查询了，但实际上<code>InnoDB</code>实际上还是这么做了。所以在<code>mysql 45讲</code>的作者认为这是一个<code>bug</code>。</p><h3 id="6-非唯一索引上存在等值的情况"><a href="#6-非唯一索引上存在等值的情况" class="headerlink" title="6.非唯一索引上存在等值的情况"></a>6.非唯一索引上存在等值的情况</h3><p>开头创建的表结构和数据中，没有存在索引<code>c</code>上有等值的数据，所以这里插入一条等值数据。</p><blockquote><p>insert into t values(30,10,30);</p></blockquote><p>执行之后，表中有两条<code>c=10</code>的数据。下图为索引<code>c</code>的间隙状态如下(上方是<code>c</code>，下方是主键)</p><p><img src="https://s2.loli.net/2023/03/02/FpGekvjcSrM7zCt.png" alt="非唯一索引间隙锁.png"></p><p>这时有两个<code>c=10</code>的记录，他们的主键<code>id</code>值不同（分别是<code>10</code>和<code>30</code>），但是这两个记录之间也是有间隙的。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>delete from t where c=10</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where c=15;<br/>(<font color='green'>Query OK</font>)</td><td></td><td>T2</td></tr><tr><td></td><td></td><td>insert into t values(12, 12,12);<br/>(<font color='red'>blocked</font>)</td><td>T3</td></tr></tbody></table><ol><li><code>sessionA</code>在遍历时先访问第一个<code>c=10</code>的记录，这时先对<code>(c=5,id=5)</code>到<code>(c=10,id=10)</code>这个<code>Next-Key Lock</code></li><li>继续向后遍历，直到碰到<code>(c=15,id=15)</code>这一行，遍历停止，根据优化2，这时一个等值查询，向右遍历第一个不满足条件的的行会退化为<code>(c=10,id=10) </code>到<code> (c=15,id=15)</code>的间隙锁。</li></ol><p>也就是说这个<code>delete</code>语句在索引<code>c</code>上的加锁范围就是下图中标记的区域，这里不包含两边的两条记录，是开区间，即<code> (c=5,id=5)</code> 和<code>(c=15,id=15)</code>这两行上都没有锁。<b>同时主键索引上锁(10,10,10) 和 (30,10,30) 两行,是行锁。</b></p><p><img src="https://s2.loli.net/2023/03/02/E5r6kSWTJDxpNQu.png" alt="非唯一索引间隙锁2.png"></p><h3 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h3><p>这个是对案例6的一个对照案例。</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>delete from t where c=10 limit 2;</td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(12, 12, 12);<br/>(<font color='green'>Query OK</font>)</td><td>T2</td></tr></tbody></table><p>这个例子对比案例6的<code>sessionA</code>，仅在<code>delete</code>语句上加了<code>limit 2</code>，可能你会觉得数据库中<code>c=10</code>的记录只有两条，加不加<code>limit 2</code>删除的效果都是一样的，但是实际上加锁的访问有所不同。</p><p>这是因为，案例7的<code>delete</code>语句明确了<code>limit 2</code>的限制，因此在遍历到<code>(c=10, id=30)</code>这一行之后，就已经满足语句了，遍历就结束了。所以索引<code>c</code>的加锁范围就变成了<code>（c=5,id=5)</code>到<code>（c=10,id=30)</code>这个前开后闭区间。所以这时<code>T2</code>时刻的<code>sessionB</code>插入<code>c=12</code>是可以执行成功的。</p><p>所以这个例子对我们的实践是有指导意义的，<b>在删除数据的时候尽量加<code>limit</code>，</b>这样不仅可以控制删除的条数，也可以减少加锁的范围。</p><h3 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>select from t where c=10 lock in share mode;</td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=d+1 where c=10;<br/>(<font color='green'>Query OK</font>)</td><td>T2</td></tr><tr><td>insert into t values(8, 8, 8)</td><td></td><td>T3</td></tr><tr><td></td><td>ERROR 1213:Deadlock found when trying to get lock; try restarting transaction</td><td>T4</td></tr></tbody></table><ol><li><code>session A </code>启动事务后执行查询语句加<code> lock in share mode</code>，在索引 <code>c </code>上加了<code> next-key lock(5,10]</code> 和间隙锁<code> (10,15)</code>；</li><li><code>session B </code>的<code> update</code> 语句也要在索引 <code>c </code>上加<code> next-key lock(5,10]</code> ，进入锁等待；</li><li>然后 <code>session A</code> 要再插入<code> (8,8,8)</code> 这一行，被<code>session B</code>的间隙锁锁住。由于出现了死锁，<code>InnoDB</code> 让 <code>session B </code>回滚。</li></ol><p>实际上步骤2中加<code>Next-Key Lock</code>是两步操作，分成间隙锁和行锁，在步骤2中加间隙锁是不会冲突，但是在加行锁的时候进入了等待，而T3时刻，<code>sessionA</code>插入数据需要等待<code>sessionB</code>释放间隙锁，所以出现了相互等待的情况，从而导致死锁。</p><p>虽然在分析<code>Next-Key Lock</code>表示间隙锁和行锁的结合，但是具体执行的时候要分为两段来执行。</p><h3 id="9-非唯一索引排序"><a href="#9-非唯一索引排序" class="headerlink" title="9.非唯一索引排序"></a>9.非唯一索引排序</h3><table><thead><tr><th>sessionA</th><th>sessionB</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from t where c&gt;=15 and c&lt;=20 order by c desc lock in share mode;</td><td></td><td>T1</td></tr><tr><td></td><td>insert into t values(6,6,6);<br/>(<font color='red'>blocked</font>)</td><td>T2</td></tr></tbody></table><ol><li>由于这里有<code>order by c desc</code>所以首先从<code>c=20</code>开始定位，所以首先加上间隙锁<code>(20, 25)</code>和<code>Next-Key Lock</code>锁<code>(15, 20]</code>。</li><li>在索引<code>c</code>向左遍历，需要扫描到<code>c=10</code>这条记录才会停止，所以<code>(5, 10]</code>。所以<code>sessionB</code>会阻塞。</li><li>在扫描的过程中，会对<code>c=10</code>，<code>c=15</code>，<code>c=20</code>这三行有数据，且查询字段是<code>select * </code>，需要进行回表，所以会在主键索引上上三个行锁。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（六）—锁（第二弹）&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（六）—锁（第二弹）&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（六）—锁（第二弹）&quot;&gt;&lt;/a&gt;mysql45讲学习总结（六）—锁（第二弹）&lt;/h1&gt;&lt;p&gt;​    本篇主要为了记录间隙锁和&lt;code&gt;next-key lock&lt;/code&gt;相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
