<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2021-06-28T14:51:03.316Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringAop浅析</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/</id>
    <published>2021-06-27T08:20:58.000Z</published>
    <updated>2021-06-28T14:51:03.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringAop浅析"><a href="#SpringAop浅析" class="headerlink" title="SpringAop浅析"></a>SpringAop浅析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>AOP</code>面向切面编程。在运行时，动态的将代码织入到类的指定方法，指定位置上的思想。实际上<code>AOP</code>不一定都像<code>Spring Aop</code>那样实现，<code>Spring Aop</code>是通过在运行时生成代理对象来进行织入。还有其他的方式，比如<code>AspectJ</code>是在编译期、类加载期织入。本篇文章就来介绍，<code>Spring Aop</code>在运行时生成代理对象的时期和过程。</p><span id="more"></span><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>​    若想使用<code>SpringAop</code>可以通过两种方式，一种是声明式，通过调用<code>Api</code>的方式；一种是通过注解方式。两者在真正触发生成代理对象的点略有不同。</p><h3 id="1-声明式"><a href="#1-声明式" class="headerlink" title="1.声明式"></a>1.声明式</h3><p>​    这里只做简单介绍，首先需要实现某种通知类型的接口，再实现切点接口(<code>Pointcut</code>)，如果是环绕通知，需将通知实现类和切点实现类绑定<code>DefaultPointcutAdvisor</code>，最后在客户代码中将通知、目标类等信息添加到<code>ProxyFactory</code>实例中后，通过<code>ProxyFactorygetProxy();</code>获取代理对象，从而实现<code>SpringAop</code>。</p><h3 id="2-注解式"><a href="#2-注解式" class="headerlink" title="2.注解式"></a>2.注解式</h3><p>​    通过<code>@Aspect</code>标记一个类为切面类，并通过<code>@Pointcut</code>注解标记一个切点，最后通过注解标记通知类型，比如环绕通知使用<code>@Around</code>进行<code>Aop</code>的业务处理。</p><p><strong>那么<code>Spring</code>如果去解析这些注解？</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="1-开启SpringAop"><a href="#1-开启SpringAop" class="headerlink" title="1.开启SpringAop"></a>1.开启<code>SpringAop</code></h3><p>​    在<code>Spring</code>中提供一个开启<code>SpringAop</code>的配置注解<code>@EnableAspectJAutoProxy</code>(在<code>springboot</code>中一般标记在启动类上)，在这个注解上使用<code>@Import</code>注解引入<code>SpringAop</code>配置类<code>AspectJAutoProxyRegistrar</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为true的话开启cglib代理，默认为jdk代理</span></span><br><span class="line"><span class="comment"> * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment"> * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否将代理对象暴露到线程上下文中 </span></span><br><span class="line"><span class="comment"> * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment"> * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment"> * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AspectJAutoProxyRegistrar</code>实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>接口，在<code>Spring</code>启动扫描配置类后会调用该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment"> * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 重点在这: 会注册AnnotationAwareAspectJAutoProxyCreator到BeanDefinitionMap中</span></span><br><span class="line">    <span class="comment">// AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor后置处理器</span></span><br><span class="line">    <span class="comment">// 这个方法比较简单, 可自行跟进去看一眼。</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"><span class="comment">// 解析注解的属性</span></span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 默认为false</span></span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认为false</span></span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Aop代理对象的生成"><a href="#2-Aop代理对象的生成" class="headerlink" title="2.Aop代理对象的生成"></a>2.<code>Aop</code>代理对象的生成</h3><p>​    在开启<code>SpringAop</code>时添加了一个<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>Spring</code>容器中，在<code>Spring</code>启动的生命周期中，会在适时调用它的实现方法。</p><p>​    看一下这个类的类图，<code>AnnotationAwareAspectJAutoProxyCreator</code>实现了<code>AbstractAutoProxyCreator</code>抽象类，在这个抽象类中，实现了<code>BeanPostProcessor</code>生命周期接口。</p><p><img src="https://i.loli.net/2021/06/27/eKqWCVnJTcGjiYS.png" alt="eKqWCVnJTcGjiYS"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Bean实例化之前调用接口:用于提前生成代理对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="comment">// this.advisedBeans用于标记某个key是否需要进行AOP代理</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">  <span class="comment">// 若用户没有自定义，默认情况下是targetSource是空的</span></span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Bean初始化之后调用接口:这个接口的调用点是在Bean对象初始化之后, 也就是Bean对象基本</span></span><br><span class="line"><span class="comment"> * 上走完了初始化流程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">// 一般情况下remove(cacheKey) != bean肯定会成立，因为前者remove方法返回null</span></span><br><span class="line">      <span class="comment">// 只有在循环依赖时，可能会出现提前暴露的bean对象与当前bean不等</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>wrapIfNecessary</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果已经完成代理了，那么直接返回这个代理的对象</span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 若这个Bean对象被标记无需AOP代理, 直接返回</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 如果不需要代理，直接返回，且标记为无需AOP代理</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">  <span class="comment">// 获取通知可以作用在这个Bean上的通知</span></span><br><span class="line">  <span class="comment">// 主要逻辑在AnnotationAwareAspectJAutoProxyCreator#findCandidateAddvisors方法</span></span><br><span class="line">  <span class="comment">// 首先获取容器中类型为Advisor的Bean, 再从容器中获取@Aspect注解标记的Bean后, 将二者结合。</span></span><br><span class="line">  <span class="comment">// 最后筛选出可以作用到这个Bean的通知。</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">    <span class="comment">// 标记这个Bean需要进行AOP代理</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">    <span class="comment">// 创建代理对象, 这里是重点</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>createProxy</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建代理工厂类</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将Interceptors转化为具体的Advisor子类的类型</span></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * createAopProxy():根据一定的配置规则获取动态代理工厂的实现类(jdk动态代理或者是cglib动态代理)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这边跟踪下来<code>createAopProxy()</code>返回的是<code>cglib</code>动态代理的实现，所以以<code>cglib</code>动态代理为例，继续往下走。进入<code>CglibAopProxy#getProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取正在包装的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">    Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">    <span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">      proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">      Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">    validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">    Enhancer enhancer = createEnhancer();</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      enhancer.setClassLoader(classLoader);</span><br><span class="line">      <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">          ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">        enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">    <span class="comment">// 设置需要代理的接口</span></span><br><span class="line">    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">    Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">      types[x] = callbacks[x].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">    enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">      <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">    enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">    <span class="comment">// 创建具体的代理对象实例</span></span><br><span class="line">    <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,ex);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-代理对象的调用"><a href="#3-代理对象的调用" class="headerlink" title="3.代理对象的调用"></a>3.代理对象的调用</h3><p><code>DynamicAdvisedInterceptor#intercept</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 获取匹配该方法的通知列表</span></span><br><span class="line"><span class="comment">// 主要逻辑在DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice方法中</span></span><br><span class="line"><span class="comment">// 根据advised中的通知列表，对当前调用方法进行匹配，将匹配成功的通知转为拦截器链返回。</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">Object retVal;</span><br><span class="line"><span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line"><span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line"><span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line"><span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line"><span class="comment">// 实例化CglibMethodInvocation后执行proceed方法</span></span><br><span class="line">retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">&#125;</span><br><span class="line">retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行拦截器链<code>proceed()</code>，进入<code>ReflectiveMethodInvocation#proceed</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="comment">// 表明执行到链尾, 直接通过反射调用目标方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到下一个要执行的拦截器</span></span><br><span class="line">Object interceptorOrInterceptionAdvice = <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"><span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line"><span class="comment">// been evaluated and found to match.</span></span><br><span class="line">InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line"><span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Dynamic matching failed.</span></span><br><span class="line"><span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line"><span class="keyword">return</span> proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line"><span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line"><span class="comment">// 调用拦截器中的invoke方法，可以看到这里将this作为参数传入了，这里是一种拦截器链的典型用法</span></span><br><span class="line">    <span class="comment">// 在我之前有篇[从myBatis Plugin看责任链模式]中有两种拦截器链的典型用法，二者的区别就是</span></span><br><span class="line">    <span class="comment">// 有没有携带链对象，这里明显是携带链对象，从而达到拦截器链逐个执行的目的。</span></span><br><span class="line"><span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是根据通知类型的不同会进入到不同的具体实现中，比如我的测试代码是环绕通知类型，这里进入环绕通知的具体实现中<code>AspectJAroundAdvice#invoke</code>去执行当前链节点的<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">  &#125;</span><br><span class="line">  ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">  <span class="comment">// 这里只是将链对象包装了一层</span></span><br><span class="line">  ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">  JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPoint jp, <span class="meta">@Nullable</span> JoinPointMatch jpMatch,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="meta">@Nullable</span> Object returnValue, <span class="meta">@Nullable</span> Throwable t)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Object[] actualArgs = args;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    actualArgs = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 反射调用通知方法</span></span><br><span class="line">    ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">    <span class="comment">// TODO AopUtils.invokeJoinpointUsingReflection</span></span><br><span class="line">    <span class="comment">// 把链对象封装在了这个arctualArgs(MethodInvocationProceedingJoinPoint)中了,</span></span><br><span class="line">    <span class="comment">// 所以切面方法中通过jointPoint.process()方法实际调用方法是与链对象挂钩的, 如果执行</span></span><br><span class="line">    <span class="comment">// 到链尾这调用目标对象, 若非链尾, 则继续进入链节点对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;Mismatch on arguments to advice method [&quot;</span> +</span><br><span class="line">                                     <span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">&quot;]; pointcut expression [&quot;</span> +</span><br><span class="line">                                     <span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以我的测试代码为例，环绕通知<code>@Around(&quot;testPointcut()&quot;)</code>的标记实现方法中，一般在前置执行一些业务代码之后，会调用<code>ProceedingJoinPoint#process()</code>方法，后再调用后置的业务代码。</p><p>而<code>ProceedingJoinPoint#process()</code>方法就是转入下一个拦截器链的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodInvocationProceedingJoinPoint</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 这个proceed()方法就回到了上面的ReflectiveMethodInvocation#proceed，且</span></span><br><span class="line">  <span class="comment">// 链下标不是-1, 而是下一个链节点的下标。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.methodInvocation.invocableClone().proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>我这里使用的是<code>springboot</code>项目，仅在项目启动类上添加了一个<code>@EnableAspectJAutoProxy</code>，且默认情况下该注解的<code>proxyTargetClass()</code>属性为<code>false</code>，那么为什么我在调试的时候会进入到<code>Cglib</code>动态代理的实现中，逻辑上应该是使用<code>jdk</code>动态代理？</p><p>​    这是因为<code>springboot</code>的自动装配<code>AopAutoConfiguration</code>中，配置的是<code>cglib</code>动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 采用jdk动态代理的配置:需明确指定配置项spring.aop.proxy-target-class=false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,matchIfMissing = false)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 采用cglib动态代理的配置:明确指定配置项spring.aop.proxy-target-class=true或者无该配置项时</span></span><br><span class="line"><span class="comment">    * 启用cglib动态代理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line">ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这里只是对<code>SpringAop</code>做了个很浅的分析，主要是明确<code>SpringAop</code>的大致创建时机、创建流程和基本的调用流程。<code>SpringAop</code>是采用动态代理的方式实现，通过<code>@EnableAspectJAutoProxy</code>的方式开启，开启的原理为添加<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanDefinitionMap</code>中；在<code>Bean</code>对象实例化之前可以通过用户自定义的方式进行提前生成代理对象。或者是在<code>Bean</code>对象初始化之后，通过上述后置处理器的<code>postProcessAfterInitialization</code>方法，将<code>Bean</code>对象转为代理对象。</p><p>​    在业务中调用代理对象的某个方法时，进入对应的拦截方法<code>intercept</code>方法，该方法会去获取匹配当前被调用方法的拦截器链，进入链对象后，通过反射调用对应的切面方法后，通过链对象调用下一个链节点，从而遍历整个拦截器链列表，这是一种典型的拦截器设计，我之前也有写一篇文章<a href="https://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank">这里</a>，简单的介绍了拦截器的两种使用方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringAop浅析&quot;&gt;&lt;a href=&quot;#SpringAop浅析&quot; class=&quot;headerlink&quot; title=&quot;SpringAop浅析&quot;&gt;&lt;/a&gt;SpringAop浅析&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;AOP&lt;/code&gt;面向切面编程。在运行时，动态的将代码织入到类的指定方法，指定位置上的思想。实际上&lt;code&gt;AOP&lt;/code&gt;不一定都像&lt;code&gt;Spring Aop&lt;/code&gt;那样实现，&lt;code&gt;Spring Aop&lt;/code&gt;是通过在运行时生成代理对象来进行织入。还有其他的方式，比如&lt;code&gt;AspectJ&lt;/code&gt;是在编译期、类加载期织入。本篇文章就来介绍，&lt;code&gt;Spring Aop&lt;/code&gt;在运行时生成代理对象的时期和过程。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Type接口</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/22/java/Type%E6%8E%A5%E5%8F%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/22/java/Type%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-06-22T13:41:58.000Z</published>
    <updated>2021-06-28T14:48:58.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Type接口"><a href="#Type接口" class="headerlink" title="Type接口"></a>Type接口</h3><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    <code>Type</code>接口是<code>Java</code>中所有类型的公共高级接口，是由<code>JDK5</code>引入，主要是为了实现参数化类型(泛型)，<code>Class</code>类是该接口的直接实现类。</p><span id="more"></span><p>​    在日常开发过程中，一些公共抽象点需要使用泛型进行结构抽象，从而达到业务调用点灵活调用的目的。之前有一次由于不懂<code>Type</code>接口以及子类，导致部分抽象做的不够灵活，本篇主要记录<code>Type</code>接口下参数化类型<code>ParameterizedType</code>的一些<code>API</code>使用。</p><h4 id="二、子接口"><a href="#二、子接口" class="headerlink" title="二、子接口"></a>二、子接口</h4><p><img src="https://i.loli.net/2021/06/22/3LURqsICMOANz7e.png" alt="3LURqsICMOANz7e"></p><p>从左到右依次是直接实现类<code>Class</code>，数组类型接口<code>GenericArrayType</code>，参数化类型接口<code>ParameterizedType</code>，通配符表达式接口<code>WildcardType</code>，类型变量接口(泛指任何类)<code>TypeVariable</code>。大概知道了几个接口之间的关系之后，直接进入一个应用场景。</p><p>​    服务端与客户端交互是设计了一个数据固定的数据结构，其中该数据结构中的存在两个属性<code>String dataJson</code>和<code>T Data</code>，而客户端只会传输经过一定的编码或者加密处理<code>dataJson</code>字段，由服务端自行处理字符串数据。最理想的情况就是，服务端做一层统一处理，接收到该实体对象之后，根据服务端和客户端之间的约定，解析其中的<code>dataJson</code>为对应的<code>data</code>数据。前面有一篇专门来说这个参数解析<a href="https://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/#more" target="_blank">这里</a>。当时同事最开始提出这个问题的时候还并没有提出想将<code>json</code>转为实体，仅想通过某种统一处理，将<code>json</code>解码(客户端传输过来的是经过某种编码)。最终选择的方案是通过<code>RequestBodyAdvice</code>，当完成解码这个动作之后，同事发现，既然都通过统一处理<code>json</code>串解码了，那不就可以通过泛型的方式把<code>json</code>转换为对应的实体？我原本以为获取不到对应类的泛型，而恰巧(真的是巧)。<code>RequestBodyAdvice#afterBodyRead</code>方法上参数是<code>Type</code>类型，从而能通过它(如果是泛型则类型为<code>ParameterizedType</code>)就可以获取到对应类的泛型类型，从而进行转换为对应的实体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span></span></span><br></pre></td></tr></table></figure><p>这里我想抛出我的问题：如果这里没有<code>Type</code>参数，可以看之前那篇文章的其他两种方式，比如现在的场景就是使用<code>@InitBuilder</code>的方式最合适，要怎么获取到<code>Type</code>，或者说获取到参数的<code>ParameterizedType</code>？</p><p>度娘了一下，对查到的一些写法的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接Class: 这种写法纯属骗人，从类图可以看出，就算用父接口引用，其实本质上还是Class类型</span></span><br><span class="line"><span class="comment">// 和ParameterizedType类型不符。</span></span><br><span class="line">DataEntity&lt;User&gt; dataEntity = <span class="keyword">new</span> DataEntity&lt;User&gt;();</span><br><span class="line">Type t = (Type)dataEntity.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过class.getGenericSuperclass():这种方式可以获取到的的确是ParameterizedType，</span></span><br><span class="line"><span class="comment">// 但那是父类的ParameterizedType(如果父类是泛型的情况)。</span></span><br><span class="line"><span class="comment">// 那么如果A继承B，B能获取到A的class, 再通过A的class获取到B的泛型参数, 虽然有点绕, 但也不失为一种方式。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Type type =list.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过反射获取: 反射是根据类来获取对应的属性，这种方式下获取的是泛型前的类型TypeVariable</span></span><br><span class="line"><span class="comment">// 如果某个方法中的参数是泛型类型, 通过method.getGenericParameterTypes()可以获取到ParameterizedType</span></span><br><span class="line">DataEntity&lt;User&gt; dataEntity = <span class="keyword">new</span> DataEntity&lt;User&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Field field = dataEntity.getClass().getField(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">  Type paraType = field.getGenericType();</span><br><span class="line">  System.out.println(paraType);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上的3种方法，1和3直接就不对。只有2沾点边。所以在设计上可以将A设计为泛型接口，B作为A的具体实现，这时就可以获取到对应的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  Type[] type = b.getClass().getGenericInterfaces();</span><br><span class="line">  System.out.println(((ParameterizedType)type[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(User data)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、常用API"><a href="#三、常用API" class="headerlink" title="三、常用API"></a>三、常用API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里要时刻注意获取的父类的的Type或者是Class。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *  class.getSuperclass() 返回直接继承的父类(类型擦除, 不显示泛型参数)</span></span><br><span class="line"><span class="comment"> *  class.getGenericSuperclass() 返回直接继承的父类(包含泛型参数)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  class.getInterfaces() 返回直接实现的接口</span></span><br><span class="line"><span class="comment"> *  class.getGenericInterface() 返回直接实现的接口(包含泛型参数)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * ParameterizedType:</span></span><br><span class="line"><span class="comment"> *   getActualTypeArguments() 返回参数化类型列表(比如DataEntity&lt;User&gt;, 通过该方法获取到的就是User)</span></span><br><span class="line"><span class="comment"> *   getOwnerType() 返回这个ParameterizedType所在类的Type</span></span><br><span class="line"><span class="comment"> *   比如Map&lt;String, Object&gt;的getOwnerType=null,Map.Entry&lt;String,String&gt;的getOwnerType=Map)</span></span><br><span class="line"><span class="comment"> *   getRawType() 表示声明此类型的类或者接口</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/22 22:39:26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Type type =list.getClass().getGenericSuperclass();</span><br><span class="line">    System.out.println(list.getClass().getGenericSuperclass());</span><br><span class="line">    System.out.println(list.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] classes = list.getClass().getInterfaces();</span><br><span class="line">    Type[] types = list.getClass().getGenericInterfaces();</span><br><span class="line"></span><br><span class="line">    System.out.println(list.getClass().getInterfaces());</span><br><span class="line">    System.out.println(list.getClass().getGenericInterfaces());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParameterizedType:</span></span><br><span class="line"><span class="comment"> *   getActualTypeArguments() 返回参数化类型列表(比如DataEntity&lt;User&gt;, 通过该方法获取到的就是User)</span></span><br><span class="line"><span class="comment"> *   getOwnerType() 返回这个ParameterizedType所在类的Type(一般来说是空的)</span></span><br><span class="line"><span class="comment"> *   比如Map&lt;String, Object&gt;的getOwnerType=null,Map.Entry&lt;String,String&gt;的getOwnerType=Map)</span></span><br><span class="line"><span class="comment"> *   getRawType() 表示声明此类型的类或者接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/22 23:16:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Method method = TypeTest.class.getMethod(<span class="string">&quot;test&quot;</span>, Map.Entry.class, </span><br><span class="line">                                                 List.class, DataEntity.class);</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            System.out.println(parameterizedType.getOwnerType() + <span class="string">&quot; || &quot;</span> + </span><br><span class="line">                               parameterizedType.getRawType() + <span class="string">&quot; || &quot;</span> + </span><br><span class="line">                               Arrays.toString(parameterizedType.getActualTypeArguments()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface java.util.Map || interface java.util.Map$Entry || [class cn.com.xiaocainiaoya.entity.User, class java.lang.String]</span></span><br><span class="line"><span class="comment">//null || interface java.util.List || [class cn.com.xiaocainiaoya.entity.User]</span></span><br><span class="line"><span class="comment">//null || class cn.com.xiaocainiaoya.entity.DataEntity || [class //cn.com.xiaocainiaoya.entity.User]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Map.Entry&lt;User, String&gt; mapEntry, List&lt;User&gt; list, DataEntity&lt;User&gt; userDataEntity)</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Type接口&quot;&gt;&lt;a href=&quot;#Type接口&quot; class=&quot;headerlink&quot; title=&quot;Type接口&quot;&gt;&lt;/a&gt;Type接口&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h4&gt;&lt;p&gt;​    &lt;code&gt;Type&lt;/code&gt;接口是&lt;code&gt;Java&lt;/code&gt;中所有类型的公共高级接口，是由&lt;code&gt;JDK5&lt;/code&gt;引入，主要是为了实现参数化类型(泛型)，&lt;code&gt;Class&lt;/code&gt;类是该接口的直接实现类。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMvc请求参数的二次处理</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</id>
    <published>2021-06-21T14:20:58.000Z</published>
    <updated>2021-06-22T01:36:13.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMvc请求参数的二次处理"><a href="#SpringMvc请求参数的二次处理" class="headerlink" title="SpringMvc请求参数的二次处理"></a>SpringMvc请求参数的二次处理</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在一个项目中原来服务端是采用<code>WebService</code>的进行客户端和服务进行交互，现根据需要调整为直接使用<code>HHTP</code>方式访问。仅修改访问的方式，其数据的访问结构等不变。</p><span id="more"></span><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><h3 id="1-HandlerMethodArgumentResolver"><a href="#1-HandlerMethodArgumentResolver" class="headerlink" title="1.HandlerMethodArgumentResolver"></a>1.HandlerMethodArgumentResolver</h3><ol><li>原数据结构：在旧项目的设计中，<code>data</code>数据是采用<code>GBK</code>的<code>base64</code>编码，在本次改造中，希望同时将解码的过程也统一处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3033941769749731426L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ApiModelProperty(&quot;请求数据(basic64)&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第一时间想到的就是<code>SpringMvc</code>的参数处理器<code>HandlerMethodArgumentResolver</code>。直接上手开干。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义参数解析器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDateParamMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否支持本自定义参数解析器</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/06/21 22:09:57</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ModelAndViewContainer mavContainer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数解析器添加到spring容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDateParamMethodArgumentResolver <span class="title">requestDateParamMethodArgumentResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestDateParamMethodArgumentResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        argumentResolvers.add(requestDateParamMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.本以为可以完美解决，断点打在<code>resolveArgument</code>，正想启动后根据断点查询对应的参数信息，在进一步完善代码。测试发现，根本就没有进入断点。</p><p>4.虽说对参数解析器的执行过程不是非常的了解，但是大概知道参数解析器的处理是在适配器<code>Adapter</code>查找对应的<code>HandlerMethod</code>之后执行，所以根据调用栈，查找关键代码。</p><p><img src="https://i.loli.net/2021/06/21/qghUHGrXaeABRNp.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 所以在内置的很多参数处理器中，只会选择一种进行处理，由于上述的写法中没有自定义注解，</span></span><br><span class="line">   <span class="comment">// 尽管supportsParameter方法的返回值为true，用户自定义的参数处理器也是排在内置处理器之后。</span></span><br><span class="line">HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">result = resolver;</span><br><span class="line"><span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line"><span class="comment">// 获取到一种匹配的参数处理器之后就跳出了</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以：</strong>若需要使用参数处理器进行处理，需要自定义一个注解后，标记在方法的属性处，而改造的本意还是希望业务代码层无需关心解码这一行为，若需要在每个方法处都标记一个注解，与初衷相悖。</p><h3 id="2-InitBinder"><a href="#2-InitBinder" class="headerlink" title="2. @InitBinder"></a>2. @InitBinder</h3><p>这种方式是比较细粒度的控制方式，仅控制单个<code>Controller</code>，在这个<code>Controller</code>中，的参数会被拦截进行数据的二次处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentResolverController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder webDataBinder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(webDataBinder.getTarget() <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User)webDataBinder.getTarget();</span><br><span class="line">            log.info(user.getUsername());</span><br><span class="line">            user.setPassword(<span class="string">&quot;updatePassword&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;setUserInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 这里打印的password是updatePassword,是被修改之后的值, 所以解码可以放在@InitBinder中。</span></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;,&#123;&#125;&quot;</span>,user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-RequestBodyAdvice"><a href="#3-RequestBodyAdvice" class="headerlink" title="3. RequestBodyAdvice"></a>3. RequestBodyAdvice</h3><p>经过尝试<code>ArgumentAdvice</code>可以解决这个问题，通过<code>afterBodyRead</code>方法可以在参数解析器处理之后获取到对应的解析实体，再根据该实体的类型，进行<code>basic64</code>解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  请求参数增强处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/21 22:37:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;cn.com.xiaocainiaoya.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentAdvice</span> <span class="keyword">implements</span> <span class="title">RequestBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpInputMessage <span class="title">beforeBodyRead</span><span class="params">(HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">             MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">             Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">                                MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                                Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(body <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            ((User) body).setPassword(<span class="string">&quot;12312&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleEmptyBody</span><span class="params">(Object body, HttpInputMessage inputMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    虽然最后没有没有通过参数处理器来解决这个问题，但是在测试过程中也发现了自己对参数解析器的理解不足，原以为只要<code>supportsParameter</code>方法为<code>true</code>，就可以进行参数处理，而我在完善代码时只需要抽象一个顶层属性接口做是否是某种类型的判断即可。</p><p>​    <code>@InitBinder</code>和<code>RequestBodyAdvice</code>都是可取的方案，取决于需求是需全局(某个包下的所有<code>Controller</code>)的参数都需要进行某种统一处理，或者是仅仅只需针对某一个<code>Controller</code>进行参数处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringMvc请求参数的二次处理&quot;&gt;&lt;a href=&quot;#SpringMvc请求参数的二次处理&quot; class=&quot;headerlink&quot; title=&quot;SpringMvc请求参数的二次处理&quot;&gt;&lt;/a&gt;SpringMvc请求参数的二次处理&lt;/h1&gt;&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;在一个项目中原来服务端是采用&lt;code&gt;WebService&lt;/code&gt;的进行客户端和服务进行交互，现根据需要调整为直接使用&lt;code&gt;HHTP&lt;/code&gt;方式访问。仅修改访问的方式，其数据的访问结构等不变。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门笔记(二)</title>
    <link href="http://xiaocainiaoya.github.io/2021/05/16/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://xiaocainiaoya.github.io/2021/05/16/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</id>
    <published>2021-05-16T13:51:58.000Z</published>
    <updated>2021-05-16T14:18:46.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch入门笔记-二"><a href="#Elasticsearch入门笔记-二" class="headerlink" title="Elasticsearch入门笔记(二)"></a>Elasticsearch入门笔记(二)</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="1-1字符串类型"><a href="#1-1字符串类型" class="headerlink" title="1.1字符串类型"></a>1.1字符串类型</h4><h5 id="1-1-1-text"><a href="#1-1-1-text" class="headerlink" title="1.1.1 text"></a>1.1.1 text</h5><p>文本数据类型，使用之后该类型字段的值会被分词，生成倒排索引，用于全文检索。</p><span id="more"></span><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;, // 指定分词器</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;text&quot;,         // 设置类型为text</span></span><br><span class="line">        <span class="meta">&quot;fielddata&quot;</span>: <span class="string">true,      // 默认为false，该字段会启用内存空间进行一些排序、聚合操作</span></span><br><span class="line">        <span class="meta">&quot;fields&quot;</span>: <span class="string">&#123;             // 多类型，若某个字段既要满足能被搜索，又要满足能排序、聚合</span></span><br><span class="line">          <span class="meta">&quot;sort&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="1-1-2-keyword"><a href="#1-1-2-keyword" class="headerlink" title="1.1.2 keyword"></a>1.1.2 keyword</h5><p> 关键字类型，该字段不会被分词，只能按确切的值进行搜索，可以进行排序、聚合、过滤。一般使用在唯一性字段邮箱地址、<code>Mac</code>地址、身份证号之类不需要被分词的字段。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;ignore_above&quot;</span>: <span class="string">1024, // 指定查询的最大长度，超过则不会进行索引</span></span><br><span class="line">        <span class="meta">&quot;norms&quot;</span>: <span class="string">true         // 在进行查询评分时，是否需要考虑字段长度，默认为false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2数字类型"><a href="#1-2数字类型" class="headerlink" title="1.2数字类型"></a>1.2数字类型</h4><p>支持<code>long</code>、<code>integer</code>、<code>short</code>、<code>byte</code>、<code>double</code>、<code>float</code>、<code>half_float</code>(半精度浮点数)、<code>scaled_float</code>(带缩放因子浮点数)</p><p>scaled_float 举例：</p><p>在索引时会将原始值*缩放因子后四舍五入得到一个新值，将这个新值作为索引值(查询时返回的还是原值)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">      <span class="meta">&quot;price&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;,</span></span><br><span class="line">        <span class="meta">&quot;scaling_factor&quot;</span>: <span class="string">100  # 需指定缩放因子</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>添加两条数据</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">book/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">10.1111 # 实际的索引值为1011</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">book/_doc/2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">11.1111 # 实际的索引值为1111</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>查询语句</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">book/_doc/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;match&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;price&quot;</span>: <span class="string">11.2222 # 11.2222 * 100再四舍五入后的值为1122,匹配不到文档</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-3布尔类型"><a href="#1-3布尔类型" class="headerlink" title="1.3布尔类型"></a>1.3布尔类型</h4><p>布尔值，可以识别字符串的布尔值<code>&quot;true&quot;</code>，<code>&quot;false&quot;</code>，<code>true</code>，<code>false</code>。</p><h4 id="1-4日期类型"><a href="#1-4日期类型" class="headerlink" title="1.4日期类型"></a>1.4日期类型</h4><p>日期类型，由于在<code>json</code>中是没有具体的日期类型的表达，所以可以是日期格式化后的字符串，可以是毫秒数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date&quot;,</span></span><br><span class="line">        <span class="meta">&quot;format&quot;</span>: <span class="string">&quot;yyyy-mm-dd||yyyy/mm/dd||epoch_millis&quot; //指定了三种格式的日期</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;aaa&quot;,</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2021-11-14&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加失败，日期格式不对</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;aaa&quot;,</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2021-11-14 14:20:20&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-5范围类型"><a href="#1-5范围类型" class="headerlink" title="1.5范围类型"></a>1.5范围类型</h4><p>范围类型，表示一个区间，若指定该类型，字段值为一个对象。需使用到<code>gt</code>、<code>gle</code>、<code>lt</code>、<code>lte</code>等逻辑标识符表示。<code>integer_range</code>，<code>long_range</code>，<code>float_range</code>，<code>double_range</code>，<code>date_range</code>，<code>ip_range</code>(ip地址的范围)。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;price&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer_range&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">      <span class="meta">&quot;my_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date_range&quot;,</span></span><br><span class="line">        <span class="meta">&quot;format&quot;</span>: <span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;gt&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;lt&quot;</span>: <span class="string">10</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;my_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;gte&quot;</span>: <span class="string">&quot;2021-01-21&quot;,</span></span><br><span class="line">    <span class="meta">&quot;lte&quot;</span>: <span class="string">&quot;2021-05-22&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-6地理类型"><a href="#1-6地理类型" class="headerlink" title="1.6地理类型"></a>1.6地理类型</h4><h5 id="1-6-1-geo-point"><a href="#1-6-1-geo-point" class="headerlink" title="1.6.1 geo_point"></a>1.6.1 geo_point</h5><p>表示一个坐标点。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建点结构</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.通过对象指定经纬度</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lat&quot;</span>: <span class="string">30,</span></span><br><span class="line">    <span class="meta">&quot;lon&quot;</span>: <span class="string">108</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.通过字符串“经度,维度”指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&quot;30,108&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.通过geohash指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&quot;wmkf9t74wmkf&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.通过数组[维度, 经度]指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">[108, 30]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">map/_doc/1</span></span><br></pre></td></tr></table></figure><h5 id="1-6-2-geo-shape"><a href="#1-6-2-geo-shape" class="headerlink" title="1.6.2 geo_shape"></a>1.6.2 geo_shape</h5><p>地理形状数据类型，使用<code>geoJson</code>表示。</p><table><thead><tr><th>geoJson</th><th>ElasticSearch Type</th><th>描述</th></tr></thead><tbody><tr><td>Point</td><td>point</td><td>单个地理坐标</td></tr><tr><td>LineString</td><td>lineString</td><td>两点或多点组成任意线</td></tr><tr><td>Polygon</td><td>polygon</td><td>一个闭合的多边形，其第一个点和最后一个点必须匹配。因此需要n+1个顶点来创建一个n边多边形，且最少4个顶点(构成三角形)</td></tr><tr><td>MultiPoint</td><td>multipoint</td><td>一组未连接但可能相关的点</td></tr><tr><td>MultiLineString</td><td>multilinestring</td><td>一组独立的线</td></tr><tr><td>MultiPolygon</td><td>multipolygon</td><td>一组独立的多边形</td></tr><tr><td>N/A</td><td>envelope</td><td>通过仅指定左上角和右下角构成的边界矩形</td></tr><tr><td>N/A</td><td>circle</td><td>由中心点和半径指定的圆，默认单位为m</td></tr></tbody></table><p><strong>例子</strong></p><blockquote><p>在线制作geojson -&gt; <a href="http://geojson.io/">http://geojson.io/</a></p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. point 单坐标,由[维度, 经度]组成</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;point&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[108, 30]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. lineString 地理线</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">  <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;lineString&quot;,</span></span><br><span class="line">  <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="meta">[108,</span> <span class="string">30],</span></span><br><span class="line">    <span class="meta">[120,</span> <span class="string">30]</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. polygon 闭合多边形，首位需要一致</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">      <span class="meta">[108,</span> <span class="string">30],[120, 30],[120, 90],[108, 90],[108, 30]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个数组表示多边形外边界，第二个数组表示内边界</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[[106,28],[117,28],[117,34],[106,34],[106,28]],</span></span><br><span class="line">      <span class="attr">[[108,29],[115,29],[115,33],[108,33],[108,29]]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 4. multiPoint 多个点</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multiPoint&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="meta">[108,</span> <span class="string">30], [108, 31]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. multilinestring 多条线</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multilinestring&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="meta">[[108,</span> <span class="string">30],[120, 30]],</span></span><br><span class="line">      <span class="meta">[[109,</span> <span class="string">30],[121, 30]],</span></span><br><span class="line">      <span class="meta">[[110,</span> <span class="string">30],[122, 30]]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. multiPolygon 多个多边形</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multipolygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">      <span class="meta">[[108,</span> <span class="string">30],[120, 30],[120, 90],[108, 90],[108, 30]]</span></span><br><span class="line">      <span class="attr">],</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">        <span class="attr">[[106,28],[117,28],[117,34],[106,34],[106,28]],</span></span><br><span class="line">        <span class="attr">[[108,29],[115,29],[115,33],[108,33],[108,29]]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.envelope，指定形状的左上角和右下角的坐标，以表示边界矩形：</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;envelope&quot;,</span></span><br><span class="line">      <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[110,39],[114,37]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 8. circle，添加一个圆，指定半径和中心点坐标</span></span><br><span class="line"><span class="comment"># 好像6版本之后不支持circle了，插入报错 circle geometry is not supported</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;circle&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[110, 39],</span></span><br><span class="line">    <span class="meta">&quot;radius&quot;</span>: <span class="string">&quot;100km&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-7特殊类型"><a href="#1-7特殊类型" class="headerlink" title="1.7特殊类型"></a>1.7特殊类型</h4><h5 id="1-7-1-IP类型"><a href="#1-7-1-IP类型" class="headerlink" title="1.7.1 IP类型"></a>1.7.1 IP类型</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;ipAddress&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;ip&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address&quot;</span>:<span class="string">&quot;192.168.1.1&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 可以通过网段搜索</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;ipAddress&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-8复合类型"><a href="#1-8复合类型" class="headerlink" title="1.8复合类型"></a>1.8复合类型</h4><h5 id="1-8-1数组"><a href="#1-8-1数组" class="headerlink" title="1.8.1数组"></a>1.8.1数组</h5><p>默认情况下任何字段都可以包含一个或多个值，当包含多个值时，就表示是一个数组，唯一要求是数组中的每个值的类型一致，不指定的情况下，以第一个值的类型为准。</p><h5 id="1-8-2对象类型"><a href="#1-8-2对象类型" class="headerlink" title="1.8.2对象类型"></a>1.8.2对象类型</h5><p>一个文档的一个属性可以是一个对象，这个对象的某一个属性可以在包含一个对象。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;,</span></span><br><span class="line">  <span class="meta">&quot;class&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;一班&quot;,</span></span><br><span class="line">    <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;province&quot;</span>: <span class="string">&quot;福建省&quot;,</span></span><br><span class="line">      <span class="meta">&quot;city&quot;</span>: <span class="string">&quot;福州市&quot;,</span></span><br><span class="line">      <span class="meta">&quot;county&quot;</span>: <span class="string">&quot;闽侯县&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="1-8-3嵌套类型"><a href="#1-8-3嵌套类型" class="headerlink" title="1.8.3嵌套类型"></a>1.8.3嵌套类型</h5><p><code>nested</code>类型。若文档的属性是一个对象数组。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address&quot;</span>: <span class="string">[</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;id&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;福建&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;id&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>以上例子，若使用对象类型保存，由于<code>luncene</code>没有内部对象的概念，所以<code>es</code>会将以上数据扁平化为简单的字段和值列表。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address.id&quot;</span>: <span class="string">[1, 2],</span></span><br><span class="line">  <span class="meta">&quot;address.name&quot;</span>: <span class="string">[&quot;福建&quot;, &quot;北京&quot;]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>这时若查询语句为查找<code>id=2,name=&quot;福建&quot;</code>也会被查询到。使用<code>nested</code>类型之后，将数组中的每一个对象作为独立文档来索引。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;address.id&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;address.name&quot;</span>: <span class="string">&quot;福建&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;address.id&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;address.name&quot;</span>: <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-索引操作"><a href="#2-索引操作" class="headerlink" title="2.索引操作"></a>2.索引操作</h3><h4 id="2-1创建索引"><a href="#2-1创建索引" class="headerlink" title="2.1创建索引"></a>2.1创建索引</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/12/TfWvHkzdpNU8nO2.png"></p><h4 id="2-2删除索引"><a href="#2-2删除索引" class="headerlink" title="2.2删除索引"></a>2.2删除索引</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DELETE</span> <span class="string">library</span></span><br></pre></td></tr></table></figure><h4 id="2-3修改索引"><a href="#2-3修改索引" class="headerlink" title="2.3修改索引"></a>2.3修改索引</h4><p>可以修改索引的属性<code>Settings</code>，比如索引的分片数、副本数、路由、读写权限等。</p><p><strong>修改索引分片数和副本数都为2</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;settings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;number_of_shards&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;number_of_replicas&quot;</span>: <span class="string">2</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-4复制索引"><a href="#2-4复制索引" class="headerlink" title="2.4复制索引"></a>2.4复制索引</h4><p>复制索引时只会复制其中的数据，不会复制<code>setting</code>中的信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_reindex</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;source&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;dest&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library2&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-索引别名"><a href="#2-5-索引别名" class="headerlink" title="2.5 索引别名"></a>2.5 索引别名</h4><p>索引别名可以指向一个或者多个索引，也就是说多个索引可以共用一个别名。比如<code>library_log_20210514</code>和<code>library_log_20210515</code>两个索引都对它们设置索引别名为<code>library_log</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_aliases</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;actions&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_log_20210514&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_log&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_log_20210515&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_log&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置之后就可以通过一个名称来进行全文检索</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library_log/_search</span></span><br></pre></td></tr></table></figure><p><strong>通过别名创建视图</strong>，为<code>library</code>中作者是<code>tom</code>创建一个视图。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_aliases</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;actions&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_alias&quot;,</span></span><br><span class="line">        <span class="meta">&quot;filter&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">          <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>索引别名其实类似关系数据库中视图的概念，只提供读操作，不能进行写操作。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有别名</span></span><br><span class="line"><span class="attr">GET</span>  <span class="string">_cat/aliases</span></span><br></pre></td></tr></table></figure><p>在真是环境中，索引的设计不可能呢一步到位，随着需求、业务的扩展，可能会修改索引的<code>mapping</code>的字段类型、或者是<code>setting</code>中的配置信息，若简单采用<code>reindex</code>操作，在实施运维操作更新这段时间内，有可能导致数据不可访问，所以可以通过指定别名的方式进行索引迁移。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建新索引结构</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library_new</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"> <span class="meta">...</span> <span class="string">// 索引结构等等</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用reindex进行索引数据迁移</span></span><br><span class="line"><span class="attr">POST</span>  <span class="string">_reindex</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;source&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;dest&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_new&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后在修改索引别名</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">_aliases?pretty</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="attr">&quot;actions&quot;&quot;[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;remove&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_new&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-6关闭-开启索引"><a href="#2-6关闭-开启索引" class="headerlink" title="2.6关闭/开启索引"></a>2.6关闭/开启索引</h4><p>索引关闭后只能获取索引的<code>setting</code>信息，不能进行读写。</p><p>关闭索引：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">book/_close</span></span><br></pre></td></tr></table></figure><p>打开索引：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">book/_open</span></span><br></pre></td></tr></table></figure><h3 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h3><h4 id="3-1新增文档"><a href="#3-1新增文档" class="headerlink" title="3.1新增文档"></a>3.1新增文档</h4><p><code>6.*</code>版本之后一个索引只允许一个类型，所以路径上固定<code>索引名/_doc/id(可选)</code>，可以指定<code>id</code>，不指定会自动生成。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定id</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定id，由es生成</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c入门&quot;,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;marry&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>返回参数解析，其中<code>_shards</code>节点中<code>total</code>为2但是只有一个分片成功的原因是，我的环境是单机单节点，但是刚刚设置的时候又设置了两个分片，其实这种设置是不符合逻辑的。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;_index&quot;</span> : <span class="string">&quot;library&quot;,  // 对应的索引</span></span><br><span class="line">  <span class="meta">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;, // 文档类型</span></span><br><span class="line">  <span class="meta">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;, // 创建的文档id</span></span><br><span class="line">  <span class="meta">&quot;_version&quot;</span> : <span class="string">2, // 文档版本</span></span><br><span class="line">  <span class="meta">&quot;result&quot;</span> : <span class="string">&quot;created&quot;,  // 操作状态，有created、updated </span></span><br><span class="line">  <span class="meta">&quot;_shards&quot;</span> : <span class="string">&#123;          // 分片上的执行状态</span></span><br><span class="line">    <span class="meta">&quot;total&quot;</span> : <span class="string">2, // 分片数量</span></span><br><span class="line">    <span class="meta">&quot;successful&quot;</span> : <span class="string">1,    // 执行成功分片数量</span></span><br><span class="line">    <span class="meta">&quot;failed&quot;</span> : <span class="string">0         // 执行失败分片数量</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;_seq_no&quot;</span> : <span class="string">2,         // 索引写操作版本</span></span><br><span class="line">  <span class="meta">&quot;_primary_term&quot;</span> : <span class="string">1    // 文档所在分片</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>​    在<code>6.7</code>之前使用<code>_version</code>来做并发控制，每一个文档都维护各自的<code>_version</code>字段，每次多这个文档的写操作都会自增这个字段，当写操作之后<code>_version</code>字段进行自增后小于存储中的<code>_version</code>时，写操作所提交的内容会被拒绝。</p><p>​    在<code>6.7</code>之后使用<code>_seq_no</code>和<code>_primary_term</code>来做并发控制，<code>seq_no</code>类似于<code>_version</code>字段，但是它的生命周期是整个索引，而<code>_version</code>的生命周期是某一个文档。</p><h4 id="3-2修改文档"><a href="#3-2修改文档" class="headerlink" title="3.2修改文档"></a>3.2修改文档</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定id进行更新，这种更新会覆盖旧文档</span></span><br><span class="line"><span class="comment"># 原文档有name和author字段，经过以下更新后只剩name字段</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 更新指定字段</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">library/_update/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;script&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;,</span></span><br><span class="line"><span class="comment">    # 设置name为参数params中的name</span></span><br><span class="line">    <span class="meta">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.name=params.name&quot;,</span></span><br><span class="line">    <span class="meta">&quot;params&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>更新指定文档通过脚本的方式更新，<code>ctx</code>可以获取到上下对象，即通过<code>GET library/_doc/1</code>获取到的数据。上下文对象中的<code>_source</code>节点就是存储的数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;library&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;java入门&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过条件进行更新操作。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">library/_update_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;script&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;,</span></span><br><span class="line">    <span class="meta">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.name=params.name&quot;,</span></span><br><span class="line">    <span class="meta">&quot;params&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3删除文档"><a href="#3-3删除文档" class="headerlink" title="3.3删除文档"></a>3.3删除文档</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定文档</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">library/_doc/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据查询条件删除</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">library/_delete_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;value&quot;</span>: <span class="string">&quot;java&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-4批量操作"><a href="#3-4批量操作" class="headerlink" title="3.4批量操作"></a>3.4批量操作</h4><p>在<code>es</code>中通过<code>Bluk api</code>来执行批量操作。</p><p>1.可以通过<code>Kibana</code>来访问<code>Bluk</code>接口。批量操作的数据语法为一行操作(<code>auction</code>)，一行数据。</p><p>2.也可以通过请求直接执行。</p><blockquote><p>curl -XPOST “<a href="http://localhost:9200/library/_bulk&quot;">http://localhost:9200/library/_bulk&quot;</a> -H “content-type:application/json” –data-binary @es-pipeline.json</p></blockquote><p><strong>注意：</strong>结尾要空出一行。</p><p>否则会报错:</p><blockquote><p>{“error”:{“root_cause”:[{“type”:”illegal_argument_exception”,”reason”:”The bulk request must be terminated by a newline [\n]”}],”type”:”illegal_argument_exception”,”reason”:”The bulk request must be terminated by a newline [\n]”},”status”:400}%</p></blockquote><p><strong>注意：</strong>执行时需要添加<code>-H &quot;content-type:application/json&quot;</code></p><p>否则会报错</p><blockquote><p>{“error”:”Content-Type header [application/x-www-form-urlencoded] is not supported”,”status”:406}%</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_bulk</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;1&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;2&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;3&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;pyton入门&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-5查询文档"><a href="#3-5查询文档" class="headerlink" title="3.5查询文档"></a>3.5查询文档</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过id获取文档</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_doc/1</span></span><br></pre></td></tr></table></figure><h4 id="3-6-数据迁移"><a href="#3-6-数据迁移" class="headerlink" title="3.6 数据迁移"></a>3.6 数据迁移</h4><p>​    在别名那里顺便提了<code>reindex</code>，通过该关键字进行索引间的数据拷贝，只拷贝数据，不拷贝<code>mapping</code>和<code>setting</code>信息。</p><h3 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4. 关键字"></a>4. 关键字</h3><h5 id="4-1-analyzer-search-analyzer"><a href="#4-1-analyzer-search-analyzer" class="headerlink" title="4.1 analyzer/search_analyzer"></a>4.1 analyzer/search_analyzer</h5><p>通过<code>analyzer</code>指定分词器，在查询时若没有通过<code>search_analyzer</code>指定分词器，默认使用该索引的<code>analyzer</code>分词器来进行分词。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;decr&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>:<span class="string">&quot;text&quot;,</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;  // 指定分词器</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-normailizer"><a href="#4-2-normailizer" class="headerlink" title="4.2 normailizer"></a>4.2 normailizer</h5><p>预处理，在查询前进行数据预处理。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;settings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;analysis&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;normalizer&quot;</span>: <span class="string">&#123;               // 创建一个预处理</span></span><br><span class="line">        <span class="meta">&quot;lowerNor&quot;</span>: <span class="string">&#123;               // 创建一个名为lowerNor的预处理器</span></span><br><span class="line">          <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;,         // 类型为自定义</span></span><br><span class="line">          <span class="meta">&quot;filter&quot;</span>: <span class="string">[&quot;lowercase&quot;]   // 过滤器:大小写转换</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;, </span></span><br><span class="line">        <span class="meta">&quot;normalizer&quot;</span>: <span class="string">&quot;lowerNor&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-3-coerce"><a href="#4-3-coerce" class="headerlink" title="4.3 coerce"></a>4.3 coerce</h5><p>设置不进行类型转换。默认情况下，若指定字段类型为<code>integer</code>，插入数据时若插入为字符串<code>&quot;10&quot;</code>，也会插入成功。若不需要该类型自动转换，则标记该字段为<code>false</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;id&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;,</span></span><br><span class="line">        <span class="meta">&quot;coerce&quot;</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-4-enabled-index"><a href="#4-4-enabled-index" class="headerlink" title="4.4 enabled/index"></a>4.4 enabled/index</h5><p><code>enabled</code>表示若某字段仅存储，不需要进行全文检索。默认为<code>true</code>表示需要进行检索。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;enabled&quot;</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询结果为空</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><code>index</code>指定一个字段是否被索引。<code>true</code>表示字段会被索引。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date&quot;,</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2020&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接报错 </span></span><br><span class="line"><span class="comment"># failed to create query: Cannot search on field [publish_date] since it is not indexed.</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2020&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-5-ignore-above"><a href="#4-5-ignore-above" class="headerlink" title="4.5 ignore_above"></a>4.5 ignore_above</h5><p>用于<code>keyword</code>类型，表示指定分词和索引字符串的最大长度，超过该长度将不会被索引。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;,</span></span><br><span class="line">        <span class="meta">&quot;ignore_above&quot;</span>: <span class="string">10</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-6-ignore-malformed"><a href="#4-6-ignore-malformed" class="headerlink" title="4.6 ignore_malformed"></a>4.6 ignore_malformed</h5><p>忽略不匹配类型数据。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;,</span></span><br><span class="line">        <span class="meta">&quot;ignore_malformed&quot;</span>: <span class="string">true // 标记允许</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;abc&quot;       // 不是integer乐西</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">user/_doc/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_version&quot;</span> : <span class="string">1,</span></span><br><span class="line">  <span class="meta">&quot;_seq_no&quot;</span> : <span class="string">0,</span></span><br><span class="line">  <span class="meta">&quot;_primary_term&quot;</span> : <span class="string">1,</span></span><br><span class="line">  <span class="meta">&quot;_ignored&quot;</span> : <span class="string">[</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span></span><br><span class="line">  <span class="attr">],</span></span><br><span class="line">  <span class="meta">&quot;found&quot;</span> : <span class="string">true,</span></span><br><span class="line">  <span class="meta">&quot;_source&quot;</span> : <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span> : <span class="string">&quot;abc&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-7-null-value"><a href="#4-7-null-value" class="headerlink" title="4.7 null_value"></a>4.7 null_value</h5><p>在 <code>es </code>中，值为 <code>nul</code> 的字段不索引也不可以被搜索，<code>null_value</code> 可以让值为<code>null </code>的字段显式的可索引、可搜索。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;,</span></span><br><span class="line">        <span class="meta">&quot;null_value&quot;</span>: <span class="string">&quot;nameNull&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">null,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过null_value指定的值来进行查询。</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">users/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;nameNull&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-8-fields"><a href="#4-8-fields" class="headerlink" title="4.8 fields"></a>4.8 fields</h5><p><code>fields</code>参数可以让同一字段有多种不同的索引方式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;text&quot;,</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;, </span></span><br><span class="line">        <span class="meta">&quot;fields&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">          <span class="meta">&quot;raw&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>:<span class="string">&quot;这是一本中国人写的书&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;这是&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe.raw&quot;</span>: <span class="string">&quot;这是一本中国人写的书&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-9-Dynamic-templates"><a href="#4-9-Dynamic-templates" class="headerlink" title="4.9.Dynamic_templates"></a>4.9.Dynamic_templates</h5><p>映射模板，默认情况下，由<code>es</code>根据默认规则对数据进行预判对应的类型，若需要自定义规则，可以使用<code>Dynamic_templates</code>。</p><h5 id="4-10-dynamic"><a href="#4-10-dynamic" class="headerlink" title="4.10 dynamic"></a>4.10 dynamic</h5><p>用于检测新发现的字段。</p><ul><li>true: 默认，新发现的字段添加到映射中。</li><li>false: 必须显示指定新字段</li><li>strict:若检测到新字段，抛出异常。</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;dynamic&quot;</span>: <span class="string">false,</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;username&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Elasticsearch入门笔记-二&quot;&gt;&lt;a href=&quot;#Elasticsearch入门笔记-二&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch入门笔记(二)&quot;&gt;&lt;/a&gt;Elasticsearch入门笔记(二)&lt;/h1&gt;&lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1. 数据类型&quot;&gt;&lt;/a&gt;1. 数据类型&lt;/h3&gt;&lt;h4 id=&quot;1-1字符串类型&quot;&gt;&lt;a href=&quot;#1-1字符串类型&quot; class=&quot;headerlink&quot; title=&quot;1.1字符串类型&quot;&gt;&lt;/a&gt;1.1字符串类型&lt;/h4&gt;&lt;h5 id=&quot;1-1-1-text&quot;&gt;&lt;a href=&quot;#1-1-1-text&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 text&quot;&gt;&lt;/a&gt;1.1.1 text&lt;/h5&gt;&lt;p&gt;文本数据类型，使用之后该类型字段的值会被分词，生成倒排索引，用于全文检索。&lt;/p&gt;</summary>
    
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/categories/elasticsearch/"/>
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门笔记(一)</title>
    <link href="http://xiaocainiaoya.github.io/2021/05/10/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://xiaocainiaoya.github.io/2021/05/10/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2021-05-10T13:51:58.000Z</published>
    <updated>2021-05-16T14:08:43.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch入门笔记-一"><a href="#Elasticsearch入门笔记-一" class="headerlink" title="Elasticsearch入门笔记(一)"></a>Elasticsearch入门笔记(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在工作的中使用到部分<code>ElasticSearch</code>沾边的东西，<code>ELK</code>日志实时分析系统，对<code>ElasticSearch</code>也略有耳闻，趁着最近有时间学习一下，并将学习过程中知识点记录下来。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>ElasticSearch</code>是基于<code>Luncene</code>的分布式高性能的全文搜索引擎，<code>Luncene</code>是使用<code>java</code>开发的一个全文搜索引擎工具包，而<code>ElasticSearch</code>它将<code>Luncene</code>的复杂性对用户屏蔽，提供简单易用的<code>Restful Api</code>，开发者只需要使用该<code>api</code>接口就可以使用全文搜索。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​    我使用的是<code>mac</code>电脑，使用的是<code>docker desktop for mac</code>工具，通过<code>Kitematic</code>工具直接搜索了<code>elasticSearch</code>进行安装，我安装的镜像是<code>blacktop/elasticsearch</code>版本是<code>7.10.1</code>，它只挂载了<code>data</code>目录，我本地通过容器管理工具将<code>plugins</code>路径也挂载出来，方便添加分词器。</p><p>​    同时还需要使用到<code>google</code>插件<code>elasticsearch-head</code>便于查看数据等情况；同样使用了<code>docker</code>安装了<code>blacktop/kibana</code>镜像,<code>kibana</code>内置了解析器，对<code>es</code>的<code>restful api</code>有对应的支持。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-集群"><a href="#1-集群" class="headerlink" title="1. 集群"></a>1. 集群</h3><p>​    <code>es</code>本质上就是一个分布式系统，允许多台服务器协同工作，可以在一台服务上部署多个<code>es</code>实例，每一个实例称为一个节点。本想模拟单机多节点的集群情况，花了很多时间发现各个节点之间就是无法访问到，不知道主要原因是不是由于<code>macos</code>的容器机制，导致宿主机无法直接访问容器<code>ip</code>导致。</p><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><p>​    <code>es</code>的数据管理顶层单位称为索引<code>Index</code>，它类似于关系数据库中的库的概念，也就是每一个<code>Index</code>就是一个数据库，且规定<strong>名称必须为小写</strong>。</p><h3 id="3-类型"><a href="#3-类型" class="headerlink" title="3.类型"></a>3.类型</h3><p>​    索引<code>Index</code>下就是类型<code>Type</code>，类似于关系数据库中的表的概念，但是在<code>6.x</code>版本之后，一个<code>Index</code>值允许一个<code>Type</code>，所以类似于一个库中只允许一张表。</p><h3 id="4-文档"><a href="#4-文档" class="headerlink" title="4.文档"></a>4.文档</h3><p>​    <code>Type</code>下就是文档<code>Document</code>，一个<code>Type</code>包含多个<code>Document</code>，<code>document</code>类似于关系数据库中一行记录。</p><h3 id="5-分片"><a href="#5-分片" class="headerlink" title="5.分片"></a>5.分片</h3><p>​    <code>es</code>的数据是存储在节点上，每个索引的数据量不一样，需要的计算和处理数据的能力不一样，所以在创建每一个索引是可以同时创建的分片数，将数据处理分散到不同的节点。同时还分为主分片和副本分片，副本分片是主分片的一个备份，若主分片所在的节点宕机，启用改节点主分片的副本分片，所以主分片和副本分片将落在不同的节点。</p><p><strong>关系型数据库和es基本结构概念对比</strong></p><table><thead><tr><th>关系型数据库</th><th>es</th></tr></thead><tbody><tr><td>库</td><td>Index</td></tr><tr><td>表</td><td>Type</td></tr><tr><td>行</td><td>Document</td></tr><tr><td>一行中的某一列</td><td>Field(es是使用json表达数据)</td></tr><tr><td>索引</td><td>全文索引(这个地方有可能出现理解的误差，二者在各自结构中的意思都是加快查询数据的速度)</td></tr></tbody></table><h3 id="6-倒排索引"><a href="#6-倒排索引" class="headerlink" title="6.倒排索引"></a>6.倒排索引</h3><p>​    倒排索引是<code>es</code>中比较核心的一个概念，是指从文档的词项映射文档<code>ID</code>的一个过程。在关系型数据库中，一般采用的是正排索引，即从数据<code>ID</code>查询某个数据的关系。</p><p>比如有以下数据：</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>10</td><td>福建省福州市</td></tr><tr><td>2</td><td>李四</td><td>10</td><td>福建省莆田市</td></tr><tr><td>3</td><td>王五</td><td>30</td><td>福建省泉州市</td></tr><tr><td>4</td><td>赵六</td><td>30</td><td>湖南省长沙市</td></tr><tr><td>5</td><td>孙七</td><td>30</td><td>福建省南平市</td></tr><tr><td>6</td><td>钱八</td><td>60</td><td>浙江省杭州市</td></tr></tbody></table><p>以上就是正排索引，当知道某个人的<code>ID</code>就可以通过主键<code>ID</code>去获取这个人的年龄和地址信息。</p><p>倒排索引结构：</p><p><strong>age</strong>字段</p><table><thead><tr><th>词项Term</th><th>文档列表</th></tr></thead><tbody><tr><td>10</td><td>[1, 2]</td></tr><tr><td>30</td><td>[3, 4, 5]</td></tr><tr><td>60</td><td>6</td></tr></tbody></table><p><strong>address</strong>字段，当然这里的词项不一定只有<code>xx省</code>，也可以是<code>xx市</code>，这里只是简单举个例子。</p><table><thead><tr><th>词项Term</th><th>文档列表</th></tr></thead><tbody><tr><td>福建省</td><td>[1, 2, 3, 5]</td></tr><tr><td>湖南省</td><td>5</td></tr><tr><td>浙江省</td><td>6</td></tr></tbody></table><p>按以上的结构存储倒排索引之后，若需要查询福建省的所有人，就可以直接根据<code>福建省</code>的词项获取到<code>1,2,3,5</code>四个文档是符合条件，然后在结合正排索引，将这符合这四个<code>id</code>的文档找出。</p><p>​    当然了或许有人会说那不是直接<code>select * from table where address like %福建省%</code>就可以找出数据吗？在关系型数据库中模糊查询是无法命中索引的，也就是说模糊索引是需要全表扫描的，对于<code>es</code>的大数据定位而言是互斥的，所以增加倒排索引使得<code>es</code>的检索效率和性能显著提高。</p><h3 id="7-路由"><a href="#7-路由" class="headerlink" title="7.路由"></a>7.路由</h3><p>​    一个索引可以指定多个分片，且在多机的集群环境中，分片可能散落在不同的服务器上，在操作时可以将相关性数据存储在同一个分片上，提高检索效率。</p><blockquote><p>shard = hash(routing) % number_of_primary_shards</p><p>数据落在的分片编号 = 哈希函数(routing值)对分片数取余，默认routing值为文档id</p></blockquote><h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><p>​    分词器又叫分析器<code>Analyzer</code>，分词器的作用就是将文本经过分析之后转化为词项，在<code>es</code>搜索的最基本单元就是词项<code>Term</code>，通过词项来建立文档之间的映射。在<code>es</code>中又内置了多种基本的分词器，都是对英文的分词。</p><table><thead><tr><th>分词器</th><th>作用</th></tr></thead><tbody><tr><td>Standard Analyzer</td><td>英文标准分词器</td></tr><tr><td>Whitespace Analyzer</td><td>空格分词器</td></tr><tr><td>Pattern Analyzer</td><td>正则分词器</td></tr><tr><td>KeyWord Analyzer</td><td>关键词分词器</td></tr></tbody></table><p>目前使用的比较多的中文分词器应该是<code>elasticsearch-analysis-ik </code>，代码托管在<code>github</code>上，可以直接下载之后添加到<code>plugins</code>目录下。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Elasticsearch入门笔记-一&quot;&gt;&lt;a href=&quot;#Elasticsearch入门笔记-一&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch入门笔记(一)&quot;&gt;&lt;/a&gt;Elasticsearch入门笔记(一)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    在工作的中使用到部分&lt;code&gt;ElasticSearch&lt;/code&gt;沾边的东西，&lt;code&gt;ELK&lt;/code&gt;日志实时分析系统，对&lt;code&gt;ElasticSearch&lt;/code&gt;也略有耳闻，趁着最近有时间学习一下，并将学习过程中知识点记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/categories/elasticsearch/"/>
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>用户token互串问题</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/27/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%A8%E6%88%B7token%E4%BA%92%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/27/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%A8%E6%88%B7token%E4%BA%92%E4%B8%B2%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-27T14:20:58.000Z</published>
    <updated>2021-04-27T12:55:50.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户token互串问题"><a href="#用户token互串问题" class="headerlink" title="用户token互串问题"></a>用户token互串问题</h3><p><img src="https://i.loli.net/2021/04/27/4bWIrKcvBh2Go6Z.png"></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>昨天要下班时遭测试反馈说某个业务日志表中的数据的基础字段(创建人、修改人)信息有问题，赶紧过去看了一眼，发现确实有问题，那张业务表主要是A角色的操作，而表中最后的数据记录的是B角色的信息。项目采用<code>Oauth2</code>的方式进行认证，很容易就想到是否是<code>token</code>互串导致，因为基础字段是直接通过<code>token</code>信息进行存储，便于后期排查问题而已？</p><span id="more"></span><h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>在简单查看代码之后，业务日志表的数据操作是在某个回调通知后触发，而这个回调类似于定时器触发或者是外部应用触发，这种情况下是没有<code>token</code>信息，也就是说在<code>ThreadLocal</code>中并不存在<code>token</code>信息。而导致这个问题的关键是容器的线程复用。</p><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><p>1.简单搭建一个<code>springboot</code>工程，采用<code>undertow</code>容器。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.4.5&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    <span class="comment">// 排除tomcat</span></span><br><span class="line">    implementation.exclude <span class="attr">module:</span> <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    <span class="comment">// 添加undertow容器依赖</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-undertow&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testCompileOnly <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testAnnotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.设置<code>undertow</code>容器线程池大小为1，仅设置一个线程来处理请求。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================</span></span><br><span class="line"><span class="comment">#        undertow配置</span></span><br><span class="line"><span class="comment"># =============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io线程数,主要执行非阻塞的任务</span></span><br><span class="line"><span class="comment"># server.undertow.threads.io=16</span></span><br><span class="line"><span class="comment"># 阻塞任务的线程池中线程个数</span></span><br><span class="line"><span class="meta">server.undertow.threads.worker</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 每块buffer的空间大小</span></span><br><span class="line"><span class="comment"># server.undertow.buffer-size=1024</span></span><br><span class="line"><span class="comment"># 是否分配直接内存(NIO直接分配的堆外内存)</span></span><br><span class="line"><span class="comment"># server.undertow.direct-buffers=true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Integer&gt; ageThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/04/27 22:15:21</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;getUserName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(<span class="meta">@RequestParam(required = false)</span>Integer age, <span class="meta">@RequestParam(required = true)</span>String requestId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ageThreadLocal.set(age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 模拟业务逻辑处理</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; get age value = &#123;&#125;&quot;</span>,requestId, ageThreadLocal.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.打开两个<code>postman</code>，一个请求携带<code>age</code>参数，一个请求不携带<code>age</code>参数，让携带<code>age</code>参数的请求先执行。结果是两个请求都打印了<code>age</code>值。由日志结果可知，使用的是同一个线程<code>XNIO-1 task-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8080/user/getUserName?requestId=A&amp;age=10</span></span><br><span class="line"><span class="comment">// http://127.0.0.1:8080/user/getUserName?requestId=B</span></span><br><span class="line"><span class="comment">// 控制台d打印信息</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">48.731</span>  INFO <span class="number">7334</span> --- [XNIO-<span class="number">1</span> task-<span class="number">1</span>] c.e.demo.controller.UserController: B get age value = <span class="number">10</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">53.738</span>  INFO <span class="number">7334</span> --- [XNIO-<span class="number">1</span> task-<span class="number">1</span>] c.e.demo.controller.UserController: A get age value = <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    由于线程池的复用，在例子中第一个请求结束后将线程还给线程池，而下一次请求进来时从线程池中刚好获取了前一个请求的线程，而<code>ThreadLocal</code>本质就是一种空间换时间的并发做法，每个线程中开辟一块空间，使得其他线程无法访问，所以第二个请求获取到的线程变量有可能是未经过初始化产生的，而是第一个请求用剩下的。当然了，解决这个问题最简单的做法就是做一个拦截器，当请求进来时，不论是否有线程变量直接清空即可。<br>​    之前看了一篇文章写的是线程池中的线程异常问题，这里多说一嘴，例子中假如第一个请求将<code>age</code>保存到<code>ThreadLocal</code>中之后，由于<code>bug</code>导致产生了异常，这时第二个线程再请求是否能获取到<code>age</code>的值？答案是获取不到的，线程池中的线程出现异常后，工作线程(<code>worker</code>线程)会被销毁掉后重新创建线程，放置到线程池中，这时从线程池中获取的新线程的<code>ThreadLoal</code>不包含任何值。</p><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#105;&#97;&#111;&#99;&#x61;&#105;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;">&#x78;&#105;&#97;&#111;&#99;&#x61;&#105;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;用户token互串问题&quot;&gt;&lt;a href=&quot;#用户token互串问题&quot; class=&quot;headerlink&quot; title=&quot;用户token互串问题&quot;&gt;&lt;/a&gt;用户token互串问题&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/27/4bWIrKcvBh2Go6Z.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;昨天要下班时遭测试反馈说某个业务日志表中的数据的基础字段(创建人、修改人)信息有问题，赶紧过去看了一眼，发现确实有问题，那张业务表主要是A角色的操作，而表中最后的数据记录的是B角色的信息。项目采用&lt;code&gt;Oauth2&lt;/code&gt;的方式进行认证，很容易就想到是否是&lt;code&gt;token&lt;/code&gt;互串导致，因为基础字段是直接通过&lt;code&gt;token&lt;/code&gt;信息进行存储，便于后期排查问题而已？&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>git多账号配置</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/26/git/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/26/git/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2021-04-26T13:51:58.000Z</published>
    <updated>2021-04-26T13:08:53.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git多账号配置"><a href="#git多账号配置" class="headerlink" title="git多账号配置"></a>git多账号配置</h3><p>[TOC]</p><p><img src="https://i.loli.net/2021/04/26/joMvuTEkm7WZH3R.png" alt="Snipaste_2021-04-26_21-03-51.png"></p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    最近看了一些博客都是在推荐技术新人通过写博客的方式记录学习到的知识点和遇到的问题，好记性不如烂笔头，我也尝试开始写博客，在通过<code>github gitpage</code>搭建博客的时候发现需要在一台电脑中配置两个<code>git</code>账号，之前都是全局配置公司的<code>gitlib</code>账号。记录一下整个的配置过程，过程中也踩了不少坑。</p><span id="more"></span><h4 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h4><p>​    在电脑上配置两个<code>git</code>账号，一个是<code>gitlib</code>账号用来工作使用，一个是<code>github</code>账号用来博客推送。</p><h4 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h4><h5 id="3-1-清除全局配置"><a href="#3-1-清除全局配置" class="headerlink" title="3.1 清除全局配置"></a>3.1 清除全局配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看全局配置;若存在用户名和邮箱则清除</span></span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除全局用户名和邮箱</span></span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><h5 id="3-2-生成秘钥"><a href="#3-2-生成秘钥" class="headerlink" title="3.2 生成秘钥"></a>3.2 生成秘钥</h5><p>生成两个秘钥，一个用于公司工作，一个用于博客。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一路回车即可</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>我这边是把生成的两个秘钥对(总共四个文件)分类在两个文件夹下(<code>company</code>和<code>xiaocaioniaoya</code>)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">xiaocainiaoya@macBook-Pro-3&gt;</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line">xiaocainiaoya@macBook-Pro-3/.ssh&gt;ls</span><br><span class="line">company   config  known_hosts   xiaocainiaoya</span><br></pre></td></tr></table></figure><p>生成之后分别把<code>.pub</code>后缀公钥放置到远程服务器的<code>SSH keys</code>中。</p><h5 id="3-3-秘钥添加到本地"><a href="#3-3-秘钥添加到本地" class="headerlink" title="3.3 秘钥添加到本地"></a>3.3 秘钥添加到本地</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/company/id_rsa_company</span><br></pre></td></tr></table></figure><h5 id="3-4-创建config文件"><a href="#3-4-创建config文件" class="headerlink" title="3.4 创建config文件"></a>3.4 创建config文件</h5><p>一下是我的<code>config</code>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">公司的 gitlib</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Host 可以随便起,只是一个命名而已</span></span><br><span class="line">Host company</span><br><span class="line">HostName xx.xx.xx.xx:xxx</span><br><span class="line">User xxx</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绝对路径</span></span><br><span class="line">IdentityFile ~/.ssh/company/id_rsa_company</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> xiaocainiaoya github</span></span><br><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">User xiaocainiaoya</span><br><span class="line">IdentityFile ~/.ssh/xiaocainiaoya/id_rsa_xiaocainiaoya</span><br></pre></td></tr></table></figure><h5 id="3-5-测试是否可以连接"><a href="#3-5-测试是否可以连接" class="headerlink" title="3.5 测试是否可以连接"></a>3.5 测试是否可以连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接就是这个命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ssh -T git@github</span></span><br><span class="line">Hi xiaocainiaoya! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原来还以为要替换成自己的用户名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh -T xiaocainiaoya@github</span></span><br></pre></td></tr></table></figure><h5 id="3-6-配置local级别用户名和邮箱"><a href="#3-6-配置local级别用户名和邮箱" class="headerlink" title="3.6 配置local级别用户名和邮箱"></a>3.6 配置<code>local</code>级别用户名和邮箱</h5><p>由于本地配置了多账号，在提交时根据不同的地址采用不同的用户名和邮箱，所以需要进入到某个项目配置当前项目的用户名和邮箱信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &quot;xiaocainiaoya&quot;</span><br><span class="line">git config --local user.email &quot;xiaocainiaoya@foxmail.com&quot;</span><br></pre></td></tr></table></figure><h4 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h4><p>在配置完成之后，也测试可以提交之后没有太多关注具体的提交信息，在使用一段时间之后发现博客的提交记录中用户名是我的名字。由于用户名的级别<code>system</code>&gt;<code>global</code>&gt;<code>local</code>。在添加了<code>local</code>配置之后，后续提交的记录上用户名和邮箱正常了，那之前提交的那些用户名和邮箱怎么改？</p><p><strong>git filter-branch</strong></p><blockquote><p>git中最猛的后悔药，没有把握慎用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --commit-filter &#x27;</span><br><span class="line">        if [ &quot;$GIT_COMMITTER_NAME&quot; = &quot;已提交的用户名&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_COMMITTER_NAME=&quot;想要变成的用户名&quot;;</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;$GIT_COMMITTER_NAME&quot;;</span><br><span class="line">                GIT_COMMITTER_EMAIL=&quot;想要变成的邮箱&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;$GIT_COMMITTER_EMAIL&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&#x27; HEAD</span><br></pre></td></tr></table></figure><p>执行命令之后会发现用户名和邮箱都已经修改为想要变成的样子。再执行<strong>强制</strong>推向远程，要确保已经是最新的<code>HEAD</code>否则会覆盖他人编写的代码。(<code>HEAD</code>可以修改为<code>HEAD~5..HEAD</code>表示最近的5个提交)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure><p><code>git filter-branch</code>还有很多的其他的用法，有一个我觉得日常中可能会使用到的。</p><p>在某次提交时提交了某个大文件或者敏感文件，虽然可以在下次提交中删除该文件，或者把该文件添加到<code>.gitignore</code>中，但是如果回溯到某个提交时那个文件还是存在，现在想要将所有历史的提交中移出改文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 中间引号那一段是shell脚本</span></span><br><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch path&#x27; </span><br><span class="line">--prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><p><code>git filter-branch</code>执行之后都需要强制推向远程，可能会覆盖他人的提交，所以称为最猛的后悔药。</p><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#x69;&#x61;&#111;&#99;&#97;&#x69;&#x6e;&#105;&#x61;&#111;&#x79;&#97;&#64;&#102;&#111;&#120;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#x69;&#x61;&#111;&#99;&#97;&#x69;&#x6e;&#105;&#x61;&#111;&#x79;&#97;&#64;&#102;&#111;&#120;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;git多账号配置&quot;&gt;&lt;a href=&quot;#git多账号配置&quot; class=&quot;headerlink&quot; title=&quot;git多账号配置&quot;&gt;&lt;/a&gt;git多账号配置&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/26/joMvuTEkm7WZH3R.png&quot; alt=&quot;Snipaste_2021-04-26_21-03-51.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;​    最近看了一些博客都是在推荐技术新人通过写博客的方式记录学习到的知识点和遇到的问题，好记性不如烂笔头，我也尝试开始写博客，在通过&lt;code&gt;github gitpage&lt;/code&gt;搭建博客的时候发现需要在一台电脑中配置两个&lt;code&gt;git&lt;/code&gt;账号，之前都是全局配置公司的&lt;code&gt;gitlib&lt;/code&gt;账号。记录一下整个的配置过程，过程中也踩了不少坑。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>认识SpEL</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/</id>
    <published>2021-04-20T14:51:58.000Z</published>
    <updated>2021-04-24T15:40:41.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识SpEL表达式"><a href="#认识SpEL表达式" class="headerlink" title="认识SpEL表达式"></a>认识SpEL表达式</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>最近项目接入苞米豆的<code>lock4j</code>用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个<code>@Lock4j</code>注解并添加相应的参数即可，在使用中发现其中有一个属性<code>keys = &#123;&quot;#userId&quot;, &quot;#user.sex&quot;&#125;</code>，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过<code>SpEL</code>的方式解析参数信息。</p></blockquote><span id="more"></span><h4 id="SpEL概述"><a href="#SpEL概述" class="headerlink" title="SpEL概述"></a>SpEL概述</h4><p><code>Spring</code>表达式语言的全拼为<code>Spring Expression Language</code>，缩写为<code>SpEL</code>。并且<code>SpEL</code>属于<code>spring-core</code>模块，不直接与<code>Spring</code>绑定，是一个独立模块，不依赖于其他模块，可以单独使用。</p><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol><li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li><li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li><li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li></ol><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  Expression expression = parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>);</span><br><span class="line">  <span class="comment">// 计算求值</span></span><br><span class="line">  System.out.println(expression.getValue(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行一些简单的运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  <span class="comment">// 进行字符串的拼接</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>).getValue(String.class));</span><br><span class="line">  <span class="comment">// 简单的运算</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1+2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 简单的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1&gt;2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 稍微复杂一点的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;2&gt;1 and (!true)&quot;</span>).getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>ParseContext</code>对象设置自定义的解析规则</strong>：这里设置表达式的解析前缀为<code>#&#123;</code>解析后缀为<code>&#125;</code>，最后通过表达式对象<code>expression.getValue()</code>获取到表达式中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;#&#123;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  String template = <span class="string">&quot;#&#123;&#x27;Hello&#x27;&#125;#&#123;&#x27;World!&#x27;&#125;&quot;</span>;</span><br><span class="line">  Expression expression = parser.parseExpression(template, parserContext);</span><br><span class="line">  System.out.println(expression.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多不同的取值方式，比如参数(上下文)是个对象，获取这个对象中的某个属性；或者参数是一个<code>List</code>获取某一个索引值；又或者是一个<code>Map</code>对象，根据某个<code>Key</code>获取对应的值等等。</p><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>​    如果平时有使用<code>Spring</code>框架应该都会有用到比如<code>@Value</code>注解，就是通过<code>SpEL</code>方式进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取字符串tom </span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;tom&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取bean对象的属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;user.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在比如接触过<code>Spring Security</code>或者<code>Shiro</code>等身份验证和授权的框架中，对不同的角色有不同的接口权限，会使用到如下场景，其中对<code>@PreAuthorize(&quot;hasAuthority(&#39;ROLE_DMIN&#39;))</code>中<code>hasAuthority(&#39;ROLE_ADMIN&#39;)</code>就是通过<code>SpEL</code>进行参数解析后，对当前用户的角色进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拥有管理员权限可查看任何用户信息,否则只能查看自己的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;))</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/getUserById/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;SysUser&gt;&gt; getUserById(String userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(userFacade.getUserById(userId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>​    之前在项目中记录系统中一些敏感接口的请求日志信息，采用的是<code>AOP</code>的方式，在请求进入控制层之前拦截进入<code>AOP</code>的切面方法，但是记录的日志部分关键信息需要从请求的参数中获取，在之前的实现中是通过约定一种表达式，对应列表<code>List</code>、<code>Map</code>、<code>bean</code>对象的取值是自实现，且仅仅支持二级取值，确实在使用上有很大的缺陷。这种场景下，就可以使用<code>SpEL</code>进行方法参数解析，省了重复造轮子的过程，且使用上更为灵活。</p><p><strong><code>SpEL</code>结合<code>AOP</code>重构请求日志保存</strong>，这边只做简单的通过<code>SpEL</code>方式进行对象等取值处理，不考虑具体实际场景中的复杂业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:06:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;basic&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicVersionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;测试&quot;,notes=&quot;测试&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@ControllerMethodLog(name = &quot;测试保存请求日志&quot;, description = &quot;测试保存请求日志&quot;)</span></span><br><span class="line">    <span class="meta">@LogAssistParams(value=&#123;</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;projectName&quot;,objField=&quot;#bidProjectInfo.id&quot;),</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;id&quot;,objField=&quot;#bidProjectInfo.projectName&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestResponse&lt;BidPackageInvitationVo&gt; <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> ProjectInfo projectInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AOP</code>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:08:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTestLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OperationLogFacade operationLogFacade;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 此处的切点是注解的方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Pointcut(&quot;@annotation(cn.com.xiaocainiaoya.annotation.ControllerMethodLog)&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;operationLog()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      OperationLog operationLog = <span class="keyword">new</span> OperationLog();</span><br><span class="line">      operationLog.setStatus(<span class="number">1</span>);<span class="comment">// 默认调用成功，异常时修改为调用失败</span></span><br><span class="line"></span><br><span class="line">      Object thing = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行切入方法内容</span></span><br><span class="line">         thing = joinPoint.proceed();</span><br><span class="line">         operationLog.setOperEndTime(DateTime.now().toJdkDate());</span><br><span class="line">         <span class="keyword">return</span> thing;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         log.error(e.getMessage(), e);</span><br><span class="line">         operationLog.setStatus(<span class="number">0</span>);<span class="comment">//发生异常时定义为调用失败</span></span><br><span class="line">         operationLog.setResultContext(e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         insertOperationLog(operationLog, joinPoint, thing);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ParameterNameDiscoverer NAME_DISCOVERER = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *   插入操作日志</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span>: 2021/04/20 23:11:28</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> operationLog 日志基础信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> joinPoint 拦截切入点信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> thing 拦截函数返回值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertOperationLog</span><span class="params">(OperationLog operationLog, ProceedingJoinPoint joinPoint, Object thing)</span> </span>&#123;</span><br><span class="line">      MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">      ControllerMethodLog methodAnnotation = signature.getMethod().getAnnotation(ControllerMethodLog.class);</span><br><span class="line">      Api typeAnnotation = (Api) signature.getDeclaringType().getAnnotation(Api.class);</span><br><span class="line">      <span class="comment">//注释不完整不进行日志记录操作</span></span><br><span class="line">      <span class="keyword">if</span> (methodAnnotation == <span class="keyword">null</span> || typeAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParams logAssistParams = signature.getMethod().getAnnotation(LogAssistParams.class);</span><br><span class="line">      <span class="keyword">if</span>(methodAnnotation == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParam[] assistParams = logAssistParams.value();</span><br><span class="line">      <span class="keyword">if</span>(ObjectUtil.isNull(assistParams) || assistParams.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; assistParams.length; i++)&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 重点在这，通过MethodBasedEvaluationContext构建解析器ExpressionParser的上下文, 底层逻辑也是通过ParameterNameDiscoverer反射获取对应的属性值</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         EvaluationContext context = <span class="keyword">new</span> MethodBasedEvaluationContext((Object) <span class="keyword">null</span>, signature.getMethod(), joinPoint.getArgs(), NAME_DISCOVERER);</span><br><span class="line">         String value = (String)PARSER.parseExpression(assistParams[i].objField()).getValue(context);</span><br><span class="line">         ReflectUtil.setFieldValue(operationLog, assistParams[i].logField(), value);</span><br><span class="line">      &#125;</span><br><span class="line">      operationLogFacade.insertSelective(operationLog);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#x69;&#97;&#111;&#x63;&#97;&#x69;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#64;&#x66;&#x6f;&#x78;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#x78;&#x69;&#97;&#111;&#x63;&#97;&#x69;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#64;&#x66;&#x6f;&#x78;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识SpEL表达式&quot;&gt;&lt;a href=&quot;#认识SpEL表达式&quot; class=&quot;headerlink&quot; title=&quot;认识SpEL表达式&quot;&gt;&lt;/a&gt;认识SpEL表达式&lt;/h3&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;最近项目接入苞米豆的&lt;code&gt;lock4j&lt;/code&gt;用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个&lt;code&gt;@Lock4j&lt;/code&gt;注解并添加相应的参数即可，在使用中发现其中有一个属性&lt;code&gt;keys = &amp;#123;&amp;quot;#userId&amp;quot;, &amp;quot;#user.sex&amp;quot;&amp;#125;&lt;/code&gt;，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过&lt;code&gt;SpEL&lt;/code&gt;的方式解析参数信息。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="SpEL" scheme="http://xiaocainiaoya.github.io/tags/SpEL/"/>
    
  </entry>
  
  <entry>
    <title>this调用导致注解未生效问题</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/</id>
    <published>2021-04-16T15:04:58.000Z</published>
    <updated>2021-04-23T11:42:56.332Z</updated>
    
    <content type="html"><![CDATA[<h4 id="动态代理导致注解未生效"><a href="#动态代理导致注解未生效" class="headerlink" title="动态代理导致注解未生效"></a>动态代理导致注解未生效</h4><p>​    今天在使用<code>mybatis-plus</code>作者苞米豆的另一个项目<code>lock4j</code>用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。</p><p>​    <code>lock4j</code>和<code>mybatis-plus</code>差不多，秉承着人性化使用的初衷，<code>lock4j</code>使用上还是非常简单的，只需要在需要上锁的接口方法上使用<code>@Lock4j</code>进行标记并设置一些简单的超时参数即可。</p><p>​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用<code>ReentrantLock</code>)，所以改造时仅仅只是对改接口上添加<code>@Lock4j</code>注解。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveInfo</span><span class="params">(String userId)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 很多业务逻辑的处理 </span></span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">this</span>.finalSaveEffective(userId);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Lock4j(keys = &#123;&quot;#userId&quot;&#125;, expire = &quot;18000&quot;, acquireTimeout = &quot;10000&quot;,</span></span><br><span class="line"><span class="meta">        keyBuilder = DefaultKeyBuilder.class)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finalSaveEffective</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//reentrantLock.lock();</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    checkInfo(..);</span><br><span class="line">    mapper.insert(..);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    log.error(e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(e.getMessage());</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//reentrantLock.unlock();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    跑起来测试后发现根本没有进入到对<code>@Lock4j</code>处理的代理方法中，马上反应到这不是和常见<code>@Transaction</code>的坑一样，不能使用<code>this.xxx</code>的方式调用，修改代码后启动，果然正常上锁，那么为什么<code>this.xxx</code>会导致异常？</p><p>​    为了知其所以然，不再盲猜硬记，我决定结合<code>@Transaction</code>注解去了解底层的机制。</p><p>​    在<code>spring</code>中的<code>aop</code>说白了就是通过动态代理实现，而动态代理有两种实现方式(<code>jdk</code>动态代理和<code>cglib</code>动态代理)。这里简单模拟一下两种动态代理的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶层接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:30:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 10:28 下午</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserFacade</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUserInfo();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入用户信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockAnnotation</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询图书信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:32:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MockAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-jdk动态代理"><a href="#1-jdk动态代理" class="headerlink" title="1. jdk动态代理"></a>1. jdk动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理的形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:33:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass()</span><br><span class="line">          .getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">            .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeJdkProxy proxy = <span class="keyword">new</span> UserFacadeJdkProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade) proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeJdkProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure><h5 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2.cglib动态代理"></a>2.cglib动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cglib方式代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:34:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">                .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">//return methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invoke(target, args);</span><br><span class="line">        <span class="comment">//Object result = methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeCglibProxy proxy = <span class="keyword">new</span> UserFacadeCglibProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade)proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeCglibProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure><p>由以上可得出结论：不论是通过哪一种动态代理实现<code>AOP</code>，使用<code>this.xxx</code>的写法都无法使得注解生效。且如果注解标记的方法为<code>final</code>或者是<code>private</code>方法也是不能进入代理方法，原因是<code>jdk</code>动态代理是基于接口代理、<code>cglib</code>动态代理是基于继承的方式，不论是那种方式的动态代理的代理对象其实都是无法进入<code>target</code>的私有方法和<code>final</code>方法。所以根据以上动态代理可以得出结论，通过<code>this.xxx</code>的方式调用本类接口是通过被代理对象直接调用本类接口，而不是通过代理对象，也就无法进入对应的<code>invoke</code>方法或者是<code>intercept</code>方法，从而无法解析到对应的注解，如果觉得将<code>this.xxx</code>修改为<code>A</code>类调用<code>B</code>类，代码需要被迫转移到其他类影响理解，在实际中可以通过<code>ApplicationContextUtil</code>的方式获取一次代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.getUserInfo(); 修改为一下写法</span></span><br><span class="line">UserFacade userFacade = ApplicationContextUtil.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userFacade.getUserInfo();</span><br></pre></td></tr></table></figure><p>但是，好玩的来了，注意看<code>UserFacadeCglibProxy</code>类中有两行注释，采用的是<code>methodProxy.invokeSuper(o, args);</code>的方式调用，运行之后可以发现通过<code>this.xxx</code>的方式竟然可以进入<code>invoice()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :UserFacadeCglibProxy.main()</span><br><span class="line">进入调用方法</span><br><span class="line">进入调用方法</span><br><span class="line">aop某方法的前置处理</span><br><span class="line">查询图书信息</span><br><span class="line">aop某方法的后置处理</span><br><span class="line">插入用户信息</span><br></pre></td></tr></table></figure><p>这边简单对这两个调用进行一个区别：</p><p><code>methodProxy.invoke(target, args)</code>的整个执行过程为：</p><ol><li>客户端调用了代理对象的<code>insertUserInfo()</code>方法</li><li>进入代理对象的<code>intercept</code>方法</li><li>通过<code>methodProxy.invoke(target, args)</code>执行被代理对象的<code>insertUserInfo()</code></li><li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是被代理对象，所以调用时不会触发<code>intercept</code>方法</li><li>调用结束</li></ol><p><code>methodProxy.invokeSuper(o, args)</code>的整个执行过程为：</p><ol><li>客户端调用了代理对象<code>insertUserInfo()</code>方法</li><li>进入代理对象的<code>intercept</code>方法</li><li>通过<code>methodProxy.invokeSuper(o, args)</code>进入被代理对象的<code>insertUserInfo()</code></li><li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是代理对象，所以<code>getUserInfo()</code>会再次触发<code>intercept()</code></li><li>进入被代理对象的<code>getUserInfo()</code></li><li>调用结束</li></ol><p>所以最终作怪的是<code>this</code>，这个<code>this</code>代表的是代理对象(<code>proxy</code>)还是被代理对象(<code>target</code>)。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;动态代理导致注解未生效&quot;&gt;&lt;a href=&quot;#动态代理导致注解未生效&quot; class=&quot;headerlink&quot; title=&quot;动态代理导致注解未生效&quot;&gt;&lt;/a&gt;动态代理导致注解未生效&lt;/h4&gt;&lt;p&gt;​    今天在使用&lt;code&gt;mybatis-plus&lt;/code&gt;作者苞米豆的另一个项目&lt;code&gt;lock4j&lt;/code&gt;用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;lock4j&lt;/code&gt;和&lt;code&gt;mybatis-plus&lt;/code&gt;差不多，秉承着人性化使用的初衷，&lt;code&gt;lock4j&lt;/code&gt;使用上还是非常简单的，只需要在需要上锁的接口方法上使用&lt;code&gt;@Lock4j&lt;/code&gt;进行标记并设置一些简单的超时参数即可。&lt;/p&gt;
&lt;p&gt;​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用&lt;code&gt;ReentrantLock&lt;/code&gt;)，所以改造时仅仅只是对改接口上添加&lt;code&gt;@Lock4j&lt;/code&gt;注解。&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title>rabbitmq交换机类型不同导致异常</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/14/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/mq%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/14/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/mq%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8/</id>
    <published>2021-04-14T14:20:58.000Z</published>
    <updated>2021-04-14T14:39:46.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="rabbitmq交换机类型不同导致异常"><a href="#rabbitmq交换机类型不同导致异常" class="headerlink" title="rabbitmq交换机类型不同导致异常"></a>rabbitmq交换机类型不同导致异常</h4><p>​    今天收到预生产环境测试人员的消息说项目启动失败，看了一下错误是<code>rabbitmq</code>的队列监听抛出找不到该队列，没有道理，逻辑上已经经过了测试环境的测试没有理由犯这么低级的错误。吓得我赶紧看去看了一下预生产环境的<code>apollo</code>配置信息(我们使用的<code>mq</code>厂商随环境的不同可能不同)，配置信息也是对的；赶紧再次核对一下错误日志，发启动时创建交换机还有另外的报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-04-14 16:58:23.014 [AMQP Connection 192.168.2.16:5672] ERROR o.s.a.r.c.CachingConnectionFactory-Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &#x27;type&#x27; for exchange &#x27;xxxxx&#x27; in vhost &#x27;/&#x27;: received &#x27;topic&#x27; but current is &#x27;fanout&#x27;, class-id=40, method-id=10)</span><br></pre></td></tr></table></figure><p>大概的意思是已经存在该名称为<code>fanout</code>类型交换机不允许改变为<code>topic</code>类型交换机。</p><span id="more"></span><p>为什么会导致这个问题？</p><p>由于数据之间的解耦传输是由两个团队处理，A团队负责发送消息，B团队负责接收消息。沟通中没有交流清楚细节导致。</p><blockquote><p>A团队创建<code>fanout</code>类型且名称为<code>PUSH_INFO_EXCHANGE</code>的交换机</p><p>B团队创建<code>topic</code>类型且名称为<code>PUSH_INFO_EXCHANGE</code>的交换机，<code>routeKey</code>为空串，队列名称为<code>RECEIVE_INFO_QUEUE</code>。</p></blockquote><p>这就导致，AB团队同时提测，如果先启动了B服务，则<code>rabbitmq</code>创建了一个名为<code>PUSH_INFO_EXCHANGE</code>类型为广播的交换机，并绑定在<code>RECEIVE_INFO_QUEUE</code>队列上；这时如果启动A服务，在<code>RabbitMq</code>中，一旦创建了交换机是不允许改变的，所以A服务的创建是不会成功，但有意思的是，A服务推送数据时，是可以找到这个交换机，且通过空串路由键B服务可以接收到相应的数据，这样也就是导致在测试环境中没有发现这个异常的原因。而在预生产环境中，严格按照先启动A服务后再启动B服务进行就抛出了开头的异常信息。</p><p>不要问为什么AB团队都创建了同名的交换机，如果这时A的业务场景有需要将某个队列绑定到这个交换机呢？</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;rabbitmq交换机类型不同导致异常&quot;&gt;&lt;a href=&quot;#rabbitmq交换机类型不同导致异常&quot; class=&quot;headerlink&quot; title=&quot;rabbitmq交换机类型不同导致异常&quot;&gt;&lt;/a&gt;rabbitmq交换机类型不同导致异常&lt;/h4&gt;&lt;p&gt;​    今天收到预生产环境测试人员的消息说项目启动失败，看了一下错误是&lt;code&gt;rabbitmq&lt;/code&gt;的队列监听抛出找不到该队列，没有道理，逻辑上已经经过了测试环境的测试没有理由犯这么低级的错误。吓得我赶紧看去看了一下预生产环境的&lt;code&gt;apollo&lt;/code&gt;配置信息(我们使用的&lt;code&gt;mq&lt;/code&gt;厂商随环境的不同可能不同)，配置信息也是对的；赶紧再次核对一下错误日志，发启动时创建交换机还有另外的报错：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2021-04-14 16:58:23.014 [AMQP Connection 192.168.2.16:5672] ERROR o.s.a.r.c.CachingConnectionFactory-Channel shutdown: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &amp;#x27;type&amp;#x27; for exchange &amp;#x27;xxxxx&amp;#x27; in vhost &amp;#x27;/&amp;#x27;: received &amp;#x27;topic&amp;#x27; but current is &amp;#x27;fanout&amp;#x27;, class-id=40, method-id=10)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;大概的意思是已经存在该名称为&lt;code&gt;fanout&lt;/code&gt;类型交换机不允许改变为&lt;code&gt;topic&lt;/code&gt;类型交换机。&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="rabbitmq" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot的jar包如何启动</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/Spring/SpringBoot%E7%9A%84jar%E5%8C%85%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/Spring/SpringBoot%E7%9A%84jar%E5%8C%85%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T07:38:35.109Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SpringBoot的jar包如何启动"><a href="#SpringBoot的jar包如何启动" class="headerlink" title="SpringBoot的jar包如何启动"></a>SpringBoot的jar包如何启动</h4><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>​    使用过<code>SprongBoot</code>打过<code>jar</code>包的都应该知道，目标文件一般都会生成两个文件，一个是以<code>.jar</code>的包，一个是<code>.jar.original</code>文件。那么使用<code>SpringBoot</code>会打出两个包，而<code>.jar.original</code>的作用是什么呢？还有就是<code>java -jar</code>是如何将一个<code>SpringBoot</code>项目启动，之间都进行了那些的操作？</p><p>​    其实<code>.jar.original</code>是<code>maven</code>在<code>SpringBoot</code>重新打包之前的原始<code>jar</code>包，内部只包含了项目的用户类，不包含其他的依赖<code>jar</code>包，生成之后，<code>SpringBoot</code>重新打包之后，最后生成<code>.jar</code>包，内部包含了原始<code>jar</code>包以及其他的引用依赖。以下提及的<code>jar</code>包都是<code>SpringBoot</code>二次加工打的包。</p><span id="more"></span><h4 id="二、jar包的内部结构"><a href="#二、jar包的内部结构" class="headerlink" title="二、jar包的内部结构"></a>二、jar包的内部结构</h4><blockquote><p><code>SpringBoot</code>打出的<code>jar</code>包，可以直接通过解压的方式查看内部的构造。一般情况下有三个目录。</p></blockquote><ul><li><code>BOOT-INF</code>：这个文件夹下有两个文件夹<code>classes</code>用来存放用户类，也就是原始<code>jar.original</code>里的类；还有一个是<code>lib</code>，就是这个原始<code>jar.original</code>引用的依赖。</li><li><code>META-INF</code>：这里是通过<code>java -jar</code>启动的入口信息，记录了入口类的位置等信息。</li><li><code>org</code>:<code>Springboot loader</code>的代码，通过它来启动。</li></ul><p><strong>这里主要介绍一下<code>/BOOT-INF/MANIFEST.MF</code>文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="meta">Implementation-Title</span>: <span class="string">springboot-server</span></span><br><span class="line"><span class="meta">Implementation-Version</span>: <span class="string">0.0.1-SNAPSHOT</span></span><br><span class="line"><span class="meta">Archiver-Version</span>: <span class="string">Plexus Archiver</span></span><br><span class="line"><span class="meta">Built-By</span>: <span class="string">Administrator</span></span><br><span class="line"><span class="meta">Implementation-Vendor-Id</span>: <span class="string">cn.com.springboot</span></span><br><span class="line"><span class="meta">Spring-Boot-Version</span>: <span class="string">1.5.13.RELEASE</span></span><br><span class="line"><span class="meta">Implementation-Vendor</span>: <span class="string">Pivotal Software, Inc.</span></span><br><span class="line"><span class="meta">Main-Class</span>: <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"><span class="meta">Start-Class</span>: <span class="string">cn.com.springboot.center.AuthEenterBootstrap</span></span><br><span class="line"><span class="meta">Spring-Boot-Classes</span>: <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="meta">Spring-Boot-Lib</span>: <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="meta">Created-By</span>: <span class="string">Apache Maven 3.6.1</span></span><br><span class="line"><span class="meta">Build-Jdk</span>: <span class="string">1.8.0_241</span></span><br><span class="line"><span class="meta">Implementation-URL</span>: <span class="string">http://projects.spring.io/spring-boot/auth-server/</span></span><br></pre></td></tr></table></figure><p>**<code>Main-Class</code>**：记录了<code>java -jar</code>的启动入口，当使用该命令启动时就会调用这个入口类的<code>main</code>方法，显然可以看出，<code>Springboot</code>转移了启动的入口，不是用户编写的<code>xxx.xxx.BootStrap</code>的那个入口类。</p><p>**<code>Start-Class</code>**：记录了用户编写的<code>xxx.xxx.BootStrap</code>的那个入口类，当内嵌的<code>jar</code>包加载完成之后，会使用<code>LaunchedURLClassLoader</code>线程加载类来加载这个用户编写的入口类。</p><h4 id="三、加载过程"><a href="#三、加载过程" class="headerlink" title="三、加载过程"></a>三、加载过程</h4><h5 id="1-使用到的一些类"><a href="#1-使用到的一些类" class="headerlink" title="1.使用到的一些类"></a>1.使用到的一些类</h5><p><strong>3.1.1 Archive</strong></p><p>​    归档文件接口，实现迭代器接口，它有两个子类，一个是<code>JarFileArchive</code>对<code>jar</code>包文件使用，提供了返回这个<code>jar</code>文件对应的<code>url</code>、或者这个<code>jar</code>文件的<code>MANIFEST</code>文件数据信息等操作。是<code>ExplodedArchive</code>是文件目录的使用也有获取这个目录<code>url</code>的方法，以及获取这个目录下的所有<code>Archive</code>文件方法。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1faa8d1fb220b5b1b466cd0b27d62e30.png"></p><p><strong>3.1.2 Launcher</strong></p><p>​    启动程序的基类，这边最后是通过<code>JarLauncher#main()</code>来启动。<code>ExecutableArchiveLauncher</code>是抽象类，提供了获取<code>Start-Class</code>类路径的方法，以及是否还有内嵌对应文件的判断方法和获取到内嵌对应文件集合的后置处理方法的抽象，由子类<code>JarLauncher</code>和<code>WarLauncher</code>自行实现。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d5ef4fccc5146602dccccc0c53b4e074.png"></p><p><strong>3.1.3 Spring.loader下的JarFile和JarEntry</strong></p><p>​    <code>jarFile</code>继承于<code>jar.util.jar.JarFile</code>，<code>JarEntry</code>继承于<code>java.util.jar.JarEntry</code>，对原始的一些方法进行重写覆盖。每一个<code>JarFileArchive</code>都拥有一个<code>JarFile</code>方法，用于存储这个<code>jar</code>包对应的文件，而每一个<code>JarFile</code>都有一个<code>JarFileEntries</code>,<code>JarFileEntries</code>是一个迭代器。总的来说，在解析<code>jar</code>包时，会将<code>jar</code>包内的文件封装成<code>JarEntry</code>对象后由<code>JarFile</code>对象保存文件列表的迭代器。所以<code>JarFileArchive</code>和<code>JarFileEntries</code>之间是通过<code>JarFile</code>连接，二者都可以获取到<code>JarFile</code>对象。</p><h5 id="2-过程分析"><a href="#2-过程分析" class="headerlink" title="2.过程分析"></a>2.过程分析</h5><p>从<code>MANIFEST.MF</code>文件中的<code>Main-class</code>指向入口开始。</p><p>创建<code>JarLauncher</code>并且通过它的<code>launch()</code>方法开始加载<code>jar</code>包内部信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarLauncher</code>的空构造方法时一个空实现，刚开始看的时候还懵了一下，以为是在后续的操作中去加载的文件，其实不然，在创建时由父类<code>ExecutableArchiveLauncher</code>的构造方法去加载的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutableArchiveLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载为归档文件对象</span></span><br><span class="line">    <span class="keyword">this</span>.archive = createArchive();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的加载方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">  CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">  URI location = (codeSource == <span class="keyword">null</span> ? <span class="keyword">null</span> : codeSource.getLocation().toURI());</span><br><span class="line">  String path = (location == <span class="keyword">null</span> ? <span class="keyword">null</span> : location.getSchemeSpecificPart());</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to determine code source archive&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  File root = <span class="keyword">new</span> File(path);</span><br><span class="line">  <span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;Unable to determine code source archive from &quot;</span> + root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断路径是否是一个文件夹，是则返回ExplodedArchive对象，否则返回JarFileArchive</span></span><br><span class="line">  <span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root): <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== JarFileArchive =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFileArchive</span> <span class="keyword">implements</span> <span class="title">Archive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFileArchive</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(file, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFileArchive</span><span class="params">(File file, URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过这个new方法创建JarFile对象</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> JarFile(file));</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== JarFile =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFile</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">jar</span>.<span class="title">JarFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RandomAccessDataFile读取文件信息</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> RandomAccessDataFile(file));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jarLauncher#launch()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 注册URL协议的处理器，没有指定时，默认指向org.springframework.boot.loader包路径</span></span><br><span class="line">  JarFile.registerUrlProtocolHandler();</span><br><span class="line">  <span class="comment">// 获取类路径下的归档文件Archive并通过这些归档文件的URL，创建线程上下文类加载器LaunchedURLClassLoader</span></span><br><span class="line">  ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">  <span class="comment">// 使用类加载器和用户编写的启动入口类，通过反射调用它的main方法。</span></span><br><span class="line">  launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarLauncher</code>的<code>getClassPathArchives()</code>是在<code>ExecutableArchiveLauncher</code>中实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Archive&gt; <span class="title">getClassPathArchives</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  List&lt;Archive&gt; archives = <span class="keyword">new</span> ArrayList&lt;Archive&gt;(</span><br><span class="line">    <span class="comment">// 获取归档文件中满足EntryFilterg过滤器的项，isNestedArchive()方法由具体</span></span><br><span class="line">    <span class="comment">// 的之类实现。</span></span><br><span class="line">    <span class="keyword">this</span>.archive.getNestedArchives(<span class="keyword">new</span> EntryFilter() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isNestedArchive(entry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;));</span><br><span class="line">  <span class="comment">// 获取到当前归档文件下的所有子归档文件之后的后置操作，是一个扩展点。在JarLauncher</span></span><br><span class="line">  <span class="comment">// 中是一个空实现。</span></span><br><span class="line">  postProcessClassPathArchives(archives);</span><br><span class="line">  <span class="keyword">return</span> archives;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JarLauncher的具体实现，这里通过判断是否在BOOT-INF/lib/包下返回true</span></span><br><span class="line"><span class="comment"> * 也就是说只会把jar包下的BOOT-INF/lib/下的文件加载为Archive对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarFileArchive</code>的<code>getNestedArchives</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Archive&gt; <span class="title">getNestedArchives</span><span class="params">(EntryFilter filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">List&lt;Archive&gt; nestedArchives = <span class="keyword">new</span> ArrayList&lt;Archive&gt;();</span><br><span class="line"><span class="keyword">for</span> (Entry entry : <span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">// 若匹配器匹配获取内嵌归档文件</span></span><br><span class="line"><span class="keyword">if</span> (filter.matches(entry)) &#123;</span><br><span class="line">nestedArchives.add(getNestedArchive(entry));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Collections.unmodifiableList(nestedArchives);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Archive <span class="title">getNestedArchive</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">JarEntry jarEntry = ((JarFileEntry) entry).getJarEntry();</span><br><span class="line"><span class="keyword">if</span> (jarEntry.getComment().startsWith(UNPACK_MARKER)) &#123;</span><br><span class="line"><span class="keyword">return</span> getUnpackedNestedArchive(jarEntry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 根据具体的Entry对象，创建JarFile对象</span></span><br><span class="line">JarFile jarFile = <span class="keyword">this</span>.jarFile.getNestedJarFile(jarEntry);</span><br><span class="line"><span class="comment">// 封装成归档文件对象后返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JarFileArchive(jarFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get nested  entry&quot;</span>+entry.getName(),ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> JarFile <span class="title">getNestedJarFile</span><span class="params">(<span class="keyword">final</span> ZipEntry entry)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getNestedJarFile((JarEntry) entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> JarFile <span class="title">getNestedJarFile</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 根据具体的Entry对象，创建JarFile对象</span></span><br><span class="line"> <span class="keyword">return</span> createJarFileFromEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException( <span class="string">&quot;Unable to open nested jar file&#x27;&quot;</span>+entry.getName()+<span class="string">&quot;&#x27;&quot;</span>,ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JarFile <span class="title">createJarFileFromEntry</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span> createJarFileFromDirectoryEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createJarFileFromFileEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JarFile <span class="title">createJarFileFromFileEntry</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (entry.getMethod() != ZipEntry.STORED) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to open nested entry &#x27;&quot;</span></span><br><span class="line">  + entry.getName() + <span class="string">&quot;&#x27;. It has been compressed and nested &quot;</span></span><br><span class="line">  + <span class="string">&quot;jar files must be stored without compression. Please check the &quot;</span></span><br><span class="line">   + <span class="string">&quot;mechanism used to create your executable jar file&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取到参数entry对应的RandomAccessData对象</span></span><br><span class="line">RandomAccessData entryData = <span class="keyword">this</span>.entries.getEntryData(entry.getName());</span><br><span class="line"><span class="comment">// 这里根据springboot扩展的url协议，在父路径的基础上添加!/来标记子包</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JarFile(<span class="keyword">this</span>.rootFile, <span class="keyword">this</span>.pathFromRoot + <span class="string">&quot;!/&quot;</span> + entry.getName(),</span><br><span class="line">                   entryData, JarFileType.NESTED_JAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这基本上读取<code>jar</code>内部信息，加载为对应归档文件对象的大概过程已经讲完了，接下来分析一下在获取到了整个<code>jar</code>的归档文件对象后的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过归档文件对象列表，获取对应的url信息，并通过url信息创建LaunchedURLClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(List&lt;Archive&gt; archives)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;(archives.size());</span><br><span class="line"><span class="keyword">for</span> (Archive archive : archives) &#123;</span><br><span class="line">urls.add(archive.getUrl());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createClassLoader(urls.toArray(<span class="keyword">new</span> URL[urls.size()]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(URL[] urls)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LaunchedURLClassLoader(urls, getClass().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到对应的<code>LaunchedUrlClassLoader</code>类加载器之后，设置线程的上下文类加载器为该加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line"><span class="comment">// 根据MANIFI.MF文件中的start-classs信息创建项目启动入口主类对象，并通过run方法启动</span></span><br><span class="line">createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== MainMethodRunner ================</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mainClassName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainMethodRunner</span><span class="params">(String mainClass, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mainClassName = mainClass;</span><br><span class="line"><span class="keyword">this</span>.args = (args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args.clone());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">.loadClass(<span class="keyword">this</span>.mainClassName);</span><br><span class="line">    <span class="comment">// 通过反射调用启动项目启动类的main方法</span></span><br><span class="line">Method mainMethod = mainClass.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来说一下这个<code>LaunchedURLClassLoader</code>，它继承于<code>URLClassLoader</code>，并重写了<code>loadClass</code>方法</p><p><code>LaunchedClassLoader</code>的<code>loadClass</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   Handler.setUseFastConnectionExceptions(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         definePackageIfNecessary(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (getPackage(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Package &quot;</span> + name + <span class="string">&quot; has already been &quot;</span></span><br><span class="line">                  + <span class="string">&quot;defined but it could not be found&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 调用父类loadClass方法，走正常委派流程，最终会被LaunchURLClassLoader</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      Handler.setUseFastConnectionExceptions(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============URLClassLoader =====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)<span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = AccessController.doPrivileged(</span><br><span class="line">      <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">          <span class="comment">// 根据name，将路径转化为以.class结尾的/分隔的格式。</span></span><br><span class="line">          String path = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">          <span class="comment">// 通过UrlClassPath对象根据路径获取资源类文件</span></span><br><span class="line">          Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, acc);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    <code>Springboot</code>主要实现了对<code>URL</code>加载方式进行了扩展，并且对一些对象<code>Archive</code>、<code>JarFile</code>、<code>Entry</code>等进行了抽象和扩展，最后使用<code>LaunchedUrlClassLoader</code>来进行处理。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;SpringBoot的jar包如何启动&quot;&gt;&lt;a href=&quot;#SpringBoot的jar包如何启动&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot的jar包如何启动&quot;&gt;&lt;/a&gt;SpringBoot的jar包如何启动&lt;/h4&gt;&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;​    使用过&lt;code&gt;SprongBoot&lt;/code&gt;打过&lt;code&gt;jar&lt;/code&gt;包的都应该知道，目标文件一般都会生成两个文件，一个是以&lt;code&gt;.jar&lt;/code&gt;的包，一个是&lt;code&gt;.jar.original&lt;/code&gt;文件。那么使用&lt;code&gt;SpringBoot&lt;/code&gt;会打出两个包，而&lt;code&gt;.jar.original&lt;/code&gt;的作用是什么呢？还有就是&lt;code&gt;java -jar&lt;/code&gt;是如何将一个&lt;code&gt;SpringBoot&lt;/code&gt;项目启动，之间都进行了那些的操作？&lt;/p&gt;
&lt;p&gt;​    其实&lt;code&gt;.jar.original&lt;/code&gt;是&lt;code&gt;maven&lt;/code&gt;在&lt;code&gt;SpringBoot&lt;/code&gt;重新打包之前的原始&lt;code&gt;jar&lt;/code&gt;包，内部只包含了项目的用户类，不包含其他的依赖&lt;code&gt;jar&lt;/code&gt;包，生成之后，&lt;code&gt;SpringBoot&lt;/code&gt;重新打包之后，最后生成&lt;code&gt;.jar&lt;/code&gt;包，内部包含了原始&lt;code&gt;jar&lt;/code&gt;包以及其他的引用依赖。以下提及的&lt;code&gt;jar&lt;/code&gt;包都是&lt;code&gt;SpringBoot&lt;/code&gt;二次加工打的包。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springboot" scheme="http://xiaocainiaoya.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>java的泛型</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/java%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/java%E7%9A%84%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-23T12:04:45.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java的泛型"><a href="#java的泛型" class="headerlink" title="java的泛型"></a>java的泛型</h3><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    泛型实现了参数化类型的概念，使代码可以应用于多种类型，设计的初衷应该是希望类或者方法能够具备最广泛的表达能力。在引入泛型之前，一般都是依赖于<code>Object</code>顶层对象实现类似泛型的功能，但是使用<code>Object</code>有一个缺陷是如果类型转换异常，编译器在编译期无法检测这种异常，只有在字节码的运行时期才会抛出类型转换异常。而<code>JDK 1.5</code>之后引入的泛型，在编译期就会对类型进行检查，使得问题可以及早发现。</p><span id="more"></span><h4 id="二、泛型方式"><a href="#二、泛型方式" class="headerlink" title="二、泛型方式"></a>二、泛型方式</h4><h5 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h5><blockquote><p>泛型类的写法是在类上指明参数，并在属性或者方法中使用。</p></blockquote><p>先来看一下在没有泛型之前的操作方式，采用<code>Object</code>的方式，使得调用点获取到这个对象，如果需要获取到对象自身实现的某个方法，就需要进行强制类型装换，所以可能会出现类型装换异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object animal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再泛型引入之后采用如下方式，调用点在通过<code>get</code>方法获取到对象时，直接是调用点设置的参数类型，所以无需进行强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T animal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2.泛型接口"></a>2.泛型接口</h5><blockquote><p>泛型也可以应用于接口，使用上与泛型类类似。</p></blockquote><p>泛型接口对调用点来说有两种方式，一种是实现类指定了参数类型，则调用点无需再参数化类型；另一种是实现类依旧采用泛型的方式继承，则调用点就需要参数化类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">implements</span> <span class="title">People</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;display: &quot;</span>+ str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;display:&quot;</span>+t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3.泛型方法"></a>3.泛型方法</h5><blockquote><p>泛型也可以应用于方法上，并且这个方法对应的类可以是泛型类也可以不是泛型类。定义泛型方法只需要将泛型列表置于返回值之前。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt;  <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式的类型说明：</strong>对泛型方法的调用，可以显式的指明类型，语法是在点操作符与方法名之间插入尖括号，然后将类型置于尖括号中，这种方式广泛用于静态方法，使用<code>tk.mybatis</code>过都知道<code>Example</code>中创建的静态泛型方法，笔者刚开始进入公司写的时候都是按部就班，不知道泛型方法的具体逻辑，学了泛型才知道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ========= WeekendSqls ============</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeekendSqls</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SqlsCriteria</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">WeekendSqls&lt;T&gt; <span class="title">custom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeekendSqls();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  WeekendSqls&lt;People&gt; weekendSql = WeekendSqls.&lt;People&gt;custom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、泛型擦除"><a href="#三、泛型擦除" class="headerlink" title="三、泛型擦除"></a>三、泛型擦除</h4><blockquote><p>java的泛型是使用擦除来实现的，所以在真正运行的时候，任何具体的类型都会被擦除，唯一知道的是，在使用某一对象，所以对以下例子而言，最后的输出结果为<code>true</code>，类型都为<code>java.util.ArrayList</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">  Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">  System.out.println(<span class="string">&quot;c1的类型为:&quot;</span> + c1 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;c2的类型为&quot;</span> + c2);</span><br><span class="line">  System.out.println( c1 == c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-泛型数组"><a href="#1-泛型数组" class="headerlink" title="1. 泛型数组"></a>1. 泛型数组</h5><p>由于<code>Class&lt;T&gt;</code>在运行时已经被擦除，实际的结果为<code>Class</code>，而通过这个没有指定类型<code>Class</code>的<code>newInstance</code>方法不会产生具体的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.kind = kind;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T[] create(<span class="keyword">int</span> size)&#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayMaker&lt;String&gt; stringArrayMaker =  <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">    String[] stringArray = stringArrayMaker.create(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// 这里的输出结果为 [null, null, null, null, null, null, null, null, null]  </span></span><br><span class="line">    System.out.println(Arrays.toString(stringArray));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 在编译时期是Generic&lt;Integer&gt;[]，在运行时期可以理解为Object[]</span></span><br><span class="line">  <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时只会报警告，运行时会抛出类型装换异常，因为从Object[]转Generic&lt;Integer&gt;[]</span></span><br><span class="line">    <span class="comment">// gia = (Generic&lt;Integer&gt;[]) new Object[SIZE];</span></span><br><span class="line">    <span class="comment">// 由于是Generic&lt;Integer&gt;[]强转Object[]，所以运行正常。</span></span><br><span class="line">    gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个更复杂一点的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从编译器层面来说，创建数组强制装换为T[]，只会报警告</span></span><br><span class="line">    <span class="comment">// 从运行层面来说，Object[]强制装换为Object[]，正常行为</span></span><br><span class="line">    array = (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span></span>&#123;</span><br><span class="line">    array[index] = item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从编译器层面来说，获取到T[]赋值为Object[],正常行为</span></span><br><span class="line">    <span class="comment">// 从运行层面来说，Object[]赋值为Object[]，正常行为</span></span><br><span class="line">    Object[] oa = gai.rep();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的例子，在实际的编写代码中要考虑到编译器层面和运行层面，对编译器来说，需要保证类型的异常转换都在编译时期通过警告或者编译不通过的方式提示用户；对运行层面来说，由于参数化类型已经被擦除，有可能会导致出现类型转换异常。总之一句话，编译器在编译时就是尽可能的做类型检查，前置了异常的抛出时机，避免所有的类型转换异常都在运行时期抛出。</p><h5 id="2-边界"><a href="#2-边界" class="headerlink" title="2.边界"></a>2.边界</h5><p><strong>2.1上界</strong></p><blockquote><p>泛型上界采用<code>&lt;? extends T&gt;</code>表示当前泛型参数只能由<code>T</code>类型的子类构成。</p></blockquote><p><code>&lt;? extends T&gt;</code>指明了这个泛型类参数化类型的参数的只能是<code>T</code>的子类，且会影响到泛型类中<strong>入参</strong>为参数化类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="title">extend</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T item;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Plate&lt;? extends Fruit&gt; plate = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  <span class="comment">// 两个set方法均报错，由于限定了参数化类型的上界，而对于Fruit来说有很多子类</span></span><br><span class="line">  <span class="comment">// 编译器在这时不知道应该使用哪个类来创建引用。</span></span><br><span class="line">  plate.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  plate.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">  </span><br><span class="line">  Fruit f = plate.get();</span><br><span class="line">  <span class="comment">// 报错，只能通过上界类获取引用</span></span><br><span class="line">  Apple a = plate.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2下界</strong></p><blockquote><p>泛型下界采用<code>&lt;? super T&gt;</code>表示当前泛型的参数只能有<code>T</code>类型的父类构成。</p></blockquote><p><code>&lt;? super T&gt;</code>指明了这个泛型类参数化类型的参数的只能是<code>T</code>的父类，且会影响到泛型类中<strong>返回值</strong>为参数化类型的方法。还是上面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Plate&lt;? <span class="keyword">super</span> Fruit&gt; pf = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Fruit());</span><br><span class="line">  <span class="comment">// 由于限定参数类型为Fruit的超类，所以添加的元素只要是Fruit以及Fruit的</span></span><br><span class="line">  <span class="comment">// 子类都会成功</span></span><br><span class="line">  pf.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Fruit());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错，由于限定参数为Fruit的超类，不能用Fruit来引用，当然了就算是Food也不行</span></span><br><span class="line">  Fruit ff = pf.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3无界(<code>?</code>通配符)</strong></p><blockquote><p><code>?</code>称为无界通配符，表示的是一种未知类型，所以一般如果采用了<code>?</code>定义一个泛型，对其调用的是与具体类型无关的方法。最常用的应该是<code>Class&lt;?&gt;</code>，因为就算是使用泛型<code>Class&lt;T&gt;</code>也并没有依赖于<code>T</code></p></blockquote><p>如果看过<code>jdk</code>容器相关的源码，都应该知道在容器中有很多的方法都采用这种写法，即无需关心具体的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c.isEmpty(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?</code>表示的未知类型，相比于<code>Object</code>应该来说是一个更大的概念，所以<code>List&lt;?&gt; != List&lt;Object&gt;</code>，并且<code>List&lt;Object&gt;</code>不能指向<code>List&lt;?&gt;</code>的引用；而<code>List&lt;?&gt;</code>可以指向<code>List&lt;Object&gt;</code>的引用。</p><p>但是有一点需要注意若<code>List&lt;?&gt;</code>指向<code>List&lt;Object&gt;</code>之后，由于类型是未知的，所以<code>List</code>中使用泛型的方法都不能使用，也就是<code>add(E e)</code>不能使用，编译器报错；而<code>remove(Object o)</code>参数没有使用泛型，则可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objects = list;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;?&gt; list = objects;</span><br></pre></td></tr></table></figure><p><strong>2.4 小结</strong></p><p>​    不论使用哪种边界，对于存在<code>?</code>来说，表示的都是未知类型，所以在使用上下界处理时要精准的知道类型之间的继承关系，上下界对<strong>入参</strong>参数化类型和<strong>返回值</strong>参数类型行为上的区别，并且在合适的场景可以进行添加操作，合适的场景可以进行获取操作。根据<code>PECS(Producer Extends Consumer Super)</code>原则，频繁读取操作，适合使用上界<code>extends</code>，频繁插入操作，适合使用下界<code>Super</code>。</p><p><strong>2.5 不使用通过符<code>?</code>的上下界</strong></p><blockquote><p>形如<T extends Fruit>或者是<T Super Fruit>，这种方式在声明处就指定了参数化类型的值。</p></blockquote><p>修改<code>Plate</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T item;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在声明处指定参数化类型的值</span></span><br><span class="line">  Plate&lt;Fruit&gt; pf = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Fruit());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处声明参数化类型的值为Apple</span></span><br><span class="line">  Plate&lt;Apple&gt; pa = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  pa.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  <span class="comment">// 编译报错，指定只能传入Apple对象</span></span><br><span class="line">  pa.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h4><h5 id="1-基本数据类型不能作为类型参数"><a href="#1-基本数据类型不能作为类型参数" class="headerlink" title="1. 基本数据类型不能作为类型参数"></a>1. 基本数据类型不能作为类型参数</h5><p>​    在泛型中不能使用基本数据类型作为类型的参数，也就是不允许<code>ArrayList&lt;int&gt;</code>的方式，只能通过<code>java</code>的自动装箱拆箱机制，使用<code>ArrayList&lt;Integer&gt;</code>来实现。</p><h5 id="2-重载问题"><a href="#2-重载问题" class="headerlink" title="2.重载问题"></a>2.重载问题</h5><p>​    当出现多个参数化类型时，由于类型擦除的原因，重载的方法实际产生的是一样类型签名，所以不能产生不同类型的参数列表，必须提供明显有区别的方法名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">    <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k)</span></span>&#123;key = k;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-自限定的泛型"><a href="#3-自限定的泛型" class="headerlink" title="3. 自限定的泛型"></a>3. 自限定的泛型</h5><p>自限定泛型强调的是创建这个类所使用的参数与这个类具有相同的类型。感觉有点绕，下面看一下<code>java</code>编程思想中的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自限定声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; </span><br><span class="line">  T element;</span><br><span class="line">  <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自限定类型的使用就两种方式，就是以下两种方式。</span></span><br><span class="line"><span class="comment"> * 1. 这边为了引入概念来说明，标记class之后的A为A1，尖括号中的A为A2</span></span><br><span class="line"><span class="comment"> *    创建的这个类A1所使用的参数A2与这个类A1具有相同的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2. 由于A已经继承了SelfBounded&lt;A&gt;，所以B可以直接继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// It&#x27;s OK.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; set(arg); <span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125; // [Compile error]: Type parameter D is not within its bound</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.set(<span class="keyword">new</span> A());</span><br><span class="line">    a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">    a = a.get();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Enum</code>的设计正是采用泛型自限定的方式。<code>Enum</code>的泛型限定了<code>E</code>的上界为<code>Enum</code>自身，确保了<code>Enum</code>的子类才能作为泛型参数，而在枚举中<code>compareTo(E o)</code>，在比较时，希望的是传入的参数类型就是<code>Enum</code>类型。所以这种设计使得方法中传入参数和返回的方法是与创建的类型保持继承关系，也就是说<code>E extends Enum&lt;E&gt;</code>保证<code>Enum&lt;E&gt;</code>的子类，比如<code>StatusEnum</code>枚举类都能够接收或者返回其本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;java的泛型&quot;&gt;&lt;a href=&quot;#java的泛型&quot; class=&quot;headerlink&quot; title=&quot;java的泛型&quot;&gt;&lt;/a&gt;java的泛型&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h4&gt;&lt;p&gt;​    泛型实现了参数化类型的概念，使代码可以应用于多种类型，设计的初衷应该是希望类或者方法能够具备最广泛的表达能力。在引入泛型之前，一般都是依赖于&lt;code&gt;Object&lt;/code&gt;顶层对象实现类似泛型的功能，但是使用&lt;code&gt;Object&lt;/code&gt;有一个缺陷是如果类型转换异常，编译器在编译期无法检测这种异常，只有在字节码的运行时期才会抛出类型转换异常。而&lt;code&gt;JDK 1.5&lt;/code&gt;之后引入的泛型，在编译期就会对类型进行检查，使得问题可以及早发现。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok的@SneakyThrows详解</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/Spring/lombok%E7%9A%84@SneakyThrows%E8%AF%A6%E8%A7%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/Spring/lombok%E7%9A%84@SneakyThrows%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:09:17.706Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Lombok的-SneakyThrows详解"><a href="#Lombok的-SneakyThrows详解" class="headerlink" title="Lombok的@SneakyThrows详解"></a>Lombok的@SneakyThrows详解</h4><p>[TOC]</p><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>​    在<code>java</code>的异常体系中<code>Exception</code>异常有两个分支，一个是运行时异常<code>RuntimeException</code>，一个是编译时异常，在<code>Exception</code>下的所有非<code>RuntimeException</code>异常，比如<code>IOException</code>、<code>SQLException</code>等；所有的运行时异常不捕获，编译时异常是一定要捕获，否则编译会报错。<code>@SneakyThrows</code>就是利用了这一机制，将当前方法抛出的异常，包装成<code>RuntimeException</code>，骗过编译器，使得调用点可以不用显示处理异常信息。</p><span id="more"></span><h4 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若不使用@SneakyThrows注解，newInsstance方法会要求抛出InstantiationException, </span></span><br><span class="line"><span class="comment"> * IllegalAccessException异常，且调用sneakyThrowsTest()的地方需要捕获这些异常，</span></span><br><span class="line"><span class="comment"> * 加上@SneakyThrows注解之后就不需要捕获异常信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SneakyThrowsDemo.class.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如下为反编译之后的结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HelloController.class.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="comment">// 调用Lombok方法转化为RuntimeException</span></span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== ombok =========</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">sneakyThrow</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Lombok.&lt;RuntimeException&gt;sneakyThrow0(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个方法是关键，这里对入参类型的约束为&lt;T extends Throwable&gt;，而调用点将异常强转为</span></span><br><span class="line"><span class="comment"> * RuntimeException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function">T <span class="title">sneakyThrow0</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> (T)t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，为什么这个地方可以对原来的异常进行强转为<code>RuntimeExcption</code>？以下为直接强转的代码，显然运行之后报类型转换异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="comment">// 直接将e强转为RuntimeException，运行到这里会报类型转换异常。</span></span><br><span class="line">    <span class="keyword">throw</span> (RuntimeException)e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这种做法是一种通过泛型欺骗了编译器，让编译器在编译期不报错(报警告)，而最后在<code>JVM</code>虚拟机中执行的字节码的并没有区别编译时异常和运行时异常，只有是不是和抛不抛异常而已。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Lombok的-SneakyThrows详解&quot;&gt;&lt;a href=&quot;#Lombok的-SneakyThrows详解&quot; class=&quot;headerlink&quot; title=&quot;Lombok的@SneakyThrows详解&quot;&gt;&lt;/a&gt;Lombok的@SneakyThrows详解&lt;/h4&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h4&gt;&lt;p&gt;​    在&lt;code&gt;java&lt;/code&gt;的异常体系中&lt;code&gt;Exception&lt;/code&gt;异常有两个分支，一个是运行时异常&lt;code&gt;RuntimeException&lt;/code&gt;，一个是编译时异常，在&lt;code&gt;Exception&lt;/code&gt;下的所有非&lt;code&gt;RuntimeException&lt;/code&gt;异常，比如&lt;code&gt;IOException&lt;/code&gt;、&lt;code&gt;SQLException&lt;/code&gt;等；所有的运行时异常不捕获，编译时异常是一定要捕获，否则编译会报错。&lt;code&gt;@SneakyThrows&lt;/code&gt;就是利用了这一机制，将当前方法抛出的异常，包装成&lt;code&gt;RuntimeException&lt;/code&gt;，骗过编译器，使得调用点可以不用显示处理异常信息。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>从myBatis Plugin看责任链模式</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:07:05.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从myBatis-Plugin看责任链模式"><a href="#从myBatis-Plugin看责任链模式" class="headerlink" title="从myBatis Plugin看责任链模式"></a>从myBatis Plugin看责任链模式</h3><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    在<code>mybatis</code>中从<code>sql</code>的解析到最后结果集的返回，经过了一系列的内部组件，比如参数处理器<code>parameterHandler</code>，语句处理器<code>StatementHandler</code>，结果集处理器<code>ResultSetHandler</code>等。若开发者需要对<code>SQL</code>执行的某一环节进行一些特定的处理，比如参数类型的转换，数据分页功能，打印执行的<code>SQL</code>语句等都可以通过<code>mybatis</code>的插件机制实现。</p><span id="more"></span><h4 id="二、mybatis的责任链"><a href="#二、mybatis的责任链" class="headerlink" title="二、mybatis的责任链"></a>二、mybatis的责任链</h4><p>​    <code>mybatis</code>中就是对内部的一个<code>List</code>数组做拦截，业务方通过实现<code>Interceptor</code>接口后，将具体的实现类通过<code>InterceptorChain#addInterceptor</code>添加到责任链中，当<code>mybatis</code>初始化资源时，会调用<code>InterceptorChain#pluginAll</code>通过代理的方式，将所有的插件通过逐层代理的方式将内部核心组件(比如<code>ParameterHandler</code>)包裹返回一个代理对象。</p><p>​    真正执行的地方是由于将内部核心组件都包装成了代理类，所以在调用执行方法时，会被代理对象拦截进入<code>invoke</code>方法，根据执行方法所属类以及注解等判断是否执行拦截器或者是执行原方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截执行该方法</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部就是一个拦截器的List</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环调用每个Interceptor.plugin方法</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、过滤器相关责任链"><a href="#三、过滤器相关责任链" class="headerlink" title="三、过滤器相关责任链"></a>三、过滤器相关责任链</h4><p>​    在权限校验等一些拦截器中，通常的做法是有多层拦截，比如简单的登录过程，先校验用户名密码是否正确，在校验是否拥有某项操作的操作权限之后才会使得用户获取到资源，但是如果用户名密码校验失败，就没有必要进入第二部的操作权限校验，所以这种场景下使用<code>mybatis</code>那种方式的责任链有所不妥。以下是基于在多层拦截下，若某层校验失败，直接拒绝继续往下校验的责任链模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截执行方法</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function">Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现A拦截</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterA</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="comment">// 在这里选择是否继续往下走，这种方式会往下走</span></span><br><span class="line">    <span class="keyword">return</span> filterChain.doFilter(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现B拦截</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterB</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="comment">// 这种方式会直接返回，不会继续执行其他拦截器(当然了在我的例子中也没有其他拦截器了)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部维护一个数组，存储各个拦截器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Iterator iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iterator == <span class="keyword">null</span>)&#123;</span><br><span class="line">      iterator = filters.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iterator.hasNext())&#123;</span><br><span class="line">      Filter filter = (Filter) iterator.next();</span><br><span class="line">      filter.doFilter(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">  FilterA filterA = <span class="keyword">new</span> FilterA();</span><br><span class="line">  FilterB filterB = <span class="keyword">new</span> FilterB();</span><br><span class="line">  filterChain.addFilter(filterA);</span><br><span class="line">  filterChain.addFilter(filterB);</span><br><span class="line">  filterChain.doFilter(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    以上两种责任链的不同形式，其实是应对于不同的业务场景，当需要所有的拦截都走一轮，则采用第一种；当在某个拦截器失败后不继续进行，则采用第二种。在实际的场景中需要综合考虑，采取最符合业务场景的形式进行编码。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;从myBatis-Plugin看责任链模式&quot;&gt;&lt;a href=&quot;#从myBatis-Plugin看责任链模式&quot; class=&quot;headerlink&quot; title=&quot;从myBatis Plugin看责任链模式&quot;&gt;&lt;/a&gt;从myBatis Plugin看责任链模式&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h4&gt;&lt;p&gt;​    在&lt;code&gt;mybatis&lt;/code&gt;中从&lt;code&gt;sql&lt;/code&gt;的解析到最后结果集的返回，经过了一系列的内部组件，比如参数处理器&lt;code&gt;parameterHandler&lt;/code&gt;，语句处理器&lt;code&gt;StatementHandler&lt;/code&gt;，结果集处理器&lt;code&gt;ResultSetHandler&lt;/code&gt;等。若开发者需要对&lt;code&gt;SQL&lt;/code&gt;执行的某一环节进行一些特定的处理，比如参数类型的转换，数据分页功能，打印执行的&lt;code&gt;SQL&lt;/code&gt;语句等都可以通过&lt;code&gt;mybatis&lt;/code&gt;的插件机制实现。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC中的过滤器和拦截器</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/spring%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/spring%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:06:54.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringMVC中的过滤器和拦截器"><a href="#SpringMVC中的过滤器和拦截器" class="headerlink" title="SpringMVC中的过滤器和拦截器"></a>SpringMVC中的过滤器和拦截器</h3><p>[TOC]</p><h4 id="一、过滤器"><a href="#一、过滤器" class="headerlink" title="一、过滤器"></a>一、过滤器</h4><blockquote><p>​    过滤器<code>Filter</code>是通过实现<code>java.servlet.filter</code>接口实现过滤器功能，作用是用于对传入的<code>request</code>和响应的<code>response</code>进行一些处理，比如对请求参数进行校验，或者设置、检验头部信息，再或者对一些非法行为进行校验。由实现的接口可知，过滤器是依赖于<code>servlet</code>容器。<strong>所以由于过滤器不依赖于<code>spring</code>容器，它也就无法获取到容器中的对象。</strong></p></blockquote><span id="more"></span><p>创建一个过滤器类继承<code>java.servlet.filter</code>接口，实现<code>filter</code>中的拦截方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="comment">// 过滤器的具体执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>把创建的过滤器类加入过滤器链中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个过滤器myFilter和myFilter2，并且分别添加到FilterRegistrationBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> </span><br><span class="line">            FilterRegistrationBean();</span><br><span class="line">filterRegistrationBean.setFilter(myFilter());</span><br><span class="line">filterRegistrationBean.setName(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line">filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">filterRegistrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//filterRegistrationBean.setInitParameters();</span></span><br><span class="line"><span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter2RegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span></span><br><span class="line">            FilterRegistrationBean();</span><br><span class="line">filterRegistrationBean.setFilter(myFilter2());</span><br><span class="line">filterRegistrationBean.setName(<span class="string">&quot;myFilter2&quot;</span>);</span><br><span class="line">filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">filterRegistrationBean.setOrder(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//filterRegistrationBean.setInitParameters();</span></span><br><span class="line"><span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">myFilter2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、拦截器"><a href="#二、拦截器" class="headerlink" title="二、拦截器"></a>二、拦截器</h4><blockquote><p>拦截器<code>Interceptor</code>是通过实现<code>org.springframework.web.servlet</code>包的<code>HandlerInterceptor</code>接口实现，这个接口是<code>spring</code>容器的接口，所以它是依赖于<code>spring</code>容器的。主要作用是<code>AOP</code>的思想，可以对某一个方法进行横切，做一些业务逻辑。</p></blockquote><p><strong>1.编写自定义拦截器类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;请求调用之前&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;请求调用之后&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;afterCompletion:请求调用完成后回调方法，即在视图渲染完成后回调&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.注册自定义拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在spring2.0中WebMvcConfigurerAdapter已经过时，这里只是为了演示效果，</span></span><br><span class="line"><span class="comment"> * 有兴趣可以看下spring2.0中的WebMvcConfigurer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">registry.addInterceptor(getHandlerInterceptor()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HandlerInterceptor <span class="title">getHandlerInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomHandlerInterceptor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>过滤器和拦截器执行过程图</strong></p><p>​    在请求到达容器前，进入<code>Filter</code>过滤器链，执行完过滤器链上每个<code>Filter#doFilter()</code>方法后，进入<code>Servlet#service()</code>方法，然后由<code>dispatcher</code>分发器将请求方法给对应映射成功的处理器<code>controller</code>，在进入<code>controller</code>具体方法之前，会被先进入<code>Interceptor#preHandler()</code>方法，然后再进入<code>controller</code>的具体返回，执行之后进入<code>Interceptor#postHandler()</code>这里主要是拦截了<code>controller</code>方法执行之后到返回的数据模型到达视图解析器之前，接着进入<code>Interceptor#afterCompletion()</code>方法，主要可以操作返回客户端之前的逻辑，最后返回到过滤链中各个<code>Filter</code>的调用点，可以处理返回到客户端的跳转等逻辑。</p><p><img src="https://gitee.com/jiangjiamin/image-bed/raw/master/upic/2020-11/GvwS1P.png"></p><h4 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h4><p>​    过滤器是<code>servlet</code>中的接口，主要可以用于在请求进入到<code>servlet</code>之前拦截请求<code>HttpServletRequest</code>并根据需要进行一些检查等逻辑操作，也可以在<code>HttpServletResponse</code>返回到客户端之前进行一些逻辑操作。</p><p>​    拦截器是<code>spring</code>中的接口，所以它可以获取到<code>spring</code>中的一些<code>bean</code>和其他的一些资源，在面向切面编程中应用比较广，拦截其实就是一种<code>AOP</code>策略。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;SpringMVC中的过滤器和拦截器&quot;&gt;&lt;a href=&quot;#SpringMVC中的过滤器和拦截器&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC中的过滤器和拦截器&quot;&gt;&lt;/a&gt;SpringMVC中的过滤器和拦截器&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、过滤器&quot;&gt;&lt;a href=&quot;#一、过滤器&quot; class=&quot;headerlink&quot; title=&quot;一、过滤器&quot;&gt;&lt;/a&gt;一、过滤器&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;​    过滤器&lt;code&gt;Filter&lt;/code&gt;是通过实现&lt;code&gt;java.servlet.filter&lt;/code&gt;接口实现过滤器功能，作用是用于对传入的&lt;code&gt;request&lt;/code&gt;和响应的&lt;code&gt;response&lt;/code&gt;进行一些处理，比如对请求参数进行校验，或者设置、检验头部信息，再或者对一些非法行为进行校验。由实现的接口可知，过滤器是依赖于&lt;code&gt;servlet&lt;/code&gt;容器。&lt;strong&gt;所以由于过滤器不依赖于&lt;code&gt;spring&lt;/code&gt;容器，它也就无法获取到容器中的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="设计模式" scheme="http://xiaocainiaoya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TransmittableThreadLocal</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/TransmittableThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/TransmittableThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:50.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><p>[TOC]</p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    上文说到父子线程传递本地变量可以通过<code>InheritableThreadlocoal</code>进行传递，但是如果采用线程池，不一定能传递，因为在线程在线程池中的存在不是每次使用都会进行创建，<code>InheritableThreadlocal</code>是在线程初始化时<code>intertableThreadLocals=true</code>才会进行拷贝传递。所以若本次使用的子线程是已经被池化的线程，从线程池中取出线下进行使用，是没有经过初始化的过程，也就不会进行父子线程的本地变量拷贝。</p><p>​    由于在日常应用场景中，绝大多数都是会采用线程池的方式进行资源的有效管理。目前知道的阿里有一个开源项目就是为了解决这个问题<code>ThansmittableThreadLocal</code>。</p><span id="more"></span><h4 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h4><p>​    在使用线程池等会池化复用线程的执行组件情况下，提供<code>ThreadLocal</code>值的传递功能，解决异步执行时上下文传递的问题。</p><p>​    <code>JDK</code>的<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html"><code>InheritableThreadLocal</code></a>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p><p>​    本章主要介绍使用线程池场景下的问题，<code>TransmittableThreadLocal</code>还有很多其他的应用场景。<a href="https://github.com/alibaba/transmittable-thread-local">传送门</a></p><h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><blockquote><p>1.引入<code>TransimittableThreadLocal</code>依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>2.简单使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建线程池</span></span><br><span class="line">  ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="comment">// 线程池经过TtlExecutors工具类包装，返回包装类ExecutorServiceTtlWrapper</span></span><br><span class="line">  executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line"><span class="comment">// 创建需要传递给线程池本地变量</span></span><br><span class="line">  TransmittableThreadLocal&lt;String&gt; username = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次调用,这时候线程池中还未有线程，就算不使用TTL也可以通过InheritableThreadLocal获取到</span></span><br><span class="line">  <span class="comment">// 父线程的本地变量。</span></span><br><span class="line">  username.set(<span class="string">&quot;zhangShang&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二次调用，由于使用的是单一线程的线程池，这时候是复用了上面创建的线程，所以这时通过</span></span><br><span class="line">  <span class="comment">// inheritableThreadLocal是获取不到本地变量的。</span></span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">  username.set(<span class="string">&quot;liSi&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">  username.set(<span class="string">&quot;wangWu&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangShang</span><br><span class="line">liSi</span><br><span class="line">wangWu</span><br></pre></td></tr></table></figure><h4 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h4><blockquote><p>从定义来看，<code>TransimittableThreadLocal</code>继承于<code>InheritableThreadLocal</code>，并实现<code>TtlCopier</code>接口，它里面只有一个<code>copy</code>方法。所以主要是对<code>InheritableThreadLocal</code>的扩展。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">TtlCopier</span>&lt;<span class="title">T</span>&gt; </span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>TransimittableThreadLocal</code>中添加<code>holder</code>属性。这个属性的作用就是被标记为具备线程传递资格的对象都会被添加到这个对象中。<strong>要标记一个类，比较容易想到的方式，就是给这个类新增一个<code>Type</code>字段，还有一个方法就是将具备这种类型的的对象都添加到一个静态全局集合中。之后使用时，这个集合里的所有值都具备这个标记。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. holder本身是一个InheritableThreadLocal对象</span></span><br><span class="line"><span class="comment">// 2. 这个holder对象的value是WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;</span></span><br><span class="line"><span class="comment">// 2.1 WeekHashMap的value总是null,且不可能被使用。</span></span><br><span class="line"><span class="comment">//    2.2 WeekHasshMap支持value=null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder = <span class="keyword">new</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写了childValue方法，实现上直接将父线程的属性作为子线程的本地变量对象。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>应用代码是通过<code>TtlExecutors</code>工具类对线程池对象进行包装。工具类只是简单的判断，输入的线程池是否已经被包装过、非空校验等，然后返回包装类<code>ExecutorServiceTtlWrapper</code>。根据不同的线程池类型，有不同和的包装类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">getTtlExecutorService</span><span class="params">(<span class="meta">@Nullable</span> ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (TtlAgent.isTtlAgentLoaded() || executorService == <span class="keyword">null</span> || executorService <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceTtlWrapper(executorService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>进入包装类<code>ExecutorServiceTtlWrapper</code>。可以注意到不论是通过<code>ExecutorServiceTtlWrapper#submit</code>方法或者是<code>ExecutorTtlWrapper#execute</code>方法，都会将线程对象包装成<code>TtlCallable</code>或者<code>TtlRunnable</code>，用于在真正执行<code>run</code>方法前做一些业务逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在ExecutorServiceTtlWrapper实现submit方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="meta">@NonNull</span> Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> executorService.submit(TtlCallable.get(task));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在ExecutorTtlWrapper实现execute方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">  executor.execute(TtlRunnable.get(command));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所以，重点的核心逻辑应该是在<code>TtlCallable#call()</code>或者<code>TtlRunnable#run()</code>中。以下以<code>TtlCallable</code>为例，<code>TtlRunnable</code>同理类似。在分析<code>call()</code>方法之前，先看一个类<code>Transmitter</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获当前线程中的是所有TransimittableThreadLocal和注册ThreadLocal的值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(captureTtlValues(), captureThreadLocalValues());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获TransimittableThreadLocal的值,将holder中的所有值都添加到HashMap后返回。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captureTtlValues() &#123;</span><br><span class="line">    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;Object&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">      ttl2Value.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ttl2Value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获注册的ThreadLocal的值,也就是原本线程中的ThreadLocal,可以注册到TTL中，在</span></span><br><span class="line"><span class="comment">    * 进行线程池本地变量传递时也会被传递。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; captureThreadLocalValues() &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;ThreadLocal&lt;Object&gt;,TtlCopier&lt;Object&gt;&gt;entry:threadLocalHolder.entrySet())&#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      <span class="keyword">final</span> TtlCopier&lt;Object&gt; copier = entry.getValue();</span><br><span class="line">      threadLocal2Value.put(threadLocal, copier.copy(threadLocal.get()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadLocal2Value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将捕获到的本地变量进行替换子线程的本地变量，并且返回子线程现有的本地变量副本backup。</span></span><br><span class="line"><span class="comment">    * 用于在执行run/call方法之后，将本地变量副本恢复。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(<span class="meta">@NonNull</span> Object captured)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Snapshot capturedSnapshot = (Snapshot) captured;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(replayTtlValues(capturedSnapshot.ttl2Value), </span><br><span class="line">                        replayThreadLocalValues(capturedSnapshot.threadLocal2Value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换TransmittableThreadLocal</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; replayTtlValues(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured) &#123;</span><br><span class="line">    <span class="comment">// 创建副本backup</span></span><br><span class="line">    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line">      <span class="comment">// 对当前线程的本地变量进行副本拷贝</span></span><br><span class="line">      backup.put(threadLocal, threadLocal.get());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若出现调用线程中不存在某个线程变量，而线程池中线程有，则删除线程池中对应的本地变量</span></span><br><span class="line">      <span class="keyword">if</span> (!captured.containsKey(threadLocal)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        threadLocal.superRemove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将捕获的TTL值打入线程池获取到的线程TTL中。</span></span><br><span class="line">    setTtlValuesTo(captured);</span><br><span class="line">    <span class="comment">// 是一个扩展点，调用TTL的beforeExecute方法。默认实现为空</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; replayThreadLocalValues(<span class="meta">@NonNull</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; captured) &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; backup = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ThreadLocal&lt;Object&gt;, Object&gt; entry : captured.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      backup.put(threadLocal, threadLocal.get());</span><br><span class="line">      <span class="keyword">final</span> Object value = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (value == threadLocalClearMark) threadLocal.remove();</span><br><span class="line">      <span class="keyword">else</span> threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清除单线线程的所有TTL和TL，并返回清除之气的backup</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;ThreadLocal&lt;Object&gt;,TtlCopier&lt;Object&gt;&gt;entry:threadLocalHolder.entrySet())&#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal2Value.put(threadLocal, threadLocalClearMark);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> replay(<span class="keyword">new</span> Snapshot(ttl2Value, threadLocal2Value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 还原</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="meta">@NonNull</span> Object backup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Snapshot backupSnapshot = (Snapshot) backup;</span><br><span class="line">    restoreTtlValues(backupSnapshot.ttl2Value);</span><br><span class="line">    restoreThreadLocalValues(backupSnapshot.threadLocal2Value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreTtlValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展点，调用TTL的afterExecute</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!backup.containsKey(threadLocal)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        threadLocal.superRemove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本地变量恢复成备份版本</span></span><br><span class="line">    setTtlValuesTo(backup);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTtlValuesTo</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttlValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; entry : ttlValues.entrySet()) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; backup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ThreadLocal&lt;Object&gt;, Object&gt; entry : backup.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 快照类，保存TTL和TL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Snapshot</span><span class="params">(HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value,</span></span></span><br><span class="line"><span class="function"><span class="params">                     HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ttl2Value = ttl2Value;</span><br><span class="line">      <span class="keyword">this</span>.threadLocal2Value = threadLocal2Value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>进入<code>TtlCallable#call()</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object captured = capturedRef.get();</span><br><span class="line">  <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterCall &amp;&amp; </span><br><span class="line">      !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;TTL value reference is released after call!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用replay方法将捕获到的当前线程的本地变量，传递给线程池线程的本地变量，</span></span><br><span class="line">  <span class="comment">// 并且获取到线程池线程覆盖之前的本地变量副本。</span></span><br><span class="line">  Object backup = replay(captured);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 线程方法调用</span></span><br><span class="line">    <span class="keyword">return</span> callable.call();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 使用副本进行恢复。</span></span><br><span class="line">    restore(backup);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到这基本上线程池方式传递本地变量的核心代码已经大概看完了。总的来说在创建<code>TtlCallable</code>对象是，调用<code>capture()</code>方法捕获调用方的本地线程变量，在<code>call()</code>执行时，将捕获到的线程变量，替换到线程池所对应获取到的线程的本地变量中，并且在执行完成之后，将其本地变量恢复到调用之前。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;TransmittableThreadLocal&quot;&gt;&lt;a href=&quot;#TransmittableThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;TransmittableThreadLocal&quot;&gt;&lt;/a&gt;TransmittableThreadLocal&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;​    上文说到父子线程传递本地变量可以通过&lt;code&gt;InheritableThreadlocoal&lt;/code&gt;进行传递，但是如果采用线程池，不一定能传递，因为在线程在线程池中的存在不是每次使用都会进行创建，&lt;code&gt;InheritableThreadlocal&lt;/code&gt;是在线程初始化时&lt;code&gt;intertableThreadLocals=true&lt;/code&gt;才会进行拷贝传递。所以若本次使用的子线程是已经被池化的线程，从线程池中取出线下进行使用，是没有经过初始化的过程，也就不会进行父子线程的本地变量拷贝。&lt;/p&gt;
&lt;p&gt;​    由于在日常应用场景中，绝大多数都是会采用线程池的方式进行资源的有效管理。目前知道的阿里有一个开源项目就是为了解决这个问题&lt;code&gt;ThansmittableThreadLocal&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>InheritableThreadLocal</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/InheritableThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/InheritableThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:20.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>[TOC]</p><h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>​    在<code>Thread</code>中除了有属性<code>threadLocals</code>引用<code>ThreadLocal.ThreadLocalMap</code>，其实还有一个属性，也就是<code>inheritableThreadLocals</code>，<code>threadLocals</code>的作用是保存本地线程变量，而<code>inneritableThreadLocals</code>的作用是传递当前线程本地变量<code>InheritableThreadLocal</code>到子线程的本地变量<code>InheritableThreadLocal</code>中。</p><span id="more"></span><h5 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  InheritableThreadLocal&lt;String&gt; username = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">  ThreadLocal&lt;String&gt; password = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">  username.set(<span class="string">&quot;zhangShang&quot;</span>);</span><br><span class="line">  password.set(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangShang</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>所以基本上可以得出结论：<code>InheritableThreadLocal</code>是具有父子线程传递的，而<code>ThreadLocal</code>不具有父子线程传递的功能。</p><h5 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h5><h6 id="1-InheritableThreadLocal的实现"><a href="#1-InheritableThreadLocal的实现" class="headerlink" title="1. InheritableThreadLocal的实现"></a>1. <code>InheritableThreadLocal</code>的实现</h6><p><code>InheritableThreadLocal</code>继承于<code>ThreadLocal</code>，并重写了<code>ThreadLocal</code>中的三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个接口是ThreadLocal的开放接口，默认实现是抛出UnsupportedOperationException异常。</span></span><br><span class="line"><span class="comment">     * 实现上仅返回入参，调用上是在创建子线程时使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写getMap,操作InheritableThreadLocal时，将只会影响到线程对象Thread的</span></span><br><span class="line"><span class="comment">     * inheritableThread属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与上面的获取方法getMap情况一致，创建时同理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-线程的创建过程"><a href="#2-线程的创建过程" class="headerlink" title="2.线程的创建过程"></a>2.线程的创建过程</h6><p>跟踪<code>new Thread()</code>方法。</p><blockquote><p>1.进入初始化方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.调用<code>init</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">  init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后实际调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">// parent线程为创建子线程的当前线程，也就是父线程。</span></span><br><span class="line">  Thread parent = currentThread();</span><br><span class="line">  </span><br><span class="line">... 省略一些与本章无关代码</span><br><span class="line">  <span class="comment">// inheritThreadLocals=true,默认值是true,且父线程的inheritableThreadLocal对象不为空</span></span><br><span class="line">  <span class="comment">// 创建当前线程的inheritableThreadLocals对象。    </span></span><br><span class="line">  <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">  <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">  <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set thread ID */</span></span><br><span class="line">  tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3.进入创建方法<code>createInheritedMap</code>方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 以父线程的inheritableThreadLocals为实例创建一个ThreadLocalMap对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以父线程的inheritableThreadLocals为实例创建子线程的inheritableThreadLocals对象</span></span><br><span class="line"><span class="comment"> * 实现上比较简单，将父线程的inheritableThreadLocals循环拷贝给子线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  Entry[] parentTable = parentMap.table;</span><br><span class="line">  <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">  setThreshold(len);</span><br><span class="line">  table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    Entry e = parentTable[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">      <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 至于这个地方为什么采用key.childValue(),内层的逻辑也仅仅是返回入参。</span></span><br><span class="line">        <span class="comment">// 网上有些人说是为了减轻代码的阅读难度，笔者觉得有点牵强。感觉是为了在获取</span></span><br><span class="line">        <span class="comment">// 过程中做一些小转换之类的？</span></span><br><span class="line">        Object value = key.childValue(e.value);</span><br><span class="line">        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        table[h] = c;</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h5><p>​    上面说父子进程通过<code>inheritableThreadLocals</code>属性来传递本地变量，在实际的应用场景中，一般不会出现父进程直接创建子进程的情况，一般都是采用线程池的方式，如果采用线程池那么<code>inheritableThreadLocal</code>还会有效吗？读者可以考虑一下，写个<code>demo</code>跑一下，看看具体的情况，下一篇文章将进行解答。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;InheritableThreadLocal&quot;&gt;&lt;a href=&quot;#InheritableThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;InheritableThreadLocal&quot;&gt;&lt;/a&gt;InheritableThreadLocal&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h5 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h5&gt;&lt;p&gt;​    在&lt;code&gt;Thread&lt;/code&gt;中除了有属性&lt;code&gt;threadLocals&lt;/code&gt;引用&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;，其实还有一个属性，也就是&lt;code&gt;inheritableThreadLocals&lt;/code&gt;，&lt;code&gt;threadLocals&lt;/code&gt;的作用是保存本地线程变量，而&lt;code&gt;inneritableThreadLocals&lt;/code&gt;的作用是传递当前线程本地变量&lt;code&gt;InheritableThreadLocal&lt;/code&gt;到子线程的本地变量&lt;code&gt;InheritableThreadLocal&lt;/code&gt;中。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal初探</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/ThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/ThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:35.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal初探"><a href="#ThreadLocal初探" class="headerlink" title="ThreadLocal初探"></a>ThreadLocal初探</h3><p>[TOC]</p><h4 id="一、ThreadLocal的实现原理"><a href="#一、ThreadLocal的实现原理" class="headerlink" title="一、ThreadLocal的实现原理"></a>一、ThreadLocal的实现原理</h4><p>​    <code>Thread</code>有一个内部变量<code>ThreadLocal.ThreadLocalMap</code>,这个类是<code>ThreadLocal</code>的静态内部类，它的实现与<code>HashMap</code>类似，当线程第一次调用<code>ThreadLocal</code>的<code>get/set</code>方法时会初始化它。它的键是这个<code>ThreadLocal</code>对象本身，值是需要存储的变量。也就是说<code>ThreadLocal</code>类型的本地变量是存放在具体的线程空间里。当不断的使用<code>get</code>方法获取时，是到线程独有线程空间中获取变量，使得其他线程无法访问到，也就达到了线程安全的目的。在使用完成之后，可以通过<code>remove</code>方法，移除不使用的本地变量。</p><span id="more"></span><p><strong>ThreadLocal和同步机制的比较</strong></p><p>​    如果说同步机制是一种以时间换空间的做法，那么<code>ThreadLocal</code>就是一种以空间换时间的做法，在同步机制下，当访问共享变量时，同步机制保证了同一个时刻只能有一个线程访问到，其他线程进入阻塞。<code>ThreadLocal</code>下，为每个线程都复制了共享变量的副本，也就不存在共享变量的说法。</p><h4 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h4><h5 id="1-set"><a href="#1-set" class="headerlink" title="1.set()"></a>1.set()</h5><blockquote><p>通过<code>ThreadLocal</code>的set方法调用到<code>ThreadLocal.ThreadLocalMap</code>静态内部类的set方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">          Thread t = Thread.currentThread();</span><br><span class="line">          ThreadLocalMap map = getMap(t);</span><br><span class="line">          <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">              map.set(<span class="keyword">this</span>, value);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若对象为空，则初始化threadLocalMap对象</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 先通过hashcode作为下标取数组对应位置的值，若为空，设置值。</span></span><br><span class="line">      <span class="comment">// 若不为空，往后移动一个位置，如果获取到的长度等于数组长度，从0位置查找。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">// 清除Entry对象还在，但是Entry的值为空的位置 &amp;&amp; 当前数量是否大于容量</span></span><br><span class="line">      <span class="comment">// 扩容</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这边的扩容有两个步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1. 重新排列table数组里的值，根据hashcode获取下标，若对应下标为空，则移动到该位置</span></span><br><span class="line">      <span class="comment">// 若下标位置不为空，往后移动位置，直到找到空位置。</span></span><br><span class="line">      expungeStaleEntries();</span><br><span class="line">      <span class="comment">// 2.排列的同时如果是空位置，会相应减少size，若排列之后的size仍然大于容量的3/4则扩容</span></span><br><span class="line">      <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 两倍原长度扩容</span></span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-get"><a href="#2-get" class="headerlink" title="2.get()"></a>2.get()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        T result = (T)e.value;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">      Entry e = table[i];</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取不到值有两种情况，e=null, e.get() == null,如果e=null直接返回null,</span></span><br><span class="line">    <span class="comment">// 如果e.get()=null，清除这个位置的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">          expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、继承性"><a href="#三、继承性" class="headerlink" title="三、继承性"></a>三、继承性</h4><blockquote><p><code>ThreadLocal</code>对父子线程也是一样，同样是不可相互访问。但是，在特殊情况下或许还是存在父子线程需要相互访问<code>ThreadLocal</code>中的值的业务需求。可以使用<code>ThreadLocal</code>的子类<code>InheritableThreadLocal</code>,它可以实现父子进程之间的变量获取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">InheritableThreadLocal继承ThreadLocal方法，并重写了三个方法，getMap、createMap方法</span></span><br><span class="line"><span class="comment">是为了让创建map和获取map的时候使用thread中的inheritableThreadLoca变量。而childValue</span></span><br><span class="line"><span class="comment">是为了在thread父进程调用init创建子进程时，创建子进程的inheritableThreadLocal的时候，逐</span></span><br><span class="line"><span class="comment">个拷贝父进程的nheritableThreadLocal值。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="comment">// 在这里拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// threalLocal中根据threadLocalMap创建threadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  Entry[] parentTable = parentMap.table;</span><br><span class="line">  <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">  setThreshold(len);</span><br><span class="line">  table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    Entry e = parentTable[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">      <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重写childChild方法</span></span><br><span class="line">        Object value = key.childValue(e.value);</span><br><span class="line">        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        table[h] = c;</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、内存泄漏"><a href="#四、内存泄漏" class="headerlink" title="四、内存泄漏"></a>四、内存泄漏</h4><p><img src="https://gitee.com/jiangjiamin/image-bed/raw/master/upic/2020-10/xCD8sO.png"></p><p>​    <code>ThreadLcal</code>的引用关系如上如所示，虚线是使用软引用的地方。如果这个地方使用的是强引用，在业务代码中使用<code>threadlocalInstance==null</code>将<code>ThreadLocalRef</code>和<code>ThreadLocal</code>之间的强引用置空，<code>value</code>还是会通过另一条引用链<code>currentThread-&gt;currentThread-&gt;map-&gt;entry-&gt;value</code>到达，也是不会被GC掉。而若采用软引用，在系统将要发生内存溢出时会回收掉，也就是会断掉<code>key</code>与<code>ThreadLocal</code>之间的引用，使得<code>key=null</code>。</p><p>​    在<code>ThreadLocal</code>的实现中，为了避免内存泄漏已经做了很多安全性的控制，在<code>get()</code>和<code>set()</code>方法中都有相应的处理，通过特定的方式对存在<code>key=null</code>的脏<code>Entry</code>进行<code>value=null</code>的处理，使得<code>value</code>的引用链不可达。</p><p> <strong>为什么使用弱引用？</strong></p><p>一是尽管使用强引用也会出现内存泄漏，二是在<code>ThreadLocal</code>的生命周期中<code>set、getEntry、remove</code>里，都针对键为空的脏<code>Entry</code>进行处理。但是尽管如此，在编程过程中，形成一种良好的规范，在使用完<code>ThreadLocal</code>后都应该手动调用<code>remove</code>方法进行清理。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;ThreadLocal初探&quot;&gt;&lt;a href=&quot;#ThreadLocal初探&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal初探&quot;&gt;&lt;/a&gt;ThreadLocal初探&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、ThreadLocal的实现原理&quot;&gt;&lt;a href=&quot;#一、ThreadLocal的实现原理&quot; class=&quot;headerlink&quot; title=&quot;一、ThreadLocal的实现原理&quot;&gt;&lt;/a&gt;一、ThreadLocal的实现原理&lt;/h4&gt;&lt;p&gt;​    &lt;code&gt;Thread&lt;/code&gt;有一个内部变量&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;,这个类是&lt;code&gt;ThreadLocal&lt;/code&gt;的静态内部类，它的实现与&lt;code&gt;HashMap&lt;/code&gt;类似，当线程第一次调用&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;get/set&lt;/code&gt;方法时会初始化它。它的键是这个&lt;code&gt;ThreadLocal&lt;/code&gt;对象本身，值是需要存储的变量。也就是说&lt;code&gt;ThreadLocal&lt;/code&gt;类型的本地变量是存放在具体的线程空间里。当不断的使用&lt;code&gt;get&lt;/code&gt;方法获取时，是到线程独有线程空间中获取变量，使得其他线程无法访问到，也就达到了线程安全的目的。在使用完成之后，可以通过&lt;code&gt;remove&lt;/code&gt;方法，移除不使用的本地变量。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>FastThreadLocal</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/FastThreadLocal/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/java/ThreadLocal/FastThreadLocal/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:08:07.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h3><p>[TOC]</p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    因为需要，研究了可以通过<code>InheritableThreadLocal</code>进行父子线程中如何传递本地线程变量，通过阿里开源项目<code>TransmitableThreadLocal</code>进行进行线程池传递本地线程变量(详解可查看以往博客)。在查找资料的过程中无意发现了<code>Dobbo</code>的<code>InternalThreadLocal</code>，其实<code>Dobbo</code>的<code>InternalThreadLocal</code>和<code>netty</code>的<code>FastThreadLocal</code>有异曲同工之妙。之前学<code>netty</code>的时候有了解一点，为了加深一下<code>ThreadLocal</code>种群的了解，使用本博客记录一下。</p><span id="more"></span><h4 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 原生线程调用方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      username.set(<span class="string">&quot;zhangSang&quot;</span>);</span><br><span class="line">      password.set(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      password.remove();</span><br><span class="line"></span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * FastThreadLocalThread线程调用方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> FastThreadLocalThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      username.set(<span class="string">&quot;zhangSang&quot;</span>);</span><br><span class="line">      password.set(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从运行结果看，都能获取到对应设置的值，二者没有任何输出区别，但是跟踪一下，可以看到调用的逻辑是有所区别的。</p><h4 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h4><p>​    熟悉<code>ThreadLocal</code>的应该知道，<code>Threadlocal</code>其实内部逻辑是一个以<code>ThreadLocal</code>对象为<code>key</code>，需要存储的值为<code>value</code>的<code>map</code>结构。而<code>FastThreadLocal</code>的内部实现是一个数组，实现上是直接通过下标定位元素，所以单纯从取、存的角度看，<code>FastThreadLocal</code>是比<code>ThreadLocal</code>高效。</p><p>​    对于使用原生线程<code>Thread</code>来说，其实最后是将数据存<code>Thread.threadLocals(ThreadLocal.ThreadLocalMap)</code>中,也就是说在这个线程所使用的所有<code>FastThreadLocal</code>最后都以 <code>key=ThreadLocal&lt;InternalThreadLocalMap&gt;</code><br>对象,<code>value=InternalThreadLocalMap</code>的方式存在线程<code>ThreadLocal</code>的一个节点中。而若使用的是<code>netty</code>封装的<code>FastThreadLocalThread</code>,则<code>FastThreadLocalThread</code>对象的属性<code>threadLocalMap</code>中。</p><p>​    <code>FastThreadLocalThread</code>是直接继承于线程类<code>Thread</code>，并且内部维护一个<code>InternalThreadLocalMap</code>，用于存储变量。虽然这个类命名为<code>Map</code>，结构上其实是一个数组。并且下标为0的元素是一个<code>Set&lt;FastThreadLocal&lt;?&gt;&gt;</code>的结构，存储着当前有效的<code>FastThreadLocal</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>InternalThreadLocalMap</code>中提供了一些静态方法，通过当前线程的不同类型，以不同的方式获取对应所需要的<code>InternalThreadlocalMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread thread = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 根据不同的线程类型，以不同的方式获取对应的InternalThreadLocalMap</span></span><br><span class="line">  <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">    <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> slowGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FastThreadLocalThred获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 直接从FastThreadLocalThread对象中获取InternalThreadLocalMap</span></span><br><span class="line">  InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">  <span class="comment">// 若为空,初始化一个InternalThreadLocalMap</span></span><br><span class="line">  <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原生线程的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从UnpaddedInternalThreadLocalMap中获取到ThreadLocal&lt;InternalThreadLocalMap&gt;</span></span><br><span class="line"><span class="comment">  * 在从ThreadLocal中获取InternalThreadLocalMap,若为空初始化一个。所以由此可知，原生线程</span></span><br><span class="line"><span class="comment">  * 的FasstThreadLocal具体值，是以InternalThreadLocalMap为值，存储在ThreadLocal中。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = </span><br><span class="line">    UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">  InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">    slowThreadLocalMap.set(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-set值"><a href="#1-set值" class="headerlink" title="1.set值"></a>1.set值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="comment">// 根据不同的线程类型，获取到的InternalThreadLocalMap进行设置值。</span></span><br><span class="line">    set(InternalThreadLocalMap.get(), value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="comment">// 将需要存储的值添加到InternalThreadLocalMap对应的下标位置。</span></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line">      addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove(threadLocalMap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据下标获取对应的元素</span></span><br><span class="line">  Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">  Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line">  <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若为空，创建set结构并将值添加到对应的下标位置</span></span><br><span class="line">    variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">    threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接应用取出的值</span></span><br><span class="line">    variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 添加元素到set集合中</span></span><br><span class="line">  variablesToRemove.add(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-get值"><a href="#2-get值" class="headerlink" title="2.get值"></a>2.get值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(InternalThreadLocalMap.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * get操作比较简单，直接从threadLocalMap获取对应的下标元素返回。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">  <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="keyword">return</span> (V) v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是一个默认值操作，可以通过最后的initValue()会调用FastThreadLocal#initialValue</span></span><br><span class="line"><span class="comment">  * 做一个初始化的操作。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  V v = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = initialValue();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    PlatformDependent.throwException(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">  addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-remove"><a href="#3-remove" class="headerlink" title="3.remove"></a>3.remove</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 删除对应下标值，赋值为UNSET占位符</span></span><br><span class="line">  Object v = threadLocalMap.removeIndexedVariable(index);</span><br><span class="line">  <span class="comment">//删除InternalThreadLocalMap[0]的Set&lt;FastThreadLocal&lt;?&gt;&gt;中的当前FastThreadLocal对象</span></span><br><span class="line">  removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 是一个增强，删除之后的业务逻辑，由子类实现，默认是空实现</span></span><br><span class="line">      onRemoval((V) v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    <code>FastThreadLocal</code>实际上采用的是数组的方式进行存储数据，在数据的获取、赋值都是通过下标的方式进行，而<code>ThreadLocal</code>是通过<code>map</code>结构，先计算哈希值，在进行线性探测的方式进行定位。所以在高并发下，<code>FastThreadLocal</code>应该相对高效，但是<code>FastThread</code>有一个弊端就是<code>index</code>是一直累加，也就是说如果移除了某个变量是通过将对应下标的元素标记为<code>UNSET</code>占位，而不进行回收，会无限制增大，会触发扩容等一些问题。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;FastThreadLocal&quot;&gt;&lt;a href=&quot;#FastThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;FastThreadLocal&quot;&gt;&lt;/a&gt;FastThreadLocal&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;​    因为需要，研究了可以通过&lt;code&gt;InheritableThreadLocal&lt;/code&gt;进行父子线程中如何传递本地线程变量，通过阿里开源项目&lt;code&gt;TransmitableThreadLocal&lt;/code&gt;进行进行线程池传递本地线程变量(详解可查看以往博客)。在查找资料的过程中无意发现了&lt;code&gt;Dobbo&lt;/code&gt;的&lt;code&gt;InternalThreadLocal&lt;/code&gt;，其实&lt;code&gt;Dobbo&lt;/code&gt;的&lt;code&gt;InternalThreadLocal&lt;/code&gt;和&lt;code&gt;netty&lt;/code&gt;的&lt;code&gt;FastThreadLocal&lt;/code&gt;有异曲同工之妙。之前学&lt;code&gt;netty&lt;/code&gt;的时候有了解一点，为了加深一下&lt;code&gt;ThreadLocal&lt;/code&gt;种群的了解，使用本博客记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    <category term="ThreadLocal" scheme="http://xiaocainiaoya.github.io/categories/java/ThreadLocal/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="源码" scheme="http://xiaocainiaoya.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>由拆箱引发NPE</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%B1%E6%8B%86%E7%AE%B1%E5%BC%95%E5%8F%91bug/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%B1%E6%8B%86%E7%AE%B1%E5%BC%95%E5%8F%91bug/</id>
    <published>2021-04-13T13:51:58.000Z</published>
    <updated>2021-04-14T06:06:06.436Z</updated>
    
    <content type="html"><![CDATA[<h5 id="由拆箱引发bug"><a href="#由拆箱引发bug" class="headerlink" title="由拆箱引发bug"></a>由拆箱引发bug</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  Integer b = <span class="keyword">null</span>;</span><br><span class="line">  System.out.println(a == b); <span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>b</code>是包装类型，而<code>a</code>是基本数据类型，在比较时对<code>b</code>进行拆箱，所以会通过<code>((Integer)null).intValue()</code>进行拆箱，从而引发<code>NPE</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;由拆箱引发bug&quot;&gt;&lt;a href=&quot;#由拆箱引发bug&quot; class=&quot;headerlink&quot; title=&quot;由拆箱引发bug&quot;&gt;&lt;/a&gt;由拆箱引发bug&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/"/>
    
    
  </entry>
  
</feed>
