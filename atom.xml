<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2021-09-12T06:34:39.142Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring事件监听机制</title>
    <link href="http://xiaocainiaoya.github.io/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaocainiaoya.github.io/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-12T05:09:33.000Z</published>
    <updated>2021-09-12T06:34:39.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring事件监听机制"><a href="#spring事件监听机制" class="headerlink" title="spring事件监听机制"></a>spring事件监听机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring</code>事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于<code>spring</code>容器进行事件的注册、发布、处理。</p><span id="more"></span><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1.创建一个类继承于顶层事件类<code>ApplicationEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendNotificationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SendNotificationVo sendNotificationVo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendNotificationEvent</span><span class="params">(ApplicationContext source, SendNotificationVo sendNotificationVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.sendNotificationVo = sendNotificationVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.监听到对应的事件后的业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.调用点发送具体的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上就是最简单的<code>spring</code>事件监听的使用。在具体的应用场景中，并不会这么简单的使用，因为若在业务逻辑上需要解耦，大部分还是希望是异步的方式进行事件的处理，然而在默认的情况下，这种模式是同步机制，也就是说待到具体的事件监听处理完成之后，才会继续执行调用点的业务逻辑。</p><h2 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h2><h3 id="1-广播器异步"><a href="#1-广播器异步" class="headerlink" title="1.广播器异步"></a>1.广播器异步</h3><p>​    在<code>spring</code>的事件监听机制中已经考虑到异步的情况，所以在事件发送器发送事件时，会判断是否存在广播器，当存在广播器时，会将具体的监听执行逻辑转移到广播器对应的线程池中。来跟踪一下源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        publishEvent((Object) event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体子类实现接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现在<code>AbstractApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取广播器, 并调用广播器对应的发送事件处理</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认仅有一个广播器的实现<code>SimpleApplicationEventMulticaster</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 获取对应的广播器线程池</span></span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="comment">// 获取这个event对应类型的所有监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="comment">// 若是配置了线程池, 则将监听任务转移到线程池中执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若是没有配置线程池, 执行执行监听任务, 所以在默认情况下与具体的业务逻辑是同步执行。</span></span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体事件监听的执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 具体执行监听逻辑</span></span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实际上就是ApplicationListener的onApplicationEvent方法</span></span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        String msg = ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">            Log logger = LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚上面介绍的最简单的使用方式中采用的<code>@EventListener</code>的方式来标记监听器的位置，实际上在初始化这个<code>bean</code>对象时，扫描到<code>@EventListener</code>后会将这个对应的方式转化为<code>ApplicationListenerMethodAdapter</code>类，该类中包含了<code>bean</code>名称、类名称、监听处理<code>method</code>等等，待到接收到事件时，通过反射调用对应的监听处理方法。</p><h3 id="2-Async注解异步"><a href="#2-Async注解异步" class="headerlink" title="2.@Async注解异步"></a>2.@Async注解异步</h3><p>​    虽然在事件发送器中内置了广播器线程池，但是若不进行配置，则它还是同步的方式执行，在它同步执行的基础上，若是利用<code>spring</code>的异步机制，也可以达到异步的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，在<code>spring</code>容器初始化时，扫描到这个<code>bean</code>对象并进行初始化时，会为这个<code>bean</code>创建一个代理类，由这个代理类来执行相应的异步逻辑。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>以上看似已经解决的异步的问题，但是在实际的使用过程中又发现如果事件发送点存在事务管理，就会导致事件中获取不到事件发送点的某些数据。(由于事件监听处理触发时，事件发送点还未提交事务。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪代码, 在事件监听的处理中, 通过id=123可能存在获取不到这条数据的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/09/12 13:54:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    mapper.insert(sendNotificationVo);</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是、但是、但是这种情况<code>spring</code>也考虑到了，<code>spring</code>监听机制中通过使用<code>@TransactionalEventListener</code></p><p>来解决这个问题。<code>@TransactionalEventListener</code>它的元注解为<code>@EventListener</code>，所以本质上也是个<code>@EventListener</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 事件触发阶段: 比如事务提交之前、事务提交之后等, 默认是在事务提交之后</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function">TransactionPhase <span class="title">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 若调用点无事务管理也触发, 默认情况下若调用点无事务接管, 该监听处理不会触发</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Alias for &#123;<span class="doctag">@link</span> #classes&#125;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The event classes that this listener handles.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚上面说到在<code>spring</code>扫描到对应的监听器处理<code>bean</code>时，会根据方法上标记的注解将监听器转换为对应的处理类。根据不同的两个注解<code>@TransactionalEventListener</code>和<code>EventListener</code>对应两个不同的生成监听类工厂<code>DefaultEventListenerFactory</code>和<code>TransactionalEventListenerFactory</code>，由它们来创建具体的监听处理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp; AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp; !isSpringContainerClass(targetType)) &#123;</span><br><span class="line">        Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从bean的class对象中找出含有@EventListener注解的方法, 存在Map&lt;Method, EventListener&gt;中</span></span><br><span class="line">            <span class="comment">// @TransactionListener方法也会被匹配, 因为它的元注解是@EventListener</span></span><br><span class="line">            annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">                            AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// An unresolvable type in a method signature, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Could not resolve methods for bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No @EventListener annotations found on bean class: &quot;</span> + targetType.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Non-empty set of methods</span></span><br><span class="line">            ConfigurableApplicationContext context = <span class="keyword">this</span>.applicationContext;</span><br><span class="line">            Assert.state(context != <span class="keyword">null</span>, <span class="string">&quot;No ApplicationContext set&quot;</span>);</span><br><span class="line">            List&lt;EventListenerFactory&gt; factories = <span class="keyword">this</span>.eventListenerFactories;</span><br><span class="line">            Assert.state(factories != <span class="keyword">null</span>, <span class="string">&quot;EventListenerFactory List not initialized&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取监听工厂, 这里有两个工厂:DefaultEventListenerFactory和TransactionalEventListenerFactory</span></span><br><span class="line">                <span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">                    <span class="comment">// 判断这个被标记的方法适配哪个工厂</span></span><br><span class="line">                    <span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line">                        Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                        <span class="comment">// 使用工厂创建对应的监听器对象</span></span><br><span class="line">                        ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                        <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">                            ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="keyword">this</span>.evaluator);</span><br><span class="line">                        &#125;</span><br><span class="line">                        context.addApplicationListener(applicationListener);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(annotatedMethods.size() + <span class="string">&quot; @EventListener methods processed on bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + annotatedMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这两个工厂生成出来的监听类，实际上是两个适配器，<code>ApplicationListenerMethodAdapter</code>和<code>ApplicationListenerMethodTransactionalAdapter</code>，由这两个适配器来执行相应的处理逻辑。这里要感叹下<code>spring</code>设计的精妙，一环扣一环，扩展性极强。</p><p>这里分析下<code>ApplicationListenerMethodTransactionalAdapter</code>中对应的监听触发方法<code>onApplicationEvent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// publish事件时: 创建一个TransactionSynchronization对象, 这个对象持有event</span></span><br><span class="line">        <span class="comment">// 创建TransactionSynchronizationEventAdapter</span></span><br><span class="line">        TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event);</span><br><span class="line">        <span class="comment">// 注册到事务管理器中</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Processing &quot;</span> + event + <span class="string">&quot; as a fallback execution on AFTER_ROLLBACK phase&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反射调用进行事件的处理</span></span><br><span class="line">        processEvent(event);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No transactional event execution at all</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No transaction is active - skipping &quot;</span> + event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本以为采用这种方式之后，就解决了对应的异步+调用点事务的问题。在测试中发现：若采用广播器实现异步，极大可能获取不到调用点事务内数据；而采用<code>@Async</code>实现异步百分百可以获取到调用点事务内数据。</p><p>简单跟踪发现：</p><ul><li>广播器方式实现异步，是将<code>onApplicationEvent</code>方法的触发丢入线程池。</li><li><code>@Async</code>方式实现异步，走下方<code>else</code>逻辑，在事件发送器中走同步逻辑，是直接执行<code>onApplicationEvent</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// invokeListener()返回最后的逻辑是去调用ApplicationListener.onApplicationEvent()</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的是否对<code>onApplicationEvent</code>方法执行执行起到了关键性的作用，因为在事务监听处理器适配器中会判断是否是否存在事务。第一种情况，由线程池内线程来执行该方法，这时事务是绑定在原线程上，所以会导致这个判断结果为<code>false</code>。第二种情况，由时间发送线程执行该方法，这时与事务在同一线程，则这个判断的结果为<code>true</code>，将对应的事件处理方法注册到事务管理器中，待到执行改事件监听处理方法时，是异步进行处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line"><span class="comment">// 省略以下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    整体使用下来，发现其中的道道还是很多的，这需要对所有的组合情况、问题情况、原理都掌握的情况下，否则随意组合，可能在某一场景下能达到需要的效果，但是就像是埋下了定时炸弹。当然了<code>spring</code>的事件监听机制毕竟只是基于内存，若对应的生产环境并没有升级停机钩子处理，或者是金丝雀升级等方式，需停机升级，有可能会导致部分监听未执行的情况，所以建议生产环境还是通过一些<code>mq</code>组件进行发布监听事件的处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring事件监听机制&quot;&gt;&lt;a href=&quot;#spring事件监听机制&quot; class=&quot;headerlink&quot; title=&quot;spring事件监听机制&quot;&gt;&lt;/a&gt;spring事件监听机制&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于&lt;code&gt;spring&lt;/code&gt;容器进行事件的注册、发布、处理。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-08-30T14:08:50.000Z</published>
    <updated>2021-08-30T14:55:43.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​    <code>spring</code>为了减少过多<code>xml</code>的配置，减轻开发者的配置负担，提供了通过注解的方式进行<code>bean</code>对象的加载。并且在单一注解的基础上增加了一些模式上的约定。</p><span id="more"></span><p>​    比如<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>，实际上它们的作用都是将标记的类生成对应的<code>bean</code>对象之后添加到<code>IOC</code>容器中，通过精细注解的方式，为注解带来一些语义。使得可以更直观的看出一些分层行为。再比如<code>springboot</code>中扩展了<code>spring</code>的<code>@Condition</code>注解，通过<code>@OnXXXConditon</code>的方式标记某个类是否需要进行加载到<code>IOC</code>容器。</p><h2 id="二、注解"><a href="#二、注解" class="headerlink" title="二、注解"></a>二、注解</h2><p>​    在注解上标记的注解称为元注解。比如在<code>@Service</code>注解之上标记<code>@Component</code>注解。使得<code>@Service</code>拥有将标记类加载为<code>Bean</code>对象后添加到<code>IOC</code>容器中的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment"> * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-AliasFor"><a href="#2-1-AliasFor" class="headerlink" title="2.1 AliasFor"></a>2.1 AliasFor</h3><p>别名注解，在注解创建时，有的时候为了加深语义以及向前兼容的原则，可以通过别名的方式进行创建新字段。比如以下例子，<code>value</code>和<code>path</code>互为别名。在日常使用中<code>path</code>更能体现访问路径的语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">  String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-使用"><a href="#2-1-1-使用" class="headerlink" title="2.1.1 使用"></a>2.1.1 使用</h4><p>​    在使用上基本上是标记两个注解属性互为别名，但若使用不当，仅在一方上标记为另一方的别名，这时实际上效果和互相标记一致，只是这样就降低了可读性，所以为了提高可读性和隐式别名带来的值覆盖，还是应该遵守规范，进行相互标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AliasFor</span> 别名注解测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/08/30 22:24:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AliaForAnnotation &#123;</span><br><span class="line">    <span class="meta">@AliasFor(value = &quot;path&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@AliasFor(value = &quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  AliaForAnnotation aliaForAnnotation = AnnotationUtils.getAnnotation(SpringMvcStart.class, AliaForAnnotation.class);</span><br><span class="line">  System.out.println(<span class="string">&quot;value:&quot;</span> + aliaForAnnotation.value());</span><br><span class="line">  System.out.println(<span class="string">&quot;path:&quot;</span> + aliaForAnnotation.path());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>spring</code>中除了在一个注解中相互标记互为注解之外，还可以对组合注解进行相互标记，同时别名具有传递性。</p><ol><li>显示标记：标记一个注解中的两个注解属性互为别名</li><li>隐式标记：<code>A</code>注解的<code>a</code>属性标记为<code>C</code>注解的<code>c</code>的别名，<code>B</code>注解的<code>b</code>属性标记为<code>C</code>注解的<code>c</code>的别名，那么可以得出<code>A</code>注解的<code>a</code>属性也是<code>B</code>注解的<code>b</code>属性的别名。</li></ol><p>在<code>PostMapping</code>注解中，<code>name</code>属性就是<code>RequestMapping</code>注解中<code>name</code>的别名，<code>value</code>属性就是<code>RequestMapping</code>注解中<code>value</code>的别名，所以当在声明<code>@PostMapping(value = &quot;/xx/x&quot;)</code>的时候，不论是直接获取<code>PostMapping</code>注解后获取<code>value</code>值，还是通过元注解获取<code>RequestMapping</code>后获取它的<code>value</code>值，都为<code>/xx/x</code>。在更为复杂的场景下，不会别名链有多长，若存在隐式标记都可能存在值的传递性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#name&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#value&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Conditional"><a href="#2-2-Conditional" class="headerlink" title="2.2 Conditional"></a>2.2 Conditional</h3><p>在<code>spring</code>中提供了条件注解<code>@Conditional</code>，用于判断在某种场景下是否需要加载某个类为<code>Bean</code>对象。在<code>springboot</code>中将其扩展之后，使用上更为方便。</p><h4 id="2-2-1-使用"><a href="#2-2-1-使用" class="headerlink" title="2.2.1 使用"></a>2.2.1 使用</h4><p>创建一个注解<code>ConditionalOnDev</code>，且使用<code>@Conditional</code>指定条件类为<code>DevCondition</code>。当<code>ConditionalOnEnviroment</code>配置类被加载，要创建<code>enviroment</code>对象之前，会进入条件类的<code>matches</code>方法，若该方法返回<code>true</code>则表示允许将这个<code>bean</code>对象添加到<code>IOC</code>容器中，反之不处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(DevCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnDev &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单演示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalOnEnviroment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnDev(value = &quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Environment <span class="title">enviroment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dev();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上示例，若对<code>springboot</code>有所了解，应该知道<code>springboot</code>中存在大量的<code>@OnXxxCondition</code>，它就是利用<code>spring</code>提供的条件控制注解的方式。比如在<code>springboot</code>中有<code>@OnBeanCondition</code>、<code>@OnClassCondition</code>、<code>@OnResourceCondition</code>等等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring注解&quot;&gt;&lt;a href=&quot;#Spring注解&quot; class=&quot;headerlink&quot; title=&quot;Spring注解&quot;&gt;&lt;/a&gt;Spring注解&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;spring&lt;/code&gt;为了减少过多&lt;code&gt;xml&lt;/code&gt;的配置，减轻开发者的配置负担，提供了通过注解的方式进行&lt;code&gt;bean&lt;/code&gt;对象的加载。并且在单一注解的基础上增加了一些模式上的约定。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>HandlerMethod</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/19/SpringMvc/Handler/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/19/SpringMvc/Handler/</id>
    <published>2021-08-19T13:24:33.000Z</published>
    <updated>2021-08-23T14:53:16.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMethod</code>是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMethod顶层接口"><a href="#1-HandlerMethod顶层接口" class="headerlink" title="1. HandlerMethod顶层接口"></a>1. HandlerMethod顶层接口</h4><p><img src="https://i.loli.net/2021/08/19/7ITf8eNah9YEn4c.png" alt="HandlerMethod类图.png"></p><p>​    <code>HandlerMethod</code>整体的结构比较简单，但是<code>HandlerMethod</code>并不是设计成接口，直接设计为类，主要用于封装对应的处理方法信息<code>method</code>和这个处理器方法所对应的类信息、这个方法上的所有注解信息等。而真正的处理器方法的处理交由子类<code>InvocableHandlerMethod</code>，这里类包含了参数解析器和参数名称解析器的处理，用于在真正方法调用前进行参数解析。最后底层实现类<code>ServletInvocableHandlerMethod</code>包含了返回值处理器链，用于处理执行处理器方法之后的返回值。</p><h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h4><p>​    在顶层类<code>HandlerMethod</code>中，主要的实现就是一些构造函数，为了应对不同场景下使用不同的参数对具体的的执行方法进行包装，比如记录具体执行方法的参数、对应的类、对应类的类型、<code>bean</code>工厂、桥接方法等。</p><p>​    在次顶层类<code>InvocableHandlerMethod</code>中，主要添加了参数解析器列表和参数名称解析器列表，用于在支持<code>support()=true</code>的情况下，对参数进行一些个性化处理。并且包含了具体执行方法的反射调用处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 参数处理</span></span><br><span class="line">    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际处理请求的方法</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体的执行方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行该方法</span></span><br><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">        String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(text, args), ex);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">        Throwable targetException = ex.getTargetException();</span><br><span class="line">        <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在<code>ServletInvocableHandlerMethod</code>类中，主要的当处理器方法执行结束后，对返回值的进行一些定制化的特殊处理。<code>springmvc</code>在异步调用的处理上就是通过返回值处理器，当返回值类型为<code>Callable</code>时，进行一些特殊的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 选择具体的返回值处理器(获取首次匹配成功的返回值处理器)</span></span><br><span class="line">    <span class="comment">// 举个异步处理的方式Callable, 由CallableMethodReturnValueHandler进行处理</span></span><br><span class="line">    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体的执行逻辑</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>参数解析器和返回值处理器在获取时，是获取列表中第一个匹配成功的那个解析器或者处理器，也就是说如果希望定制化的解析器或者处理器被执行到，需要确保它所在的位置之前没有其他的解析器或者处理器会被命中。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerMethod&quot;&gt;&lt;a href=&quot;#HandlerMethod&quot; class=&quot;headerlink&quot; title=&quot;HandlerMethod&quot;&gt;&lt;/a&gt;HandlerMethod&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerMethod&lt;/code&gt;是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>HandlerAdapter</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/18/SpringMvc/HandlerAdapter/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/18/SpringMvc/HandlerAdapter/</id>
    <published>2021-08-18T14:12:53.000Z</published>
    <updated>2021-08-23T14:58:54.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerAdapter</code>是<code>Handler</code>的适配器，每种类型的<code>Handler</code>都对应一个<code>HandlerAdapter</code>。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在顶层接口<code>HandlerAdapter</code>的实现中，基本上都是直接具体的实现。</p><span id="more"></span><p><img src="https://i.loli.net/2021/08/18/PksoX39nvUDiZHB.png" alt="HandlerAdapter类图png.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HandlerAdapter 是否支持这个 Handler</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler the handler object to check</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 利用 Handler 处理请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment">  * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以<code>AbstractHandlerMethodAdapter</code>为例进行分析。这个抽象类也比较简答，仅仅是将顶层接口中的参数进行具象化，再调用本类的模板方法，供子类直接使用，所以子类就不需要在进行类型装换等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果handler是HandlerMethod, 直接强转后调用模板方法</span></span><br><span class="line">    <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">supportsInternal</span><span class="params">(HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 仅仅是强转了类型之后, 直接调用模板方法</span></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>具体实现<strong>RequestMappingHandlerAdapter</strong></p><p>​    <code>RequestMappingHandlerAdapter</code>是<code>HandlerAdapter</code>体系中最复杂的类，包含了具体<code>Handler</code>执行前后需要特殊处理或者是一些开放的扩展点的处理。比如有参数处理器、参数名称处理器、<code>HttpMessageConverter</code>、结果处理器等等。</p><p><strong>1.初始化</strong></p><p>​    <code>RequestMappingHandlerAdapter</code>的初始化分为两步，一步是在构造函数中进行默认<code>HttpMessageConvert</code>的添加，另一步是通过<code>afterPropertiesSet</code>进行一些全局处理的缓存和一些组件的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;&gt;());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        <span class="comment">// Ignore when no TransformerFactory implementation is available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化全局的三个变量modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line">    initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数解析器argumentResolvers参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getDefaultArgumentResolvers()中定义了一些常用的参数解析器，同时支持添加用户自定义参数解析器</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化initBinder式参数绑定器initBinderArgumentResolvers</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过getDefaultInitBinderArgumentResolvers()获取默认的解析器，同时支持添加用户自定义参数绑定器</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化返回值处理器returnValueHandlers</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过getDefaultReturnValueHandlers()方法获取返回值解析器，同时支持添加用户自定义返回值处理器</span></span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化全局的三个变量modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2021/08/18 10:12:25</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initControllerAdviceCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取带有@ControllerAdvice的所有类</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">        Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在@ModelAttribute注解, 但不存在@RequestMapping注解的方法</span></span><br><span class="line">        Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在@InitBinder注解的方法</span></span><br><span class="line">        Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是RequestBodyAdvice或者是ResponseBodyAdvice的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">            requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若在上述解析过程中存在实现类, 则添加到最前面, 所以在requestResponseBodyAdvice中, 自定义的优先级高于默认</span></span><br><span class="line">    <span class="keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.requestResponseBodyAdvice.addAll(<span class="number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.实际处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    <span class="comment">//判断是否支持当前request的方法，该方法在WebContentGenerator类中定义，通过内置的supportedMethods属性来进行判断</span></span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                <span class="comment">// 具体的执行方法</span></span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">            applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            prepareResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取创建WebDataBinder实例的工厂类，其中WebDataBinder类用于绑定request参数到JavaBean对象</span></span><br><span class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 获取@ModelAttribute的非@RequestMapping方法</span></span><br><span class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ServletInvocableHandlerMethod是继承于HandlerMethod, 这里相当于只是将handlerMethod中的属性值赋值给invocableMethod, 仅仅只做了包了一层</span></span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="comment">// 为ServletInvocableHandlerMethod中的一些数据赋值, 增加了参数解析、处理器方法调用、返回值解析等逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">//设置参数名称处理器</span></span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建模型和视图容器</span></span><br><span class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">        <span class="comment">// 设置FlashMap中的值</span></span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        <span class="comment">// 初始化模型</span></span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步处理相关代码</span></span><br><span class="line">        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            Object result = asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">                String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体的执行方法</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="comment">// 若是异步方式, 这里就直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建ModelAndView实例</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServletInvocableHandlerMethod</code>就是具体的<code>HandlerMethod</code>的实现，所以在最后通过<code>invocableMethod.invokeAndHandle(webRequest, mavContainer)</code>调用到具体的实现。以下基本上就是具体<code>Handler</code>的调用前最后一步了，返回执行结果之后，由结果处理器进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑(这里会先经过参数解析器的处理之后，再通过反射调用到具体的方法)</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里想简要说明一下异步调用的场景：<code>Servlet3.0</code>支持服务器异步操作，在<code>springmvc</code>中也添加了响应的支持。整个请求的过程与同步类似，只是在具体的<code>handler</code>调用之后，如果是异步方式，假设是使用<code>Callable</code>，则这里获取到的返回值处理器就是<code>CallableMethodReturnValueHandler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue;</span><br><span class="line">    <span class="comment">// 进入Callable方式异步处理逻辑</span></span><br><span class="line">    WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(<span class="keyword">final</span> WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Assert.notNull(webAsyncTask, <span class="string">&quot;WebAsyncTask must not be null&quot;</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">&quot;AsyncWebRequest must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    Long timeout = webAsyncTask.getTimeout();</span><br><span class="line">    <span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 设置异步线程池</span></span><br><span class="line"><span class="comment">      *   1. 默认情况下会创建DEFAULT_TASK_EXECUTOR -&gt; SimpleAsyncTaskExecutor线程池</span></span><br><span class="line"><span class="comment">      *   2. 一般来说, 在RequestMappingHandlerAdapter中, 创建的WebAsyncManager时会传入它的this.taskExecutor</span></span><br><span class="line"><span class="comment">      *      2.1 而RequestMappingHandlerAdapter也会创建一个默认的SimpleAsyncTaskExecutor(名称前缀为MvcAsync)</span></span><br><span class="line"><span class="comment">      *        2.1.1 但是在springmvc中, 初始化Bean RequestMappingHandlerAdapter时为它添加了单一线程池Executor.newSingleThreadExecutor</span></span><br><span class="line"><span class="comment">      *        2.1.2 但是在springboot中, 初始化Bean RequestMappingHandlerAdapter时为它添加了一个名为applicationTaskExecutor的线程池</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    AsyncTaskExecutor executor = webAsyncTask.getExecutor();</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskExecutor = executor;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        logExecutorWarning();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置拦截器</span></span><br><span class="line">    List&lt;CallableProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.add(webAsyncTask.getInterceptor());</span><br><span class="line">    interceptors.addAll(<span class="keyword">this</span>.callableInterceptors.values());</span><br><span class="line">    interceptors.add(timeoutCallableInterceptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取具体的callable</span></span><br><span class="line">    <span class="keyword">final</span> Callable&lt;?&gt; callable = webAsyncTask.getCallable();</span><br><span class="line">    <span class="comment">// 创建拦截器链对象, 拦截器链对象一般情况下都会包含拦截列表、具体执行对象以及具体执行到某个拦截器的下标值</span></span><br><span class="line">    <span class="keyword">final</span> CallableInterceptorChain interceptorChain = <span class="keyword">new</span> CallableInterceptorChain(interceptors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Async request timeout for &quot;</span> + formatRequestUri());</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = interceptorChain.triggerAfterTimeout(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">        <span class="keyword">if</span> (result != CallableProcessingInterceptor.RESULT_NONE) &#123;</span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置错误处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addErrorHandler(ex -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.errorHandlingInProgress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Async request error for &quot;</span> + formatRequestUri() + <span class="string">&quot;: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = interceptorChain.triggerAfterError(<span class="keyword">this</span>.asyncWebRequest, callable, ex);</span><br><span class="line">            result = (result != CallableProcessingInterceptor.RESULT_NONE ? result : ex);</span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置正常完成处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(() -&gt; interceptorChain.triggerAfterCompletion(<span class="keyword">this</span>.asyncWebRequest, callable));</span><br><span class="line"></span><br><span class="line">    interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">    <span class="comment">// 设置一些标志位为启动状态</span></span><br><span class="line">    startAsyncProcessing(processingContext);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将callable丢入线程池中</span></span><br><span class="line">        Future&lt;?&gt; future = <span class="keyword">this</span>.taskExecutor.submit(() -&gt; &#123;</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptorChain.applyPreProcess(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">                result = callable.call();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = ex;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, callable, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行完成之后进行结果的分发, 这个具体在不同容器有不同的实现(tomcat、undertow)</span></span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        interceptorChain.setTaskFuture(future);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        Object result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, callable, ex);</span><br><span class="line">        setConcurrentResultAndDispatch(result);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerAdapter&quot;&gt;&lt;a href=&quot;#HandlerAdapter&quot; class=&quot;headerlink&quot; title=&quot;HandlerAdapter&quot;&gt;&lt;/a&gt;HandlerAdapter&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerAdapter&lt;/code&gt;是&lt;code&gt;Handler&lt;/code&gt;的适配器，每种类型的&lt;code&gt;Handler&lt;/code&gt;都对应一个&lt;code&gt;HandlerAdapter&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;在顶层接口&lt;code&gt;HandlerAdapter&lt;/code&gt;的实现中，基本上都是直接具体的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>DispatcherServlet</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/DispatcherServlet/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/DispatcherServlet/</id>
    <published>2021-08-15T06:56:09.000Z</published>
    <updated>2021-08-23T14:53:23.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>DispatcherServlet</code>是一个<code>Servlet</code>，在<code>springmvc</code>中被称为前端控制器，根据请求的路径、类型等进行请求的分发。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>DispatcherServlet</code>类图</p><p><img src="https://i.loli.net/2021/08/15/OrjQ6AYMb7R2Pd1.png" alt="DispatcherServlet类图.png"></p><p>​    上图中的红色部分为<code>Servlet</code>接口，在<code>Springmvc</code>中实现并扩展了该<code>Servlet</code>接口。在我最早学<code>javaweb</code>开发时，并不是上来就使用各种<code>MVC</code>框架，而是从编写简单的<code>Servlet</code>开始，就是继承<code>HttpServlet</code>后，重写它的<code>service</code>方法。而<code>Springmvc</code>的设计同理，它也继承了<code>HttpServlet</code>并重写它的<code>service</code>方法，同时配置该<code>servlet</code>拦截所有的请求，从而实现了由<code>DispatcherServlet</code>来分发所有的请求。</p><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>​    因为<code>DispatcherServlet</code>实际上是一个<code>Servlet</code>，所以当配置它生效时它同时也就遵循<code>Servlet</code>的生命周期。在<code>Servlet</code>的生命周期有三个阶段：</p><ul><li><code>init()</code>：初始化请求</li><li><code>service()</code>：获取到请求后的业务处理以及跳转</li><li><code>distory()</code>：请求处理完成之后的销毁</li></ul><p>所以当<code>tomcat</code>容器(<code>servlet</code>容器)启动时，会触发<code>servlet</code>的初始化方法。<code>HttpServletBean</code>实现了该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际的处理在这, 由子类FrameworkServlet实现</span></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FrameworkServlet</code>的<code>initServletBean</code>方法，真正核心的地方在于<code>initWebApplicationContext()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Initializing Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化web容器上下文</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">                <span class="string">&quot;shown which may lead to unsafe logging of potentially sensitive data&quot;</span> :</span><br><span class="line">                <span class="string">&quot;masked to prevent unsafe logging of potentially sensitive data&quot;</span>;</span><br><span class="line">        logger.debug(<span class="string">&quot;enableLoggingRequestDetails=&#x27;&quot;</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                <span class="string">&quot;&#x27;: request parameters and headers will be &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Completed initialization in &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取由ContextLoaderListener初始化并注册在ServletContext中的根上下文，记为rootContext</span></span><br><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 2.如果webApplicationContext已经不为空，表示这个Servlet类是通过编程式注册到容器中的（Servlet 3.0+中的ServletContext.addServlet() ），</span></span><br><span class="line">    <span class="comment">// 上下文也由编程式传入。若这个传入的上下文还没被初始化，将rootContext上下文设置为它的父上下文，然后将其初始化，否则直接使用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.通过wac变量的引用是否为null，判断第2步中是否已经完成上下文的设置（即上下文是否已经用编程式方式传入），如果wac==null成立，说明该Servlet不是</span></span><br><span class="line">    <span class="comment">// 由编程式注册到容器中的。此时以contextAttribute属性的值为键，在ServletContext中查找上下文，查找得到，说明上下文已经以别的方式初始化并注册在contextAttribute下，直接使用。</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.检查wac变量的引用是否为null，如果wac==null成立，说明2、3两步中的上下文初始化策略都没成功，此时调用createWebApplicationContext(rootContext)，建立一个全新的以rootContext</span></span><br><span class="line">    <span class="comment">// 为父上下文的上下文，作为SpringMVC配置元素的容器上下文。大多数情况下我们所使用的上下文，就是这个新建的上下文。</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建成功之后会调用spring的refresh方法</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.以上三种初始化上下文的策略，都会回调onRefresh(ApplicationContext context)方法（回调的方式根据不同策略有不同），onRefresh方法在DispatcherServlet类中被覆写，</span></span><br><span class="line">    <span class="comment">// 以上面得到的上下文为依托，完成SpringMVC中默认实现类的初始化。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// onRefresh方法在DispatcherServlet类中被覆写，所以从这里可以知道先创建spring容器, 在springBean都创建成功之后, 再通过onRefresh方法进行DispatcherServlet的初始化。</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.最后，将这个上下文发布到ServletContext中，也就是将上下文以一个和Servlet类在web.xml中注册名字有关的值为键，设置为ServletContext的一个属性。你可以通过改变</span></span><br><span class="line">    <span class="comment">// publishContext的值来决定是否发布到ServletContext中，默认为true。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>onRefresh(wac)</code>方法，调用到子类<code>DispatcherServlet</code>具体的初始化方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化DispatcherServlet策略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化DispatcherServlet策略(九大组件)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上传组件处理器</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 处理器映射器</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 处理器适配器</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">// 处理器异常整理器</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 视图处理器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-分发逻辑"><a href="#2-分发逻辑" class="headerlink" title="2. 分发逻辑"></a>2. 分发逻辑</h4><p><img src="https://i.loli.net/2021/08/15/Eh6UipmYNGXSPDo.png" alt="springmvc流程图.png"></p><ul><li>当客户端发起请求，请求进入<code>DispatcherServlet</code>，由它来进行处理器<code>Handler</code>的查找。</li><li>首先根据请求信息<code>HttpServletRequest</code>，遍历已注册的所有<code>handlerMappings</code>。返回的结构为<code>HandlerExecutionChain</code>，是包含了具体的处理器<code>handler</code>和拦截器<code>interceptor</code>的结构。</li><li>获取到<code>HandlerExcecutionChain</code>后，根据具体的处理器，遍历所有的<code>handlerAdapters</code>，返回支持的<code>HandlerAdapter</code>。</li><li>在获取到<code>HandlerAdapter</code>之后，执行具体的<code>handler</code>之前，会先遍历执行<code>HandlerExecutionChain</code>中的拦截器的前置拦截方法<code>preHandle()</code>，**若出现某个拦截器的前置方法执行后方法<code>false</code>，则直接从当前节点开始往前执行<code>afterCompletion()</code>**，执行完毕后直接终止请求。</li><li>根据<code>HandlerAdapter</code>处理器适配器执行具体的处理器<code>Handler</code>逻辑。</li><li>在执行完成具体的<code>handler</code>之后，会遍历执行<code>HandlerExecutionChain</code>中拦截器的<code>postHandle</code>方法。</li><li><code>Handler</code>执行完毕之后会返回<code>ModeAndView</code>。</li><li>执行正常的情况下，在渲染模板后，请求返回前，会遍历执行<code>HandlerExecutionChain</code>中拦截器的<code>afterCompletion</code>方法。</li></ul><h4 id="3-设置springmvc容器"><a href="#3-设置springmvc容器" class="headerlink" title="3.设置springmvc容器"></a>3.设置springmvc容器</h4><p>​    根据类图可知<code>DispatcherServlet</code>也是实现了<code>ApplicationContextAware</code>接口，而<code>xxxAware</code>接口，是在<code>springbean</code>初始化时的一个<code>postProcessBeforeInitialization</code>扩展点，由类<code>ApplicationContextAwareProcessor</code>去执行具体的逻辑，简单来说就是将<code>ApplicationContext</code>通过<code>setApplicationContext</code>的方法传递给正在初始化的这个<code>bean</code>。</p><p>​    在<code>springboot</code>中就是通过这个方法，将<code>spring</code>容器(<code>applicationContext</code>)传给<code>DispatcherServlet</code>，待到真正去执行<code>DispatcherServlet</code>的初始化方法时<code>this.applicationContext</code>就不为空，所以在<code>initWebApplicationContext()</code>方法中，就走第一个<code>if</code>的逻辑，这也是<code>springboot</code>最终不会产生父子容器的原因。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;DispatcherServlet&quot;&gt;&lt;a href=&quot;#DispatcherServlet&quot; class=&quot;headerlink&quot; title=&quot;DispatcherServlet&quot;&gt;&lt;/a&gt;DispatcherServlet&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;DispatcherServlet&lt;/code&gt;是一个&lt;code&gt;Servlet&lt;/code&gt;，在&lt;code&gt;springmvc&lt;/code&gt;中被称为前端控制器，根据请求的路径、类型等进行请求的分发。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>HandlerMapping</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/HandlerMapping/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/15/SpringMvc/HandlerMapping/</id>
    <published>2021-08-15T06:56:09.000Z</published>
    <updated>2021-08-23T14:53:00.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMapping</code>处理器映射器，是<code>SpringMvc</code>的核心组件之一，用来根据请求的<code>request</code>信息查询对应的<code>Handler</code>，在<code>web</code>环境中，每个请求都需要一个对应的<code>Handler</code>来处理，所以当接收到一个请求，需要哪一个<code>Handler</code>来处理，<code>HandlerMapping</code>的作用就是找到处理的那个<code>Handler</code>。</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMapping顶层接口"><a href="#1-HandlerMapping顶层接口" class="headerlink" title="1. HandlerMapping顶层接口"></a>1. HandlerMapping顶层接口</h4><p><img src="https://i.loli.net/2021/08/15/IObtEmouNveLT2y.png" alt="HandlerMapping类图.png"></p><p>以上为<code>HandlerMapping</code>的类图，在<code>HandlerMapping</code>接口中有一个公共的抽象类<code>AbstractHandlerMapping</code><br>所有的子孙都会继承它。该抽象类有两个子类<code>AbstractHandlerMethodMapping</code>表示基于方法的映射方法，这个方式就是我们日常使用的<code>Controller</code>的那种方式，<code>AbstractUrlHandlerMapping</code>表示根据<code>url</code>获取到对应的<code>Handler</code>。</p><p>这里分析一下公共抽象父类<strong>AbstractHandlerMapping</strong>。这个抽象类采用了模板方法的设计模式，编写了<code>HandlerMapping</code>的核心逻辑<code>getHandler()</code>方法，获取具体的<code>handler</code>由子类继承并实现<code>getHandlerInternal</code>方法，在获取到具体的<code>handler</code>之后，添加该请求匹配的拦截器列表，再返回<code>HandlerExecutionChain</code>结构，里面包含了具体的<code>handler</code>和拦截器列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法接口, 不同子类不同实现</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加匹配的拦截器</span></span><br><span class="line">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">        CorsConfiguration config = (<span class="keyword">this</span>.corsConfigurationSource != <span class="keyword">null</span> ? <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="keyword">null</span>);</span><br><span class="line">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">        config = (config != <span class="keyword">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里点一下初始化拦截器的方法。由于<code>AbstractHandlerMapping</code>间接继承于<code>ApplicationContextAware</code>接口，在<code>bean</code>初始化时会调用该接口进行<code>applicationContext</code>的赋值。而改方法中设置了一个模板方法接口，由具体子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationObjectSupport</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bean初始化时会调用这个接口(BeanPostProcessor)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2021/08/04 16:56:03</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">        <span class="comment">// Reset internal context state.</span></span><br><span class="line">        <span class="keyword">this</span>.applicationContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Initialize with passed-in context.</span></span><br><span class="line">        <span class="keyword">if</span> (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                    <span class="string">&quot;Invalid application context: needs to be of type [&quot;</span> + requiredContextClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = context;</span><br><span class="line">        <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">new</span> MessageSourceAccessor(context);</span><br><span class="line">        initApplicationContext(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Ignore reinitialization if same context passed in.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != context) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                    <span class="string">&quot;Cannot reinitialize with different application context: current one is [&quot;</span> +</span><br><span class="line">                    <span class="keyword">this</span>.applicationContext + <span class="string">&quot;], passed-in one is [&quot;</span> + context + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 扩展点, 由子类自行实现</span></span><br><span class="line">    initApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractHandlerMapping#initApplicationContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主要是初始化拦截器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Initializes the interceptors.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #extendInterceptors(java.util.List)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #initInterceptors()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 空实现。</span></span><br><span class="line">    <span class="comment">// 子类可重写此方法以注册额外的拦截器</span></span><br><span class="line">    extendInterceptors(<span class="keyword">this</span>.interceptors);</span><br><span class="line">    <span class="comment">// 从上下文中查询拦截器并添加到拦截器列表中</span></span><br><span class="line">    detectMappedInterceptors(<span class="keyword">this</span>.adaptedInterceptors);</span><br><span class="line">    <span class="comment">// 初始化拦截器</span></span><br><span class="line">    initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以下代码可以得出一个简单的结论，拦截器的作用范围实际上是在<code>Handler</code>执行的前后，而过滤器<code>Filter</code>作用的范围应该是在请求进入到<code>servlet</code>的前和执行完<code>servlet</code>逻辑之后，套在<code>springmvc</code>中，<code>Filter</code>的作用范围是在请求进入到<code>DispatcherServlet</code>之前和执行完<code>DispatcherServlet</code>之后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将自定义bean设置到适配拦截器中，bean需实现HandlerInterceptor或WebRequestInterceptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setInterceptors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #adaptInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.interceptors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.interceptors.size(); i++) &#123;</span><br><span class="line">            Object interceptor = <span class="keyword">this</span>.interceptors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Entry number &quot;</span> + i + <span class="string">&quot; in interceptors array is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-AbstractHandlerMethodMapping"><a href="#2-AbstractHandlerMethodMapping" class="headerlink" title="2. AbstractHandlerMethodMapping"></a>2. AbstractHandlerMethodMapping</h4><p>​    <code>AbstractHandlerMethodMapping</code>这个就是<code>RequestMappingHandlerMapping</code>的抽象顶层父类，这种映射方式就是我们日常开发的那种，将标记有<code>@Controller</code>的类中的每个标记有<code>@RequestMapping</code>的方法都抽象为一个对应的<code>HandlerMethod</code>。</p><p><strong>简单罗列一下使用到的类：</strong></p><ol><li><strong>HandlerMethod：</strong>在初始化<code>RequestMappingHandlerMapping</code>会将<code>spring</code>容器中标记有<code>@Controller</code>的类中的<code>@RequestMapping</code>的方法都封装为<code>HandlerMethod</code>实体，包含了<code>Handler</code>对应的方法以及<code>ControllerBean</code>，并提供一些访问参数、方法返回值、获取注解等方法。</li><li><strong>RequestMappingInfo：</strong>在<code>@Controller</code>类上标记的<code>@RequestMaping</code>或者是在方法上标记的<code>@RequestMapping</code>最终都会加载到<code>RequestMappingInfo</code>实体中。</li><li><strong>MappingRegistration：</strong>主要记录<code>RequestMappingInfo</code>与<code>HandlerMethod</code>关系</li><li><strong>MappingRegistry：</strong>一个注册表，它维护到处理程序方法的所有映射，公开执行查找的方法并提供并发访问。</li></ol><p><strong>AbstractHandlerMethodMapping</strong>分支的类图：</p><p><img src="https://i.loli.net/2021/08/17/fCx685RjaIJiYwK.png" alt="RequestMappingHandlerMapping类图.png"></p><p>图中红框中的三个类，分别依次继承，我们日常开发所使用的就是<code>RequestMappingHandlerMapping</code>。</p><h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h5><p>​    在<code>springbean</code>容器启动后，当初始化类<code>RequestMappingHandlerMapping</code>完成时，由于它间接实现了初始化的后置方法<code>InitializingBean</code>，所以会进入<code>afterPropertiesSet</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestMappingHandlerMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化RequestMappingInfo构建配置</span></span><br><span class="line">    <span class="keyword">this</span>.config = <span class="keyword">new</span> RequestMappingInfo.BuilderConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.config.setUrlPathHelper(getUrlPathHelper());</span><br><span class="line">    <span class="keyword">this</span>.config.setPathMatcher(getPathMatcher());</span><br><span class="line">    <span class="keyword">this</span>.config.setSuffixPatternMatch(useSuffixPatternMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setTrailingSlashMatch(useTrailingSlashMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法调用到父类的afterPropertiesSet, 从而调用到父类的initHandlerMethods方法(这个方法是完成映射的解析工作)</span></span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 后置初始化方法, 当这个Bean初始化完成之后调用, 获取容器中所有BeanDefinition</span></span><br><span class="line"><span class="comment"> * 中含有<span class="doctag">@RequestMapping</span>或者是<span class="doctag">@Controller</span>的Bean信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initHandlerMethods</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从容器中获取所有Bean的名称,默认只查找SpringMVC的IOC容器，不查找它的父容器Spring的IOC容器</span></span><br><span class="line">    <span class="comment">// 获取容器中所有Object.class类型的bean, 逐个遍历进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// 利用反射得到@ControllerBean中的Method并包装成HandlerMethod，然后放入注册表中</span></span><br><span class="line">            processCandidateBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCandidateBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 isHandler()方法由子类(RequestMappingHandlerMapping)实现，判断是否拥有 @Controller 注解或 @RequestMapping 注解</span></span><br><span class="line">    <span class="comment">// 这个isHandler()是个抽象接口, 由子类实现来控制是否进行接下来的注册。</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">        <span class="comment">// 利用反射得到@ControllerBean中的Method并包装成HandlerMethod，然后放入注册表中</span></span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来就是将具体的<code>@Controller</code>标记的类中的方法进行解析，满足条件的<code>method</code>封装为<code>HandlerMethod</code>后，添加到注册表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用反射得到 Bean 中的 Method 并包装成 HandlerMethod，然后放入 Map 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Look for handler methods in the specified handler bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据字符串获取到对应的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ? obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若是代理对象获取目标类型</span></span><br><span class="line">        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">        <span class="comment">// 收集要封装的接口信息, 键为method的引用, 值为RequestMethodInfo的引用</span></span><br><span class="line">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 根据 Method 和它的 @RequestMapping 注解，创建 RequestMappingInfo 对象。</span></span><br><span class="line">                        <span class="comment">// 这里的 T 就是 RequestMappingInfo，它封装了 @RequestMapping 信息</span></span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> + userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line">        methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">            Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">            <span class="comment">// 注册到mappingRegistry中</span></span><br><span class="line">            registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;Method, T&gt; <span class="title">selectMethods</span><span class="params">(Class&lt;?&gt; targetType, <span class="keyword">final</span> MetadataLookup&lt;T&gt; metadataLookup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集要封装的接口信息, 键为method的引用, 值为RequestMethodInfo的引用</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Method, T&gt; methodMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; handlerTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; specificHandlerType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非代理类</span></span><br><span class="line">    <span class="keyword">if</span> (!Proxy.isProxyClass(targetType)) &#123;</span><br><span class="line">        specificHandlerType = ClassUtils.getUserClass(targetType);</span><br><span class="line">        handlerTypes.add(specificHandlerType);</span><br><span class="line">    &#125;</span><br><span class="line">    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; currentHandlerType : handlerTypes) &#123;</span><br><span class="line">        <span class="comment">// specificHandlerType若为空表示其为代理类, 则取currentHandlerType</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetClass = (specificHandlerType != <span class="keyword">null</span> ? specificHandlerType : currentHandlerType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式接口: 遍历currentHandlerType的所有methods, 并执行第二个函数引用</span></span><br><span class="line">        ReflectionUtils.doWithMethods(currentHandlerType, method -&gt; &#123;</span><br><span class="line">            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line">            <span class="comment">// 获取@RequestMapping信息</span></span><br><span class="line">            T result = metadataLookup.inspect(specificMethod);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line">                <span class="keyword">if</span> (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    methodMap.put(specificMethod, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methodMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了两次的函数式接口，不同函数式接口可能看到这回有点吃力。第一个函数式接口的作用其实就是将某个<code>method</code>上标记的<code>@RequestMapping</code>信息和这个<code>method</code>所在类上标记的<code>@RequestMapping</code>信息拼接起来后包装为<code>RequestMappingInfo</code>后返回。第二个函数式接口的作用是将第一个函数式接口处理之后返回的<code>RequestMappingInfo</code>信息暂存到某个变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后将解析出来的所有RequestMappingInfo信息逐个遍历，通过调用以下方法，添加到注册表中。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Assert that the handler method is not a suspending one.</span></span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass())) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> ((parameterTypes.length &gt; <span class="number">0</span>) &amp;&amp; <span class="string">&quot;kotlin.coroutines.Continuation&quot;</span>.equals(parameterTypes[parameterTypes.length - <span class="number">1</span>].getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported suspending handler method detected: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化一个HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">        <span class="comment">// 校验是否已经存在这个handlerMethod</span></span><br><span class="line">        validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">        <span class="comment">// 添加到mappingLookup查找器中</span></span><br><span class="line">        <span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">        <span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">            addMappingName(name, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取跨域的配置</span></span><br><span class="line">        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">        <span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注册跨域配置</span></span><br><span class="line">            <span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * getHandlerInternal()方法是由AbstractHandlerMapping抽象类定义的模板方法，具体细节由</span></span><br><span class="line"><span class="comment"> * 子类实现，用于获取对应的HandlerMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前请求获取“查找路径”</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前请求最佳匹配的处理方法（即Controller类的方法中）</span></span><br><span class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体是通过该方法获取HandlerMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从MappingRegistry.urlLookup属性中，获取lookupPath对应的mapping集合</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取匹配的mapping，添加到matches列表</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配lookupPath的实例，则遍历所有的mapping，查找符合条件的mapping</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明存在符合条件的mapping</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 多个的情况</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//获取匹配条件的排序器，由抽象方法getMappingComparator()方法获取，该方法由子类实现</span></span><br><span class="line">          <span class="comment">// 这个排序规则也是个模板方法, 由子类实现, 由子类控制当出现多个匹配的mapping</span></span><br><span class="line">          <span class="comment">// 通过比较器排序后, 选择第一个为最匹配的mapping</span></span><br><span class="line">            Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">            matches.sort(comparator);</span><br><span class="line">            bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(matches.size() + <span class="string">&quot; matching mappings: &quot;</span> + matches);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                String uri = request.getRequestURI();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HandlerMapping&quot;&gt;&lt;a href=&quot;#HandlerMapping&quot; class=&quot;headerlink&quot; title=&quot;HandlerMapping&quot;&gt;&lt;/a&gt;HandlerMapping&lt;/h3&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​    &lt;code&gt;HandlerMapping&lt;/code&gt;处理器映射器，是&lt;code&gt;SpringMvc&lt;/code&gt;的核心组件之一，用来根据请求的&lt;code&gt;request&lt;/code&gt;信息查询对应的&lt;code&gt;Handler&lt;/code&gt;，在&lt;code&gt;web&lt;/code&gt;环境中，每个请求都需要一个对应的&lt;code&gt;Handler&lt;/code&gt;来处理，所以当接收到一个请求，需要哪一个&lt;code&gt;Handler&lt;/code&gt;来处理，&lt;code&gt;HandlerMapping&lt;/code&gt;的作用就是找到处理的那个&lt;code&gt;Handler&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>认识SpringMvc</title>
    <link href="http://xiaocainiaoya.github.io/2021/08/09/SpringMvc/%E8%AE%A4%E8%AF%86SpringMvc/"/>
    <id>http://xiaocainiaoya.github.io/2021/08/09/SpringMvc/%E8%AE%A4%E8%AF%86SpringMvc/</id>
    <published>2021-08-09T14:46:11.000Z</published>
    <updated>2021-08-23T14:53:31.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识SpringMvc"><a href="#认识SpringMvc" class="headerlink" title="认识SpringMvc"></a>认识SpringMvc</h3><h2 id="认识SpringMvc-1"><a href="#认识SpringMvc-1" class="headerlink" title="认识SpringMvc"></a>认识SpringMvc</h2><p>​    <code>SpringMvc</code>是基于<code>spring</code>在<code>web</code>领域进行开发的框架，使得业务开发者无需关心<code>Servlet</code>组件的逻辑处理，让业务开发者仅需要关心业务逻辑的处理。<span id="more"></span></p><p>​    由于在我较为整体的学习<code>SpringMvc</code>源码时，市面上已经比较倾向于前后端分离的开发模式，已经少有这种传统的<code>jsp</code>的模板结构的模式了。所以基本上只会记录从请求到前端控制器<code>DispatcherServlet</code>以及<code>HandlerMapping</code>、<code>HandlerAdapter</code>等的处理，并不会记录视图解析器等与视图相关内容。</p><!--more--><p><strong>以下先简单罗列后续会比较重点介绍的部分。</strong></p><ul><li><code>DispathcerServlet</code>：前端控制器，实际是它就是一个<code>servlet</code>。若你学过最原生的写法，不依赖于任何<code>mvc</code>框架，应该是继承一个<code>HttpServlet</code>后，重写它的<code>service</code>方法，然后再通过请求方式的不同等进行不同的路由跳转或者重定向等操作。实际上<code>DispatcherServlet</code>也以此为主要逻辑，它就是控制请求的分发。</li><li><code>Handler</code>：处理器(具体的业务逻辑)，在项目启动时会将<code>@Controller</code>中的一个个<code>@RequestMapping</code>方法都抽象为这个接口的结构。</li><li><code>HandlerMapping</code>：处理器映射器，当请求来临时，根据请求的<code>url</code>等结构，寻找具体的<code>Handler</code>。</li><li><code>HanderApdater</code>：处理器适配器，会将<code>Handler</code>包装为处理器适配器，从而支持多种类型的处理器，通过它根据适配的结构调用正在的处理器的业务逻辑方法，完成功能处理。</li></ul><h4 id="1-spring、springmvc、springboot间父子容器的问题？"><a href="#1-spring、springmvc、springboot间父子容器的问题？" class="headerlink" title="1. spring、springmvc、springboot间父子容器的问题？"></a>1. <strong>spring、springmvc、springboot间父子容器的问题？</strong></h4><p><strong>对于传统的<code>springmvc</code>项目而言，可以通过<code>web.xml</code>文件配置来配置</strong></p><ol><li><p>仅配置了<code>&lt;servlet&gt;</code>(<code>DispatcherServlet</code>)。这时在启动项目时，在对<code>DispatcherServlet</code>进行初始化时，调用父类<code>FrameworkServlet</code>的<code>initWebApplicationContext</code>方法，在该方法中的设置父容器，是获取不到<code>spring</code>容器的，所以这种情况下整个项目仅有<code>springmvc</code>容器。</p></li><li><p>若配置了<code>&lt;listener&gt;</code>(<code>ContextLoaderListener</code>)和<code>&lt;servlet&gt;</code>(<code>DispatcherServlet</code>)，这时项目启动时，先通过监听器加载<code>spring</code>容器，待完成<code>spring</code>容器加载后，才会通过<code>DispatcherServlet</code>进行<code>springmvc</code>容器的加载。(<strong>为什么在加载<code>spring</code>容器的过程中不会加载<code>DispatcherServlet</code>：</strong>这时<code>spring</code>并不会识别到<code>DispatcherServlet</code>)，在<code>springmvc</code>容器加载时，可以获取到<code>spring</code>容器，并设置为<code>springmvc</code>容器的父容器。</p></li><li><p>仅配置<code>&lt;listener&gt;</code>(<code>ContextLoaderListener</code>)，这种情况就没得说了，如果不加载<code>DispathcerServlet</code>那根本就不是<code>springmvc</code>项目。</p></li></ol><p><strong>注意：</strong>以上第二种情况，需特别注意若是使用中出现事务、或者<code>AOP</code>等处理，需保证父子容器中都有对应的处理。</p><p><strong><code>springboot</code>是如何处理<code>springmvc</code>中的父子容器问题？</strong></p><p>​    我认为<code>springmvc</code>的这种父子容器思想(子容器可以访问父容器，父容器不可访问子容器)，是可以有效的进行框架层级边界的划分，比如<code>service</code>层一般放在<code>spring</code>容器中，而<code>web</code>层(<code>controller/Action</code>)等放在<code>springmvc</code>容器中，所以如果需要跟换<code>web</code>层框架，比如将<code>springmvc</code>更换为<code>struct</code>，仅仅只需要将<code>spring-servlet.xml</code>文件替换为<code>struct</code>的配置文件即可。</p><p>​    在<code>springboot</code>中，并没有延续<code>springmvc</code>的这种父子容器思想，从设计结构来说，<code>DispatcherServlet</code>的父接口中有<code>ApplicationContextAware</code>接口，也就是说，如果在<code>spring</code>容器初始化过程中，将<code>DispatcherServlet</code>识别为<code>bean</code>，那么就会通过后置接口为<code>DispatcherServlet</code>设置容器，所以真正调用<code>DispatcherServlet</code>的初始化方法时，<code>this.webApplicationContext</code>已经通过后置接口赋值，就就不会重新创建一个新的容器，<code>springboot</code>就是通过这种方式，来控制整个上下文仅使用一个容器。</p><h4 id="2-springmvc和servlet之间的关系？"><a href="#2-springmvc和servlet之间的关系？" class="headerlink" title="2. springmvc和servlet之间的关系？"></a>2. springmvc和servlet之间的关系？</h4><p>​    <code>web</code>端开发实际上就是客户端和服务端进行交换数据，而交换数据的过程中不可避免的需要经过建立连接、传输数据、业务逻辑处理、返回数据、关闭连接的过程。而在日常开发过程中，业务开发者并不需要关心整个过程，业务开发者只需要关注业务逻辑处理这一环节。这是因为<code>tomcat</code>处理了这些动作。</p><p>在<code>springmvc</code>中，通过<code>web.xml</code>配置文件来配置<code>DispatcherServlet</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/spring/SpringMVC-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这里配置说明拦截了所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上<code>DispatcherServlet</code>就是一个<code>servlet</code>，这个配置文件配置了<code>DispathcerServlet</code>这个<code>Servlet</code>需要拦截的<code>url</code>地址，显然这个配置的是<code>/</code>，也就是入站的所有地址。也就是说当客户端发起请求时，先进入<code>tomcat</code>，由<code>tomcat</code>为其建立连接后将请求等信息传递给<code>DispatcherServlet</code>这个<code>servlet</code>。由这个<code>DispatcherServlet</code>来处理请求的分发，在<code>SpringMvc</code>中称它为前端控制器。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识SpringMvc&quot;&gt;&lt;a href=&quot;#认识SpringMvc&quot; class=&quot;headerlink&quot; title=&quot;认识SpringMvc&quot;&gt;&lt;/a&gt;认识SpringMvc&lt;/h3&gt;&lt;h2 id=&quot;认识SpringMvc-1&quot;&gt;&lt;a href=&quot;#认识SpringMvc-1&quot; class=&quot;headerlink&quot; title=&quot;认识SpringMvc&quot;&gt;&lt;/a&gt;认识SpringMvc&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;SpringMvc&lt;/code&gt;是基于&lt;code&gt;spring&lt;/code&gt;在&lt;code&gt;web&lt;/code&gt;领域进行开发的框架，使得业务开发者无需关心&lt;code&gt;Servlet&lt;/code&gt;组件的逻辑处理，让业务开发者仅需要关心业务逻辑的处理。</summary>
    
    
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/categories/springmvc/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="springmvc" scheme="http://xiaocainiaoya.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactoryProcessor</title>
    <link href="http://xiaocainiaoya.github.io/2021/07/07/Spring/BeanFactoryProcessor/"/>
    <id>http://xiaocainiaoya.github.io/2021/07/07/Spring/BeanFactoryProcessor/</id>
    <published>2021-07-07T13:45:33.000Z</published>
    <updated>2021-08-23T14:55:54.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeanFactoryProcessor"><a href="#BeanFactoryProcessor" class="headerlink" title="BeanFactoryProcessor"></a>BeanFactoryProcessor</h1><p>​    <code>BeanFactoryPostProcessor</code>是<code>spring</code>中一个很重要的扩展点，它与<code>BeanPostProcessor</code>长相类似，触发点略有不同。<code>BeanFactoryPostProcessor</code>的作用时期是在所有<code>bean</code>实例化之前。所以它的作用是加载<code>BeanDefinition</code>。或者可以动态的修改或者是新增<code>BeanDefinition</code>。<span id="more"></span></p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><code>BeanFactoryPostProcessor</code>有一个扩展接口，这个扩展接口的方法会优先与<code>BeanFactoryPostProcessor</code>的方法执行。</p><p><img src="https://i.loli.net/2021/07/07/dU1jTIlg8Kr4YHs.png" alt="BeanFactoryPostProcessor类图.png"></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>​    还是从<code>spring</code>的核心方法<code>refresh</code>入手。其中的<code>invokeBeanFactoryPostProcessors(beanFactory);</code>就是用来处理<code>BeanFactoryPostProcessor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// 准备刷新容器操作(设置一些状态位,监听器、事件器)</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// 实例化一个Bean工厂(DefaultListableBeanFactory)</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="comment">// 初始化BeanFactory, 进行一些属性的初始化赋值</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">        <span class="comment">// 空方法扩展点(springboot中有使用到)</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        <span class="comment">// 调用BeanFactoryPostProcessor ---&gt; (在这里执行!!!)</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">        <span class="comment">// 注册所有的BeanPostProcessor</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">        <span class="comment">// 国际化</span></span><br><span class="line">        initMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">        <span class="comment">// 初始化事件广播器</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">        <span class="comment">// 扩展点, 由子类实现</span></span><br><span class="line">        onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">        <span class="comment">// 注册事件监听器</span></span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        <span class="comment">// 实例化所有的非懒加载的单例对象</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        destroyBeans();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">        cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">        <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">        resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的处理方法在<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code>，源码处已有一些注释。这里简单描述一下整个流程。</p><p>第一步：参数中传递进来的 <code>beanFactoryPostProcessors</code>，由上述可知，这里可能是<code>BeanDefinitionRegistryPostProcessor</code>也可能是<code>BeanFactoryPostProcessor</code>的实现类。所以定义两个集合<code>regularPostProcessors</code>和<code>registryProcessors</code>用于将二者分离开。这里会执行参数中传递进来的<code>BeanDefinitionRegistryPostProcessor</code>类型的接口。(在<code>springboot</code>中，可以在启动类的启动方法中添加)</p><p>第二步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，挑选出包含实现了<code>PriorityOrdered</code>接口的类，根据特定的排序规则进行排序后逐一执行。(在默认的情况下，这里仅会获取到<code>ConfigurationClassPostProcessor</code>，这里类的作用是处理配置类，将配置类[也就是开发者标记<code>@Configuration</code>、<code>@Component</code>、<code>@ImportSelector</code>等等]添加到容器中。)</p><p>第三步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，挑选出包含实现了<code>Ordered</code>接口的类，过滤执行过<code>BeanDefinitionRegistryPostProcessor</code>(若某个接口同时实现<code>Ordered</code>和<code>PriorityOrdered</code>，则应该在第二步中执行)，根据特定的排序规则进行排序后逐一执行。</p><p>第四步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，过滤已经执行过的，将剩下未执行的所有类，根据特定的排序规则进行排序后逐一执行。(这里使用死循环的原因：可能出现套娃情况，某个<code>BeanDefinitionRegistryPostProcessor</code>的实现方法中又创建了一个新的<code>BeanDefinitionRegistryPostProcessor</code>。)</p><p><strong>以上便已经执行了容器中所有<code>BeanDefinitionRegistryPostProcessor</code>的扩展点。接下来就是执行<code>BeanFactoryPostPostProcessor</code>扩展点。</strong></p><p>第五步：执行上述所有步骤中的<code>BeanDefinitionRegistryPostProcessor</code>的<code>BeanFactoryPostProcessor</code>的实现接口。(就是扩展接口中的扩展方法已经都执行完了，在这个地方统一执行父接口中的实现方法。)</p><p>第六步：执行参数中传递进来的<code>beanFactoryPostProcessors</code>中仅实现<code>BeanFactoryPostProcessor</code>的实现接口。</p><p>第七步：(<code>BeanFactoryPostPostProcessor</code>的执行比较简单，用一步概括)，获取容器中所有实现了<code>BeanFactoryPostProcessor</code>的类，将它们分为三类<code>PriorityOrdered</code>、<code>Ordered</code>、和没有实现这两个接口的。然后分别根据排序规则进行排序后逐一执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行BeanFactoryPostProcessor扩展点</span></span><br><span class="line"><span class="comment"> * 1. 执行BeanDefinitionRegistryPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> * 1.1. 执行参数beanFactoryPostProcessors中是BeanDefinitionRegistryPostProcessor的实现类的扩展点</span></span><br><span class="line"><span class="comment"> * 1.2. 执行spring容器中的BeanDefinitionRegistryPostProcessor的实现且依次<span class="doctag">@PriorityOrdered</span>、<span class="doctag">@Ordered</span></span></span><br><span class="line"><span class="comment"> * 1.3. 执行容器中还存在BeanDefinitionRegistryPostProcessor实现但未加入已执行集合(registryProcessors)中的实现类</span></span><br><span class="line"><span class="comment"> *2. 执行BeanDefinitionPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> *2.1. 执行非直接实现BeanDefinitionRegistryPostProcessor集合(registryProcessors)的BeanFactoryPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> *2.2. 执行直接实现BeanFactoryPostProcessor集合(regularPostProcessors)的BeanFactoryPostProcessor的扩展点(这个集合中若存在</span></span><br><span class="line"><span class="comment"> *元素, 则是开发者通过调用参数携带进来, 在第一步骤执行是分离出来)</span></span><br><span class="line"><span class="comment"> *2.3. 执行spring容器中还未执行的BeanFactoryPostProcessor、顺序依次为<span class="doctag">@PriorityOrdered</span>、<span class="doctag">@Ordered</span>、最后是没有标记前者两注解的</span></span><br><span class="line"><span class="comment"> *BeanFactoryPostProcessor的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/09 10:05:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactoryPostProcessors 这个是自定义的beanFactoryPostProcessors, 默认是空的, 除非自己扩展</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line"><span class="comment">//处理过的BeanDefinitionRegistryPostProcessors类型的bean名字集合</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"><span class="comment">// 常规postProcessor(直接实现BeanFactoryPostProcessor的实现类)集合</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// registryProcessor(非直接实现BeanFactoryPostProcessor的实现类)且已经调用过扩展点的集合</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactoryPostProcessor是BeanDefinitionRegistryPostProcessor的父接口, 执行beanFactoryPostProcessors中的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">// 并将执行过后的BeanDefinitionRegistryPostProcessor放置在registryProcessors, 将未执行的BeanFactoryPostProcessor添加到regularPostProcessors</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"><span class="comment">// 调用BeanDefinitionRegistryPostProcessor扩展点</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 直接实现了BeanFactoryPostProcessor接口的实现</span></span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line"><span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line"><span class="comment">// 放内部的BeanDefinitionRegistryPostProcessor后置处理器</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 首先, 调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment">// (若没有改造或者二次开发过, 此处只会返回ConfigurationClassPostProcessor类</span></span><br><span class="line"><span class="comment">//  ConfigurationClassPostProcessor类的作用是加载配置类)</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">// 执行BeanDefinitionRegistryPostProcessors扩展点</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 其次, 调用仅实现了Ordered接口的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">// 过滤调用过的processedBean</span></span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 最后, 调用processedBeans中没有标记过的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment">// 这个while循环是由于可能出现套娃的情况: 比如A类实现了BeanDefinitionRegistryPostProcessor, 在调用A的</span></span><br><span class="line">    <span class="comment">//postProcessBeanDefinitionRegistry中又添加了一个BeanDefinitionRegistryPostProcessor类B。</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"><span class="comment">// 不要在此处初始化 FactoryBeans：我们需要保留所有未初始化的常规bean，让 bean 工厂后处理器应用于它们！</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>​    从<code>spring</code>的生命周期看<code>BeanFactoryPostProcessor</code>的执行时机就是在<code>BeanPostProcessor</code>注册之前，甚至可以说是在大部分的<code>bean</code>注入之前。但若大量使用<code>BeanFactoryPostProcessor</code>进行扩展，若有重叠区域，则需考虑执行的先后顺序。比如后期的扩展是否需要控制新的<code>BeanFactoryPostProcessor</code>要在旧<code>BeanFactoryPostProcessor</code>之前或者之后？这个执行顺序是一个很容易忽略的<strong>关键点</strong>(自定义的<code>BeanFactoryPostProcessor</code>可以通过实现<code>Order</code>接口控制执行顺序)</p><p><strong>实例1</strong></p><p>​    可以通过<code>BeanDefinitionRegistryPostProcessor</code>修改<code>BeanDefinition</code>，比如在业务场景中有非常多的地方使用的是名称注入的方式，现要让这个名称注入容器中的类由新类，替换旧类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 替换class</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 获取扫描路径下的旧类 </span></span><br><span class="line">      BeanDefinition beanDefinition = registry.getBeanDefinition(<span class="string">&quot;roomService&quot;</span>);</span><br><span class="line">      <span class="comment">// 使其指向新类</span></span><br><span class="line">      beanDefinition.setBeanClassName(<span class="string">&quot;cn.com.xiaocainiaoya.service.NewRoomService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例2</strong></p><p>​    <code>springframwork</code>的扫描工作中比较核心的类<code>ConfigurationClassPostProcessor</code>，这个类的作用就是扫描配置类，扫描指定路径下的各种配置注解<code>@Configuration</code>、<code>Component</code>、<code>ComponentScan</code>等等。将这些类解析后添加到<code>BeanDefinition</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从注册表中的配置类派生进一步的 bean 定义。简单说根据BeanDefinition将配置类添加到spring容器中</span></span><br><span class="line"><span class="comment"> * 1. 完成扫描</span></span><br><span class="line"><span class="comment"> * 2. 对配置类的定义, 完成对配置类的标记</span></span><br><span class="line"><span class="comment"> * 3. 对import的处理</span></span><br><span class="line"><span class="comment"> * 3.1 ImportSelector(在springboot中自动装配典型使用)</span></span><br><span class="line"><span class="comment"> * 3.2 ImportBeanDefinitionRegistrar(在mybatis中典型使用)</span></span><br><span class="line"><span class="comment"> * 3.3 普通类</span></span><br><span class="line"><span class="comment"> * 3.3.1 没有任何特殊注解</span></span><br><span class="line"><span class="comment"> * 3.3.2 加了Import</span></span><br><span class="line"><span class="comment"> * 3.4 ImportResource</span></span><br><span class="line"><span class="comment"> * 4. <span class="doctag">@Bean</span>的处理</span></span><br><span class="line"><span class="comment"> * 5. 接口当中的<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> * 6. <span class="doctag">@PropertySource</span>的处理</span></span><br><span class="line"><span class="comment"> * 7. 内部类的处理</span></span><br><span class="line"><span class="comment"> * 8. 父类的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Derive further bean definitions from the configuration classes in the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 生成一个id，放置后面再重复执行</span></span><br><span class="line"><span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若重复执行  就抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此registry里的BeanDefinition收集动作，已经做了  避免再重复收集此registry</span></span><br><span class="line"><span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据配置类，收集到所有的bd信息,并且做出mark标注：是Full模式还是Lite模式</span></span><br><span class="line">processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>​    <code>BeanFactoryPostProcessor</code>算是<code>spring</code>给予开发者很高的权限去处理<code>BeanDefinitions</code>，但使用的过程中还需遵守<code>spring</code>的规范，不可将<code>bean</code>实例化，即不可在<code>BeanFactoryPostProcessor</code>中触发<code>bean</code>实例化的操作。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">// 这个getBeansOfType调用会触发getBean方法，会导致Bean提前注入，而在生命周期的这个节点</span></span><br><span class="line">      <span class="comment">// 自动注入的BeanPostProcessor还没有注入，还不会作用在bean的创建过程中，所以会导致</span></span><br><span class="line">      <span class="comment">// RoomService的属性注入会失效。</span></span><br><span class="line">      Map&lt;String, RoomService&gt; map = beanFactory.getBeansOfType(RoomService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以，在<code>BeanFactoryPostProcessor</code>的使用中切记要确保不会触发<code>Bean</code>的提前实例化。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BeanFactoryProcessor&quot;&gt;&lt;a href=&quot;#BeanFactoryProcessor&quot; class=&quot;headerlink&quot; title=&quot;BeanFactoryProcessor&quot;&gt;&lt;/a&gt;BeanFactoryProcessor&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;是&lt;code&gt;spring&lt;/code&gt;中一个很重要的扩展点，它与&lt;code&gt;BeanPostProcessor&lt;/code&gt;长相类似，触发点略有不同。&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的作用时期是在所有&lt;code&gt;bean&lt;/code&gt;实例化之前。所以它的作用是加载&lt;code&gt;BeanDefinition&lt;/code&gt;。或者可以动态的修改或者是新增&lt;code&gt;BeanDefinition&lt;/code&gt;。</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Springbean的生命周期</title>
    <link href="http://xiaocainiaoya.github.io/2021/07/04/Spring/Springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://xiaocainiaoya.github.io/2021/07/04/Spring/Springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-07-04T12:27:56.000Z</published>
    <updated>2021-09-09T06:12:08.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springbean的生命周期"><a href="#Springbean的生命周期" class="headerlink" title="Springbean的生命周期"></a>Springbean的生命周期</h1><p>​    虽然大概知道<code>springbean</code>的生命周期的过程，但怕这老年人记忆，过段时间就忘了，故本篇将记录一下常用生命周期节点，以及事件的一些节点。<span id="more"></span></p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>下图为<code>BeanPostProcessor</code>的接口方法以及它的扩展接口的方法，这些接口就是贯穿<code>spring</code>一个<code>bean</code>创建完成的全过程。</p><p><img src="https://i.loli.net/2021/07/04/b932EyxHtVz4G1X.png" alt="BeanPostProcessor扩展点.png"></p><p>简单看一下这些接口的方法。</p><ol><li><code>BeanPostProcessor</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化之前调用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化之后调用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>MergedBeanDefinitionPostProcessor</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MergedBeanDefinitionPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并RootBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A notification that the bean definition for the specified name has been reset,</span></span><br><span class="line"><span class="comment"> * and that this post-processor should clear any metadata for the affected bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DefaultListableBeanFactory#resetBeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>InstantiationAwareBeanPostProcessor</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化之前的操作, 用于创建一个bean对象可能是一个代理用于替代目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否允许注入校验</span></span><br><span class="line"><span class="comment"> * 实例化之后的操作, 在populateBean方法中，如果返回false表示不允许进行注入，直接跳出方法</span></span><br><span class="line"><span class="comment"> * 相当于populateBean的前置校验方法，若跳出则表示什么都没有注入。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要就是处理 通过注解注入属性的一系列操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弃用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>SmartInstantiationAwareBeanPostProcessor</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推断构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理循环依赖时使用，获取提前暴露对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体在<code>bean</code>创建过程中的哪一个环节中使用到。</strong></p><p><img src="https://i.loli.net/2021/07/04/NckDGq61TmasItW.png" alt="BeanPostProcessor具体调用点.png"></p><ol><li>这里判断正要实例化的<code>bean</code>是否需要被代理，也就是这个扩展点允许开发者干预<code>springbean</code>的创建流程，若开发者实现这个方法并返回代理对象，这是仅是调用<code>BeanPostProcessor#postProcessAfterInitialization</code>后就将对象打入容器中，不会走<code>springbean</code>的创建流程。</li><li>这个扩展点就是为了第1点中的情况结合使用。</li><li>推断构造函数，在没有指定构造函数时，可以通过这个扩展点，进行推断构造函数，<code>@PostConstruct</code>注解就是通过实现这个扩展点实现。</li><li>这个扩展点用于动态修改<code>BeanDefinition</code>后进行合并父子<code>BeanDefinition</code>。</li><li>这个扩展点在<code>populateBean()</code>方法的较前位置，主要判断这个<code>bean</code>是否允许进行属性的依赖注入，若这个扩展方法返回<code>false</code>，则表示不允许进行依赖注入，所以就不注入属性依赖，直接返回原对象。</li><li>这里先执行<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessProperties</code>方法，若这个接口返回值为空时，则执行<code>postProcessPropertyValues</code>方法。<code>@Autowired</code>和<code>@Resource</code>注解就是通过实现这个扩展点进行属性注入。</li><li>这个扩展点是在处理循环依赖时，当正在创建的<code>beanA</code>需要注入还未创建的<code>beanB</code>时，通过这个扩展点来获取<code>beanB</code>，这时可以通过这个扩展点对<code>beanB</code>对象进行一些处理，比如<code>SpringAOP</code>就是在这个扩展点上对<code>beanB</code>实现了代理对象，将代理对象注入到正在创建的<code>beanA</code>中。</li><li>这个扩展点就是顶层接口<code>BeanPostProcessor</code>后置处理器的<code>postProcessorBeforeInitialization</code>。比如<code>CommonAnnotationBeanPostProcessor</code>的父类<code>InitDestroyAnnotationBeanPostProcessor</code>实现了这个方法，在这个方法中处理<code>@PostConstruct</code>注解标记方法的反射调用。</li><li>这个扩展点就是顶层接口<code>BeanPostProcessor</code>后置处理器的<code>postProcessorAfterInitialization</code>。比如<code>AbstractAutoProxyCreator</code>使用这个方法对创建完成的<code>bean</code>进行<code>AOP</code>代理。</li></ol><h2 id="事件机制的生命周期"><a href="#事件机制的生命周期" class="headerlink" title="事件机制的生命周期"></a>事件机制的生命周期</h2><p><code>spring</code>的事件机制实际上就是发布订阅模式的实现，且<code>spring</code>内置就有好几个伴随着<code>spring</code>容器生命周期的事件，但好像使用比较多的是被<code>springboot</code>扩展的事件，<code>springboot</code>通过实现<code>ApplicationEvent</code>抽象类，又扩展了一些事件。</p><p><strong><code>springboot</code>中的事件</strong>：<code>SpringApplicationEvent</code>是<code>springboot</code>的所有事件接口的抽象父接口</p><p><img src="https://i.loli.net/2021/07/06/dVxezH5KOCEgUBY.png" alt="springboot事件监听类继承关系.png"></p><ol><li><code>ApplicationStartingEvent</code>：框架启动发送事件，在<code>springboot</code>的启动方法中，当调用<code>run</code>方法后，随之就发送该事件。</li><li><code>ApplicationEnvironmentPreparedEvent</code>：环境准备完成发送事件，在步骤1事件发送之后，<code>springboot</code>就进行读取启动命令行参数以及<code>environment</code>的处理，完成该处理后发生时间。</li><li><code>ApplicationContextInitializedEvent</code>：Spring上下文初始化完成且在加载bean之前发送，在<code>SpringApplication#prepareContext</code>方法中触发该事件。</li><li><code>ApplicationPreparedEvent</code>：Spring上下文准备完成且Bean尚未加载完成，在<code>SpringApplication#prepareContext</code>的最后触发该事件，这个事件发送之后就进入<code>spring</code>的核心方法<code>refresh</code>。</li><li><code>ApplicationStartedEvent</code>：在<code>spring</code>的<code>refresh</code>方法执行完毕之后发送该事件，表示容器启动完成。</li><li><code>ApplicationReadyEvent</code>：在<code>SpringApplication#run</code>方法的最后，发送该事件。</li></ol><p>以上6个事件是依次执行，根据上述信息可得，<code>spring</code>内置的事件的执行时期，应该是在第四步骤中。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Springbean的生命周期&quot;&gt;&lt;a href=&quot;#Springbean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Springbean的生命周期&quot;&gt;&lt;/a&gt;Springbean的生命周期&lt;/h1&gt;&lt;p&gt;​    虽然大概知道&lt;code&gt;springbean&lt;/code&gt;的生命周期的过程，但怕这老年人记忆，过段时间就忘了，故本篇将记录一下常用生命周期节点，以及事件的一些节点。</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring循环依赖(下)</title>
    <link href="http://xiaocainiaoya.github.io/2021/07/04/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96(%E4%B8%8B)/"/>
    <id>http://xiaocainiaoya.github.io/2021/07/04/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96(%E4%B8%8B)/</id>
    <published>2021-07-04T07:20:02.000Z</published>
    <updated>2021-07-04T07:41:25.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring循环依赖-下"><a href="#Spring循环依赖-下" class="headerlink" title="Spring循环依赖(下)"></a>Spring循环依赖(下)</h1><p>​    上文中把<code>springbean</code>的创建过程大致整理了一下，但是似乎还没有回答上文<strong>背景</strong>中提出的问题，为什么在某个方法上加了一个<code>@Async</code>注解之后，导致出现了循环依赖报错，而上文中有两个简单小例子，其中使用了<code>AOP</code>，却没有出现循环依赖报错？(如果对<code>spring</code>中的<code>AOP</code>和<code>@Async</code>实现方式有一个大概了解的话，应该知道二者都是通过生成代理对象的方式实现。)</p><span id="more"></span><p>这里举两个个例子：</p><ol><li>A对象和B对象相互依赖，且A对象中的<code>printHelloWorld</code>标记<code>@Async</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>A对象和B对象相互依赖，且A对象中的<code>printHelloWorld</code>被<code>AOP</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.com.xiaocainiaoya.cyclic.A.printHelloWorld(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect before&quot;</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在第一个例子中，在创建B对象时，B通过第三级缓存中的提前暴露对象工厂获得的A对象是A在创建过程中的空对象。当A的经过初始化之后(在<code>initialization()</code>方法中会执行实现了<code>BeanPostProcessor</code>后置处理器中的<code>postProcessAfterInitialization</code>方法，而<code>@Async</code>的实现就是<code>AsyncAnnotationBeanPostProcessor</code>，经过该方法后生成的代理对象为<code>proxyA</code>)，所以就导致A对象提前暴露给B对象注入的对象与最后初始化生成的对象不一致，根据上文说的判定逻辑，最终导致循环依赖报错。</p><p><img src="https://i.loli.net/2021/07/04/BaP8rXsQo1Zfwdi.png" alt="循环依赖2.png"></p><p>​    在第二个例子中，在创建B对象时，B通过第三级缓存中的提前暴露对象工厂获取的A对象是经过<code>BeanPostProcessor</code>后置处理器的一个子扩展接口<code>SmartInstantiationAwareBeanPostProcessor</code>的<code>getEarlyBeanReference</code>方法，处理之后变为代理对象<code>proxyA</code>，(这里通过提前暴露对象的工厂获取到的就是代理对象，也就是提前暴露的对象就是代理对象)，所以进入上文的判定逻辑，正常返回。</p><p><img src="https://i.loli.net/2021/07/04/tjRu7AGEqvhrQL1.png" alt="循环依赖2-1.png"></p><p><strong>注意：</strong>二者之前的差别就是提前暴露的对象是不是代理对象。获取说是代理对象的暴露时机有所不同。那么为什么二者暴露代理对象的时机有所不同？二者都是通过<code>BeanPostProcessor</code>的实现进行处理，<code>AOP</code>实现类和<code>@Async</code>的实现类<code>AnnotationAwareAspectJAutoProxyCreator</code>和<code>AsyncAnnotationBeanPostProcessor</code>有一个很大的区别是前者实现了<code>SmartInstantiationAwareBeanPostProcessor</code>接口，在提前暴露对象工厂中，只会执行实现了这个接口的<code>getEarlyBeanReference</code>方法来获取提前暴露对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring循环依赖-下&quot;&gt;&lt;a href=&quot;#Spring循环依赖-下&quot; class=&quot;headerlink&quot; title=&quot;Spring循环依赖(下)&quot;&gt;&lt;/a&gt;Spring循环依赖(下)&lt;/h1&gt;&lt;p&gt;​    上文中把&lt;code&gt;springbean&lt;/code&gt;的创建过程大致整理了一下，但是似乎还没有回答上文&lt;strong&gt;背景&lt;/strong&gt;中提出的问题，为什么在某个方法上加了一个&lt;code&gt;@Async&lt;/code&gt;注解之后，导致出现了循环依赖报错，而上文中有两个简单小例子，其中使用了&lt;code&gt;AOP&lt;/code&gt;，却没有出现循环依赖报错？(如果对&lt;code&gt;spring&lt;/code&gt;中的&lt;code&gt;AOP&lt;/code&gt;和&lt;code&gt;@Async&lt;/code&gt;实现方式有一个大概了解的话，应该知道二者都是通过生成代理对象的方式实现。)&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring循环依赖(上)</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/29/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96(%E4%B8%8A)/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/29/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96(%E4%B8%8A)/</id>
    <published>2021-06-29T12:20:58.000Z</published>
    <updated>2021-07-04T07:40:27.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring循环依赖-上"><a href="#Spring循环依赖-上" class="headerlink" title="Spring循环依赖(上)"></a>Spring循环依赖(上)</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    今天在开发过程中，同事在一个<code>xxxService</code>中的某个方法上添加了<code>@Async</code>注解，本意是希望这个方法可以异步执行，但是添加注解之后，发现启动报错。</p><span id="more"></span><p>报错信息如下：</p><blockquote><p>Bean with name ‘xxxService’ has been injected into other beans [xxxAService,xxxBService,xxxCService,xxxDService,xxxEService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using ‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.</p></blockquote><p>从报错信息中可以明显的知道，是因为<code>spring bean</code>之间出现了循环依赖。以往只记得一个结论，<code>spring</code>是支持循环依赖，且<code>spring</code>中通过三级缓存来解决循环依赖出现的问题。正好借这个问题，且最近刚好在开<code>spring</code>启动流程，对<code>bean</code>的生命周期有大概的了解。</p><h2 id="Bean的创建过程"><a href="#Bean的创建过程" class="headerlink" title="Bean的创建过程"></a>Bean的创建过程</h2><p>​    实际上一个<code>Spring Bean</code>的创建包含了三个过程：实例化、注入依赖项、初始化，在<code>spring</code>中分别对应的是<code>instantiation</code>、<code>populate</code>、<code>initialization</code>。在没有看<code>spring</code>之前，我一度以为实例化和初始化是一个意思，一直以为两个单词是一个意思。</p><ul><li>实例化(<code>instantiation</code>)：通过指定的静态函数或者实例化对象的某个函数，或者是无参构造函数等方式创建一个空对象。</li><li>注入依赖项(<code>populate</code>)：比如实现了<code>BeanPostProcessor</code>的<code>InstantiationAwareBeanPostProcessor</code>开放的扩展点进行特定情况的依赖项注入，比如在属性上标记的<code>@Autowird</code>，则是通过<code>AutowiredAnnotationBeanPostProcessor</code>进行注入处理。</li><li>初始化(<code>initilization</code>)：注入依赖项之后的一些操作，比如指定了初始化<code>initMethod</code>方法，或者是<code>BeanPostProcessor#postProcessBeforeInitialization</code>接口等。</li></ul><p><code>Spring</code>的<code>bean</code>的创建过程，主要是从<code>AbstractApplicationContext#refresh</code>方法说起，这个方法涉及到了<code>Spring bean</code>的整个生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备刷新容器操作(设置一些状态位,监听器、事件器)</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 实例化一个Bean工厂(DefaultListableBeanFactory)</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 初始化BeanFactory, 进行一些属性的初始化赋值</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 空方法扩展点(springboot中有使用到)</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用BeanFactoryPostProcessor</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 注册所有的BeanPostProcessor</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 初始化事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 扩展点, 由子类实现</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 注册事件监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 实例化所有的非懒加载的单例对象</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建<code>Bean</code>的三个过程，在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法中均有体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ①实例化对象</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">// bean是否需要提前暴露: 需满足三个条件 -&gt; 1.是单例; 2.支持循环依赖; 3.bean正在创建中(在singletonsCurrentlyInCreation中能获取到)</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加三级缓存工厂</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ②填充属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// ③初始化对象:填充属性之后进行初始化及一些扩展点的操作</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面逐个来简单分析下。</p><h3 id="1-实例化对象"><a href="#1-实例化对象" class="headerlink" title="1.实例化对象"></a>1.实例化对象</h3><p>通过以下代码分析，实例化其实就是通过这几种方式，创建了一个空对象，并获取这个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取这个bean的class属性，确保beanDefinition中beanClass属性已经完成解析</span></span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过beanDefinition中的supplier实例化这个bean，一般情况下不会通过这种方式创建</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通过FactoryMethod实例化这个bean</span></span><br><span class="line">    <span class="comment">// 通过工厂方式实例化(包含静态工厂和实例工厂)</span></span><br><span class="line">    <span class="comment">// @Bean是通过实例工厂(实例工厂也被spring容器管理[获取对应Bean之后通过反射调用实例化对象])来实例化对象</span></span><br><span class="line">    <span class="comment">// xml方式中可以指定class为静态类factory-method为静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.下面这段代码都是在通过构造函数实例化这个Bean,分两种情况，一种是通过默认的无参构造，一种是通过推断出来的构造函数</span></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Candidate constructors for autowiring? 获取构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注入依赖项"><a href="#2-注入依赖项" class="headerlink" title="2.注入依赖项"></a>2.注入依赖项</h3><p>主要的逻辑就是根据<code>BeanPostProcessor</code>扩展点的接口，或者实现它的二次扩展接口。通过这些扩展接口的实现，来进行特殊方式的注入，比如使用<code>@Autowird</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 是否允许注入校验, 如果postProcessAfterInstantiation返回false则表示不允许注入</span></span><br><span class="line">                <span class="comment">// 直接跳出populateBean方法</span></span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 执行InstantiationAwareBeanPostProcessor#postProcessProperties</span></span><br><span class="line">                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pvs = pvsToUse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-初始化对象"><a href="#3-初始化对象" class="headerlink" title="3.初始化对象"></a>3.初始化对象</h3><p>主要逻辑就是在注入依赖项之后，进行一些对象完善，可以通过制定初始化方法<code>initMethod</code>或者通过实现<code>BeanPostProcessor</code>后置处理器来处理一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 调用aware扩展点方法</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 2. 执行BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 执行指定的初始化initMethod方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 4. 执行BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong>从大方向来说，<code>spring</code>创建<code>bean</code>的过程就是以上三个过程。而循环依赖的主要处理逻辑应该是在注入依赖项这一环，判定是否循环依赖是在初始化方法之后进行判定。</p><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>在<code>spring</code>中通过三级缓存来解决循环依赖，三级缓存分别为：</p><ul><li><code>singletonObjects</code>：一级缓存，保存的是初始化完成的单例<code>Bean</code>对象</li><li><code>earlySingletonObjects</code>：二级缓存，保存的是实例化之后，注入依赖项之前的对象，换句话说就是一个空对象的引用。</li><li><code>singletonFactories</code>：三级缓存，保存的是需要提前暴露的对象的单例工厂，二级缓存中的对象引用，是由这个工厂生成。</li></ul><p>在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法的，实例化对象之后，注入依赖项之前，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean是否需要提前暴露: 需满足三个条件 -&gt; 1.是单例; 2.支持循环依赖; 3.bean正在创建中</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加三级缓存工厂</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultSingletonBeanRegistry#addSingletonFactory</span></span><br><span class="line"><span class="comment">// 这里会将这个实例化bean的工厂添加到三级缓存中。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">    <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">    <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化bean的工厂方法</span></span><br><span class="line"><span class="comment">// 这个方法大致的作用就是对传入的这个bean对象, 进行满足一下条件的BeanPostProcessor的处理</span></span><br><span class="line"><span class="comment">// 默认情况下只有AOP的一个BeanPostProcessor。在目标bean无需AOP的情况下, 返回的其实就是传入的bean</span></span><br><span class="line"><span class="comment">// 也就是仅仅只经过实例化的bean。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举一个简单的例子，来演示<code>spring</code>创建<code>bean</code>过程中三级缓存的变化。假设需要往<code>spring</code>容器中添加两个对象<code>A、B</code>，且这两个对象相互依赖，且<code>spring</code>先处理<code>A</code>在处理<code>B</code>。</p><p><img src="https://i.loli.net/2021/06/29/95yxZlftYqKW2Rz.png"></p><p>简单通过文字描述下整个流程(当然了三级缓存中的一级缓存中的创建完成的<code>bean</code>不止这两个对象，还包含<code>spring</code>内置的一些对象)：</p><p><strong>A对象的创建过程</strong></p><ol><li><p>A对象实例化：这时仅通过A对象的无参构造函数，创建了一个空对象。</p></li><li><p>将A提前暴露的工厂添加到第三级缓存中：通过<code>addSingletonFactory()</code>方法，这个方法的第二个参数，是个函数式接口，核心逻辑就是使得在第一步实例化的这个空对象提前被满足条件的<code>BeanPostProcessor</code>处理后暴露出来。(所以经过这一步骤后三级缓存中的第三级缓存工厂中添加了一个提交暴露A对象的工厂方法。)</p></li><li><p>A对象依赖注入：假设A对象需要引入的B对象是通过<code>@Autowird</code>属性注入的方式注入的，那么这时会进入到<code>AutowiredAnnotationBeanPostProcessor#postProcessProperties</code>进行属性遍历解析后注入，而在这个时间节点，B对象还未创建，所以进入B对象的创建流程。</p><p><strong>B对象的创建过程</strong></p><p>3.1 B对象实例化：这时仅通过B对象的无参构造函数创建了一个空的B对象。</p><p>3.2 添加B对象的提前暴露工厂：同理步骤2。(所以经过这一步骤后三级缓存中的第三级缓存工厂中又添加了一个提交暴露B对象的工厂方法。在这个时间节点，这个工厂列表中就有两个元素)。</p><p>3.3 B对象依赖注入：同理步骤3的前半步骤。由于这个时候去三级缓存中的一级和二级缓存中获取不到A对象，则进入第三级缓存，通过第三级缓存，获取到了A对象的提前暴露对象，同时移除第三级缓存中A的工厂对象。(这时第二级缓存中存在一个A的提前暴露对象，第三级缓存中仅剩B对象的提前暴露工厂)</p><p>3.4 B对象的初始化：执行一些指定初始化方法，<code>aware</code>方法等。(这时第一级缓存中就有一个创建完成的B对象，第二级缓存中存在一个A的提前暴露对象，第三级缓存中无元素) ==&gt;准确的说这个第一级缓存的添加B对象和第三级缓存中的移除提前暴露B对象的工厂操作并不是在初始化(<code>initializeBean</code>)方法中，而是在获取到B对象之后，有一个是否创建了实例的校验。具体代码在<code>DefaultSingletonBeanRegistry#getSingleton</code></p><p>方法的<code>finally</code>之后，有兴趣可以自行查看。</p><p>这时回到了A对象的注入流程，而A对象就可以获取到创建好的B对象，将B通过反射注入到自身属性中。(所以经过这一步骤后第二级缓存中存在一个A的提前暴露对象，第三级缓存中仅剩B对象的提前暴露工厂)</p></li><li><p>最后A对象的实例化：与3.4步骤同理。最后三级缓存中仅有一级缓存中存在两个元素。</p></li></ol><p><strong>小结：</strong>其实分析下来，整个过程并不难理解，提前暴露到二级缓存中的空对象，其实是每个<code>bean</code>创建的第一步，也就是每个<code>bean</code>都首先会经过一次创建空对象的过程，然后将这个空对象是否需要暴露的决定权，添加到第三级缓存的工厂对象中，如果出现其他对象引用的时候，则提交暴露这个空对象，让依赖对象主体持有这个空对象的引用，这样并不会影响到被依赖对象后续的注入与初始化。</p><p><strong>上述的创建流程是最理想的情况，而比较复杂的情况是3.3步骤中，通过第三级缓存中获取到A对象，有可能并不是在步骤1中创建的空对象 ，而是经过一些<code>BeanPostProcessor</code>处理过的代理对象，比如<code>AOP</code>代理。</strong></p><p>在看两个个例子：</p><ol><li>A与B分别通过<code>@Autowired</code>注入对方，且B被<code>LogAspect</code>进行<code>AOP</code>处理。这种情况下，在3.3步骤B去获取A的提前暴露对象后，B在初始化方法中经过<code>AOP</code>变成一个代理对象返回给A对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.com.xiaocainiaoya.cyclic.B.printHelloWorld(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect before&quot;</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>A与B分别通过<code>@Autowired</code>注入对方，且A被<code>LogAspect</code>进行<code>AOP</code>处理。这种情况下，在3.3步骤B去获取A的提前暴露对象时，获取的是一个代理对象，B将这个代理对象的引用挂在自身声明的A属性处后，将B对象返回。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.com.xiaocainiaoya.cyclic.A.printHelloWorld(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect before&quot;</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判定规则"><a href="#判定规则" class="headerlink" title="判定规则"></a>判定规则</h2><p>​    其实判定是否是循环依赖报错并不是在上面说的创建过程三个步骤中，而是在每一个对象经过这三个步骤后，要添加到<code>spring</code>容器中之前有一个判断逻辑，来进行判定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory#doCreateBean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 从三级缓存中获取提前暴露对象</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 若存在, 有可能是一级缓存也有可能是二级缓存</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较经过实例化创建的bean和经过初始化之后的exposeObject是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            <span class="comment">// 若相等 --&gt; 将提前暴露的对象注入到容器中</span></span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="comment">// 判断这个beanName对应的bean的依赖是否都创建完成</span></span><br><span class="line">            <span class="comment">// 若依赖都创建完成, 则将初始化的exposedObject注入到容器中</span></span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                    actualDependentBeans.add(dependentBean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                        <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                        StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                        <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring循环依赖-上&quot;&gt;&lt;a href=&quot;#Spring循环依赖-上&quot; class=&quot;headerlink&quot; title=&quot;Spring循环依赖(上)&quot;&gt;&lt;/a&gt;Spring循环依赖(上)&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    今天在开发过程中，同事在一个&lt;code&gt;xxxService&lt;/code&gt;中的某个方法上添加了&lt;code&gt;@Async&lt;/code&gt;注解，本意是希望这个方法可以异步执行，但是添加注解之后，发现启动报错。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringAop浅析</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/</id>
    <published>2021-06-27T08:20:58.000Z</published>
    <updated>2021-07-04T07:44:09.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringAop浅析"><a href="#SpringAop浅析" class="headerlink" title="SpringAop浅析"></a>SpringAop浅析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>AOP</code>面向切面编程。在运行时，动态的将代码织入到类的指定方法，指定位置上的思想。实际上<code>AOP</code>不一定都像<code>Spring Aop</code>那样实现，<code>Spring Aop</code>是通过在运行时生成代理对象来进行织入。还有其他的方式，比如<code>AspectJ</code>是在编译期、类加载期织入。本篇文章就来介绍，<code>Spring Aop</code>在运行时生成代理对象的时期和过程。</p><span id="more"></span><h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>​    若想使用<code>SpringAop</code>可以通过两种方式，一种是声明式，通过调用<code>Api</code>的方式；一种是通过注解方式。两者在真正触发生成代理对象的点略有不同。</p><h3 id="1-声明式"><a href="#1-声明式" class="headerlink" title="1.声明式"></a>1.声明式</h3><p>​    这里只做简单介绍，首先需要实现某种通知类型的接口，再实现切点接口(<code>Pointcut</code>)，如果是环绕通知，需将通知实现类和切点实现类绑定<code>DefaultPointcutAdvisor</code>，最后在客户代码中将通知、目标类等信息添加到<code>ProxyFactory</code>实例中后，通过<code>ProxyFactorygetProxy();</code>获取代理对象，从而实现<code>SpringAop</code>。</p><h3 id="2-注解式"><a href="#2-注解式" class="headerlink" title="2.注解式"></a>2.注解式</h3><p>​    通过<code>@Aspect</code>标记一个类为切面类，并通过<code>@Pointcut</code>注解标记一个切点，最后通过注解标记通知类型，比如环绕通知使用<code>@Around</code>进行<code>Aop</code>的业务处理。</p><p><strong>那么<code>Spring</code>如何去解析这些注解？在什么时机解析？</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="1-开启SpringAop"><a href="#1-开启SpringAop" class="headerlink" title="1.开启SpringAop"></a>1.开启<code>SpringAop</code></h3><p>​    在<code>Spring</code>中提供一个开启<code>SpringAop</code>的配置注解<code>@EnableAspectJAutoProxy</code>(在<code>springboot</code>中一般标记在启动类上)，在这个注解上使用<code>@Import</code>注解引入<code>SpringAop</code>配置类<code>AspectJAutoProxyRegistrar</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 为true的话开启cglib代理，默认为jdk代理</span></span><br><span class="line"><span class="comment">    * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">    * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否将代理对象暴露到线程上下文中 </span></span><br><span class="line"><span class="comment">    * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">    * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">    * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AspectJAutoProxyRegistrar</code>实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>接口，在<code>Spring</code>启动扫描配置类后会调用该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">    * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重点在这: 会注册AnnotationAwareAspectJAutoProxyCreator到BeanDefinitionMap中</span></span><br><span class="line">        <span class="comment">// AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor后置处理器</span></span><br><span class="line">        <span class="comment">// 这个方法比较简单, 可自行跟进去看一眼。</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="comment">// 解析注解的属性</span></span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Aop代理对象的生成"><a href="#2-Aop代理对象的生成" class="headerlink" title="2.Aop代理对象的生成"></a>2.<code>Aop</code>代理对象的生成</h3><p>​    在开启<code>SpringAop</code>时添加了一个<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>Spring</code>容器中，在<code>Spring</code>启动的生命周期中，会在适时调用它的实现方法。</p><p>​    看一下这个类的类图，<code>AnnotationAwareAspectJAutoProxyCreator</code>实现了<code>AbstractAutoProxyCreator</code>抽象类，在这个抽象类中，实现了<code>BeanPostProcessor</code>生命周期接口。</p><p><img src="https://i.loli.net/2021/06/27/eKqWCVnJTcGjiYS.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean实例化之前调用接口:用于提前生成代理对象</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line">    <span class="comment">// this.advisedBeans用于标记某个key是否需要进行AOP代理</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">    <span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">    <span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="comment">// 若用户没有自定义，默认情况下是targetSource是空的</span></span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean初始化之后调用接口:这个接口的调用点是在Bean对象初始化之后, 也就是Bean对象基本</span></span><br><span class="line"><span class="comment">* 上走完了初始化流程。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="comment">// 一般情况下remove(cacheKey) != bean肯定会成立，因为前者remove方法返回null</span></span><br><span class="line">            <span class="comment">// 只有在循环依赖时，可能会出现提前暴露的bean对象与当前bean不等</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>wrapIfNecessary</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经完成代理了，那么直接返回这个代理的对象</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若这个Bean对象被标记无需AOP代理, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不需要代理，直接返回，且标记为无需AOP代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 获取通知可以作用在这个Bean上的通知</span></span><br><span class="line">    <span class="comment">// 主要逻辑在AnnotationAwareAspectJAutoProxyCreator#findCandidateAddvisors方法</span></span><br><span class="line">    <span class="comment">// 首先获取容器中类型为Advisor的Bean, 再从容器中获取@Aspect注解标记的Bean后, 将二者结合。</span></span><br><span class="line">    <span class="comment">// 最后筛选出可以作用到这个Bean的通知。</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="comment">// 标记这个Bean需要进行AOP代理</span></span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建代理对象, 这里是重点</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>createProxy</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建代理工厂类</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将Interceptors转化为具体的Advisor子类的类型</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* createAopProxy():根据一定的配置规则获取动态代理工厂的实现类(jdk动态代理或者是cglib动态代理)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这边跟踪下来<code>createAopProxy()</code>返回的是<code>cglib</code>动态代理的实现，所以以<code>cglib</code>动态代理为例，继续往下走。进入<code>CglibAopProxy#getProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取正在包装的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">    Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">    <span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">      proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">      Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">    validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">    Enhancer enhancer = createEnhancer();</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      enhancer.setClassLoader(classLoader);</span><br><span class="line">      <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">          ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">        enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">    <span class="comment">// 设置需要代理的接口</span></span><br><span class="line">    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">    Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">      types[x] = callbacks[x].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">    enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">      <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">    enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">    <span class="comment">// 创建具体的代理对象实例</span></span><br><span class="line">    <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,ex);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-代理对象的调用"><a href="#3-代理对象的调用" class="headerlink" title="3.代理对象的调用"></a>3.代理对象的调用</h3><p><code>DynamicAdvisedInterceptor#intercept</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取匹配该方法的通知列表</span></span><br><span class="line">        <span class="comment">// 主要逻辑在DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice方法中</span></span><br><span class="line">        <span class="comment">// 根据advised中的通知列表，对当前调用方法进行匹配，将匹配成功的通知转为拦截器链返回。</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">        <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">            <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">            <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">            <span class="comment">// 实例化CglibMethodInvocation后执行proceed方法</span></span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行拦截器链<code>proceed()</code>，进入<code>ReflectiveMethodInvocation#proceed</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="comment">// 表明执行到链尾, 直接通过反射调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到下一个要执行的拦截器</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice = <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="comment">// 调用拦截器中的invoke方法，可以看到这里将this作为参数传入了，这里是一种拦截器链的典型用法</span></span><br><span class="line">        <span class="comment">// 在我之前有篇[从myBatis Plugin看责任链模式]中有两种拦截器链的典型用法，二者的区别就是</span></span><br><span class="line">        <span class="comment">// 有没有携带链对象，这里明显是携带链对象，从而达到拦截器链逐个执行的目的。</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是根据通知类型的不同会进入到不同的具体实现中，比如我的测试代码是环绕通知类型，这里进入环绕通知的具体实现中<code>AspectJAroundAdvice#invoke</code>去执行当前链节点的<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">  &#125;</span><br><span class="line">  ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">  <span class="comment">// 这里只是将链对象包装了一层</span></span><br><span class="line">  ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">  JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPoint jp, <span class="meta">@Nullable</span> JoinPointMatch jpMatch,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="meta">@Nullable</span> Object returnValue, <span class="meta">@Nullable</span> Throwable t)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Object[] actualArgs = args;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    actualArgs = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 反射调用通知方法</span></span><br><span class="line">    ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">    <span class="comment">// TODO AopUtils.invokeJoinpointUsingReflection</span></span><br><span class="line">    <span class="comment">// 把链对象封装在了这个arctualArgs(MethodInvocationProceedingJoinPoint)中了,</span></span><br><span class="line">    <span class="comment">// 所以切面方法中通过jointPoint.process()方法实际调用方法是与链对象挂钩的, 如果执行</span></span><br><span class="line">    <span class="comment">// 到链尾这调用目标对象, 若非链尾, 则继续进入链节点对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;Mismatch on arguments to advice method [&quot;</span> +</span><br><span class="line">                                     <span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">&quot;]; pointcut expression [&quot;</span> +</span><br><span class="line">                                     <span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以我的测试代码为例，环绕通知<code>@Around(&quot;testPointcut()&quot;)</code>的标记实现方法中，一般在前置执行一些业务代码之后，会调用<code>ProceedingJoinPoint#process()</code>方法，后再调用后置的业务代码。</p><p>而<code>ProceedingJoinPoint#process()</code>方法就是转入下一个拦截器链的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodInvocationProceedingJoinPoint</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 这个proceed()方法就回到了上面的ReflectiveMethodInvocation#proceed，且</span></span><br><span class="line">    <span class="comment">// 链下标不是-1, 而是下一个链节点的下标。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.methodInvocation.invocableClone().proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>我这里使用的是<code>springboot</code>项目，仅在项目启动类上添加了一个<code>@EnableAspectJAutoProxy</code>，且默认情况下该注解的<code>proxyTargetClass()</code>属性为<code>false</code>，那么为什么我在调试的时候会进入到<code>Cglib</code>动态代理的实现中，逻辑上应该是使用<code>jdk</code>动态代理？</p><p>​    这是因为<code>springboot</code>的自动装配<code>AopAutoConfiguration</code>中，配置的是<code>cglib</code>动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 采用jdk动态代理的配置:需明确指定配置项spring.aop.proxy-target-class=false</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,matchIfMissing = false)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 采用cglib动态代理的配置:明确指定配置项spring.aop.proxy-target-class=true或者无该配置项时</span></span><br><span class="line"><span class="comment">        * 启用cglib动态代理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line">        ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这里只是对<code>SpringAop</code>做了个很浅的分析，主要是明确<code>SpringAop</code>的大致创建时机、创建流程和基本的调用流程。<code>SpringAop</code>是采用动态代理的方式实现，通过<code>@EnableAspectJAutoProxy</code>的方式开启，开启的原理为添加<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanDefinitionMap</code>中；在<code>Bean</code>对象实例化之前可以通过用户自定义的方式进行提前生成代理对象。或者是在<code>Bean</code>对象初始化之后，通过上述后置处理器的<code>postProcessAfterInitialization</code>方法，将<code>Bean</code>对象转为代理对象。</p><p>​    在业务中调用代理对象的某个方法时，进入对应的拦截方法<code>intercept</code>方法，该方法会去获取匹配当前被调用方法的拦截器链，进入链对象后，通过反射调用对应的切面方法后，通过链对象调用下一个链节点，从而遍历整个拦截器链列表，这是一种典型的拦截器设计，我之前也有写一篇文章<a href="https://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank">这里</a>，简单的介绍了拦截器的两种使用方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringAop浅析&quot;&gt;&lt;a href=&quot;#SpringAop浅析&quot; class=&quot;headerlink&quot; title=&quot;SpringAop浅析&quot;&gt;&lt;/a&gt;SpringAop浅析&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    &lt;code&gt;AOP&lt;/code&gt;面向切面编程。在运行时，动态的将代码织入到类的指定方法，指定位置上的思想。实际上&lt;code&gt;AOP&lt;/code&gt;不一定都像&lt;code&gt;Spring Aop&lt;/code&gt;那样实现，&lt;code&gt;Spring Aop&lt;/code&gt;是通过在运行时生成代理对象来进行织入。还有其他的方式，比如&lt;code&gt;AspectJ&lt;/code&gt;是在编译期、类加载期织入。本篇文章就来介绍，&lt;code&gt;Spring Aop&lt;/code&gt;在运行时生成代理对象的时期和过程。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Type接口</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/22/java/Type%E6%8E%A5%E5%8F%A3/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/22/java/Type%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-06-22T13:41:58.000Z</published>
    <updated>2021-06-28T14:48:58.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Type接口"><a href="#Type接口" class="headerlink" title="Type接口"></a>Type接口</h3><p>[TOC]</p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    <code>Type</code>接口是<code>Java</code>中所有类型的公共高级接口，是由<code>JDK5</code>引入，主要是为了实现参数化类型(泛型)，<code>Class</code>类是该接口的直接实现类。</p><span id="more"></span><p>​    在日常开发过程中，一些公共抽象点需要使用泛型进行结构抽象，从而达到业务调用点灵活调用的目的。之前有一次由于不懂<code>Type</code>接口以及子类，导致部分抽象做的不够灵活，本篇主要记录<code>Type</code>接口下参数化类型<code>ParameterizedType</code>的一些<code>API</code>使用。</p><h4 id="二、子接口"><a href="#二、子接口" class="headerlink" title="二、子接口"></a>二、子接口</h4><p><img src="https://i.loli.net/2021/06/22/3LURqsICMOANz7e.png" alt="3LURqsICMOANz7e"></p><p>从左到右依次是直接实现类<code>Class</code>，数组类型接口<code>GenericArrayType</code>，参数化类型接口<code>ParameterizedType</code>，通配符表达式接口<code>WildcardType</code>，类型变量接口(泛指任何类)<code>TypeVariable</code>。大概知道了几个接口之间的关系之后，直接进入一个应用场景。</p><p>​    服务端与客户端交互是设计了一个数据固定的数据结构，其中该数据结构中的存在两个属性<code>String dataJson</code>和<code>T Data</code>，而客户端只会传输经过一定的编码或者加密处理<code>dataJson</code>字段，由服务端自行处理字符串数据。最理想的情况就是，服务端做一层统一处理，接收到该实体对象之后，根据服务端和客户端之间的约定，解析其中的<code>dataJson</code>为对应的<code>data</code>数据。前面有一篇专门来说这个参数解析<a href="https://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/#more" target="_blank">这里</a>。当时同事最开始提出这个问题的时候还并没有提出想将<code>json</code>转为实体，仅想通过某种统一处理，将<code>json</code>解码(客户端传输过来的是经过某种编码)。最终选择的方案是通过<code>RequestBodyAdvice</code>，当完成解码这个动作之后，同事发现，既然都通过统一处理<code>json</code>串解码了，那不就可以通过泛型的方式把<code>json</code>转换为对应的实体？我原本以为获取不到对应类的泛型，而恰巧(真的是巧)。<code>RequestBodyAdvice#afterBodyRead</code>方法上参数是<code>Type</code>类型，从而能通过它(如果是泛型则类型为<code>ParameterizedType</code>)就可以获取到对应类的泛型类型，从而进行转换为对应的实体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span></span></span><br></pre></td></tr></table></figure><p>这里我想抛出我的问题：如果这里没有<code>Type</code>参数，可以看之前那篇文章的其他两种方式，比如现在的场景就是使用<code>@InitBuilder</code>的方式最合适，要怎么获取到<code>Type</code>，或者说获取到参数的<code>ParameterizedType</code>？</p><p>度娘了一下，对查到的一些写法的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接Class: 这种写法纯属骗人，从类图可以看出，就算用父接口引用，其实本质上还是Class类型</span></span><br><span class="line"><span class="comment">// 和ParameterizedType类型不符。</span></span><br><span class="line">DataEntity&lt;User&gt; dataEntity = <span class="keyword">new</span> DataEntity&lt;User&gt;();</span><br><span class="line">Type t = (Type)dataEntity.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过class.getGenericSuperclass():这种方式可以获取到的的确是ParameterizedType，</span></span><br><span class="line"><span class="comment">// 但那是父类的ParameterizedType(如果父类是泛型的情况)。</span></span><br><span class="line"><span class="comment">// 那么如果A继承B，B能获取到A的class, 再通过A的class获取到B的泛型参数, 虽然有点绕, 但也不失为一种方式。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Type type =list.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过反射获取: 反射是根据类来获取对应的属性，这种方式下获取的是泛型前的类型TypeVariable</span></span><br><span class="line"><span class="comment">// 如果某个方法中的参数是泛型类型, 通过method.getGenericParameterTypes()可以获取到ParameterizedType</span></span><br><span class="line">DataEntity&lt;User&gt; dataEntity = <span class="keyword">new</span> DataEntity&lt;User&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Field field = dataEntity.getClass().getField(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">  Type paraType = field.getGenericType();</span><br><span class="line">  System.out.println(paraType);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上的3种方法，1和3直接就不对。只有2沾点边。所以在设计上可以将A设计为泛型接口，B作为A的具体实现，这时就可以获取到对应的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  Type[] type = b.getClass().getGenericInterfaces();</span><br><span class="line">  System.out.println(((ParameterizedType)type[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(User data)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、常用API"><a href="#三、常用API" class="headerlink" title="三、常用API"></a>三、常用API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里要时刻注意获取的父类的的Type或者是Class。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *  class.getSuperclass() 返回直接继承的父类(类型擦除, 不显示泛型参数)</span></span><br><span class="line"><span class="comment"> *  class.getGenericSuperclass() 返回直接继承的父类(包含泛型参数)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  class.getInterfaces() 返回直接实现的接口</span></span><br><span class="line"><span class="comment"> *  class.getGenericInterface() 返回直接实现的接口(包含泛型参数)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * ParameterizedType:</span></span><br><span class="line"><span class="comment"> *   getActualTypeArguments() 返回参数化类型列表(比如DataEntity&lt;User&gt;, 通过该方法获取到的就是User)</span></span><br><span class="line"><span class="comment"> *   getOwnerType() 返回这个ParameterizedType所在类的Type</span></span><br><span class="line"><span class="comment"> *   比如Map&lt;String, Object&gt;的getOwnerType=null,Map.Entry&lt;String,String&gt;的getOwnerType=Map)</span></span><br><span class="line"><span class="comment"> *   getRawType() 表示声明此类型的类或者接口</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/22 22:39:26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Type type =list.getClass().getGenericSuperclass();</span><br><span class="line">    System.out.println(list.getClass().getGenericSuperclass());</span><br><span class="line">    System.out.println(list.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] classes = list.getClass().getInterfaces();</span><br><span class="line">    Type[] types = list.getClass().getGenericInterfaces();</span><br><span class="line"></span><br><span class="line">    System.out.println(list.getClass().getInterfaces());</span><br><span class="line">    System.out.println(list.getClass().getGenericInterfaces());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParameterizedType:</span></span><br><span class="line"><span class="comment"> *   getActualTypeArguments() 返回参数化类型列表(比如DataEntity&lt;User&gt;, 通过该方法获取到的就是User)</span></span><br><span class="line"><span class="comment"> *   getOwnerType() 返回这个ParameterizedType所在类的Type(一般来说是空的)</span></span><br><span class="line"><span class="comment"> *   比如Map&lt;String, Object&gt;的getOwnerType=null,Map.Entry&lt;String,String&gt;的getOwnerType=Map)</span></span><br><span class="line"><span class="comment"> *   getRawType() 表示声明此类型的类或者接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/22 23:16:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Method method = TypeTest.class.getMethod(<span class="string">&quot;test&quot;</span>, Map.Entry.class, </span><br><span class="line">                                                 List.class, DataEntity.class);</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            System.out.println(parameterizedType.getOwnerType() + <span class="string">&quot; || &quot;</span> + </span><br><span class="line">                               parameterizedType.getRawType() + <span class="string">&quot; || &quot;</span> + </span><br><span class="line">                               Arrays.toString(parameterizedType.getActualTypeArguments()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface java.util.Map || interface java.util.Map$Entry || [class cn.com.xiaocainiaoya.entity.User, class java.lang.String]</span></span><br><span class="line"><span class="comment">//null || interface java.util.List || [class cn.com.xiaocainiaoya.entity.User]</span></span><br><span class="line"><span class="comment">//null || class cn.com.xiaocainiaoya.entity.DataEntity || [class //cn.com.xiaocainiaoya.entity.User]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Map.Entry&lt;User, String&gt; mapEntry, List&lt;User&gt; list, DataEntity&lt;User&gt; userDataEntity)</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Type接口&quot;&gt;&lt;a href=&quot;#Type接口&quot; class=&quot;headerlink&quot; title=&quot;Type接口&quot;&gt;&lt;/a&gt;Type接口&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h4&gt;&lt;p&gt;​    &lt;code&gt;Type&lt;/code&gt;接口是&lt;code&gt;Java&lt;/code&gt;中所有类型的公共高级接口，是由&lt;code&gt;JDK5&lt;/code&gt;引入，主要是为了实现参数化类型(泛型)，&lt;code&gt;Class&lt;/code&gt;类是该接口的直接实现类。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMvc请求参数的二次处理</title>
    <link href="http://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>http://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</id>
    <published>2021-06-21T14:20:58.000Z</published>
    <updated>2021-06-22T01:36:13.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMvc请求参数的二次处理"><a href="#SpringMvc请求参数的二次处理" class="headerlink" title="SpringMvc请求参数的二次处理"></a>SpringMvc请求参数的二次处理</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在一个项目中原来服务端是采用<code>WebService</code>的进行客户端和服务进行交互，现根据需要调整为直接使用<code>HHTP</code>方式访问。仅修改访问的方式，其数据的访问结构等不变。</p><span id="more"></span><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><h3 id="1-HandlerMethodArgumentResolver"><a href="#1-HandlerMethodArgumentResolver" class="headerlink" title="1.HandlerMethodArgumentResolver"></a>1.HandlerMethodArgumentResolver</h3><ol><li>原数据结构：在旧项目的设计中，<code>data</code>数据是采用<code>GBK</code>的<code>base64</code>编码，在本次改造中，希望同时将解码的过程也统一处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3033941769749731426L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ApiModelProperty(&quot;请求数据(basic64)&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第一时间想到的就是<code>SpringMvc</code>的参数处理器<code>HandlerMethodArgumentResolver</code>。直接上手开干。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义参数解析器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDateParamMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否支持本自定义参数解析器</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/06/21 22:09:57</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ModelAndViewContainer mavContainer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数解析器添加到spring容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDateParamMethodArgumentResolver <span class="title">requestDateParamMethodArgumentResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestDateParamMethodArgumentResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        argumentResolvers.add(requestDateParamMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.本以为可以完美解决，断点打在<code>resolveArgument</code>，正想启动后根据断点查询对应的参数信息，在进一步完善代码。测试发现，根本就没有进入断点。</p><p>4.虽说对参数解析器的执行过程不是非常的了解，但是大概知道参数解析器的处理是在适配器<code>Adapter</code>查找对应的<code>HandlerMethod</code>之后执行，所以根据调用栈，查找关键代码。</p><p><img src="https://i.loli.net/2021/06/21/qghUHGrXaeABRNp.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 所以在内置的很多参数处理器中，只会选择一种进行处理，由于上述的写法中没有自定义注解，</span></span><br><span class="line">   <span class="comment">// 尽管supportsParameter方法的返回值为true，用户自定义的参数处理器也是排在内置处理器之后。</span></span><br><span class="line">HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line"><span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">result = resolver;</span><br><span class="line"><span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line"><span class="comment">// 获取到一种匹配的参数处理器之后就跳出了</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以：</strong>若需要使用参数处理器进行处理，需要自定义一个注解后，标记在方法的属性处，而改造的本意还是希望业务代码层无需关心解码这一行为，若需要在每个方法处都标记一个注解，与初衷相悖。</p><h3 id="2-InitBinder"><a href="#2-InitBinder" class="headerlink" title="2. @InitBinder"></a>2. @InitBinder</h3><p>这种方式是比较细粒度的控制方式，仅控制单个<code>Controller</code>，在这个<code>Controller</code>中，的参数会被拦截进行数据的二次处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentResolverController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder webDataBinder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(webDataBinder.getTarget() <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User)webDataBinder.getTarget();</span><br><span class="line">            log.info(user.getUsername());</span><br><span class="line">            user.setPassword(<span class="string">&quot;updatePassword&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;setUserInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 这里打印的password是updatePassword,是被修改之后的值, 所以解码可以放在@InitBinder中。</span></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;,&#123;&#125;&quot;</span>,user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-RequestBodyAdvice"><a href="#3-RequestBodyAdvice" class="headerlink" title="3. RequestBodyAdvice"></a>3. RequestBodyAdvice</h3><p>经过尝试<code>ArgumentAdvice</code>可以解决这个问题，通过<code>afterBodyRead</code>方法可以在参数解析器处理之后获取到对应的解析实体，再根据该实体的类型，进行<code>basic64</code>解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  请求参数增强处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/21 22:37:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;cn.com.xiaocainiaoya.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentAdvice</span> <span class="keyword">implements</span> <span class="title">RequestBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpInputMessage <span class="title">beforeBodyRead</span><span class="params">(HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">             MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">             Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">                                MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                                Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(body <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            ((User) body).setPassword(<span class="string">&quot;12312&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleEmptyBody</span><span class="params">(Object body, HttpInputMessage inputMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    虽然最后没有没有通过参数处理器来解决这个问题，但是在测试过程中也发现了自己对参数解析器的理解不足，原以为只要<code>supportsParameter</code>方法为<code>true</code>，就可以进行参数处理，而我在完善代码时只需要抽象一个顶层属性接口做是否是某种类型的判断即可。</p><p>​    <code>@InitBinder</code>和<code>RequestBodyAdvice</code>都是可取的方案，取决于需求是需全局(某个包下的所有<code>Controller</code>)的参数都需要进行某种统一处理，或者是仅仅只需针对某一个<code>Controller</code>进行参数处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringMvc请求参数的二次处理&quot;&gt;&lt;a href=&quot;#SpringMvc请求参数的二次处理&quot; class=&quot;headerlink&quot; title=&quot;SpringMvc请求参数的二次处理&quot;&gt;&lt;/a&gt;SpringMvc请求参数的二次处理&lt;/h1&gt;&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;在一个项目中原来服务端是采用&lt;code&gt;WebService&lt;/code&gt;的进行客户端和服务进行交互，现根据需要调整为直接使用&lt;code&gt;HHTP&lt;/code&gt;方式访问。仅修改访问的方式，其数据的访问结构等不变。&lt;/p&gt;</summary>
    
    
    
    <category term="srping" scheme="http://xiaocainiaoya.github.io/categories/srping/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门笔记(二)</title>
    <link href="http://xiaocainiaoya.github.io/2021/05/16/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://xiaocainiaoya.github.io/2021/05/16/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</id>
    <published>2021-05-16T13:51:58.000Z</published>
    <updated>2021-05-16T14:18:46.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch入门笔记-二"><a href="#Elasticsearch入门笔记-二" class="headerlink" title="Elasticsearch入门笔记(二)"></a>Elasticsearch入门笔记(二)</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="1-1字符串类型"><a href="#1-1字符串类型" class="headerlink" title="1.1字符串类型"></a>1.1字符串类型</h4><h5 id="1-1-1-text"><a href="#1-1-1-text" class="headerlink" title="1.1.1 text"></a>1.1.1 text</h5><p>文本数据类型，使用之后该类型字段的值会被分词，生成倒排索引，用于全文检索。</p><span id="more"></span><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;, // 指定分词器</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;text&quot;,         // 设置类型为text</span></span><br><span class="line">        <span class="meta">&quot;fielddata&quot;</span>: <span class="string">true,      // 默认为false，该字段会启用内存空间进行一些排序、聚合操作</span></span><br><span class="line">        <span class="meta">&quot;fields&quot;</span>: <span class="string">&#123;             // 多类型，若某个字段既要满足能被搜索，又要满足能排序、聚合</span></span><br><span class="line">          <span class="meta">&quot;sort&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="1-1-2-keyword"><a href="#1-1-2-keyword" class="headerlink" title="1.1.2 keyword"></a>1.1.2 keyword</h5><p> 关键字类型，该字段不会被分词，只能按确切的值进行搜索，可以进行排序、聚合、过滤。一般使用在唯一性字段邮箱地址、<code>Mac</code>地址、身份证号之类不需要被分词的字段。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;ignore_above&quot;</span>: <span class="string">1024, // 指定查询的最大长度，超过则不会进行索引</span></span><br><span class="line">        <span class="meta">&quot;norms&quot;</span>: <span class="string">true         // 在进行查询评分时，是否需要考虑字段长度，默认为false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2数字类型"><a href="#1-2数字类型" class="headerlink" title="1.2数字类型"></a>1.2数字类型</h4><p>支持<code>long</code>、<code>integer</code>、<code>short</code>、<code>byte</code>、<code>double</code>、<code>float</code>、<code>half_float</code>(半精度浮点数)、<code>scaled_float</code>(带缩放因子浮点数)</p><p>scaled_float 举例：</p><p>在索引时会将原始值*缩放因子后四舍五入得到一个新值，将这个新值作为索引值(查询时返回的还是原值)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">      <span class="meta">&quot;price&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;,</span></span><br><span class="line">        <span class="meta">&quot;scaling_factor&quot;</span>: <span class="string">100  # 需指定缩放因子</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>添加两条数据</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">book/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">10.1111 # 实际的索引值为1011</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">book/_doc/2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">11.1111 # 实际的索引值为1111</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>查询语句</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">book/_doc/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;match&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;price&quot;</span>: <span class="string">11.2222 # 11.2222 * 100再四舍五入后的值为1122,匹配不到文档</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-3布尔类型"><a href="#1-3布尔类型" class="headerlink" title="1.3布尔类型"></a>1.3布尔类型</h4><p>布尔值，可以识别字符串的布尔值<code>&quot;true&quot;</code>，<code>&quot;false&quot;</code>，<code>true</code>，<code>false</code>。</p><h4 id="1-4日期类型"><a href="#1-4日期类型" class="headerlink" title="1.4日期类型"></a>1.4日期类型</h4><p>日期类型，由于在<code>json</code>中是没有具体的日期类型的表达，所以可以是日期格式化后的字符串，可以是毫秒数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date&quot;,</span></span><br><span class="line">        <span class="meta">&quot;format&quot;</span>: <span class="string">&quot;yyyy-mm-dd||yyyy/mm/dd||epoch_millis&quot; //指定了三种格式的日期</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;aaa&quot;,</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2021-11-14&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加失败，日期格式不对</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;aaa&quot;,</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2021-11-14 14:20:20&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-5范围类型"><a href="#1-5范围类型" class="headerlink" title="1.5范围类型"></a>1.5范围类型</h4><p>范围类型，表示一个区间，若指定该类型，字段值为一个对象。需使用到<code>gt</code>、<code>gle</code>、<code>lt</code>、<code>lte</code>等逻辑标识符表示。<code>integer_range</code>，<code>long_range</code>，<code>float_range</code>，<code>double_range</code>，<code>date_range</code>，<code>ip_range</code>(ip地址的范围)。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;price&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer_range&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">      <span class="meta">&quot;my_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date_range&quot;,</span></span><br><span class="line">        <span class="meta">&quot;format&quot;</span>: <span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;gt&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;lt&quot;</span>: <span class="string">10</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;my_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;gte&quot;</span>: <span class="string">&quot;2021-01-21&quot;,</span></span><br><span class="line">    <span class="meta">&quot;lte&quot;</span>: <span class="string">&quot;2021-05-22&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-6地理类型"><a href="#1-6地理类型" class="headerlink" title="1.6地理类型"></a>1.6地理类型</h4><h5 id="1-6-1-geo-point"><a href="#1-6-1-geo-point" class="headerlink" title="1.6.1 geo_point"></a>1.6.1 geo_point</h5><p>表示一个坐标点。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建点结构</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.通过对象指定经纬度</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lat&quot;</span>: <span class="string">30,</span></span><br><span class="line">    <span class="meta">&quot;lon&quot;</span>: <span class="string">108</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.通过字符串“经度,维度”指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&quot;30,108&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.通过geohash指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&quot;wmkf9t74wmkf&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.通过数组[维度, 经度]指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">[108, 30]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">map/_doc/1</span></span><br></pre></td></tr></table></figure><h5 id="1-6-2-geo-shape"><a href="#1-6-2-geo-shape" class="headerlink" title="1.6.2 geo_shape"></a>1.6.2 geo_shape</h5><p>地理形状数据类型，使用<code>geoJson</code>表示。</p><table><thead><tr><th>geoJson</th><th>ElasticSearch Type</th><th>描述</th></tr></thead><tbody><tr><td>Point</td><td>point</td><td>单个地理坐标</td></tr><tr><td>LineString</td><td>lineString</td><td>两点或多点组成任意线</td></tr><tr><td>Polygon</td><td>polygon</td><td>一个闭合的多边形，其第一个点和最后一个点必须匹配。因此需要n+1个顶点来创建一个n边多边形，且最少4个顶点(构成三角形)</td></tr><tr><td>MultiPoint</td><td>multipoint</td><td>一组未连接但可能相关的点</td></tr><tr><td>MultiLineString</td><td>multilinestring</td><td>一组独立的线</td></tr><tr><td>MultiPolygon</td><td>multipolygon</td><td>一组独立的多边形</td></tr><tr><td>N/A</td><td>envelope</td><td>通过仅指定左上角和右下角构成的边界矩形</td></tr><tr><td>N/A</td><td>circle</td><td>由中心点和半径指定的圆，默认单位为m</td></tr></tbody></table><p><strong>例子</strong></p><blockquote><p>在线制作geojson -&gt; <a href="http://geojson.io/">http://geojson.io/</a></p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. point 单坐标,由[维度, 经度]组成</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;point&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[108, 30]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. lineString 地理线</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">  <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;lineString&quot;,</span></span><br><span class="line">  <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="meta">[108,</span> <span class="string">30],</span></span><br><span class="line">    <span class="meta">[120,</span> <span class="string">30]</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. polygon 闭合多边形，首位需要一致</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">      <span class="meta">[108,</span> <span class="string">30],[120, 30],[120, 90],[108, 90],[108, 30]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个数组表示多边形外边界，第二个数组表示内边界</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[[106,28],[117,28],[117,34],[106,34],[106,28]],</span></span><br><span class="line">      <span class="attr">[[108,29],[115,29],[115,33],[108,33],[108,29]]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 4. multiPoint 多个点</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multiPoint&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="meta">[108,</span> <span class="string">30], [108, 31]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. multilinestring 多条线</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multilinestring&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="meta">[[108,</span> <span class="string">30],[120, 30]],</span></span><br><span class="line">      <span class="meta">[[109,</span> <span class="string">30],[121, 30]],</span></span><br><span class="line">      <span class="meta">[[110,</span> <span class="string">30],[122, 30]]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. multiPolygon 多个多边形</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multipolygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">      <span class="meta">[[108,</span> <span class="string">30],[120, 30],[120, 90],[108, 90],[108, 30]]</span></span><br><span class="line">      <span class="attr">],</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">        <span class="attr">[[106,28],[117,28],[117,34],[106,34],[106,28]],</span></span><br><span class="line">        <span class="attr">[[108,29],[115,29],[115,33],[108,33],[108,29]]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.envelope，指定形状的左上角和右下角的坐标，以表示边界矩形：</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;envelope&quot;,</span></span><br><span class="line">      <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[110,39],[114,37]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 8. circle，添加一个圆，指定半径和中心点坐标</span></span><br><span class="line"><span class="comment"># 好像6版本之后不支持circle了，插入报错 circle geometry is not supported</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;circle&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[110, 39],</span></span><br><span class="line">    <span class="meta">&quot;radius&quot;</span>: <span class="string">&quot;100km&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-7特殊类型"><a href="#1-7特殊类型" class="headerlink" title="1.7特殊类型"></a>1.7特殊类型</h4><h5 id="1-7-1-IP类型"><a href="#1-7-1-IP类型" class="headerlink" title="1.7.1 IP类型"></a>1.7.1 IP类型</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;ipAddress&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;ip&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address&quot;</span>:<span class="string">&quot;192.168.1.1&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 可以通过网段搜索</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;ipAddress&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-8复合类型"><a href="#1-8复合类型" class="headerlink" title="1.8复合类型"></a>1.8复合类型</h4><h5 id="1-8-1数组"><a href="#1-8-1数组" class="headerlink" title="1.8.1数组"></a>1.8.1数组</h5><p>默认情况下任何字段都可以包含一个或多个值，当包含多个值时，就表示是一个数组，唯一要求是数组中的每个值的类型一致，不指定的情况下，以第一个值的类型为准。</p><h5 id="1-8-2对象类型"><a href="#1-8-2对象类型" class="headerlink" title="1.8.2对象类型"></a>1.8.2对象类型</h5><p>一个文档的一个属性可以是一个对象，这个对象的某一个属性可以在包含一个对象。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;,</span></span><br><span class="line">  <span class="meta">&quot;class&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;一班&quot;,</span></span><br><span class="line">    <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;province&quot;</span>: <span class="string">&quot;福建省&quot;,</span></span><br><span class="line">      <span class="meta">&quot;city&quot;</span>: <span class="string">&quot;福州市&quot;,</span></span><br><span class="line">      <span class="meta">&quot;county&quot;</span>: <span class="string">&quot;闽侯县&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="1-8-3嵌套类型"><a href="#1-8-3嵌套类型" class="headerlink" title="1.8.3嵌套类型"></a>1.8.3嵌套类型</h5><p><code>nested</code>类型。若文档的属性是一个对象数组。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address&quot;</span>: <span class="string">[</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;id&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;福建&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;id&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>以上例子，若使用对象类型保存，由于<code>luncene</code>没有内部对象的概念，所以<code>es</code>会将以上数据扁平化为简单的字段和值列表。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address.id&quot;</span>: <span class="string">[1, 2],</span></span><br><span class="line">  <span class="meta">&quot;address.name&quot;</span>: <span class="string">[&quot;福建&quot;, &quot;北京&quot;]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>这时若查询语句为查找<code>id=2,name=&quot;福建&quot;</code>也会被查询到。使用<code>nested</code>类型之后，将数组中的每一个对象作为独立文档来索引。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;address.id&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;address.name&quot;</span>: <span class="string">&quot;福建&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;address.id&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;address.name&quot;</span>: <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-索引操作"><a href="#2-索引操作" class="headerlink" title="2.索引操作"></a>2.索引操作</h3><h4 id="2-1创建索引"><a href="#2-1创建索引" class="headerlink" title="2.1创建索引"></a>2.1创建索引</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/12/TfWvHkzdpNU8nO2.png"></p><h4 id="2-2删除索引"><a href="#2-2删除索引" class="headerlink" title="2.2删除索引"></a>2.2删除索引</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DELETE</span> <span class="string">library</span></span><br></pre></td></tr></table></figure><h4 id="2-3修改索引"><a href="#2-3修改索引" class="headerlink" title="2.3修改索引"></a>2.3修改索引</h4><p>可以修改索引的属性<code>Settings</code>，比如索引的分片数、副本数、路由、读写权限等。</p><p><strong>修改索引分片数和副本数都为2</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;settings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;number_of_shards&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;number_of_replicas&quot;</span>: <span class="string">2</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-4复制索引"><a href="#2-4复制索引" class="headerlink" title="2.4复制索引"></a>2.4复制索引</h4><p>复制索引时只会复制其中的数据，不会复制<code>setting</code>中的信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_reindex</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;source&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;dest&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library2&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-索引别名"><a href="#2-5-索引别名" class="headerlink" title="2.5 索引别名"></a>2.5 索引别名</h4><p>索引别名可以指向一个或者多个索引，也就是说多个索引可以共用一个别名。比如<code>library_log_20210514</code>和<code>library_log_20210515</code>两个索引都对它们设置索引别名为<code>library_log</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_aliases</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;actions&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_log_20210514&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_log&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_log_20210515&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_log&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置之后就可以通过一个名称来进行全文检索</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library_log/_search</span></span><br></pre></td></tr></table></figure><p><strong>通过别名创建视图</strong>，为<code>library</code>中作者是<code>tom</code>创建一个视图。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_aliases</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;actions&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_alias&quot;,</span></span><br><span class="line">        <span class="meta">&quot;filter&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">          <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>索引别名其实类似关系数据库中视图的概念，只提供读操作，不能进行写操作。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有别名</span></span><br><span class="line"><span class="attr">GET</span>  <span class="string">_cat/aliases</span></span><br></pre></td></tr></table></figure><p>在真是环境中，索引的设计不可能呢一步到位，随着需求、业务的扩展，可能会修改索引的<code>mapping</code>的字段类型、或者是<code>setting</code>中的配置信息，若简单采用<code>reindex</code>操作，在实施运维操作更新这段时间内，有可能导致数据不可访问，所以可以通过指定别名的方式进行索引迁移。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建新索引结构</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library_new</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"> <span class="meta">...</span> <span class="string">// 索引结构等等</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用reindex进行索引数据迁移</span></span><br><span class="line"><span class="attr">POST</span>  <span class="string">_reindex</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;source&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;dest&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_new&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后在修改索引别名</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">_aliases?pretty</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="attr">&quot;actions&quot;&quot;[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;remove&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_new&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-6关闭-开启索引"><a href="#2-6关闭-开启索引" class="headerlink" title="2.6关闭/开启索引"></a>2.6关闭/开启索引</h4><p>索引关闭后只能获取索引的<code>setting</code>信息，不能进行读写。</p><p>关闭索引：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">book/_close</span></span><br></pre></td></tr></table></figure><p>打开索引：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">book/_open</span></span><br></pre></td></tr></table></figure><h3 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h3><h4 id="3-1新增文档"><a href="#3-1新增文档" class="headerlink" title="3.1新增文档"></a>3.1新增文档</h4><p><code>6.*</code>版本之后一个索引只允许一个类型，所以路径上固定<code>索引名/_doc/id(可选)</code>，可以指定<code>id</code>，不指定会自动生成。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定id</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定id，由es生成</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c入门&quot;,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;marry&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>返回参数解析，其中<code>_shards</code>节点中<code>total</code>为2但是只有一个分片成功的原因是，我的环境是单机单节点，但是刚刚设置的时候又设置了两个分片，其实这种设置是不符合逻辑的。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;_index&quot;</span> : <span class="string">&quot;library&quot;,  // 对应的索引</span></span><br><span class="line">  <span class="meta">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;, // 文档类型</span></span><br><span class="line">  <span class="meta">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;, // 创建的文档id</span></span><br><span class="line">  <span class="meta">&quot;_version&quot;</span> : <span class="string">2, // 文档版本</span></span><br><span class="line">  <span class="meta">&quot;result&quot;</span> : <span class="string">&quot;created&quot;,  // 操作状态，有created、updated </span></span><br><span class="line">  <span class="meta">&quot;_shards&quot;</span> : <span class="string">&#123;          // 分片上的执行状态</span></span><br><span class="line">    <span class="meta">&quot;total&quot;</span> : <span class="string">2, // 分片数量</span></span><br><span class="line">    <span class="meta">&quot;successful&quot;</span> : <span class="string">1,    // 执行成功分片数量</span></span><br><span class="line">    <span class="meta">&quot;failed&quot;</span> : <span class="string">0         // 执行失败分片数量</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;_seq_no&quot;</span> : <span class="string">2,         // 索引写操作版本</span></span><br><span class="line">  <span class="meta">&quot;_primary_term&quot;</span> : <span class="string">1    // 文档所在分片</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>​    在<code>6.7</code>之前使用<code>_version</code>来做并发控制，每一个文档都维护各自的<code>_version</code>字段，每次多这个文档的写操作都会自增这个字段，当写操作之后<code>_version</code>字段进行自增后小于存储中的<code>_version</code>时，写操作所提交的内容会被拒绝。</p><p>​    在<code>6.7</code>之后使用<code>_seq_no</code>和<code>_primary_term</code>来做并发控制，<code>seq_no</code>类似于<code>_version</code>字段，但是它的生命周期是整个索引，而<code>_version</code>的生命周期是某一个文档。</p><h4 id="3-2修改文档"><a href="#3-2修改文档" class="headerlink" title="3.2修改文档"></a>3.2修改文档</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定id进行更新，这种更新会覆盖旧文档</span></span><br><span class="line"><span class="comment"># 原文档有name和author字段，经过以下更新后只剩name字段</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 更新指定字段</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">library/_update/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;script&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;,</span></span><br><span class="line"><span class="comment">    # 设置name为参数params中的name</span></span><br><span class="line">    <span class="meta">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.name=params.name&quot;,</span></span><br><span class="line">    <span class="meta">&quot;params&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>更新指定文档通过脚本的方式更新，<code>ctx</code>可以获取到上下对象，即通过<code>GET library/_doc/1</code>获取到的数据。上下文对象中的<code>_source</code>节点就是存储的数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;library&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;java入门&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过条件进行更新操作。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">library/_update_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;script&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;,</span></span><br><span class="line">    <span class="meta">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.name=params.name&quot;,</span></span><br><span class="line">    <span class="meta">&quot;params&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3删除文档"><a href="#3-3删除文档" class="headerlink" title="3.3删除文档"></a>3.3删除文档</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定文档</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">library/_doc/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据查询条件删除</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">library/_delete_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;value&quot;</span>: <span class="string">&quot;java&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-4批量操作"><a href="#3-4批量操作" class="headerlink" title="3.4批量操作"></a>3.4批量操作</h4><p>在<code>es</code>中通过<code>Bluk api</code>来执行批量操作。</p><p>1.可以通过<code>Kibana</code>来访问<code>Bluk</code>接口。批量操作的数据语法为一行操作(<code>auction</code>)，一行数据。</p><p>2.也可以通过请求直接执行。</p><blockquote><p>curl -XPOST “<a href="http://localhost:9200/library/_bulk&quot;">http://localhost:9200/library/_bulk&quot;</a> -H “content-type:application/json” –data-binary @es-pipeline.json</p></blockquote><p><strong>注意：</strong>结尾要空出一行。</p><p>否则会报错:</p><blockquote><p>{“error”:{“root_cause”:[{“type”:”illegal_argument_exception”,”reason”:”The bulk request must be terminated by a newline [\n]”}],”type”:”illegal_argument_exception”,”reason”:”The bulk request must be terminated by a newline [\n]”},”status”:400}%</p></blockquote><p><strong>注意：</strong>执行时需要添加<code>-H &quot;content-type:application/json&quot;</code></p><p>否则会报错</p><blockquote><p>{“error”:”Content-Type header [application/x-www-form-urlencoded] is not supported”,”status”:406}%</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_bulk</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;1&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;2&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;3&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;pyton入门&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-5查询文档"><a href="#3-5查询文档" class="headerlink" title="3.5查询文档"></a>3.5查询文档</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过id获取文档</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_doc/1</span></span><br></pre></td></tr></table></figure><h4 id="3-6-数据迁移"><a href="#3-6-数据迁移" class="headerlink" title="3.6 数据迁移"></a>3.6 数据迁移</h4><p>​    在别名那里顺便提了<code>reindex</code>，通过该关键字进行索引间的数据拷贝，只拷贝数据，不拷贝<code>mapping</code>和<code>setting</code>信息。</p><h3 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4. 关键字"></a>4. 关键字</h3><h5 id="4-1-analyzer-search-analyzer"><a href="#4-1-analyzer-search-analyzer" class="headerlink" title="4.1 analyzer/search_analyzer"></a>4.1 analyzer/search_analyzer</h5><p>通过<code>analyzer</code>指定分词器，在查询时若没有通过<code>search_analyzer</code>指定分词器，默认使用该索引的<code>analyzer</code>分词器来进行分词。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;decr&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>:<span class="string">&quot;text&quot;,</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;  // 指定分词器</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-normailizer"><a href="#4-2-normailizer" class="headerlink" title="4.2 normailizer"></a>4.2 normailizer</h5><p>预处理，在查询前进行数据预处理。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;settings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;analysis&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;normalizer&quot;</span>: <span class="string">&#123;               // 创建一个预处理</span></span><br><span class="line">        <span class="meta">&quot;lowerNor&quot;</span>: <span class="string">&#123;               // 创建一个名为lowerNor的预处理器</span></span><br><span class="line">          <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;,         // 类型为自定义</span></span><br><span class="line">          <span class="meta">&quot;filter&quot;</span>: <span class="string">[&quot;lowercase&quot;]   // 过滤器:大小写转换</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;, </span></span><br><span class="line">        <span class="meta">&quot;normalizer&quot;</span>: <span class="string">&quot;lowerNor&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-3-coerce"><a href="#4-3-coerce" class="headerlink" title="4.3 coerce"></a>4.3 coerce</h5><p>设置不进行类型转换。默认情况下，若指定字段类型为<code>integer</code>，插入数据时若插入为字符串<code>&quot;10&quot;</code>，也会插入成功。若不需要该类型自动转换，则标记该字段为<code>false</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;id&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;,</span></span><br><span class="line">        <span class="meta">&quot;coerce&quot;</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-4-enabled-index"><a href="#4-4-enabled-index" class="headerlink" title="4.4 enabled/index"></a>4.4 enabled/index</h5><p><code>enabled</code>表示若某字段仅存储，不需要进行全文检索。默认为<code>true</code>表示需要进行检索。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;enabled&quot;</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询结果为空</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><code>index</code>指定一个字段是否被索引。<code>true</code>表示字段会被索引。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date&quot;,</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2020&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接报错 </span></span><br><span class="line"><span class="comment"># failed to create query: Cannot search on field [publish_date] since it is not indexed.</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2020&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-5-ignore-above"><a href="#4-5-ignore-above" class="headerlink" title="4.5 ignore_above"></a>4.5 ignore_above</h5><p>用于<code>keyword</code>类型，表示指定分词和索引字符串的最大长度，超过该长度将不会被索引。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;,</span></span><br><span class="line">        <span class="meta">&quot;ignore_above&quot;</span>: <span class="string">10</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-6-ignore-malformed"><a href="#4-6-ignore-malformed" class="headerlink" title="4.6 ignore_malformed"></a>4.6 ignore_malformed</h5><p>忽略不匹配类型数据。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;,</span></span><br><span class="line">        <span class="meta">&quot;ignore_malformed&quot;</span>: <span class="string">true // 标记允许</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;abc&quot;       // 不是integer乐西</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">user/_doc/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_version&quot;</span> : <span class="string">1,</span></span><br><span class="line">  <span class="meta">&quot;_seq_no&quot;</span> : <span class="string">0,</span></span><br><span class="line">  <span class="meta">&quot;_primary_term&quot;</span> : <span class="string">1,</span></span><br><span class="line">  <span class="meta">&quot;_ignored&quot;</span> : <span class="string">[</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span></span><br><span class="line">  <span class="attr">],</span></span><br><span class="line">  <span class="meta">&quot;found&quot;</span> : <span class="string">true,</span></span><br><span class="line">  <span class="meta">&quot;_source&quot;</span> : <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span> : <span class="string">&quot;abc&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-7-null-value"><a href="#4-7-null-value" class="headerlink" title="4.7 null_value"></a>4.7 null_value</h5><p>在 <code>es </code>中，值为 <code>nul</code> 的字段不索引也不可以被搜索，<code>null_value</code> 可以让值为<code>null </code>的字段显式的可索引、可搜索。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;,</span></span><br><span class="line">        <span class="meta">&quot;null_value&quot;</span>: <span class="string">&quot;nameNull&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">null,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过null_value指定的值来进行查询。</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">users/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;nameNull&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-8-fields"><a href="#4-8-fields" class="headerlink" title="4.8 fields"></a>4.8 fields</h5><p><code>fields</code>参数可以让同一字段有多种不同的索引方式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;text&quot;,</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;, </span></span><br><span class="line">        <span class="meta">&quot;fields&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">          <span class="meta">&quot;raw&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>:<span class="string">&quot;这是一本中国人写的书&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;这是&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe.raw&quot;</span>: <span class="string">&quot;这是一本中国人写的书&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-9-Dynamic-templates"><a href="#4-9-Dynamic-templates" class="headerlink" title="4.9.Dynamic_templates"></a>4.9.Dynamic_templates</h5><p>映射模板，默认情况下，由<code>es</code>根据默认规则对数据进行预判对应的类型，若需要自定义规则，可以使用<code>Dynamic_templates</code>。</p><h5 id="4-10-dynamic"><a href="#4-10-dynamic" class="headerlink" title="4.10 dynamic"></a>4.10 dynamic</h5><p>用于检测新发现的字段。</p><ul><li>true: 默认，新发现的字段添加到映射中。</li><li>false: 必须显示指定新字段</li><li>strict:若检测到新字段，抛出异常。</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;dynamic&quot;</span>: <span class="string">false,</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;username&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Elasticsearch入门笔记-二&quot;&gt;&lt;a href=&quot;#Elasticsearch入门笔记-二&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch入门笔记(二)&quot;&gt;&lt;/a&gt;Elasticsearch入门笔记(二)&lt;/h1&gt;&lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1. 数据类型&quot;&gt;&lt;/a&gt;1. 数据类型&lt;/h3&gt;&lt;h4 id=&quot;1-1字符串类型&quot;&gt;&lt;a href=&quot;#1-1字符串类型&quot; class=&quot;headerlink&quot; title=&quot;1.1字符串类型&quot;&gt;&lt;/a&gt;1.1字符串类型&lt;/h4&gt;&lt;h5 id=&quot;1-1-1-text&quot;&gt;&lt;a href=&quot;#1-1-1-text&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 text&quot;&gt;&lt;/a&gt;1.1.1 text&lt;/h5&gt;&lt;p&gt;文本数据类型，使用之后该类型字段的值会被分词，生成倒排索引，用于全文检索。&lt;/p&gt;</summary>
    
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/categories/elasticsearch/"/>
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch入门笔记(一)</title>
    <link href="http://xiaocainiaoya.github.io/2021/05/10/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://xiaocainiaoya.github.io/2021/05/10/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2021-05-10T13:51:58.000Z</published>
    <updated>2021-05-16T14:08:43.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch入门笔记-一"><a href="#Elasticsearch入门笔记-一" class="headerlink" title="Elasticsearch入门笔记(一)"></a>Elasticsearch入门笔记(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在工作的中使用到部分<code>ElasticSearch</code>沾边的东西，<code>ELK</code>日志实时分析系统，对<code>ElasticSearch</code>也略有耳闻，趁着最近有时间学习一下，并将学习过程中知识点记录下来。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>ElasticSearch</code>是基于<code>Luncene</code>的分布式高性能的全文搜索引擎，<code>Luncene</code>是使用<code>java</code>开发的一个全文搜索引擎工具包，而<code>ElasticSearch</code>它将<code>Luncene</code>的复杂性对用户屏蔽，提供简单易用的<code>Restful Api</code>，开发者只需要使用该<code>api</code>接口就可以使用全文搜索。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​    我使用的是<code>mac</code>电脑，使用的是<code>docker desktop for mac</code>工具，通过<code>Kitematic</code>工具直接搜索了<code>elasticSearch</code>进行安装，我安装的镜像是<code>blacktop/elasticsearch</code>版本是<code>7.10.1</code>，它只挂载了<code>data</code>目录，我本地通过容器管理工具将<code>plugins</code>路径也挂载出来，方便添加分词器。</p><p>​    同时还需要使用到<code>google</code>插件<code>elasticsearch-head</code>便于查看数据等情况；同样使用了<code>docker</code>安装了<code>blacktop/kibana</code>镜像,<code>kibana</code>内置了解析器，对<code>es</code>的<code>restful api</code>有对应的支持。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-集群"><a href="#1-集群" class="headerlink" title="1. 集群"></a>1. 集群</h3><p>​    <code>es</code>本质上就是一个分布式系统，允许多台服务器协同工作，可以在一台服务上部署多个<code>es</code>实例，每一个实例称为一个节点。本想模拟单机多节点的集群情况，花了很多时间发现各个节点之间就是无法访问到，不知道主要原因是不是由于<code>macos</code>的容器机制，导致宿主机无法直接访问容器<code>ip</code>导致。</p><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><p>​    <code>es</code>的数据管理顶层单位称为索引<code>Index</code>，它类似于关系数据库中的库的概念，也就是每一个<code>Index</code>就是一个数据库，且规定<strong>名称必须为小写</strong>。</p><h3 id="3-类型"><a href="#3-类型" class="headerlink" title="3.类型"></a>3.类型</h3><p>​    索引<code>Index</code>下就是类型<code>Type</code>，类似于关系数据库中的表的概念，但是在<code>6.x</code>版本之后，一个<code>Index</code>值允许一个<code>Type</code>，所以类似于一个库中只允许一张表。</p><h3 id="4-文档"><a href="#4-文档" class="headerlink" title="4.文档"></a>4.文档</h3><p>​    <code>Type</code>下就是文档<code>Document</code>，一个<code>Type</code>包含多个<code>Document</code>，<code>document</code>类似于关系数据库中一行记录。</p><h3 id="5-分片"><a href="#5-分片" class="headerlink" title="5.分片"></a>5.分片</h3><p>​    <code>es</code>的数据是存储在节点上，每个索引的数据量不一样，需要的计算和处理数据的能力不一样，所以在创建每一个索引是可以同时创建的分片数，将数据处理分散到不同的节点。同时还分为主分片和副本分片，副本分片是主分片的一个备份，若主分片所在的节点宕机，启用改节点主分片的副本分片，所以主分片和副本分片将落在不同的节点。</p><p><strong>关系型数据库和es基本结构概念对比</strong></p><table><thead><tr><th>关系型数据库</th><th>es</th></tr></thead><tbody><tr><td>库</td><td>Index</td></tr><tr><td>表</td><td>Type</td></tr><tr><td>行</td><td>Document</td></tr><tr><td>一行中的某一列</td><td>Field(es是使用json表达数据)</td></tr><tr><td>索引</td><td>全文索引(这个地方有可能出现理解的误差，二者在各自结构中的意思都是加快查询数据的速度)</td></tr></tbody></table><h3 id="6-倒排索引"><a href="#6-倒排索引" class="headerlink" title="6.倒排索引"></a>6.倒排索引</h3><p>​    倒排索引是<code>es</code>中比较核心的一个概念，是指从文档的词项映射文档<code>ID</code>的一个过程。在关系型数据库中，一般采用的是正排索引，即从数据<code>ID</code>查询某个数据的关系。</p><p>比如有以下数据：</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>10</td><td>福建省福州市</td></tr><tr><td>2</td><td>李四</td><td>10</td><td>福建省莆田市</td></tr><tr><td>3</td><td>王五</td><td>30</td><td>福建省泉州市</td></tr><tr><td>4</td><td>赵六</td><td>30</td><td>湖南省长沙市</td></tr><tr><td>5</td><td>孙七</td><td>30</td><td>福建省南平市</td></tr><tr><td>6</td><td>钱八</td><td>60</td><td>浙江省杭州市</td></tr></tbody></table><p>以上就是正排索引，当知道某个人的<code>ID</code>就可以通过主键<code>ID</code>去获取这个人的年龄和地址信息。</p><p>倒排索引结构：</p><p><strong>age</strong>字段</p><table><thead><tr><th>词项Term</th><th>文档列表</th></tr></thead><tbody><tr><td>10</td><td>[1, 2]</td></tr><tr><td>30</td><td>[3, 4, 5]</td></tr><tr><td>60</td><td>6</td></tr></tbody></table><p><strong>address</strong>字段，当然这里的词项不一定只有<code>xx省</code>，也可以是<code>xx市</code>，这里只是简单举个例子。</p><table><thead><tr><th>词项Term</th><th>文档列表</th></tr></thead><tbody><tr><td>福建省</td><td>[1, 2, 3, 5]</td></tr><tr><td>湖南省</td><td>5</td></tr><tr><td>浙江省</td><td>6</td></tr></tbody></table><p>按以上的结构存储倒排索引之后，若需要查询福建省的所有人，就可以直接根据<code>福建省</code>的词项获取到<code>1,2,3,5</code>四个文档是符合条件，然后在结合正排索引，将这符合这四个<code>id</code>的文档找出。</p><p>​    当然了或许有人会说那不是直接<code>select * from table where address like %福建省%</code>就可以找出数据吗？在关系型数据库中模糊查询是无法命中索引的，也就是说模糊索引是需要全表扫描的，对于<code>es</code>的大数据定位而言是互斥的，所以增加倒排索引使得<code>es</code>的检索效率和性能显著提高。</p><h3 id="7-路由"><a href="#7-路由" class="headerlink" title="7.路由"></a>7.路由</h3><p>​    一个索引可以指定多个分片，且在多机的集群环境中，分片可能散落在不同的服务器上，在操作时可以将相关性数据存储在同一个分片上，提高检索效率。</p><blockquote><p>shard = hash(routing) % number_of_primary_shards</p><p>数据落在的分片编号 = 哈希函数(routing值)对分片数取余，默认routing值为文档id</p></blockquote><h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><p>​    分词器又叫分析器<code>Analyzer</code>，分词器的作用就是将文本经过分析之后转化为词项，在<code>es</code>搜索的最基本单元就是词项<code>Term</code>，通过词项来建立文档之间的映射。在<code>es</code>中又内置了多种基本的分词器，都是对英文的分词。</p><table><thead><tr><th>分词器</th><th>作用</th></tr></thead><tbody><tr><td>Standard Analyzer</td><td>英文标准分词器</td></tr><tr><td>Whitespace Analyzer</td><td>空格分词器</td></tr><tr><td>Pattern Analyzer</td><td>正则分词器</td></tr><tr><td>KeyWord Analyzer</td><td>关键词分词器</td></tr></tbody></table><p>目前使用的比较多的中文分词器应该是<code>elasticsearch-analysis-ik </code>，代码托管在<code>github</code>上，可以直接下载之后添加到<code>plugins</code>目录下。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Elasticsearch入门笔记-一&quot;&gt;&lt;a href=&quot;#Elasticsearch入门笔记-一&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch入门笔记(一)&quot;&gt;&lt;/a&gt;Elasticsearch入门笔记(一)&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    在工作的中使用到部分&lt;code&gt;ElasticSearch&lt;/code&gt;沾边的东西，&lt;code&gt;ELK&lt;/code&gt;日志实时分析系统，对&lt;code&gt;ElasticSearch&lt;/code&gt;也略有耳闻，趁着最近有时间学习一下，并将学习过程中知识点记录下来。&lt;/p&gt;</summary>
    
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/categories/elasticsearch/"/>
    
    
    <category term="elasticsearch" scheme="http://xiaocainiaoya.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>用户token互串问题</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/27/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%A8%E6%88%B7token%E4%BA%92%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/27/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%A8%E6%88%B7token%E4%BA%92%E4%B8%B2%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-27T14:20:58.000Z</published>
    <updated>2021-04-27T12:55:50.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户token互串问题"><a href="#用户token互串问题" class="headerlink" title="用户token互串问题"></a>用户token互串问题</h3><p><img src="https://i.loli.net/2021/04/27/4bWIrKcvBh2Go6Z.png"></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>昨天要下班时遭测试反馈说某个业务日志表中的数据的基础字段(创建人、修改人)信息有问题，赶紧过去看了一眼，发现确实有问题，那张业务表主要是A角色的操作，而表中最后的数据记录的是B角色的信息。项目采用<code>Oauth2</code>的方式进行认证，很容易就想到是否是<code>token</code>互串导致，因为基础字段是直接通过<code>token</code>信息进行存储，便于后期排查问题而已？</p><span id="more"></span><h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>在简单查看代码之后，业务日志表的数据操作是在某个回调通知后触发，而这个回调类似于定时器触发或者是外部应用触发，这种情况下是没有<code>token</code>信息，也就是说在<code>ThreadLocal</code>中并不存在<code>token</code>信息。而导致这个问题的关键是容器的线程复用。</p><h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><p>1.简单搭建一个<code>springboot</code>工程，采用<code>undertow</code>容器。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.4.5&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    <span class="comment">// 排除tomcat</span></span><br><span class="line">    implementation.exclude <span class="attr">module:</span> <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    <span class="comment">// 添加undertow容器依赖</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-undertow&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testCompileOnly <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testAnnotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.设置<code>undertow</code>容器线程池大小为1，仅设置一个线程来处理请求。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================</span></span><br><span class="line"><span class="comment">#        undertow配置</span></span><br><span class="line"><span class="comment"># =============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io线程数,主要执行非阻塞的任务</span></span><br><span class="line"><span class="comment"># server.undertow.threads.io=16</span></span><br><span class="line"><span class="comment"># 阻塞任务的线程池中线程个数</span></span><br><span class="line"><span class="meta">server.undertow.threads.worker</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 每块buffer的空间大小</span></span><br><span class="line"><span class="comment"># server.undertow.buffer-size=1024</span></span><br><span class="line"><span class="comment"># 是否分配直接内存(NIO直接分配的堆外内存)</span></span><br><span class="line"><span class="comment"># server.undertow.direct-buffers=true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Integer&gt; ageThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/04/27 22:15:21</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;getUserName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(<span class="meta">@RequestParam(required = false)</span>Integer age, <span class="meta">@RequestParam(required = true)</span>String requestId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ageThreadLocal.set(age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 模拟业务逻辑处理</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; get age value = &#123;&#125;&quot;</span>,requestId, ageThreadLocal.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.打开两个<code>postman</code>，一个请求携带<code>age</code>参数，一个请求不携带<code>age</code>参数，让携带<code>age</code>参数的请求先执行。结果是两个请求都打印了<code>age</code>值。由日志结果可知，使用的是同一个线程<code>XNIO-1 task-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8080/user/getUserName?requestId=A&amp;age=10</span></span><br><span class="line"><span class="comment">// http://127.0.0.1:8080/user/getUserName?requestId=B</span></span><br><span class="line"><span class="comment">// 控制台d打印信息</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">48.731</span>  INFO <span class="number">7334</span> --- [XNIO-<span class="number">1</span> task-<span class="number">1</span>] c.e.demo.controller.UserController: B get age value = <span class="number">10</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">53.738</span>  INFO <span class="number">7334</span> --- [XNIO-<span class="number">1</span> task-<span class="number">1</span>] c.e.demo.controller.UserController: A get age value = <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    由于线程池的复用，在例子中第一个请求结束后将线程还给线程池，而下一次请求进来时从线程池中刚好获取了前一个请求的线程，而<code>ThreadLocal</code>本质就是一种空间换时间的并发做法，每个线程中开辟一块空间，使得其他线程无法访问，所以第二个请求获取到的线程变量有可能是未经过初始化产生的，而是第一个请求用剩下的。当然了，解决这个问题最简单的做法就是做一个拦截器，当请求进来时，不论是否有线程变量直接清空即可。<br>​    之前看了一篇文章写的是线程池中的线程异常问题，这里多说一嘴，例子中假如第一个请求将<code>age</code>保存到<code>ThreadLocal</code>中之后，由于<code>bug</code>导致产生了异常，这时第二个线程再请求是否能获取到<code>age</code>的值？答案是获取不到的，线程池中的线程出现异常后，工作线程(<code>worker</code>线程)会被销毁掉后重新创建线程，放置到线程池中，这时从线程池中获取的新线程的<code>ThreadLoal</code>不包含任何值。</p><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#105;&#97;&#111;&#99;&#x61;&#105;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;">&#x78;&#105;&#97;&#111;&#99;&#x61;&#105;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;用户token互串问题&quot;&gt;&lt;a href=&quot;#用户token互串问题&quot; class=&quot;headerlink&quot; title=&quot;用户token互串问题&quot;&gt;&lt;/a&gt;用户token互串问题&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/27/4bWIrKcvBh2Go6Z.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;昨天要下班时遭测试反馈说某个业务日志表中的数据的基础字段(创建人、修改人)信息有问题，赶紧过去看了一眼，发现确实有问题，那张业务表主要是A角色的操作，而表中最后的数据记录的是B角色的信息。项目采用&lt;code&gt;Oauth2&lt;/code&gt;的方式进行认证，很容易就想到是否是&lt;code&gt;token&lt;/code&gt;互串导致，因为基础字段是直接通过&lt;code&gt;token&lt;/code&gt;信息进行存储，便于后期排查问题而已？&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>git多账号配置</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/26/git/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/26/git/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2021-04-26T13:51:58.000Z</published>
    <updated>2021-04-26T13:08:53.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git多账号配置"><a href="#git多账号配置" class="headerlink" title="git多账号配置"></a>git多账号配置</h3><p>[TOC]</p><p><img src="https://i.loli.net/2021/04/26/joMvuTEkm7WZH3R.png" alt="Snipaste_2021-04-26_21-03-51.png"></p><h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    最近看了一些博客都是在推荐技术新人通过写博客的方式记录学习到的知识点和遇到的问题，好记性不如烂笔头，我也尝试开始写博客，在通过<code>github gitpage</code>搭建博客的时候发现需要在一台电脑中配置两个<code>git</code>账号，之前都是全局配置公司的<code>gitlib</code>账号。记录一下整个的配置过程，过程中也踩了不少坑。</p><span id="more"></span><h4 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h4><p>​    在电脑上配置两个<code>git</code>账号，一个是<code>gitlib</code>账号用来工作使用，一个是<code>github</code>账号用来博客推送。</p><h4 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h4><h5 id="3-1-清除全局配置"><a href="#3-1-清除全局配置" class="headerlink" title="3.1 清除全局配置"></a>3.1 清除全局配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看全局配置;若存在用户名和邮箱则清除</span></span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除全局用户名和邮箱</span></span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><h5 id="3-2-生成秘钥"><a href="#3-2-生成秘钥" class="headerlink" title="3.2 生成秘钥"></a>3.2 生成秘钥</h5><p>生成两个秘钥，一个用于公司工作，一个用于博客。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一路回车即可</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>我这边是把生成的两个秘钥对(总共四个文件)分类在两个文件夹下(<code>company</code>和<code>xiaocaioniaoya</code>)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">xiaocainiaoya@macBook-Pro-3&gt;</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line">xiaocainiaoya@macBook-Pro-3/.ssh&gt;ls</span><br><span class="line">company   config  known_hosts   xiaocainiaoya</span><br></pre></td></tr></table></figure><p>生成之后分别把<code>.pub</code>后缀公钥放置到远程服务器的<code>SSH keys</code>中。</p><h5 id="3-3-秘钥添加到本地"><a href="#3-3-秘钥添加到本地" class="headerlink" title="3.3 秘钥添加到本地"></a>3.3 秘钥添加到本地</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/company/id_rsa_company</span><br></pre></td></tr></table></figure><h5 id="3-4-创建config文件"><a href="#3-4-创建config文件" class="headerlink" title="3.4 创建config文件"></a>3.4 创建config文件</h5><p>一下是我的<code>config</code>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">公司的 gitlib</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Host 可以随便起,只是一个命名而已</span></span><br><span class="line">Host company</span><br><span class="line">HostName xx.xx.xx.xx:xxx</span><br><span class="line">User xxx</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绝对路径</span></span><br><span class="line">IdentityFile ~/.ssh/company/id_rsa_company</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> xiaocainiaoya github</span></span><br><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">User xiaocainiaoya</span><br><span class="line">IdentityFile ~/.ssh/xiaocainiaoya/id_rsa_xiaocainiaoya</span><br></pre></td></tr></table></figure><h5 id="3-5-测试是否可以连接"><a href="#3-5-测试是否可以连接" class="headerlink" title="3.5 测试是否可以连接"></a>3.5 测试是否可以连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接就是这个命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ssh -T git@github</span></span><br><span class="line">Hi xiaocainiaoya! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原来还以为要替换成自己的用户名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh -T xiaocainiaoya@github</span></span><br></pre></td></tr></table></figure><h5 id="3-6-配置local级别用户名和邮箱"><a href="#3-6-配置local级别用户名和邮箱" class="headerlink" title="3.6 配置local级别用户名和邮箱"></a>3.6 配置<code>local</code>级别用户名和邮箱</h5><p>由于本地配置了多账号，在提交时根据不同的地址采用不同的用户名和邮箱，所以需要进入到某个项目配置当前项目的用户名和邮箱信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &quot;xiaocainiaoya&quot;</span><br><span class="line">git config --local user.email &quot;xiaocainiaoya@foxmail.com&quot;</span><br></pre></td></tr></table></figure><h4 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h4><p>在配置完成之后，也测试可以提交之后没有太多关注具体的提交信息，在使用一段时间之后发现博客的提交记录中用户名是我的名字。由于用户名的级别<code>system</code>&gt;<code>global</code>&gt;<code>local</code>。在添加了<code>local</code>配置之后，后续提交的记录上用户名和邮箱正常了，那之前提交的那些用户名和邮箱怎么改？</p><p><strong>git filter-branch</strong></p><blockquote><p>git中最猛的后悔药，没有把握慎用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --commit-filter &#x27;</span><br><span class="line">        if [ &quot;$GIT_COMMITTER_NAME&quot; = &quot;已提交的用户名&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_COMMITTER_NAME=&quot;想要变成的用户名&quot;;</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;$GIT_COMMITTER_NAME&quot;;</span><br><span class="line">                GIT_COMMITTER_EMAIL=&quot;想要变成的邮箱&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;$GIT_COMMITTER_EMAIL&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&#x27; HEAD</span><br></pre></td></tr></table></figure><p>执行命令之后会发现用户名和邮箱都已经修改为想要变成的样子。再执行<strong>强制</strong>推向远程，要确保已经是最新的<code>HEAD</code>否则会覆盖他人编写的代码。(<code>HEAD</code>可以修改为<code>HEAD~5..HEAD</code>表示最近的5个提交)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure><p><code>git filter-branch</code>还有很多的其他的用法，有一个我觉得日常中可能会使用到的。</p><p>在某次提交时提交了某个大文件或者敏感文件，虽然可以在下次提交中删除该文件，或者把该文件添加到<code>.gitignore</code>中，但是如果回溯到某个提交时那个文件还是存在，现在想要将所有历史的提交中移出改文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 中间引号那一段是shell脚本</span></span><br><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch path&#x27; </span><br><span class="line">--prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure><p><code>git filter-branch</code>执行之后都需要强制推向远程，可能会覆盖他人的提交，所以称为最猛的后悔药。</p><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#x69;&#x61;&#111;&#99;&#97;&#x69;&#x6e;&#105;&#x61;&#111;&#x79;&#97;&#64;&#102;&#111;&#120;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#x69;&#x61;&#111;&#99;&#97;&#x69;&#x6e;&#105;&#x61;&#111;&#x79;&#97;&#64;&#102;&#111;&#120;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;git多账号配置&quot;&gt;&lt;a href=&quot;#git多账号配置&quot; class=&quot;headerlink&quot; title=&quot;git多账号配置&quot;&gt;&lt;/a&gt;git多账号配置&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/26/joMvuTEkm7WZH3R.png&quot; alt=&quot;Snipaste_2021-04-26_21-03-51.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;​    最近看了一些博客都是在推荐技术新人通过写博客的方式记录学习到的知识点和遇到的问题，好记性不如烂笔头，我也尝试开始写博客，在通过&lt;code&gt;github gitpage&lt;/code&gt;搭建博客的时候发现需要在一台电脑中配置两个&lt;code&gt;git&lt;/code&gt;账号，之前都是全局配置公司的&lt;code&gt;gitlib&lt;/code&gt;账号。记录一下整个的配置过程，过程中也踩了不少坑。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://xiaocainiaoya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>认识SpEL</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/</id>
    <published>2021-04-20T14:51:58.000Z</published>
    <updated>2021-04-24T15:40:41.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识SpEL表达式"><a href="#认识SpEL表达式" class="headerlink" title="认识SpEL表达式"></a>认识SpEL表达式</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>最近项目接入苞米豆的<code>lock4j</code>用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个<code>@Lock4j</code>注解并添加相应的参数即可，在使用中发现其中有一个属性<code>keys = &#123;&quot;#userId&quot;, &quot;#user.sex&quot;&#125;</code>，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过<code>SpEL</code>的方式解析参数信息。</p></blockquote><span id="more"></span><h4 id="SpEL概述"><a href="#SpEL概述" class="headerlink" title="SpEL概述"></a>SpEL概述</h4><p><code>Spring</code>表达式语言的全拼为<code>Spring Expression Language</code>，缩写为<code>SpEL</code>。并且<code>SpEL</code>属于<code>spring-core</code>模块，不直接与<code>Spring</code>绑定，是一个独立模块，不依赖于其他模块，可以单独使用。</p><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol><li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li><li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li><li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li></ol><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  Expression expression = parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>);</span><br><span class="line">  <span class="comment">// 计算求值</span></span><br><span class="line">  System.out.println(expression.getValue(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进行一些简单的运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  <span class="comment">// 进行字符串的拼接</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>).getValue(String.class));</span><br><span class="line">  <span class="comment">// 简单的运算</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1+2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 简单的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1&gt;2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 稍微复杂一点的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;2&gt;1 and (!true)&quot;</span>).getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>ParseContext</code>对象设置自定义的解析规则</strong>：这里设置表达式的解析前缀为<code>#&#123;</code>解析后缀为<code>&#125;</code>，最后通过表达式对象<code>expression.getValue()</code>获取到表达式中的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;#&#123;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  String template = <span class="string">&quot;#&#123;&#x27;Hello&#x27;&#125;#&#123;&#x27;World!&#x27;&#125;&quot;</span>;</span><br><span class="line">  Expression expression = parser.parseExpression(template, parserContext);</span><br><span class="line">  System.out.println(expression.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多不同的取值方式，比如参数(上下文)是个对象，获取这个对象中的某个属性；或者参数是一个<code>List</code>获取某一个索引值；又或者是一个<code>Map</code>对象，根据某个<code>Key</code>获取对应的值等等。</p><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>​    如果平时有使用<code>Spring</code>框架应该都会有用到比如<code>@Value</code>注解，就是通过<code>SpEL</code>方式进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取字符串tom </span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;tom&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取bean对象的属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;user.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在比如接触过<code>Spring Security</code>或者<code>Shiro</code>等身份验证和授权的框架中，对不同的角色有不同的接口权限，会使用到如下场景，其中对<code>@PreAuthorize(&quot;hasAuthority(&#39;ROLE_DMIN&#39;))</code>中<code>hasAuthority(&#39;ROLE_ADMIN&#39;)</code>就是通过<code>SpEL</code>进行参数解析后，对当前用户的角色进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拥有管理员权限可查看任何用户信息,否则只能查看自己的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;))</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/getUserById/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;SysUser&gt;&gt; getUserById(String userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(userFacade.getUserById(userId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>​    之前在项目中记录系统中一些敏感接口的请求日志信息，采用的是<code>AOP</code>的方式，在请求进入控制层之前拦截进入<code>AOP</code>的切面方法，但是记录的日志部分关键信息需要从请求的参数中获取，在之前的实现中是通过约定一种表达式，对应列表<code>List</code>、<code>Map</code>、<code>bean</code>对象的取值是自实现，且仅仅支持二级取值，确实在使用上有很大的缺陷。这种场景下，就可以使用<code>SpEL</code>进行方法参数解析，省了重复造轮子的过程，且使用上更为灵活。</p><p><strong><code>SpEL</code>结合<code>AOP</code>重构请求日志保存</strong>，这边只做简单的通过<code>SpEL</code>方式进行对象等取值处理，不考虑具体实际场景中的复杂业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:06:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;basic&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicVersionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;测试&quot;,notes=&quot;测试&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@ControllerMethodLog(name = &quot;测试保存请求日志&quot;, description = &quot;测试保存请求日志&quot;)</span></span><br><span class="line">    <span class="meta">@LogAssistParams(value=&#123;</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;projectName&quot;,objField=&quot;#bidProjectInfo.id&quot;),</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;id&quot;,objField=&quot;#bidProjectInfo.projectName&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestResponse&lt;BidPackageInvitationVo&gt; <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> ProjectInfo projectInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AOP</code>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:08:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTestLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OperationLogFacade operationLogFacade;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 此处的切点是注解的方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Pointcut(&quot;@annotation(cn.com.xiaocainiaoya.annotation.ControllerMethodLog)&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;operationLog()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      OperationLog operationLog = <span class="keyword">new</span> OperationLog();</span><br><span class="line">      operationLog.setStatus(<span class="number">1</span>);<span class="comment">// 默认调用成功，异常时修改为调用失败</span></span><br><span class="line"></span><br><span class="line">      Object thing = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行切入方法内容</span></span><br><span class="line">         thing = joinPoint.proceed();</span><br><span class="line">         operationLog.setOperEndTime(DateTime.now().toJdkDate());</span><br><span class="line">         <span class="keyword">return</span> thing;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         log.error(e.getMessage(), e);</span><br><span class="line">         operationLog.setStatus(<span class="number">0</span>);<span class="comment">//发生异常时定义为调用失败</span></span><br><span class="line">         operationLog.setResultContext(e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         insertOperationLog(operationLog, joinPoint, thing);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ParameterNameDiscoverer NAME_DISCOVERER = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *   插入操作日志</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span>: 2021/04/20 23:11:28</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> operationLog 日志基础信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> joinPoint 拦截切入点信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> thing 拦截函数返回值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertOperationLog</span><span class="params">(OperationLog operationLog, ProceedingJoinPoint joinPoint, Object thing)</span> </span>&#123;</span><br><span class="line">      MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">      ControllerMethodLog methodAnnotation = signature.getMethod().getAnnotation(ControllerMethodLog.class);</span><br><span class="line">      Api typeAnnotation = (Api) signature.getDeclaringType().getAnnotation(Api.class);</span><br><span class="line">      <span class="comment">//注释不完整不进行日志记录操作</span></span><br><span class="line">      <span class="keyword">if</span> (methodAnnotation == <span class="keyword">null</span> || typeAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParams logAssistParams = signature.getMethod().getAnnotation(LogAssistParams.class);</span><br><span class="line">      <span class="keyword">if</span>(methodAnnotation == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParam[] assistParams = logAssistParams.value();</span><br><span class="line">      <span class="keyword">if</span>(ObjectUtil.isNull(assistParams) || assistParams.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; assistParams.length; i++)&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 重点在这，通过MethodBasedEvaluationContext构建解析器ExpressionParser的上下文, 底层逻辑也是通过ParameterNameDiscoverer反射获取对应的属性值</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         EvaluationContext context = <span class="keyword">new</span> MethodBasedEvaluationContext((Object) <span class="keyword">null</span>, signature.getMethod(), joinPoint.getArgs(), NAME_DISCOVERER);</span><br><span class="line">         String value = (String)PARSER.parseExpression(assistParams[i].objField()).getValue(context);</span><br><span class="line">         ReflectUtil.setFieldValue(operationLog, assistParams[i].logField(), value);</span><br><span class="line">      &#125;</span><br><span class="line">      operationLogFacade.insertSelective(operationLog);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p><p>联系方式：<a href="mailto:&#x78;&#x69;&#97;&#111;&#x63;&#97;&#x69;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#64;&#x66;&#x6f;&#x78;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#x78;&#x69;&#97;&#111;&#x63;&#97;&#x69;&#x6e;&#x69;&#97;&#111;&#121;&#97;&#64;&#x66;&#x6f;&#x78;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p><p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;认识SpEL表达式&quot;&gt;&lt;a href=&quot;#认识SpEL表达式&quot; class=&quot;headerlink&quot; title=&quot;认识SpEL表达式&quot;&gt;&lt;/a&gt;认识SpEL表达式&lt;/h3&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;最近项目接入苞米豆的&lt;code&gt;lock4j&lt;/code&gt;用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个&lt;code&gt;@Lock4j&lt;/code&gt;注解并添加相应的参数即可，在使用中发现其中有一个属性&lt;code&gt;keys = &amp;#123;&amp;quot;#userId&amp;quot;, &amp;quot;#user.sex&amp;quot;&amp;#125;&lt;/code&gt;，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过&lt;code&gt;SpEL&lt;/code&gt;的方式解析参数信息。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/categories/spring/"/>
    
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/tags/java/"/>
    
    <category term="spring" scheme="http://xiaocainiaoya.github.io/tags/spring/"/>
    
    <category term="SpEL" scheme="http://xiaocainiaoya.github.io/tags/SpEL/"/>
    
  </entry>
  
  <entry>
    <title>this调用导致注解未生效问题</title>
    <link href="http://xiaocainiaoya.github.io/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/"/>
    <id>http://xiaocainiaoya.github.io/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/</id>
    <published>2021-04-16T15:04:58.000Z</published>
    <updated>2021-04-23T11:42:56.332Z</updated>
    
    <content type="html"><![CDATA[<h4 id="动态代理导致注解未生效"><a href="#动态代理导致注解未生效" class="headerlink" title="动态代理导致注解未生效"></a>动态代理导致注解未生效</h4><p>​    今天在使用<code>mybatis-plus</code>作者苞米豆的另一个项目<code>lock4j</code>用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。</p><p>​    <code>lock4j</code>和<code>mybatis-plus</code>差不多，秉承着人性化使用的初衷，<code>lock4j</code>使用上还是非常简单的，只需要在需要上锁的接口方法上使用<code>@Lock4j</code>进行标记并设置一些简单的超时参数即可。</p><p>​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用<code>ReentrantLock</code>)，所以改造时仅仅只是对改接口上添加<code>@Lock4j</code>注解。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveInfo</span><span class="params">(String userId)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 很多业务逻辑的处理 </span></span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">this</span>.finalSaveEffective(userId);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Lock4j(keys = &#123;&quot;#userId&quot;&#125;, expire = &quot;18000&quot;, acquireTimeout = &quot;10000&quot;,</span></span><br><span class="line"><span class="meta">        keyBuilder = DefaultKeyBuilder.class)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finalSaveEffective</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//reentrantLock.lock();</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    checkInfo(..);</span><br><span class="line">    mapper.insert(..);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    log.error(e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(e.getMessage());</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//reentrantLock.unlock();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    跑起来测试后发现根本没有进入到对<code>@Lock4j</code>处理的代理方法中，马上反应到这不是和常见<code>@Transaction</code>的坑一样，不能使用<code>this.xxx</code>的方式调用，修改代码后启动，果然正常上锁，那么为什么<code>this.xxx</code>会导致异常？</p><p>​    为了知其所以然，不再盲猜硬记，我决定结合<code>@Transaction</code>注解去了解底层的机制。</p><p>​    在<code>spring</code>中的<code>aop</code>说白了就是通过动态代理实现，而动态代理有两种实现方式(<code>jdk</code>动态代理和<code>cglib</code>动态代理)。这里简单模拟一下两种动态代理的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶层接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:30:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 10:28 下午</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserFacade</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUserInfo();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入用户信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockAnnotation</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询图书信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:32:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MockAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-jdk动态代理"><a href="#1-jdk动态代理" class="headerlink" title="1. jdk动态代理"></a>1. jdk动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理的形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:33:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass()</span><br><span class="line">          .getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">            .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeJdkProxy proxy = <span class="keyword">new</span> UserFacadeJdkProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade) proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeJdkProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure><h5 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2.cglib动态代理"></a>2.cglib动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cglib方式代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:34:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">                .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">//return methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invoke(target, args);</span><br><span class="line">        <span class="comment">//Object result = methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeCglibProxy proxy = <span class="keyword">new</span> UserFacadeCglibProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade)proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeCglibProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure><p>由以上可得出结论：不论是通过哪一种动态代理实现<code>AOP</code>，使用<code>this.xxx</code>的写法都无法使得注解生效。且如果注解标记的方法为<code>final</code>或者是<code>private</code>方法也是不能进入代理方法，原因是<code>jdk</code>动态代理是基于接口代理、<code>cglib</code>动态代理是基于继承的方式，不论是那种方式的动态代理的代理对象其实都是无法进入<code>target</code>的私有方法和<code>final</code>方法。所以根据以上动态代理可以得出结论，通过<code>this.xxx</code>的方式调用本类接口是通过被代理对象直接调用本类接口，而不是通过代理对象，也就无法进入对应的<code>invoke</code>方法或者是<code>intercept</code>方法，从而无法解析到对应的注解，如果觉得将<code>this.xxx</code>修改为<code>A</code>类调用<code>B</code>类，代码需要被迫转移到其他类影响理解，在实际中可以通过<code>ApplicationContextUtil</code>的方式获取一次代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.getUserInfo(); 修改为一下写法</span></span><br><span class="line">UserFacade userFacade = ApplicationContextUtil.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userFacade.getUserInfo();</span><br></pre></td></tr></table></figure><p>但是，好玩的来了，注意看<code>UserFacadeCglibProxy</code>类中有两行注释，采用的是<code>methodProxy.invokeSuper(o, args);</code>的方式调用，运行之后可以发现通过<code>this.xxx</code>的方式竟然可以进入<code>invoice()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :UserFacadeCglibProxy.main()</span><br><span class="line">进入调用方法</span><br><span class="line">进入调用方法</span><br><span class="line">aop某方法的前置处理</span><br><span class="line">查询图书信息</span><br><span class="line">aop某方法的后置处理</span><br><span class="line">插入用户信息</span><br></pre></td></tr></table></figure><p>这边简单对这两个调用进行一个区别：</p><p><code>methodProxy.invoke(target, args)</code>的整个执行过程为：</p><ol><li>客户端调用了代理对象的<code>insertUserInfo()</code>方法</li><li>进入代理对象的<code>intercept</code>方法</li><li>通过<code>methodProxy.invoke(target, args)</code>执行被代理对象的<code>insertUserInfo()</code></li><li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是被代理对象，所以调用时不会触发<code>intercept</code>方法</li><li>调用结束</li></ol><p><code>methodProxy.invokeSuper(o, args)</code>的整个执行过程为：</p><ol><li>客户端调用了代理对象<code>insertUserInfo()</code>方法</li><li>进入代理对象的<code>intercept</code>方法</li><li>通过<code>methodProxy.invokeSuper(o, args)</code>进入被代理对象的<code>insertUserInfo()</code></li><li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是代理对象，所以<code>getUserInfo()</code>会再次触发<code>intercept()</code></li><li>进入被代理对象的<code>getUserInfo()</code></li><li>调用结束</li></ol><p>所以最终作怪的是<code>this</code>，这个<code>this</code>代表的是代理对象(<code>proxy</code>)还是被代理对象(<code>target</code>)。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;动态代理导致注解未生效&quot;&gt;&lt;a href=&quot;#动态代理导致注解未生效&quot; class=&quot;headerlink&quot; title=&quot;动态代理导致注解未生效&quot;&gt;&lt;/a&gt;动态代理导致注解未生效&lt;/h4&gt;&lt;p&gt;​    今天在使用&lt;code&gt;mybatis-plus&lt;/code&gt;作者苞米豆的另一个项目&lt;code&gt;lock4j&lt;/code&gt;用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;lock4j&lt;/code&gt;和&lt;code&gt;mybatis-plus&lt;/code&gt;差不多，秉承着人性化使用的初衷，&lt;code&gt;lock4j&lt;/code&gt;使用上还是非常简单的，只需要在需要上锁的接口方法上使用&lt;code&gt;@Lock4j&lt;/code&gt;进行标记并设置一些简单的超时参数即可。&lt;/p&gt;
&lt;p&gt;​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用&lt;code&gt;ReentrantLock&lt;/code&gt;)，所以改造时仅仅只是对改接口上添加&lt;code&gt;@Lock4j&lt;/code&gt;注解。&lt;/p&gt;</summary>
    
    
    
    <category term="超级大坑" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/"/>
    
    <category term="java" scheme="http://xiaocainiaoya.github.io/categories/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/"/>
    
    
  </entry>
  
</feed>
