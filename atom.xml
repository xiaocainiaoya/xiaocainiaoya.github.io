<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaocainiaoya&#39;s blog</title>
  
  <subtitle>日常积累</subtitle>
  <link href="http://xiaocainiaoya.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaocainiaoya.github.io/"/>
  <updated>2022-11-14T01:39:24.379Z</updated>
  <id>http://xiaocainiaoya.github.io/</id>
  
  <author>
    <name>xiaocainiaoya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis控制部分字段不打印</title>
    <link href="http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/"/>
    <id>http://xiaocainiaoya.github.io/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/</id>
    <published>2022-11-13T14:13:58.000Z</published>
    <updated>2022-11-14T01:39:24.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis控制部分字段不打印"><a href="#mybatis控制部分字段不打印" class="headerlink" title="mybatis控制部分字段不打印"></a>mybatis控制部分字段不打印</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在<code>MySQL</code>的一些执行打印了<code>text</code>等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭<code>mybatis</code>的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为<code>text</code>等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。</p><span id="more"></span>    <h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    具体的<code>mybatis</code>的几个核心组件执行流程这里不过多介绍，这里仅简单说明一条<code>SQL</code>的执行，是要先经过参数解析器，将具体的参数和数据类型解析处理，而后通过执行器，通过<code>Statement</code>或者是<code>PrepareStatement</code>等进行执行之后，再由结果集处理器进行结果映射相关逻辑。</p><p>​    在跟踪了一下<code>mybatis</code>的执行代码之后发现，日志的打印逻辑是在执行器<code>Executor</code>中，而数据类型相关的处理是在参数解析器中，也就是说如果想做到部分字段不打印，就需要在执行器中修改打印的逻辑。</p><p>我这边测试的是通过<code>PreparedStatement</code>方式进行插入数据，处理打印的类是<code>PreparedStatementLogger</code>的<code>invoke</code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 打印数据在这里</span></span><br><span class="line">        debug(<span class="string">&quot;Parameters: &quot;</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... 省略很多无效代码</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用父类<code>BaseJdbcLogger</code>的<code>getParameterValueString</code>方法获取要打印的数据。可以看到这里就是直接将<code>columnValues</code>列表中的值进行拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">  <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      typeList.add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      typeList.add(objectValueString(value) + <span class="string">&quot;(&quot;</span> + value.getClass().getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">  <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，由于这个地方并没有提供扩展点，所以如果我想要打印的时候忽略某些类型的字段，我需要重写这个类，再有我需要在这里能获取到对应的数据类型，尝试之后发现，这个对象中主要是有一个<code>Map</code>对象，键是序号（填充最后执行<code>SQL</code>的序号），值就是对应要填充<code>SQL</code>的值。所以单纯的重写这个类型，获取不到对应的类型，也就无法进行类型的判断，所以需要外层这个类的地方，将执行<code>SQL</code>的类型信息传进来。</p><p><b>类型相关信息是解析到了<code>BoundSql</code>对象中。所以需要想方设法的将<code>BoundSql</code>对象传进来</b>，这个<code>PreparedStatementLogger</code>的创建和被调用并不是在同一个时间节点，也就是说将类型相关参数传进来有两种手段，一种是在<code>PreparedStatementLogger</code>创建的时候，跟着原本构造函数相关的参数带进来，另一种是在<code>invoke</code>方法在调用之前传进来。当然了根据尝试，否定了第一种方式，原因是创建这个对象的地方也没有类型相关信息。</p><p>后来发现在<code>PreparedStatementLogger#invoke</code>方法被调用之前是可以获取到<code>BoundSql</code>对象，调用的地方是<code>PreparedStatementHandler</code>的<code>update</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里是动态代理，通过这里进入到PreparedStatementLogger#invoke中</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只需要在这里做文章，将<code>BoundSql</code>对象传到<code>PreparedStatementLogger</code>中基本上就可以达到目的。</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p>1.将<code>PreparedStatementLogger</code>拷贝到应用的类路径下，并创建同名类路径<code>org.apache.ibatis.logging.jdbc.PreparedStatementLogger</code>类，然后添加一个属性字段<code>BoundSql</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BoundSql boundSql;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略很多代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.同样，将<code>PreparedStatementHandler</code>拷贝到应用类路径下，并创建同名类路径<code>org.apache.ibatis.executor.statement.PreparedStatementHandler</code>，并在执行前设置<code>boundSql</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里获取到的是PreparedStatementLogger的动态代理对象，所以需要获取到被代理对象target</span></span><br><span class="line">  <span class="comment">// 然后判断被代理对象是否为PreparedStatementLogger，是的话就赋值boundSql</span></span><br><span class="line">  <span class="keyword">if</span> (Proxy.isProxyClass(statement.getClass())) &#123;</span><br><span class="line">    MetaObject metaObject = SystemMetaObject.forObject(statement);</span><br><span class="line">    Object target = metaObject.getValue(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> PreparedStatementLogger)&#123;</span><br><span class="line">      PreparedStatementLogger preparedStatementLogger = (PreparedStatementLogger) target;</span><br><span class="line">      preparedStatementLogger.boundSql = boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最后在需要忽略日志打印的实体字段上标记能识别到<code>jdbcType</code>的注解，我这里用的是<code>tk.mybatis</code>，所以标记注解是<code>tk.mybatis.mapper.annotation.ColumnType</code>。如果用的是<code>mybatis-plus</code>应该是<code>com.baomidou.mybatisplus.annotation.TableField</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;GROUP_ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;PROJECT_ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="meta">@ColumnType(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="keyword">private</span> String extraInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的打印逻辑我这里就不去写了，附一张到这里的断点图，到这里已经能获取到字段的类型和字段的值。</p><p><img src="https://s2.loli.net/2022/11/14/Kp4nfxJ5MHWEekQ.png" alt="mybaits控制字段打印.png"></p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>​    这里通过自己定义了与<code>mybatis</code>中相关的包路径和同名类来达到替换第三方<code>jar</code>包中的同名对象。原理实际上就是<code>jdk</code>的类加载机制，采用的是双亲委派模型，如果一个类加载器收到了需要加载类的请求，它不会马上进行解析，而是把这个请求委派给父类去加载，每一个层级的类加载器都是入参，当最上层加载器无法解析之后，它才会一层一层往下委派。</p><p>​    比如<code>java.lang.Object</code>存放在<code>rt.jar</code>中，如果编写另一个<code>java.lang.Object</code>并放到<code>ClassPath</code>中，编译上是没有问题的，但是由于双亲委派模型，当获取<code>java.lang.Object</code>时会委派到最上级的启动类加载器，而类路径<code>ClassPath</code>是应用程序类加载器。</p><p>​    但是对于上面重写的两个类，使用到的都是应用程序类加载器，但是如果在在应用<code>ClassPath</code>下创建同名路径，那么编译之后，代码是在<code>classes</code>文件夹中，而第三方包是在<code>lib</code>文件夹中，这里加载类进行查找对应<code>.class</code>文件时也有一个优先级的关系，会优先获取<code>classes</code>中的<code>.class</code>文件。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;a href=&quot;#mybatis控制部分字段不打印&quot; class=&quot;headerlink&quot; title=&quot;mybatis控制部分字段不打印&quot;&gt;&lt;/a&gt;mybatis控制部分字段不打印&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在&lt;code&gt;MySQL&lt;/code&gt;的一些执行打印了&lt;code&gt;text&lt;/code&gt;等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭&lt;code&gt;mybatis&lt;/code&gt;的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为&lt;code&gt;text&lt;/code&gt;等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。&lt;/p&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>nacos简单入门</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-27T13:04:58.000Z</published>
    <updated>2022-10-28T02:42:43.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nacos入门"><a href="#nacos入门" class="headerlink" title="nacos入门"></a>nacos入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近闲来无事看到一篇关于<code>DynamicTp</code>动态可监控线程池框架，也去<code>DynamicTp</code>官网看了一下，发现原来跟<code>Hutool</code>出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中<code>apollo</code>已经使用比较多，所以这次想尝试一下使用<code>nacos</code>。<span id="more"></span></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>​    因为我使用的是<code>mac</code>，且安装了<code>docker</code>和<code>kitematic</code>，本以为只需要从容器仓库中拉一个<code>nacos</code>的镜像就大工告成，没想到，事情没有我想象的那么顺利，还是一波三折。</p><p>​    通过<code>kitematic</code>直接搜索<code>nacos</code>镜像，并下载启动。</p><p><img src="https://s2.loli.net/2022/10/27/DqZVrThs5FeLSip.png" alt="nacos部署.png"></p><p>启动后直接报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No DataSource set</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.DumpService.dumpOperate(DumpService.java:236)</span><br><span class="line">at com.alibaba.nacos.config.server.service.dump.ExternalDumpService.init(ExternalDumpService.java:52)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)</span><br><span class="line">... 53 common frames omitted</span><br></pre></td></tr></table></figure><p>看报错信息，大概率是数据连接的问题，到目前为止，容器是镜像下载之后直接启动的，我并没有配置数据库连接相关信息，到这里，我第一反应是将<code>nacos</code>的部分文件/文件夹挂载到宿主机，修改是也方便，但是对于容器的修改挂载点有点复杂，有的说去修改底层的那个<code>config.v2.json</code>文件，有的说通过<code>export</code>修改，不知道是我操作有问题还是怎么样，我尝试了之后是没有成功。后面我是将这个运行容器删掉，利用镜像重新启动一个容器，这时就可以指定对应的挂载卷，本来想把整个<code>/nacos</code>文件夹都挂载出来，但是指定之后，死活报错，某个文件找不到，启动失败，无奈只能走最下策，进入容器操作。</p><p>所以进入容器中，查看相关配置信息。</p><p>进入容器中定位到<code>/home/nacos/conf/application.properties</code>，不同容器应该会不太一样，但是大概率是在<code>~/nacos/conf</code>文件夹。</p><p>想将<code>conf</code>文件夹下的数据库脚本文件<code>shcema.sql</code>脚本，拿到数据库中执行之后，在修改<code>application.properties</code>文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">$&#123;SERVER_SERVLET_CONTEXTPATH:/nacos&#125;</span></span><br><span class="line"><span class="meta">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">$&#123;NACOS_APPLICATION_PORT:8848&#125;</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">$&#123;SPRING_DATASOURCE_PLATFORM:mysql&#125;</span></span><br><span class="line"><span class="meta">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="meta">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="meta">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">$&#123;MYSQL_DATABASE_NUM:1&#125;</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://$&#123;MYSQL_SERVICE_HOST:docker.for.mac.host.internal&#125;:$&#123;MYSQL_SERVICE_PORT:32786&#125;/$&#123;MYSQL_SERVICE_DB_NAME:nacos&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&#125;</span></span><br><span class="line"><span class="comment"># db.url.1=jdbc:mysql://$&#123;MYSQL_SERVICE_HOST&#125;:$&#123;MYSQL_SERVICE_PORT:3306&#125;/$&#123;MYSQL_SERVICE_DB_NAME&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&#125;</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">$&#123;MYSQL_SERVICE_USER:root&#125;</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">$&#123;MYSQL_SERVICE_PASSWORD:root&#125;</span></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">$&#123;NACOS_AUTH_SYSTEM_TYPE:nacos&#125;</span></span><br></pre></td></tr></table></figure><p>填写上数据库相关信息之后，重启还是报错，在这个地方磨了好久，一直想不明白为什么数据库连接不上。</p><p>这里主要原因是因为我的<code>mysql</code>数据库不是直接安装在本机上，也是通过<code>docker</code>容器部署，所以我最开始的时候通过<code>nacos</code>容器去<code>ping</code>连接<code>mysql</code>的容器，在<code>ping</code>通的情况下，我以为<code>nascos</code>容器通过<code>mysql</code>容器的<code>ip</code>可以直接访问到数据库。一直报错之后，使用<code>telnet</code>命令查看端口是否可访问时，报错了，才发现了问题。</p><p>按我理解，访问不到的原因可能是如果<code>ip</code>写的是<code>mysql</code>容器的<code>ip</code>，那么端口应该写哪个合适?是写容器对应开放的端口，还是写宿主机绑定的端口？我两种都尝试了一次，结果都是访问不到。所以将访问<code>ip</code>修改为访问宿主机<code>ip</code>+宿主机绑定<code>mysql</code>容器的端口，这种方式是可以访问到的。</p><p>这里必须安利一波<code>mac</code>上的<code>docker</code>和<code>kitematic</code>，基本上所有的类似组件，比如<code>rabbitmq</code>，<code>mysql</code>，<code>redis</code>，<code>jenkins</code>，<code>nexus3</code>等我都是通过容器化部署，只需要把对应的数据卷挂载到宿主机，保证重启是数据不丢失即可，好处当然多多，一是干净，二是简单。</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><blockquote><p>127.0.0.1:4567/nacos/index.html</p></blockquote><p><code>nacos</code>的默认账号和密码都是<code>nacos</code></p><p><img src="https://s2.loli.net/2022/10/27/IM5EVBWFh98iYw4.png" alt="nacos登录页.png"></p><p>在<code>nacos</code>中有命名空间和分组的概念，每一个命名空间中可以划分多个组，在<code>spring</code>配置文件中，可以指定需要拉取哪个命名空间下的那个组的配置。</p><p>通过『命名空间』创建<code>dev</code>、<code>test</code>命名空间之后，在『配置列表』会显示出对应的命名空间。</p><p><img src="https://s2.loli.net/2022/10/27/ymrj5ZHOnDb7cpo.png" alt="nacos配置列表.png"></p><h2 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h2><p>引入<code>nacos</code>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类启用<code>nacos</code>配置注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@NacosPropertySource(dataId = &quot;simple-dev-yaml&quot;, groupId = &quot;DEV_GROUP&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootSimpleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootSimpleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件添加<code>nacos</code>服务器访问地址</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nacos.config.server-addr</span>=<span class="string">127.0.0.1:4567</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NacosValue(value = &quot;$&#123;useLocalCache:false&#125;&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useLocalCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useLocalCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是想使用一下<code>nacos</code>，所以采用的都是最简单的写法，写死的方式指定了<code>dataId</code>和<code>groupId</code>，在实际的使用中一般都是使用配置文件来进行管理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nacos入门&quot;&gt;&lt;a href=&quot;#nacos入门&quot; class=&quot;headerlink&quot; title=&quot;nacos入门&quot;&gt;&lt;/a&gt;nacos入门&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    最近闲来无事看到一篇关于&lt;code&gt;DynamicTp&lt;/code&gt;动态可监控线程池框架，也去&lt;code&gt;DynamicTp&lt;/code&gt;官网看了一下，发现原来跟&lt;code&gt;Hutool&lt;/code&gt;出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中&lt;code&gt;apollo&lt;/code&gt;已经使用比较多，所以这次想尝试一下使用&lt;code&gt;nacos&lt;/code&gt;。</summary>
    
    
    
    <category term="nacos" scheme="http://xiaocainiaoya.github.io/categories/nacos/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatis-plus特性</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/</id>
    <published>2022-10-14T14:13:58.000Z</published>
    <updated>2022-11-14T01:43:44.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis-plus特性"><a href="#mybatis-plus特性" class="headerlink" title="mybatis-plus特性"></a>mybatis-plus特性</h1><span id="more"></span><h2 id="1-字段类型转换器"><a href="#1-字段类型转换器" class="headerlink" title="1.字段类型转换器"></a>1.字段类型转换器</h2><p>如果出现实体字段类型与数据库类型不一致情况，比如实体是<code>String</code>但是数据库是<code>Date</code>，或者实体中是对象，而数据库中是<code>varchar</code>存储<code>json</code>；则可以通过字段类型转换器进行统一转换，无需业务层在每次存取时进行手段转换。</p><p><b>1.实体上设置转换器类型(设置之后，在通过基础接口的处理都会进行转换)</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里需要设置autoResultMap = true, 否则查询时不会将数据库中的json转换为对应实体</span></span><br><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">    <span class="comment">// 设置转换器的类型,这个是内置转换器,也可以自定义</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserExtraInfo userExtraInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.第一步骤中的设置仅导致通过内置接口的处理会进行转换，但是通过自定义XML的脚本语句不会进行转换。</b><br>法一：在<code>mapper</code>语句上通过<code>@Results</code>设置对应的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Results(value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;user_extra_info&quot;, property = &quot;userExtraInfo&quot;, typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：需要在<code>xml</code>文件中配置<code>resultMap</code>结果集，并在结果集映射中设置对应的类型转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.entity.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MOBILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deleteStatus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DELETE_STATUS&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userExtraInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;USER_EXTRA_INFO&quot;</span> <span class="attr">typeHandler</span> = <span class="string">&quot;com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testXmlSql&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-基础类扩展"><a href="#2-基础类扩展" class="headerlink" title="2.基础类扩展"></a>2.基础类扩展</h2><p>直接通过继承<code>mybatis-plus</code>提供的三层基础接口，可以直接具备一些数据操作能力，比如通过<code>deleteById</code>可以直接通过<code>id</code>删除记录，无需编写<code>SQL</code>语句。同时<code>mybatis-plus</code>还提供了对基础层的扩展，用户可自定义扩展点后，业务处理再继承于自定义的扩展点，使得系统应用具备自定义扩展底层接口的能力。<br><img src="https://s2.loli.net/2022/10/14/eropFI59y32lt4k.png" alt="mybatis-plus基础接口扩展.png"></p><p>上图中<code>userFacade</code>、<code>userService</code>、<code>userMapper</code>是业务层；<code>customerService&lt;User&gt;</code>、<code>CustomerServiceImpl</code>、<code>CustomerMapper</code>是自定义扩展层；<code>IService&lt;T&gt;</code>、<code>ServiceImpl</code>、<code>BaseMapper</code>是<code>mybatis-plus</code>的三次基础接口。</p><p><b>假设现在要扩展<code>Insert ignore</code>的插入语句</b></p><p><b>1.继承<code>AbstractMethod</code>编写具体<code>SQL</code>的拼写等处理：</b>可以参考原有的其他对<code>AbstractMethod</code>的实现，比如<code>com.baomidou.mybatisplus.core.injector.methods</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIgnore</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        CustomerSqlMethod sqlMethod = CustomerSqlMethod.INSERT_IGNORE_ONE;</span><br><span class="line">        String columnScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlColumnMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlPropertyMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(tableInfo.getKeyProperty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(sqlMethod.getMethod(), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, sqlMethod.getMethod(), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>2.设置自定义<code>SQL</code>注入器并注入到<code>Spring</code>容器：</b>将步骤一中创建的具体<code>SQL</code>执行器注入到<code>mybatis-plus</code>相应处理中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">iSqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomerSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>3.创建扩展的<code>mapper</code>层：</b>添加需要扩展的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>service</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>4.创建扩展<code>serviceImpl</code>层</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insertIgnore(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>5.到这里，业务层只要继承于扩展层，就具备了自定扩展的处理能力</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> <span class="keyword">extends</span> <span class="title">CustomerService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserExtraInfo userExtraInfo = UserExtraInfo.builder()</span><br><span class="line">                .address(<span class="string">&quot;北京市&quot;</span>)</span><br><span class="line">                .city(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                .id(<span class="string">&quot;12312311&quot;</span>)</span><br><span class="line">                .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                .mobile(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .deleteStatus(<span class="number">0</span>)</span><br><span class="line">                .userExtraInfo(userExtraInfo)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 这里就可以直接调用到扩展的接口</span></span><br><span class="line">        insertIgnore(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-逻辑删除"><a href="#3-逻辑删除" class="headerlink" title="3.逻辑删除"></a>3.逻辑删除</h2><p>只需要设置<code>@TableLogic</code>就具备了逻辑删除的能力，但是这仅限制与通过<code>mybatis-plus</code>的基础接口处理数据，如果是通过<code>xml</code>手写<code>SQL</code>是无法自动补充逻辑删除条件。</p><ul><li>插入语句不处理，也就是说默认值需要业务方插入或者通过数据库设置默认值来处理</li><li>查找、更新会追加查询条件</li><li>删除转为更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置逻辑删除字段</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mybatis-plus特性&quot;&gt;&lt;a href=&quot;#mybatis-plus特性&quot; class=&quot;headerlink&quot; title=&quot;mybatis-plus特性&quot;&gt;&lt;/a&gt;mybatis-plus特性&lt;/h1&gt;</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mysql问题汇总</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-10-11T14:13:58.000Z</published>
    <updated>2022-10-11T07:42:47.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL单表数据数据最大两千万？"><a href="#MySQL单表数据数据最大两千万？" class="headerlink" title="MySQL单表数据数据最大两千万？"></a>MySQL单表数据数据最大两千万？</h2><p>相比大家也有听说过<code>MySQL</code>单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。<span id="more"></span></p><p>其实这种说法的背后是索引高度的问题，<code>MySQL</code>索引内部使用的是<code>B+</code>树，叶子节点存具体的数据，非叶子节点是为了去叶子节点寻址。<code>MySQL</code>的数据是按页存储，每一页的大小是16k，读取的时候也是按页读取，也就是说就算你的语句里有<code>limit 1</code>，但是实际上也是将整页都加载到内存中。</p><p>这个16k大小的页包含有页头（页号，寻址指针等内容）、页尾（检验码等）、页目录（这一页内的数据目录，用于快速找到页内数据），剩下的空间就是存放具体的数据记录<code>record</code>。结合<code>B+</code>树的特性，非叶子节点内具体的数据记录<code>record</code>实际上存储的某一页的页号以及这一页的最小记录的<code>id</code>值。叶子节点内具体的数据记录<code>record</code>实际上存储的是行信息(再具体到存储的是行记录的多少内容，要看是什么索引)。</p><p>所以想查询某一行数据的主要过程：从索引的根往下找，先根据非叶子节点的<code>id</code>值匹配，匹配到对应的<code>id</code>值之后根据页号，找到对应的叶子节点，从而获取到整行数据。</p><p>当数据庞大时，树的叶子节点如果想要容纳所有数据就需要增加高度，高度越高，能容纳的数据量也就越大。同时也伴随着更多的磁盘io，一般3层索引树，会有3次磁盘io，并且是随机io。<br>这里有一个计算公式：<code>(x ^ (z-1)) * y</code></p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的<code>record</code>数量为<code>y</code></li><li><code>B+</code>树的层数为<code>z</code></li></ul><p><b>x的值：</b>主键假设是bigint（8Byte），而页号在源码里叫FIL_PAGE_OFFSET（4Byte），那么非叶子节点里的一条数据是12Byte左右，整个数据页16k， 页头页尾那部分数据全加起来大概128Byte，加上页目录毛估占1k吧。那剩下的15k除以12Byte，等于1280，也就是可以指向x=1280页。<br><b>y的值：</b>叶子节点和非叶子节点结构是一致的，这里也假设记录可用空间为15k，假设一行数据需要占用1k空间，那么叶子节点可用容纳15行的数据。</p><p>根据公式：<br>若z=2，则(1280 ^ (2-1)) * 15 ≈ 2w<br>若z=3，则(1280 ^ (3-1)) * 15 ≈ 2.5kw<br>这里的<code>2.5kw</code>也就是通常说的单表数据不要超过2kw的估值，如果高度再加一层，那么所能容纳的数据量就更加庞大。但是你有没有发现，我假设了单行数据的空间是1k，如果表字段不多，单行数据仅0.25k呢，那么这个计算结果就是1亿，也就是在三层高度的情况下，数据量也有可能达到1亿。</p><h2 id="随机IO-顺序IO"><a href="#随机IO-顺序IO" class="headerlink" title="随机IO/顺序IO"></a>随机IO/顺序IO</h2><p>顺序IO是指读写操作的访问地址连续。随机IO是指读写操作的时间连续，但访问的地址不连续。</p><h2 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h2><p>深度分页涉及到的问题通常是使用<code>limit offset, size</code>，对于<code>limit 10, 10</code>和<code>limit 10000, 10</code>，性能上前者是快于后者的，这是因为后者也是需要查出10000条数据，然后丢弃掉，再往后获取10条数据，也就是说前者总共获取了20条数据，后者获取了10010条数据。</p><p>这种情况其实是无解的，因为这是<code>MySQL</code>的内部逻辑，我们根本就触及不到，但是在一定条件下，可以通过一定的手段进行优化。假设有语句：</p><blockquote><p>select * from page order by id limit 10000, 10;</p></blockquote><p>这条查询语句还是有优化空间的，由于这里需要查询整行数据，也就导致了丢弃的10000行数据也去查询了整行数据，实际上这是没有必要的。<br>优化如下，虽然它也是会获取那丢弃的10000条数据，但是这10000条数据仅获取了id值，并没有获取整行数据，当行数据比较长时，还是会有一定的性能提升。</p><blockquote><p>select * from page  where id &gt;=(select id from page  order by id limit 10000, 1) order by id limit 10; </p></blockquote><p>再看在非主键索引上的操作：</p><blockquote><p>select * from page order by user_name  limit 10000, 10;</p></blockquote><p>这里由于是非主键索引，所以会对这丢弃的10000条数据都进行一次回表操作，影响性能。可以通过连接来优化，减少回表次数：</p><blockquote><p>select * from page t1, (select id from page order by user_name limit 10000, 10) t2  WHERE t1.id = t2.id;</p></blockquote><p>前面的优化实际上也都会查询丢弃的10000条数据，所以这里再怎么优化都是治标不治本的优化手段。所以只能通过一些特殊手段控制，比如百度、淘宝的搜索页只会固定页码，到一定页码之后就不允许往后页码查。再比如抖音这种这种滚动下只有翻页没有跳页，可以将当前页设置一个最小值，下一页在这个最小值的基础上查询。这也是同步大表时的一个手段。</p><p>如果同步一个大表，你使用的是<code>select * from tableName</code>，同步到异构系统，比如es等，因为数据量比较大，数据库无法一次性获取到所有数据而报错，如果仅仅通过<code>limit offset, size</code>就有可能出现深度分页的情况，所以一般来说可以通过<code>id</code>排序，将<code>id</code>对应的记录分块，当前块的最大<code>id</code>值，作为下一块<code>id</code>的查询条件。</p><blockquote><p>select * from tableName where id &gt; 上一块id的最大值 order by id limit 100</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;a href=&quot;#MySQL单表数据数据最大两千万？&quot; class=&quot;headerlink&quot; title=&quot;MySQL单表数据数据最大两千万？&quot;&gt;&lt;/a&gt;MySQL单表数据数据最大两千万？&lt;/h2&gt;&lt;p&gt;相比大家也有听说过&lt;code&gt;MySQL&lt;/code&gt;单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（五）---排序</title>
    <link href="http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/"/>
    <id>http://xiaocainiaoya.github.io/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/</id>
    <published>2022-10-09T14:13:58.000Z</published>
    <updated>2022-10-09T08:50:06.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（五）—排序"><a href="#mysql45讲学习总结（五）—排序" class="headerlink" title="mysql45讲学习总结（五）—排序"></a>mysql45讲学习总结（五）—排序</h1><p>​<br>本篇记录<code>MySQL</code>在执行<code>order by</code>语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。</p><span id="more"></span><h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><blockquote><p>select name, age, address from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>使用<code>explain</code>分析该语句：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>bid_confirm_project</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>4033</td><td>10</td><td>Using where; Using filesort</td></tr></tbody></table><p><code>Using filesort</code>：表示需要排序。<code>MySQL</code>会给每个线程分配一块<code>sort_buffer</code>内存空间用于排序。</p><p>假设在<code>name</code>上有索引排序流程：</p><ol><li>初始化<code>sort_buffer</code>空间，确定将用于存入字段<code>name</code>、<code>age</code>、<code>address</code>的值。</li><li>从索引<code>name</code>上找到第一个满足<code>xxx</code>条件的<code>id</code>。</li><li>根据这个<code>id</code>通过主键索引获取整行数据，将<code>name</code>、<code>age</code>、<code>address</code>的值存入到<code>sort_buffer</code>中。</li><li>从索引<code>name</code>取下一个记录的主键。</li><li>重复3,4步骤，直到从索引<code>name</code>取到的值不满足查询条件为止。</li><li>对<code>sort_buffer</code>空间的数据按照<code>age</code>进行排序。</li><li>返回结果集数据。</li></ol><p>​    <b>步骤6中按照<code>age</code>进行排序：这个可能在内存中完成，也有可能需要使用到外部排序。</b>这取决于排序所需要的内存空间大小和参数<code>sort_buffer_size</code>。如果需要排序的数据量小于<code>sort_buffer_size</code>则使用内存空间进行排序，如果需要排序的数量大于<code>sort_buffer_size</code>则需要使用磁盘临时文件辅助排序。</p><p>仅仅使用<code>explain</code>只能分析改语句是否需要排序，至于排序是在内存中排序还是在磁盘中排序就无法得知，需要使用其他手段。<b><code>MySQL</code>版本需要到5.6以上。</b></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开 optimizer_trace，只对本线程有效</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 OPTIMIZER_TRACE 输出 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`</span><br></pre></td></tr></table></figure><p>查询的结果是一个<code>json</code>结果：(<code>json</code>结果比较大，截取一段)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;filesort_summary&quot;: &#123;</span><br><span class="line">  &quot;rows&quot;: 4250,  </span><br><span class="line">  &quot;examined_rows&quot;: 4291, // 排序的行数</span><br><span class="line">  &quot;number_of_tmp_files&quot;: 11,   // 排序过程中使用的临时文件数，如果在内存中排序，则这个值为0</span><br><span class="line">  &quot;sort_buffer_size&quot;: 261696,  // 就是上面说的排序的空间大小，这个是可以通过命令调整</span><br><span class="line">  &quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>假设查询语句变为：</p><blockquote><p>select * from t where name = ‘xxx’ order by age limit 1000  ;</p></blockquote><p>对比可知，仅仅是将查询结果的字段修改为了<code>*</code>，这时在步骤1中就需要为很多无需排序的字段开辟空间，那么就会造成<code>sort_buffer_size</code>空间中单行的数据比较长，那么<code>MySQL</code>会怎么做？</p><p>实际上当<code>MySQL</code>判断单行数据过长时，它会修改<code>sort_buffer_size</code>存放值的策略，之前全字段排序时<code>sort_buffer</code>存放的字段为<code>name</code>、<code>age</code>、<code>address</code>，而如果单行数据过长时，<code>sort_buffer</code>存储的字段就变成<code>id</code>、<code>age</code>，排序完成之后，通过主键<code>id</code>索引进行一次回表，也就是说比全字段排序多了一个步骤，在排序完成之后需要进行一次回表。</p><p>同时在刚刚的<code>optimizer_trace</code>的<code>json</code>中的<code>sort_mode</code>项中会标识出是否采用了<code>rowid</code>算法。通过参数<code>max_length_for_sort_data</code>控制单行数据长度。</p><p><b>全字段排序对比rowid排序</b></p><p>如果<code>MySQL</code>认为内存足够大，会优先选择<b>全字段排序</b>，如果认为排序内存太小，影响排序效率，则会采用<code>rowid</code>排序算法，这样排序过程中一次可以排多行，但是需要再回表取相关字段数据。</p><p>排序对于<code>MySQL</code>来说是一个成本比较高的操作，并不是所有的<code>order by</code>都需要排序操作，之所以需要排序操作，是因为查到的数据是无序的，所有才需要进行排序操作，但是在<code>MySQL</code>中有一种方式是天然排序的，那就是索引，可以通过创建对应索引，使得查询到的数据已经是有序，那么就无需在经过排序操作。这种情况下<code>explain</code>得到的结果中就没有<code>filesort</code>。</p><h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><blockquote><p>CREATE TABLE <code>words</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>word</code> varchar(64) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB;</p><p>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=0;<br>  while i&lt;10000 do<br>    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;</p><p>call idata();</p></blockquote><p>然后执行以下语句用于获取随机的前三个数据，这里的<code>order by rand()</code>，会对每一行的数据都生成一个随机值，然后根据这个随机值进行排序，最后取得前三行数据。</p><blockquote><p>select word from words order by rand() limit 3;</p></blockquote><p>使用<code>explain</code>命令执行结果如下：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>words</td><td>ALL</td><td></td><td></td><td></td><td></td><td>10304</td><td>Using temporary; Using filesort</td></tr></tbody></table><p><code>Using temporary</code>表示需要使用到临时表，这里是因为需要为每一行生成一个随机值进行排序，所以需要一个临时表存储生成的这个随机值。</p><p>对于内存临时表来说，会选用那种算法存放数据？是全字段索引的算法？还是<code>rowid</code>算法？。<br>答案是使用<code>rowid</code>算法，因为对内存临时表来说，回表只是简单的根据数据行的位置直接访问到数据，不会导致访问磁盘，所以这时采用的是<code>rowid</code>排序。</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p><b>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</b></p><h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>当需要到临时表的空间比较大时，超过了<code>tmp_table_size</code>的值，那么内存临时表会转换为磁盘临时表。<br>在磁盘临时表中还有一种优化算法：优先队列排序算法。对于这个查询语句，实际上只需要取值最小的3个值，但是如果使用归并排序的话，是将所有数据都排序了，所以实际上浪费了很大的计算量。所以这里<code>MySQL</code>提供了优先队列排序算法：<br>  先取3行数据构建一个堆，再取下一行数据，与这个堆的最大值进行比较，如果大则丢弃，如果小则替换，依次执行，知道扫描完整个表。</p><p>如果需要的空间大于<code>sort_buffer_size</code>则采用磁盘临时表，通过磁盘临时表进行排序。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（五）—排序&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（五）—排序&quot;&gt;&lt;/a&gt;mysql45讲学习总结（五）—排序&lt;/h1&gt;&lt;p&gt;​&lt;br&gt;本篇记录&lt;code&gt;MySQL&lt;/code&gt;在执行&lt;code&gt;order by&lt;/code&gt;语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（四）---锁</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/</id>
    <published>2022-09-29T14:13:58.000Z</published>
    <updated>2022-10-12T03:06:54.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（四）—锁"><a href="#mysql45讲学习总结（四）—锁" class="headerlink" title="mysql45讲学习总结（四）—锁"></a>mysql45讲学习总结（四）—锁</h1><p>​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p><span id="more"></span><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><ul><li><code>DML</code>：数据操纵语言(Data Manipulation Language)</li><li><code>DDL</code>：数据定义语言(Data Definition Language)</li><li><code>MDL</code>：元数据锁(meta data lock)</li></ul><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>​    全局锁顾名思义就是对整个数据库实例上锁，让整个数据库处于只读状态，<code>MySQL</code>提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock(FTWRL)</code>。使用这个命令之后，其他线程的数据更新语句<code>DML</code>(增删改)、数据定义语句<code>DDL</code>(建表、修改字段信息)和更新类事务的提交语句。</p><p>一般来说全局锁的使用场景就是全库的备份，使用<code>FTWRL</code>命令之后，使得整个库处于只读状态之后，进行数据备份。那么有两种情况，如果在主库进行备份，备份期间，主库处于业务停摆；如果在从库备份，从库无法执行主库过来的<code>binlog</code>，导致主从延迟。</p><p>那么有没有什么方式可以不影响业务？</p><p>先简单还原全库备份如果不上全局锁产生的问题：假设有两张表，一张账户余额表，一张用户课程表；事务内的操作顺序为余额表扣款，课程表添加一条课程记录。假设这个动作是在备份过程中执行，在余额表扣款之前，备份了余额表，在课程表添加记录之后，备份了课程表，导致在备份库中，余额表的金额是原值，课程表却新增了一条记录。从语义上简单说就是钱没有花，但是买到了课。</p><p>产生这个问题的原因主要是备份库得到的不是一个逻辑时间点，视图的逻辑是不一致的，所以备份的时候应该要拿到一个时间点的一致性视图。也就是在可重复读隔离级别看开启一个事务，那么在这个事务中的操作，对于每个表来说已经形成了”快照“，对这个”快照“进行备份，从而保证备份库数据逻辑正确。</p><p>官方自带的逻辑备份工具<code>mysqldump</code>，使用参数<code>--single-transaction</code>后备份数据会启动一个事务，来确保拿到的是一致性视图，但是要注意，这个参数需要存储引擎支持可重复读这个隔离级别。比如<code>MyISAM</code>不支持，那么只能使用<code>FTWRL</code>进行备份。</p><p>当然了还有人说可以使用<code>set global readonly = true</code>的方式让整个库处于只读的状态，但是这种做法存在两个致命的问题：</p><ul><li>使用<code>FTWRL</code>命令，当这个线程因为发生异常断开之后，会释放这个全局锁。</li><li>假设其他应用层框架通过这个<code>readonly</code>全局参数判断是否是主库，导致一些应用层逻辑出现问题。</li></ul><p>业务的更新不只是<b>增删改数据（<code>DML</code>)</b>，还有可能是加字段等<b>修改表结构的操作（<code>DDL</code>）</b>。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p><h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p><code>MySQL</code>里面的表级别锁有两种：表锁和元数据锁<code>MDL</code>。</p><h2 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h2><blockquote><p>表锁的语法是 lock tables … read/write</p></blockquote><p>与<code>FTWRL</code>类似，可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。</p><p><code>lock tables</code>命令除了会限制别的线程的读写之外，也会限制自身线程的数据访问权限：假设线程A中执行<code>lock tables t1 read, t2 write</code>那么其他线程的写<code>t1</code>、读写<code>t2</code>都会被阻塞。同时当线程A在执行<code>unlock tables</code>之前，自身线程只能执行读<code>t1</code>、读写<code>t2</code>，这时连写<code>t1</code>都不允许，自然不能访问其他表。</p><p>一般不使用<code>lock tables</code>来控制并发，这个锁的面积太大。</p><h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>​    <code>MDL</code>不需要显示使用，在访问一个表的时候会自动加上，它的作用是保证读写的正确性，这是因为假设一个查询正在遍历表数据，突然另一个线程变更了表结构，那么查询线程获取到的数据结构跟原本对不上。</p><p>​    所以当对一个表做增删改操作时，加<code>DML</code>读锁，当要对表结构做变更时，加<code>DML</code>写锁。</p><ul><li>读锁之间不互斥，因此你可以多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，一个线程获取了读锁，另一个线程如果要获取写锁就需要进入等待。</li></ul><p>尽管这样还是可能会出现一些问题：</p><p>​    在给一个表添加字段、修改字段或者索引的处理，这些操作是需要全表扫描的。假设线程A获取了<code>DML</code>读锁，在对表进行查询操作，线程B想要获取<code>DML</code>写锁，进行修改表字段操作，这时由于线程A持有<code>DML</code>读锁，线程B阻塞进入等待，同时其他线程若想再查这个表数据，需要获取<code>DML</code>读锁，都会因为线程B而进入等待，如果这个表查询比较频繁，且很多客户端是有重试机制，也就是等待超时之后会重启一个<code>session</code>再次请求，那么这个库的线程很快就会满。<b>事务中的<code>DML</code>锁，在语句执行开始时申请，并不是在语句执行完成后就释放，而是在事务提交之后才释放。</b></p><p>所以一般情况下，首先要解决长事务，事务不提交会一直持有<code>DML</code>锁，或者将这个线程<code>kill</code>掉，但是对于热点表来说，可能<code>kill</code>不是那么有效果，可能刚<code>kill</code>掉，请求马上就又来了，所以只能通过为这个变更语句设置等待时间，如果在这个时间之内能获取到<code>DML</code>锁，就执行变更，如果获取不到，也不要阻塞业务，先放弃，之后在重复执行这个命令。</p><blockquote><p>ALTER TABLE tbl_name NOWAIT add column …</p><p>ALTER TABLE tbl_name WAIT N add column …</p></blockquote><h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>​    <code>MySQL</code>的行锁是各个引擎层自己实现，并不是所有存储引擎都支持行锁，比如<code>MyISAM</code>就不支持行锁，也就是锁它的并发控制只能使用表锁，这种颗粒度严重影响了业务并发度。</p><p>​    行锁就是针对于数据表中行记录的锁，锁的是主键索引，比如事务A更新了一行，这时候事务B也要更新同一行，那么事务B进入等待，如果事务B更新的不是同一行，那么事务B无需等待。</p><p><b>两阶段锁</b></p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;<br>update t set k=k+1 where id=1;<br>update t set k= k+1 where id=2;</td><td></td></tr><tr><td></td><td>Begin;<br>update t set k=k+2 wehre id=1;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这种情况下，事务A在执行两条更新语句之后，持有了这两条记录的行锁，但是事务A是在提交之后才会释放行锁，所以事务B的更新语句，要在事务A提交之后才能执行。</p><p><b>在<code>InnoDB</code>事务中，行锁是在执行语句的时候获取的，但并不是语句执行之后就释放，而是在这个事务提交之后才释放，这就是两阶段协议。</b></p><h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>间隙锁是用来解决幻读带来的问题，幻读是指事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</p><p>创建一个表，这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。</p><blockquote><p>CREATE TABLE <code>t</code> (<br><code>id</code> int(11) NOT NULL,<br><code>c</code> int(11) DEFAULT NULL,<br><code>d</code> int(11) DEFAULT NULL,<br>PRIMARY KEY (<code>id</code>),<br>KEY <code>c</code> (<code>c</code>)<br>) ENGINE=InnoDB;</p><p>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p></blockquote><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td></td><td>insert into t value(1, 1, 5)</td></tr><tr><td>select * from where d=5 for update</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p><code>sessionA</code>第一次查询的时候只返回一条记录，第二次查询的时候由于<code>sessionB</code>已经提交了，所以可以查到两条记录。</p><p>也就是说幻读指一个事务内的两次查询，后一次的查询看到了前一次查询没有看到的行。</p><p>仔细观察<code>sessionA</code>的查询语句，可以发现，<code>for update</code>命令加上之后，是当前读，当前读就是要读到已经提交的最新值，所以<code>sessionA</code>看到<code>sessionB</code>提交的结果看起来并没有什么问题。</p><p>但是，实际上这是有问题的，因为<code>sessionA</code>的第一个查询语句的语义是要锁住所有<code>d=5</code>的行，不允许其他事务进行写操作，如果将<code>sessionB</code>的语句修改为<code>update c=1 where d=5</code>，这时<code>sessionB</code>就会进入等待，等待<code>sessionA</code>提交之后释放锁。</p><p><b>锁的设计是为了在并发时保持数据的一致性，包括数据库内部数据状态的一致性，也包括了日志的一致性。</b></p><p>看下面的例子：</p><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th><th></th></tr></thead><tbody><tr><td>begin;<br>select * from where d=5 for update;<br>update t set d=100 where d=5;</td><td></td><td></td><td>T1</td></tr><tr><td></td><td>update t set d=5 where id=0;<br>update t set c=5 where id = 0;</td><td></td><td>T2</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T3</td></tr><tr><td></td><td></td><td>insert into t values(1,1,5);<br>update set c=5 where id=1;</td><td>T4</td></tr><tr><td>select * from where d=5 for update;</td><td></td><td></td><td>T5</td></tr><tr><td>commit;</td><td></td><td></td><td>T6</td></tr></tbody></table><p>当执行完成之后数据库数据结果：</p><ol><li>经过T1之后，id=5这一行变成(5, 5, 100)，但是这个要在T6之后才正式提交。</li><li>经过T2之后，id=0这一行变成(0, 5, 5)</li><li>经过T4之后，表里对了一行(1, 5, 5)</li></ol><p>所以<code>binlog</code>中的语句大概是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure><p>如果使用这个<code>binlog</code>来备份或者是从库同步数据都会出现数据不一致的情况。</p><p>那么是什么导致了这个数据不一致？可以简单的认为是<code>sessionA</code>在T1时未锁住数据导致的，那么如果它在T1时刻锁住了所有扫描到的行又会怎么样？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure><p>可以看到，就算锁住了所有扫描行，阻塞了<code>sessionB</code>的执行，但是也无法锁住<code>sessionC</code>语句的执行，<b>换句话说就是即使是所有数据都上锁，也还是无法阻止新记录的插入。</b>这也就是为什么幻读需要单独拿出来说的原因。</p><p>所以产生幻读的原因是行锁只能锁住数据行，而新插入的数据是插入到数据行之间的间隙，因此为了解决幻读，<code>InnoDB</code>引入了间隙锁(<code>Gap Lock</code>)。</p><p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，在主键索引上这就产生了 7 个间隙。</p><p><img src="https://s2.loli.net/2022/10/12/DqFhULJ4MSvCWje.png" alt="间隙锁.png"></p><p>所以当执行<code>select * from t where d=5 for update</code>时，不止是给数据库中已有的6个记录上锁，同时也加上了7个间隙锁。这样就可以确保数据无法插入。也就是说在扫描行时不仅给行上锁，也给行两边的间隙上锁。</p><p>间隙锁的性质与之前碰到的锁性质有所不同。</p><p>比如行锁分为读写锁，读锁之间不冲突，读写、写写之间是冲突。而间隙锁，两个<code>session</code>可以同时对一个间隙上间隙锁，只要不插入数据就不会产生冲突。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin<br>select * from t where c=7 lock in share mode;</td><td></td></tr><tr><td></td><td>begin<br>select * from t where c=7 lock in share mode;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里的<code>sessionB</code>并不会阻塞，因为对于<code>sessionB</code>来说也是对(0,5)这个范围加间隙锁，它也<code>sessionA</code>锁住的范围是一致的，目标也是一致的，都是为了保护(0,5)这个范围不能插入数据。</p><p>间隙锁和行锁合称<code>next-key lock</code>，每个<code>next-key lock</code>是前开后闭区间。</p><p>当然了间隙锁的引入也会带来一些问题。</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>select * from where id=5 for update;</td><td></td></tr><tr><td></td><td>select * from where id=5 for update;<br>insert into t values(5,1,5);</td></tr><tr><td>insert into t values(5,1,5);</td><td></td></tr></tbody></table><p>这个会带来死锁，原因是<code>sessionA</code>为(5,10)加上了间隙锁，<code>sessionB</code>也为(5, 10)加上了间隙锁，但是<code>sessionB</code>的插入语句需要等待<code>sessionA</code>释放间隙锁，<code>sessionA</code>的插入语句也在等待<code>sessionB</code>释放间隙锁，从而造成死锁。</p><p>间隙锁实际上是可重复读的隔离级别才会出现，如果隔离级别设置为读提交就不会产生幻读，也就不需要引入间隙锁。在读提交下，一般将日志格式设置为<code>row</code>来解决数据不一致的问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>行锁：对索引记录加锁。</li><li>间隙锁：锁住某个区间。(可以是两个索引记录之间，也可以是第一个索引之前或者最后一个索引之后的空间)</li><li>next-key锁：行锁和间隙锁的组合。</li></ul><p><b>如果检索条件不是索引的话会全表扫描，这时是表级锁。</b></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>如果需要删除一个表里前10000行数据，有一下三种方法可以做到：</p><ol><li>直接执行 <code>delete from T limit 10000</code>：单个语句占用时间过长，锁的时间比较长，而且大事务还会导致主从延迟。</li><li>在一个连接中循环执行20次<code>delete from T limit 500</code>：一般推荐这种方式。</li><li>在20个连接中同时执行<code>delete from T limit 500</code>：人为造成锁冲突。但是如果可以加上特定的条件，将这10000天然的分开，或者可以获取到主键<code>ID</code>，那么这种方式也不错。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（四）—锁&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（四）—锁&quot;&gt;&lt;/a&gt;mysql45讲学习总结（四）—锁&lt;/h1&gt;&lt;p&gt;​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（三）---事务</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-09-26T14:13:58.000Z</published>
    <updated>2022-09-29T02:51:11.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（三）—事务"><a href="#mysql45讲学习总结（三）—事务" class="headerlink" title="mysql45讲学习总结（三）—事务"></a>mysql45讲学习总结（三）—事务</h1><p>​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在<code>MySQL</code>中，事务支持是在引擎层实现的。<code>MySQL</code>是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如<code>MySQL</code>原生的<code>MyISAM</code>引擎就不支持事务，这也是<code>MyISAM</code>被<code>InnoDB</code>取代的重要原因之一。</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p><p>当数据库上有多个事务同时执行的时候，就可能出现：</p><ul><li>脏读（dirty read）：无效数据的读出，假设事务T1将某一值修改，这是事务T2读取到这一新值，但是事务T1由于某种原因回滚了新值，这就导致事务T2所读到的新值是无效的。</li><li>不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，在这个数据还没有结束时，另一个事务也访问了同一数据，那么第一个事务在两次读取数据之间由于第二个事务的修改，导致前后读取到的数据不一样，因此称为不可重复读，即原始读取不可重复。</li><li>幻读（phantom read）：事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</li></ul><p>对应的<code>SQL</code>标准事务隔离级别包括：</p><ul><li>读未提交（read uncommitted）：一个事务还没有提交时，它做的变更可以被其他事务看到。</li><li>读提交（read committed）：一个事务提交之后，它做的变更才能被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的；未提交的变更对其他事务也是不可见。</li><li>串行化（serializable ）：对同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写冲突时，后访问的事务需等待前访问事务释放锁，才可执行。</li></ul><p><b>例子</b></p><blockquote><p>create table T(c int) engine=InnoDB;</p><p>insert into T(c) values(1);</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>启动事务查询得到值1</td><td>启动事务</td></tr><tr><td></td><td>查询得到值1</td></tr><tr><td></td><td>将1改成2</td></tr><tr><td>查询得到值V1</td><td></td></tr><tr><td></td><td>提交事务B</td></tr><tr><td>查询得到值V2</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td>查询得到值V3</td><td></td></tr></tbody></table><p>不同隔离级别下V1，V2，V3的返回值：</p><ul><li>读未提交：V1=V2=V3=2（V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2）</li><li>读提交：V1=1，V2=V3=2（V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2）</li><li>可重复读：V1=V2=1，V3=2（V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的）</li><li>序列化：V1=V2=1，V3=2（在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2）</li></ul><p>在实现上，<code>MYSQL</code>引入视图的概念，访问的时候以视图的逻辑结果为准。</p><ul><li>读未提交：可以直接看到未提交事务的变更，不存在视图。</li><li>读提交：在每个<code>SQL</code>语句开始执行的时候创建视图。</li><li>可重复读：在事务启动时创建，整个事务存在期间都使用这个视图。</li><li>序列化：直接使用锁来控制并行访问，不存在视图。</li></ul><p><b>不同的隔离级别，数据库的行为有所不同，<code>Oracle</code>数据库的默认隔离级别是”读提交“，<code>MySQL</code>默认的隔离级别是可重复读，如果是将<code>Oracle</code>迁移到<code>MySql</code>的引用，为保证数据库隔离级别一致，可以将<code>MySQL</code>的隔离级别设置为”度提交“</b></p><blockquote><p>show variables like ‘transaction_isolation’</p><p>将参数transaction-isolation 的值设置成 READ-COMMITTED</p></blockquote><p><b>使用”可重复读“的场景</b></p><p>​    假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。        </p><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>​    在<code>MYSQL</code>中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值通过一个个回滚操作，可以回到之前的旧值。</p><p>假设一个值从1&rarr;2&rarr;3&rarr;4，最后新值为4，那么在回滚日志和视图如下：</p><p><img src="https://s2.loli.net/2022/09/26/tM79KoGIlz4OVhA.png" alt="事务隔离回滚.png"></p><p>最新值为4，但是不同时刻启动的事务会产生不同的视图，在在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。 对于视图A来说，要想等到值为1，只需要将最新值依次执行回滚动作。所以即使现在有新事务将4改成5，这个事务对视图A，B，C对应的事务不会存在冲突。当系统中没有比回滚日志更早的视图时，这些回滚日志就会被删除。</p><p>所以尽量不要使用长事务，长事务意味着系统里会存在很老的事务视图，导致在这个事务提交之前，这个事务可能用到的回滚记录都必须被保留，也就造成了占用了大量的存储空间。</p><h1 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h1><ol><li>显示启动事务语句，<code>begin</code>或者<code>start transaction</code>，结束事务使用<code>commit</code>，回滚使用<code>rollback</code>。</li><li><code>set autocommit=0</code>，关闭这个线程的自动提交，意味着只要执行一个<code>select</code>事务都会启动，并且不会自动提交，只有到显示<code>commit</code>或者<code>rollback</code>或者断开连接。</li></ol><p>查询持续时间超过60s的事务：</p><blockquote><p>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p></blockquote><h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><blockquote><p>CREATE TABLE <code>t</code> (</p><p>  <code>id</code> int(11) NOT NULL,</p><p>  <code>k</code> int(11) DEFAULT NULL,</p><p>  PRIMARY KEY (<code>id</code>)</p><p>) ENGINE=InnoDB;</p><p>insert into t(id, k) values(1,1),(2,2);</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td></td><td>update t set k=k+1 where id = 1;</td></tr><tr><td></td><td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td><td></td></tr><tr><td>select k from t where id =1;<br/>commit;</td><td></td><td></td></tr><tr><td></td><td>commit;</td><td></td></tr></tbody></table><p><b>注意：</b><code>begin/start transaction</code>命令并不是一个事务的起点，在执行到他们之后的第一个操作<code>InnoDB</code>表的语句，事务才真正启动，若想马上启动则使用<code>start transaction with consistent snapshot</code>命令。</p><p>事务C没有显示的使用<code>begin/commit</code>，表示这个<code>update</code>语句本身是一个事务，语句在执行完成后会自动提交。</p><p>在上述三个事务中：事务A查到的k=1，事务B查到的k=3。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>​    在可重复读隔离级别下，事务在启动的时候就对整个数据库“拍了个快照”。当然了，这个“快照”不是简单理解为拷贝数据，而是通过逻辑手段进行处理。</p><p>​    在<code>InnoDB</code>里面每个事务都有一个唯一的事务<code>ID(transaction id)</code>，在事务开始时向事务组件申请，是严格按照申请顺序递增。</p><p>​    每一行数据都是有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并把这个数据版本上的<code>row trx_id</code>标记为这个事务<code>ID</code>，同时旧数据版本，通过<code>undo log</code>来拿到具体旧数据版本。</p><p>综上：每一行数据，其实可能有多个版本<code>row</code>，每个版本有自己的<code>row_trx_id</code>。</p><p><img src="https://s2.loli.net/2022/09/27/mcCoSq971UtjWpR.png" alt="MVCC例子.png"></p><p>上图就是一个记录被多个事务更新后的状态，虚线框中是一行数据的4个版本，V4是最新的版本；图中的U1，U2，U3就是<code>undo log</code>，但需要获取到前置版本数据时，就是通过<code>undo log</code>计算出来，比如需要V2的时候，就是通过V4依次执行U3，U2计算得出。(上图中的数据版本所对应的事务都是提交状态，避免有人理解为还能对事务id=15的事务进行回滚。)</p><p>所以，某一个事务在启动的时候，会声明：“在我启动时刻为准，如果一个数据版本是在我启动之前生成，我可见；如果是在我启动之后才生成，我不可见，我必须找它之前的我可见的版本；如果是自身事务版本，我也是可见”。</p><p><code>InnoDB</code>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃中”(启动还未提交)的所有事务<code>ID</code>。当一个事务启动时，这个数组中的元素就是“活跃中”事务和自身事务(顺序排列)。当判断数据版本可见性时，就通过这个数组来进行判断，比如一个事务的数组为<code>[7,8, 10]</code>（自身事务id=9）：</p><ul><li>查询某个数据版本的<code>row trx_id=10</code>，这就表示这个数据版本是在当前事务之后生成，故向前获取版本。</li><li>查询某个数据版本的<code>row trx_id=6</code>，比数组中最小的还小，表示是在事务启动前生成的，可见。</li><li>查询某个数据版本的<code>row trx_id=7</code>，落在这个数组中，表示这个版本事务还未提交，不可见。</li><li>查询某个数据版本的<code>row trx_id=8</code>，比数组中最小的大，但是不落在这个数组中，表示这个版本事务已提交，可见。</li></ul><p>根据上述结论，分析之前事务A的查询情况：</p><ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ol><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><p><img src="https://s2.loli.net/2022/09/27/iIohujG3qXvKedk.png" alt="MVCC事务A分析.png"></p><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p><p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>当事务 A 读事务时，由于它的视图数组是 [99,100]。读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id=101，比自身数组的最大值大，不可见</li><li>找到 (1,2) 的时候，判断出 row trx_id=102，比自身数组的最大值大，不可见</li><li>找到 (1,1) 的时候，它的 row trx_id=90，比自身数组的最小值小，可见</li></ul><p>综上：</p><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><p><b>但是上述实际上只是查询数据时的逻辑，可以将上述分析结果代入事务B，会发现按这种规则代入，事务B中的k值应该为1，而不是2，问题出在事务B在查询之前执行了一次更新操作。</b></p><p>这是因为事务B要去更新数据时，就不能是历史版本上更新了，否则事务C的更新就丢失了，所以事务B此时的更新操作是在事务C的基础上操作的。</p><p><b>当前读：更新数据都是先读后写，这个读，只能读当前的值。</b></p><p>实际上除了<code>update</code>语句，<code>select</code>语句如果加锁，也是当前读。</p><blockquote><p>select k from t where id=1 lock in share mode;  // 读锁（S 锁，共享锁）</p><p>select k from t where id=1 for update; // 写锁（X 锁，排他锁）</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td><td></td></tr><tr><td></td><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td></td><td>start transaction with consistent snapshot;<br>update t set k=k+1 where id = 1;</td></tr><tr><td></td><td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td><td></td></tr><tr><td>select k from t where id =1;<br/>commit;</td><td></td><td>commit</td></tr><tr><td></td><td>commit;</td><td></td></tr></tbody></table><p>如果事务C并不是马上提交，而是在事务B执行更新动作之后提交，这时在事务C在执行更新操作时，是获取了这行数据的行锁，事务C在更新之后，事务B的更新操作需要去获取行锁，但是被事务C锁住，故事务B进入等待，直到事务C提交事务后，事务B获取到锁继续往下执行。</p><p>综上：可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（三）—事务&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（三）—事务&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（三）—事务&quot;&gt;&lt;/a&gt;mysql45讲学习总结（三）—事务&lt;/h1&gt;&lt;p&gt;​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在&lt;code&gt;MySQL&lt;/code&gt;中，事务支持是在引擎层实现的。&lt;code&gt;MySQL&lt;/code&gt;是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如&lt;code&gt;MySQL&lt;/code&gt;原生的&lt;code&gt;MyISAM&lt;/code&gt;引擎就不支持事务，这也是&lt;code&gt;MyISAM&lt;/code&gt;被&lt;code&gt;InnoDB&lt;/code&gt;取代的重要原因之一。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（二）---索引</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/</id>
    <published>2022-09-21T14:13:58.000Z</published>
    <updated>2022-10-17T03:47:17.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（二）—索引"><a href="#mysql45讲学习总结（二）—索引" class="headerlink" title="mysql45讲学习总结（二）—索引"></a>mysql45讲学习总结（二）—索引</h1><p>​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><span id="more"></span><h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>​    索引实际上就像是字典的目录，当需要查询某个字时，通过目录可以快速定位到某一页，从而快速查找到所需要的数据，不必进行全局遍历，达到提高查询效率的目的，实现上一般都是通过设计某种的数据结构，简单介绍几个常用的数据结构。</p><ol><li>哈希表：一种以键值对存储数据的数据结构，类似于<code>Java</code>中的<code>HashMap</code>的实现（当然了<code>jdk8</code>之后是采用数组加红黑树的方式），数据结构为一个数组加链表（有的地方称拉链法），当添加某个值时计算出这个值的<code>HASH</code>值，然后插入到数组对应的链表尾部，这种数据结构对于添加和删除的效率是比较高的，只需要移动一个节点的引用。</li><li>有序数组（规则数组）：通过某种规则将数据存入到数组中，在查询时同样可以根据这种规则直接通过下标获取到数据，如果是有序数组，对于范围查询的效率也是比较高的。这种数据结构瓶颈在于扩容以及空间的使用率上，比如现在是有序数组，数组长度为10，假设现在仅有两个值1和50，那么50的这个值存放在哪个位置？如果将数组长度扩大50，空间利用率就极低。</li><li>二叉树：二叉树是课本中经典的数据结构了，同样在添加、删除节点时，需要进行平衡。</li></ol><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>​    <code>InnoDB</code>引擎中采用<code>B+</code>数索引模型，每一个索引都对应着一颗<code>B+</code>树。分为主键索引和非主键索引。</p><p>​    主键索引又称为聚簇索引，主键索引的叶子节点是整行数据。</p><p><img src="https://s2.loli.net/2022/07/29/Cdn3PoHR5vbi8Iy.png" alt="主键索引示意图.png"></p><p>​        非主键索引又称为二级索引，非主键索引的叶子节点的内容是主键的值。由下图可知，非主键索引的查询逻辑是通过非主键索引获取到要查询数据的主键，再通过主键索引获取到对应行数据，这个过程称为回表。</p><p><img src="https://s2.loli.net/2022/07/29/nI3Ay1ZM4bpQRs8.png" alt="非主键索引示意图.png"></p><h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><p>​    在<code>InnoDB</code>存储引擎中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。<code>InnoDB</code>使用的索引模型为<code>B+</code>树形索引模型，所以数据都是存储在<code>B+</code>树中。</p><p>每一个索引在<code>InnoDB</code>里面都对应着一颗<code>B+</code>树。</p><p>假设有一个表，<code>ID</code>为主键，且还有字段<code>k,name</code>，同时<code>k</code>字段上有索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表中有5条记录：(ID,K)&rarr; (100,1)、(200,2)、(300,3)、(500,5) 、 (600,6)</p><p>主键索引树和<code>k</code>字段索引树如下：(图中主键索引显示为[100, 200]在一页，[300, 500, 600]在一页)</p><p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p><p>由上图可知：</p><p>索引类型分为主键索引(聚簇索引)和非主键(二级索引)索引。</p><ul><li>主键索引的叶子节点存储的是一整行的记录。</li><li>非主键索引的叶子节点存储的是主键ID。</li></ul><p>某个查询语句使用主键索引和非主键索引的差别在于，非主键索引查询到树节点之后得到叶子节点上的主键<code>ID</code>之后，需要再通过主键索引树再查找一轮，得到主键<code>ID</code>对应的行数据，这个过程称为回表。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>​    根据第一小节中的常见的索引模型可知，索引之所以查询速度高，实际上是依赖于索引模型，也就是说在插入数据时，就需要根据索引模型相应的规则进行数据的存储。所以虽然添加索引的查询效率高，但索引的数量并不是越多越好，过多的索引会增加插入数据带来的成本。</p><p>以上方索引树的图为例：</p><ul><li>如果插入的新行<code>ID</code>值为700，则只需要在R5的记录后面插入一条新记录。</li><li>如果插入的新行<code>ID</code>值为400，则需要将500和600往后挪，空出位置。如果R5所在的数据页满了，则需要申请一个新的数据页，然后将部分数据挪过去，这个过程称为页分裂。</li><li>如果相邻两页数据由于删除了数据，导致利用率比较低，那么就会出现合并页，这个过程是页分裂的逆过程。</li></ul><h1 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h1><p>还是这个表为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"># 同时插入6条记录</span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p><p>执行查询语句：</p><blockquote><p>select * from T where k between 3 and 5</p></blockquote><p>执行流程：</p><ol><li>到非主键索引<code>k</code>上搜索<code>k=3</code>的树节点，得到主键<code>ID=100</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R3</code>。</li><li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=5</code>这个树节点，得到主键<code>ID=500</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R4</code>。</li><li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=6</code>这个树节点，不满足<code>where</code>条件，循环结束。</li></ol><p>在步骤1和步骤2都有回表的动作，这是因为需要查询的字段在非主键索引<code>k</code>上没有，那么有没有办法避免回表？</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果将执行语句修改为：</p><blockquote><p>select ID from T where k between 3 and 5</p></blockquote><p>由于这时需要查询的字段<code>ID</code>，就是非主键索引<code>k</code>的叶子节点上能获取到的数据，所以就不需要进行回表的操作，也就达到了减少一次回表查询的动作，从而提升查询效率。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>所以为了不进行回表，就需要在数节点上存储的数据做文章，就需要通过联合索引。这里的<code>name_age</code>就是联合索引。</p><p>假设一个市民信息表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure><p>如果这时需要用市民的名称查询他的年龄：</p><blockquote><p>select age from tuser where name = “xxx”</p></blockquote><p>如果使用<code>name_age</code>索引，就不需要进行一次回表就可以查出想要的某个名称对应的年龄，当然了这里会出现多条记录的情况。</p><h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>如果将这条查询语句换个查询条件，能否使用这个联合索引呢？</p><blockquote><p>select name from tuser where age = xx</p></blockquote><p><img src="https://s2.loli.net/2022/09/22/uneZG4Os8JbfMRS.jpg" alt="联合索引.jpeg"></p><p>由上图可以看出，联合索引是根据联合索引定义时字段的先后顺序进行排序，也就是这里先根据<code>name</code>排序，再根据<code>age</code>排序。</p><ul><li>当需求为查询所有名字为”张三“的人，可以快速定位到ID4，然后逐个遍历节点与<code>where</code>条件进行比对。</li><li>当需求为查询所有名字第一个字为”张”，查询语句为<code>where name like &#39;张%&#39;</code>，也会命中这个索引，查询到第一个符合条件的节点为ID3，然后逐个遍历节点与<code>where</code>条件进行比对。</li><li>当需求为查询年龄为20的人，就无法使用这个索引。对这个索引来说，是先对<code>name</code>进行排序，在<code>name</code>一致的情况下，对<code>age</code>排序。</li></ul><p>综上：查询条件中不一定要全部定义，只要满足最左前缀，就可以利用这个索引来加速检索。这个最左前缀可以是联合索引的最左<code>N</code>个字段，也可以是字符串索引的最左<code>M</code>个字符。</p><p><b>在建立联合索引的时候，如何安排索引内的字段顺序。</b></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<b>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</b></p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>如果查询语句的查询条件部分满足最左前缀原则呢？</p><p>以市民表的联合索引<code>(name, age)</code>为例</p><blockquote><p>select * from tuser where name like ‘张 %’ and age=10 and ismale=1;</p></blockquote><p>根据最左前缀的规则，这个语句在搜索树时，只能用到”张”，找到第一个满足条件的记录X，然后根据其他判断条件进行判断，就算只有这样，也是要比全表扫描效率高。</p><p>在<code>MYSQL5.6</code>之前，只能从记录X开始一个个回表，到主键索引上找出记录行，在对比字段值。</p><p>在<code>MYSQL5.6</code>之后，引入索引下推优化，可以在所有遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>无索引下推执行过程如下图所示：不会获取联合索引中<code>age</code>的值，在匹配”张“之后，逐个往后遍历，并进行回表取出对应行数据进行查询条件的判断。</p><p><img src="https://s2.loli.net/2022/09/22/Ik84FoZC3MHlWPV.jpg" alt="无索引下推.jpeg"></p><p>采用索引下推的执行过程如下图所示：在匹配”张“之后，会获取<code>age</code>的值与查询条件进行匹配，如果不匹配直接获取下一个节点。所以这里的年龄等于30和20的数据，获取到之后不会进行回表操作。</p><p><img src="https://s2.loli.net/2022/09/22/OzSdyGrlAkwEhUC.jpg" alt="有索引下推.jpeg"></p><h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>重建非主键索引：</p><blockquote><p>alter table T drop index k;</p><p>alter table T add index(k);</p></blockquote><p>重建主键索引：</p><blockquote><p>alter table T drop primary key;</p><p>alter table T add primary key(id);</p></blockquote><p>重建非主键索引的做法是合理的，可以达到省空间的目的；但是重建主键索引的过程是不合理的，不论是删除主键还是创建主键，都会将整个表重建，所以第一个语句其实可有可无，单纯执行第二个语句就会对表进行重建。再者可以使用<code>alter table T engine=InnoDB</code>对表进行重建。</p><p><b>表数据删除一半，表文件大小不变？</b></p><p>​    <code>InnoDB</code>表包含两个部分，表结构定义和数据。在<code>MYSQL8.0</code>之前，表结构是存储在以<code>.frm</code>为后缀的文件里。而<code>MYSQL8.0</code>则已经允许将把表结构定义放在系统数据表，实际上表结构定义占用的空间很小，所以占用空间的主要部分就是表数据。</p><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的：</p><ol><li>这个参数设置为<code>OFF</code>表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为<code>ON</code>表示的是，每个<code>InnoDB</code>表数据存储在一个以<code>.ibd</code>为后缀的文件中。</li></ol><p>从<code>MySQL 5.6.6</code>版本开始，它的默认值就是<code>ON</code>。一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>在<code>InnoDB</code>中，数据都是以<code>B+</code>树模型且按页存储，前面也有说到，在进行查询数据时，<code>MYSQL</code>是将数据的某一页或者某几页加载到内存中。假设要删除<code>A</code>页的<code>R4</code>这条记录，这里只会将这个空间标记为复用，但是占用的空间并没有减少，如果之后又在300~600间插入一条数据，那么会复用这个空间，所以有时候删除记录并不会减少表占用空间。</p><p><img src="https://s2.loli.net/2022/09/23/ARtpzfZ5Dg7G1O6.png" alt="索引数据页结构.png"></p><p>​    当然了，如果将300-600的数据行都删除，那么这整个<code>A</code>数据页就被标记复用，对应数据页的复用，比行的复用稍微灵活，比如上述中将500对应行删除之后，只能在插入300-600之间的数据可以复用这个空间，但是如果整个数据页被标记复用，这个时候如果需要使用新页，这个标记删除的数据页就可以被复用。如果相邻两个数据页的利用率比较低，<code>MYSQL</code>也会将这两个页的数据合并到一个页，将另一个页标记为复用。</p><p>​    所以如果使用<code>delete</code>删除整个表，结果就是这个表的所有数据页被标记为复用，但是占用的磁盘空间并不会减少；但是若使用<code>truncate</code>命令，相当于使用了<code>drop</code>和<code>create</code>命令的结合，单纯从这一方面看，<code>truncate</code>在删除整个表数据时会减少空间。(但是<code>truncate</code>不能加<code>where</code>条件，动作上是先删除表<code>drop</code>再<code>create</code>表，所以它是<code>DDL</code>命令)。</p><p>​    这里将这些标记为复用的空间称为”空洞“。新增、删除、修改(比如将300修改为800，则操作上是将300对应行标记复用，在插入800对应行)数据都会存在生成新的空洞的情况，比如新增一条数据，导致某个页进行了页分裂，但是由于页空间没有填满，造成了较大的空洞，如果空洞比较多，产生的现象就是删除部分数据，并不会导致磁盘空间的减少。所以如果在删除数据之后能将这些空洞去掉，就可以减少占用磁盘空间。</p><h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>​    假设已经存在了一个较多空洞的表<code>A</code>，可以通过创建一个同样的表<code>B</code>，按照主键递增的顺序将数据从<code>A</code>表中读出，再写入到表<code>B</code>中，由于表<code>B</code>是新建表，所以表<code>A</code>主键索引上的空洞在表<code>B</code>是不存在的。这时用表<code>B</code>替换表<code>A</code>，从结果上来看，起到了收缩表<code>A</code>的目的。</p><p>​    在<code>MYSQL</code>中已经存在这个命令，通过使用<code>alter table A engine=InnoDB</code>来重建表。实际上流程就是上述流程，只不过<code>MYSQL</code>将这些操作内置，你只需要通过这一个命令即可。</p><p>​    当然了，这个过程中最消耗资源的过程，就是将表<code>A</code>数据拷贝到表<code>B</code>的过程。但是在这个过程中，如果出现新数据需要写入到表<code>A</code>中，就有可能造成数据丢失，所以在这个过程中表<code>A</code>不能有更新。</p><p>在<code>MYSQL5.6</code>版本开始引入<code>Online DDL</code>，对这个操作流程进行优化。也就是在拷贝的过程中，通过记录一个<code>row log</code>，拷贝完成之后，将<code>row log</code>的操作应用到表<code>B</code>。由于这个优化之后，在表重建过程中，允许对表<code>A</code>做写操作，所以称为<code>Online DDL</code>。</p><p>​    这个<code>DDL</code>在<code>alter</code>启动的时候就获取了<code>DML</code>写锁，但是在真正拷贝数据时，就退化为读锁，这样是为了实现<code>Online</code>，<code>MDL</code>读锁不会阻塞写操作，至于为什么不直接释放锁，是因为要禁止其他线程同时做<code>DDL</code>。</p><p>上述的这些重建方法都会扫描原表数据和构建临时文件，对于大表来说，这个操作是很消耗<code>IO</code>和<code>CPU</code>资源，所以可以通过一些比较稳定的开源组件操作，比如<code>GitHub</code>开源的<code>gh-ost</code>。</p><p>据说100万行数据以下，可以使用<code>online ddl</code>超过百万可以使用<code>gh-ost</code></p><p>关于重建表的三个命令：</p><ul><li><code>alter table t engine = InnoDB</code>：在5.6版本之后，默认就是<code>Online DDL</code>的方式。</li><li><code>analyze table t</code>：这个命令实际上不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程加了<code>MDL</code>读锁。</li><li><code>optimize table t</code>：这个命令等于<code>recreate</code>+<code>analyze</code></li></ul><h1 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h1><p>使用唯一索引还是普通索引？这是分为查询过程和更新过程来分析两种索引之间的性能差别</p><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><blockquote><p>select id from T where k=5</p></blockquote><p>这个查询语句在索引树上查找的过程：先从<code>B+</code>树根开始按层搜索叶子节点。</p><ul><li>普通索引：查找到满足条件的第一个记录(5, 500)后，需要查找下一个记录，知道碰到第一个不满足的<code>k=5</code>条件的记录。</li><li>唯一索引：查找到满足条件的第一个记录(5, 500)后，由于唯一索引的特性，直接停止检索。</li></ul><p>所以对于查询语句来说，两种索引的性能差别几乎没有差别，由于<code>MYSQL</code>是按页读写数据，所以当找到<code>k=5</code>的记录时，它所在的数据页都在内存里，那么对于普通索引来说仅比唯一索引多做了一个判断而已，所以几乎忽略不计。</p><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><blockquote><p>change buffer：当需要更新一个数据页时，如果这个数据页在内存中，则直接更新这个数据页；如果这个数据页不在内存中，在不影响数据一致性的情况下，InnoDB会将这些更新动作缓存在 change buffer 中，这样就不需要从磁盘中读出这个数据页，当下次查询出这个数据页时，将数据页读入到内存中，然后先执行 change buffer 中与这个页相关的动作之后，再返回。(虽然这块缓存的名称叫 change buffer 实际上它是可以持久化数据，也就是说 change buffer 的数据也会被写入磁盘中。)</p><p>将 change buffer 的动作应用到操作页，得到最新的数据结果的过程称为 merge。除了访问数据页之外，后台会用定时线程会触发 merge、数据库正常关闭也会触发 merge。</p></blockquote><p>实际上唯一索引并不会用到 change buffer。这是因为唯一索引在更新时，需进行唯一性约束。而这个判断就使得必须将数据页读入内存才能判断，所以如果都已经将数据读入到内存中，那么直接更新内存中的值即可。</p><p>如果要插入一个新记录（4, 400）：</p><p>第一种情况，这个记录要更新的数据行在内存中。</p><ul><li>唯一索引：找到3到5之间的位置，判断到没有冲突，插入新记录。</li><li>普通索引：找到3到5之间的位置，插入新记录。</li></ul><p>普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p><p>第二种情况，这个记录要更新的数据行不在内存中。</p><ul><li>唯一索引：需要将数据页读到内存中，判断没有冲突，插入新记录</li><li>普通索引：将动作插入到 change buffer。</li></ul><p>将数据从磁盘读入到内存中涉及随机IO的访问，是数据库里成本最高的操作之一。change buffer 减少了随机磁盘访问，所以对更新性能是很明显。</p><h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><p>​    在<code>MySQL</code>中一张表是可以创建多个索引，但是具体的<code>SQL</code>语句使用哪个索引来进行查询，是由<code>MySQL</code>来确定，有没有可能<code>MySQL</code>选到的索引不是最优解。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 创建<span class="number">10</span>w条数据: 从(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)，(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)，(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)直到(<span class="number">100000</span>,<span class="number">100000</span>,<span class="number">100000</span>)</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>现在来看一条<code>SQL</code>查询语句：</p><blockquote><p>select * from t where a between 10000 and 20000;</p></blockquote><p>这样查询语句会使用索引<code>a</code>来提高查询效率，用<code>explain</code>命令结果：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t</td><td>range</td><td>a</td><td>a</td><td>5</td><td></td><td>10000</td><td>Using where</td></tr></tbody></table><p>果然<code>key=a</code>表示使用了所以<code>a</code>，扫描了10000行数据。</p><p>再来：</p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>Start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td>delete from t;<br>call idata();</td></tr><tr><td></td><td></td></tr><tr><td></td><td>explain select * from t where a between 10000 and 20000;</td></tr><tr><td>commit;</td><td></td></tr></tbody></table><p>这里表示<code>sessionA</code>开启一个事务后，<code>sessionB</code>把数据删了之后，再次调用写10w行数据的存储过程，再通过<code>explain</code>命令查询这条<code>SQL</code>语句的执行。</p><p>这时<code>sessionB</code>的查询语句就不会再选择索引<code>a</code>，但是如果这里使用<code>select * from t force index(a) where a between 10000 and 20000;</code>就会使用索引。</p><p>这个例子对应的就是我们平常不断的删除数据和新增数据的场景，在这种情况下<code>MySQL</code>可能会选错索引。</p><p>在<code>sessionB</code>中删除了所有数据，然后通过<code>call idata()</code>插入10w行数据，看上去这里重新插入了10w行数据，但是<code>sessionA</code>在<code>sessionB</code>删除之前就开启了事务且还没有提交，所以之前的10w行数据还不能删除，这就导致之前的每一行数据都有两个版本，旧版本是数据，新版本被标记<code>delete</code>。所以再重新插入10w行数据之后，索引<code>a</code>上就有两份10w行数据。</p><p>至于为什么会选错索引，实际上优化器在选择索引的时候，有很多判断维度：扫描行、是否使用临时表、是否排序等。这里主要是因为旧的10w行数据的存在，优化器认为需要扫描的行数比较多，索引没有命中索引。其实优化器在对扫描行的判断，是通过采样分析，也是一个预估的值。可以通过<code>analyze table t</code>来重新进行统计。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;geek&#96; (</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;d&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;a&#96;,&#96;b&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;),</span><br><span class="line">  KEY &#96;ca&#96; (&#96;c&#96;,&#96;a&#96;),</span><br><span class="line">  KEY &#96;cb&#96; (&#96;c&#96;,&#96;b&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure><p>表<code>geek</code>已经存在联合主键<code>(a, b)</code>，是不是只需要创建<code>(c)</code>索引包含了<code>(ca)</code>和<code>(cb)</code>的场景，为什么需要再创建<code>(ca)</code>和<code>(cb)</code>?</p><p>假设存在以下两条语句：</p><blockquote><p>select * from geek where c=N order by a limit 1;</p><p>select * from geek where c=N order by b limit 1;</p></blockquote><p>那么这时所有<code>ca</code>和索引<code>cb</code>有存在的必要吗？</p><p>假设表中记录为：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>d</td></tr><tr><td>1</td><td>3</td><td>2</td><td>d</td></tr><tr><td>1</td><td>4</td><td>3</td><td>d</td></tr><tr><td>2</td><td>1</td><td>3</td><td>d</td></tr><tr><td>2</td><td>2</td><td>2</td><td>d</td></tr><tr><td>2</td><td>3</td><td>4</td><td>d</td></tr></tbody></table><p>主键<code>a</code>和<code>b</code>的联合主键相当于对数据进行<code>order by a, b</code>。也就是先按<code>a</code>排序，再按<code>b</code>排序，<code>c</code>无序，这里没有使用到<code>d</code>。</p><p>索引<code>ca</code>的组织结果：逻辑上最后一列是<code>ab</code>的值，但是由于联合索引中已经存在了<code>a</code>，索引最后一列中只有<code>b</code>。<b>与索引<code>(c)</code>一致。</b></p><table><thead><tr><th>c</th><th>a</th><th>b(主键的b部分)</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>3</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>1</td><td>2</td></tr><tr><td>3</td><td>1</td><td>4</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>3</td></tr></tbody></table><p>索引<code>cb</code>的组织结果：同理，最后一列也只有<code>b</code>。</p><table><thead><tr><th>c</th><th>a</th><th>a(主键的a部分)</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>2</td><td>3</td><td>1</td></tr><tr><td>3</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>3</td><td>4</td><td>1</td></tr><tr><td>4</td><td>3</td><td>2</td></tr></tbody></table><p>综上：<code>ca</code>索引和<code>c</code>的数据组织结果一致，但<code>cb</code>不一致，若上述两条查询语句为高频语句，则<code>cb</code>可以保留。</p><h2 id="字符串添加索引"><a href="#字符串添加索引" class="headerlink" title="字符串添加索引"></a>字符串添加索引</h2><p>​    字符串字段存在一个问题，如果是热点字段使用比较频繁，在不加字段的情况下，就会出现一直全表扫描，那么如果为字符串字段添加索引？</p><p>如果你仅仅只想到直接为该字符串字段添加一个索引，那么只能说你只看到了问题的表面，因为为字符串字段添加索引需要考虑到这个字符串字段的长度问题，如果这个字符串长度比较长，那么这个索引需要占用的空间就会比较大。</p><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是只取字段的部分长度作为索引：</p><blockquote><p>alter table SUser add index index2(email(6));</p></blockquote><p>设置<code>SUser</code>表的<code>email</code>字段的前6位作为索引。<br>假设表中有数据：</p><table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>xiaocainiaoya@foxmail</td></tr><tr><td>2</td><td>cainiao@foxmail</td></tr><tr><td>3</td><td>niao@foxmail</td></tr></tbody></table><p>那么如果根据<code>email</code>前六位来做为前缀索引就只需要匹配一次，回表一次后，将字段值与查询值再次匹配若匹配成功，则获取数据。<br>所以这种方式需要这个字段存储的值具备一定的规则，然后根据规则设置索引的长度，长度越长，区分度就越高，查询效率就越高，伴随着占用空间就越大。</p><p><b>注：前缀索引会破坏覆盖索引，如果仅查询索引上的字段，但是由于需要回表进行一次匹配（系统不知道这个字段值到底有没有被截断）。所以覆盖索引相关的优化可能就失效了。</b></p><h3 id="倒叙存储"><a href="#倒叙存储" class="headerlink" title="倒叙存储"></a>倒叙存储</h3><p>一些字段的规则比如身份证，身份证的前面6位表示地域位置，在查询时需要遍历的列就比较多，可以将身份证倒叙存储，也就是通过<code>reverse(idCard)</code>进行存储，再通过<code>index(idCard(6))</code>设置索引，减少遍历的行数。</p><h3 id="哈希字段"><a href="#哈希字段" class="headerlink" title="哈希字段"></a>哈希字段</h3><p>再设置一个哈希字段，比如创建身份证字段之后，再创建一个身份证的哈希字段，插入的时候计算身份证的哈希值填入，那么就可以为这个哈希字段添加索引，从而减少索引字段的长度，但是由于不同值经过哈希算法后可能会得到同一个值，所以存在一定的误差，在查询时还是要将身份证的原值加上。</p><blockquote><p>select field_list from t where id_card_crc=crc32(‘input_id_card_string’) and id_card=’input_id_card_string’</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>直接创建完整索引，这样可能比较占用空间；</p></li><li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p></li><li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p></li><li><p>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</p></li></ol><h2 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h2><p>如果在查询条件上添加聚合函数会导致索引失效，这是因为对索引字段进行聚合函数会破坏索引的有序性，导致优化器放弃走索引树的搜索功能，但是并不是说放弃了这个索引，因为如果遍历这个索引比遍历主键索引来的快，还是会使用这个索引，但是结果是使用了这个索引扫描的行也是全表的行数。</p><p>但是尽管有些聚合操作不破坏索引有序性，但是<code>MySQL</code>也不予支持，比如<code>where age + 1 = 1001</code>，不会改变索引的有序性，但是这时候也是扫描全表，要修改为<code>where age = 1001 - 1</code></p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>如果表中有一个<code>varchar</code>字段，但是查询语句是<code>where age = 10</code>，那么就涉及到类型的转换，<code>MySQL</code>采用的是字符串转换成数字的转换。也就是说<code>where age = 10</code>，需要将全表的数据都进行字符串转数字的转换，所以导致了索引失效。<br>如果换过来，表中有一个<code>int</code>字段，但是查询语句是<code>where age = &#39;10&#39;</code>,这个时候实际上是将这个<code>&#39;10&#39;</code>转为数字，在去表中匹配，这时就会命中索引。</p><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>假设有两个表有关联操作，但是关联字段的编码不一样，一个是<code>utf8mb4</code>，一个是<code>utf8</code>，因为<code>utf8mb4</code>是<code>utf8</code>的超集，在做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，是按“数据长度增加的方向”进行转换。</p><p>也就是说，实际上这个语句等同于下面这个写法: </p><blockquote><p>select * from trade_detail  where traideid USING utf8mb4 = $L2.tradeid.value;<br>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</p></blockquote><p>在这种情况下实际上就是需要判断谁是驱动表，谁是被驱动表，</p><blockquote><p>select * from trade_detail  where traideid = CONVERT($L2.tradeid.value USING utf8mb4);</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（二）—索引&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（二）—索引&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（二）—索引&quot;&gt;&lt;/a&gt;mysql45讲学习总结（二）—索引&lt;/h1&gt;&lt;p&gt;​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql45讲学习总结（一）---初试</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/</id>
    <published>2022-09-21T14:13:58.000Z</published>
    <updated>2022-09-29T02:51:46.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql45讲学习总结（一）—初试"><a href="#mysql45讲学习总结（一）—初试" class="headerlink" title="mysql45讲学习总结（一）—初试"></a>mysql45讲学习总结（一）—初试</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    感觉自身对于<code>MYSQL</code>的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说<code>MYSQL</code>45讲对<code>MYSQL</code>介绍比较细致，所以希望通过学习<code>MYSQL</code>45讲让自己的<code>MYSQL</code>形成知识网络。<span id="more"></span></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>​    下方为<code>MYSQL</code>的基本架构示意图，一个执行语句在不查询缓存的情况下，基本查询路径为：客户端&rarr;连接器 &rarr;分析器&rarr;优化器&rarr;执行器&rarr;存储引擎。对应过程：</p><ol><li>连接：连接管理模块，接收请求；连接进行和用户模块，验证通过；连接线程和客户端连接。</li><li>查询：（查询缓存）<ol><li>分析器：内建解析树，对其语法检查，<code>form</code>&rarr;<code>on</code>&rarr;<code>join</code>&rarr;<code>where</code>，检查权限，生成新的解析树，语义检查。</li><li>优化器：将解析树转换为执行计划，选择索引，并评估最优执行。</li><li>执行器：获取锁，打开表，通过<code>meta</code>数据，获取查询数据。</li></ol></li><li>返回结果：返回给连接进程，然后情况，等待新的请求。</li></ol><p><img src="https://s2.loli.net/2022/09/21/tsHEepgh6AIGyJZ.webp" alt="MySQL 的逻辑架构图.png"></p><p>总体来说<code>MYSQL</code>基本架构分为两个部分：</p><h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1.Server层"></a>1.Server层</h3><p><code>Server</code>层包含了很多执行组件，涵盖了<code>MYSQL</code>的大多数核心业务功能，以及所有的内置函数（聚合函数的处理），所有跨存储引擎的功能都是在这一层实现，比如存储过程、触发器、视图等。从图中可以看出所有存储引擎共用同一个<code>Server</code>层。</p><h4 id="1-1连接器"><a href="#1-1连接器" class="headerlink" title="1.1连接器"></a>1.1连接器</h4><p>当使用以下连接命令之后，连接器通过<code>TCP</code>与客户端建立连接、获取权限、维持和管理连接。</p><blockquote><p>mysql -h$ip -P$port -u$user -p</p></blockquote><p>通过以下命令可以查看每个连接的状态</p><blockquote><p>show processlist;</p></blockquote><table><thead><tr><th>Id</th><th>User</th><th>Host</th><th>db</th><th>Command</th><th>Time</th><th>State</th><th>Info</th></tr></thead><tbody><tr><td>5</td><td>root</td><td>172.17.0.1:40922</td><td>binlog_test</td><td>Query</td><td>0</td><td></td><td>show processlist</td></tr><tr><td>6</td><td>root</td><td>172.17.0.1:40926</td><td>binlog_test</td><td>Sleep</td><td>1237</td><td></td><td></td></tr></tbody></table><p><code>Command</code>列中存在一个<code>Sleep</code>，表示有一个连接处于空闲状态。</p><h4 id="1-2分析器"><a href="#1-2分析器" class="headerlink" title="1.2分析器"></a>1.2分析器</h4><p>分析器的主要作用是对接收到的<code>SQL</code>语句进行解析。</p><p>首先进行”词法分析“：识别收到的<code>SQL</code>语句中代表的是什么、识别出列<code>ID</code>，查询条件等。</p><p>其次进行”语法分析“：进行语法规则的校验，判断输入<code>SQL</code>是否满足<code>MYSQL</code>语法，若语法错误则会抛出<code>You have an error in your SQL syntax</code>。</p><h4 id="1-3查询缓存"><a href="#1-3查询缓存" class="headerlink" title="1.3查询缓存"></a>1.3查询缓存</h4><p>​    接收到的<code>SQL</code>在进入到分析器之前，会先进入到查询缓存组件，判断之前是否执行过该语句，如果执行过直接返回结果，若没有执行过则进入分析器。但是大多数的情况下，由于缓存失效的非常频繁，只要对一个表存在更新操作，这个表所对应的所有缓存都失效，导致对缓存的命中率比较低。</p><blockquote><p>query_cache_type设置为DEMAND表示开启，NO表示关闭</p></blockquote><p>或者也可以通过<code>SQL</code>中关键字<code>SQL_CACHE</code>指定：</p><blockquote><p>select SQL_CACHE * from T where ID=10；</p></blockquote><p>同时在<code>MYSQL  8.0</code>版本中移除了缓存模块。</p><h4 id="1-4优化器"><a href="#1-4优化器" class="headerlink" title="1.4优化器"></a>1.4优化器</h4><p>​    优化器接收到了经过了分析器的<code>SQL</code>，优化器的主要作用是对<code>SQL</code>进行优化、多表连接顺序、多索引时选择使用哪个索引等。同一个<code>SQL</code>语句，不同的连接顺序、索引选择虽然查询结果一致，但是执行效率上存在差异。</p><p>​    优化器的作用便是在同样查询结果的情况下，对<code>SQL</code>语句进行优化，尽可能提升语句的查询效率，但是也有可能经过优化器处理之后，反而导致执行时长变长。</p><h4 id="1-5执行器"><a href="#1-5执行器" class="headerlink" title="1.5执行器"></a>1.5执行器</h4><p>​    优化器执行之后，<code>SQL</code>语句的执行方案就确定下来，然后进入执行器，在开始执行之前，需判断登录用户对操作表有没有执行查询的权限，若没有权限则报错：</p><blockquote><p>ERROR 1142 (42000): SELECT command denied to user ‘b’@’localhost’ for table ‘T’</p></blockquote><p>比如查询语句为：</p><blockquote><p>select * from T where ID=10;</p></blockquote><p>表 <code>T</code> 中，<code>ID</code> 字段没有索引，在执行器中的执行流程为：</p><ol><li>调用<code>InnoDB</code>引擎接口取这个表的第一行，判断<code>ID</code>值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>如果<code>ID</code>字段存在索引，只是在第1步骤中使用的调用存储引擎的接口不一致。</p><p>在慢查询日志中会有一个<code>rows_examined</code>的字段，表示这个语句在执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟<code>rows_examined</code>并不是完全相同的。</p><h3 id="2-存储引擎层"><a href="#2-存储引擎层" class="headerlink" title="2.存储引擎层"></a>2.存储引擎层</h3><p>存储引擎层负责数据的存储和提取。其架构模式是插件式，支持<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>。默认情况下使用<code>InnoDB</code>，也就是说通过<code>create Table</code>创建表时，若没有明确指定存储情况，默认就会使用<code>InnoDB</code>。</p><ul><li>InnoDB：事务型数据库的首选存储引擎，支持书屋安全表<code>ACID</code>，支持行锁和外键，<code>InnoDB</code>是<code>MYSQL</code>的默认存储引擎。</li><li>MyISAM：基于<code>ISAM</code>存储引擎，并对其进行扩展，它是在<code>Web</code>、数据仓储和其他应用环境下最常使用的存储引擎之一，拥有较高的插入和查询速度，但不支持事务。</li><li>Memory：内存数据库，将表中的数据存储到内存中。</li></ul><h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><p>​    更新语句和查询语句在执行器之前经过的<code>Server</code>层组件是一样的(唯一不同的是更新语句会移除所操作表的查询缓存)。与查询流程不一样的是，更新流程还涉及到两个重要的日志模块<code>redo log</code>(重做日志)，<code>binlog</code>(归档日志)。</p><h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><p>​    在<code>MYSQL</code>45讲中，使用《孔乙己》中酒店掌柜的例子，粉板和账本指代<code>redo log</code>和磁盘。当有一个更新操作时先将记录写入到<code>redo log</code>中，并不是执行写入磁盘(这么做的话<code>IO</code>成本、查找成本太高)。而是在适当的时机将<code>redo log</code>的内容写入到磁盘中。</p><p>​    通过<code>redo log</code>和磁盘结合的方式进行数据记录，这个整合的过程，就是<code>MYSQL</code>的<code>WAL(Write-Ahead Logging)</code>技术，它的关键点就是先写日志，再写磁盘。</p><h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><p>​    <code>redo log</code>是<code>InnoDB</code>引擎特有的日志，<code>bin log</code>是<code>Server</code>层日志。</p><p>这两种日志的不同点：</p><ul><li><code>redo log</code>是<code>InnoDB</code>引擎特有的；<code>bin log</code>是<code>Server</code>层实现，所有存储引擎都可以使用。</li><li><code>redo log</code>记录的是物理日志，记录的是”在某一个数据页上做了什么修改“，<code>bin log</code>是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c 字段加 1 “。</li><li><code>redo log</code>是循环写，空间是固定(粉板)，当写满之后会覆盖掉以前的日志；<code>bin log</code>是可以追加写，当文件写入到一定大小后会根据规则生成新的日志文件，不会覆盖旧日志。</li></ul><blockquote><p>create table T(ID int primary key, c int);</p><p>update T set c=c+1 where ID=2;</p></blockquote><p><strong>两阶段提交的简单流程</strong></p><ol><li>执行器先通过存储引擎接口获取到<code>ID=2</code>这一行记录，如果<code>ID=2</code>这行记录的数据页在内存中，则直接从内存中获取后返回给执行器。否则需要先将磁盘中这一页数据加载到内存中，再返回。</li><li>执行器得到这一行数据后，对<code>c</code>列执行<code>+1</code>操作，再调用存储引擎接口，将结果写入到这行新数据中。</li><li>存储引擎将这行数据更新到内存中，之后将这个更新操作写入到<code>redo log</code>中，并标记状态为<code>prepare</code>，然后告知执行器可以进行提交<code>commit</code>操作。</li><li>执行器生成这个操作的<code>bin log</code>，并将<code>bin log</code>刷盘。</li><li>执行器调用存储引擎的提交事务接口，存储引擎将刚刚的<code>redo log</code>由<code>perpare</code>修改为<code>commit</code>状态。</li></ol><p>先说这样做的好处：实际上引入<code>redo log</code>的作用是希望<code>MYSQL</code>具备<code>crash-safe</code>(指服务器宕机重启后，能够保证已提交的事务仍然存在)。</p><p>若服务器宕机出现在以上的某个流程中：</p><ul><li>在第3步骤写入<code>redo log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是不完整的，直接回滚事务。</li><li>在第4步骤写入<code>bin log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是完整的，直接提交事务。</li><li>在第5步骤修改<code>redo log</code>状态为<code>commit</code>状态，显然直接提交这个事务。</li></ul><p><strong>若不使用两阶段提交：</strong></p><p>假设两个前提：</p><ul><li>数据在一定周期内进行全量备份，可以是一天一备，也可以是一周一备。</li><li>开启<code>bin log</code>。</li></ul><p>在这种情况下数据恢复到某一时间点的操作为：</p><ol><li>找到最近一次的全量备份，将这个备份恢复到临时库中。</li><li>从备份的时间点开始，将备份时间点之后的的<code>bin log</code>依次取出，在临时库进行重放到需要恢复的这一时刻。</li><li>这时在临时库就有被误删的数据，简单处理可以手动将数据从临时表取出，按需恢复到线上库。</li></ol><p>由于存在两个日志文件，所以就需要保证两个日志文件在<code>MYSQL</code>发生异常时，数据能保持一致。</p><ol><li>**先写<code>binlog</code>后写<code>redo log</code>**：假设在<code>binlog</code>写完之后，<code>MYSQL</code>发生异常，由于<code>redo log</code>还没有写，导致<code>MYSQL</code>重启后<code>binlog</code>存在某一个操作，而<code>redo log</code>中没有这一操作，若从库使用<code>binlog</code>重放，则导致从库会有这一操作，从而导致主从数据不一致。</li><li>**先写<code>redo log</code>再写<code>binlog</code>**：假设在<code>redo log</code>写完之后，<code>MYSQL</code>发生异常，由于<code>binlog</code>还没写，导致重启之后，通过<code>redo log</code>进行数据恢复，所以主库中是存在这一操作，但是由于<code>binlog</code>中没有写入，所以导致使用<code>binlog</code>重放时，从库丢失一个操作。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    <code>redo log</code>的主要作用是利用”粉板”和”账本”的配合，提高<code>MYSQL</code>的吞吐性能，降低<code>IO</code>成本、查找成本。<code>bin log</code>是<code>Server</code>层日志，它存在于<code>redo log</code>之前，<code>redo log</code>是在<code>InnoDB</code>存储引擎诞生时，由<code>innoDB</code>引擎自身携带，其他存储引擎是没有的。还有<code>redo log</code>是对一个日志文件进行循环写，到一定数据量之后会覆盖旧值，不持久保存，<code>binlog</code>才具备”归档“的能力。</p><p>故障恢复是使用<code>redo log</code>日志进行恢复。主从同步是使用<code>binlog</code>进行数据同步。</p><ul><li><code>innodb_flush_log_at_trx_commit</code>：设置为1时表示，表示每次事务的<code>redo log</code>都直接持久化到磁盘。建议设置为1，保证<code>MySQL</code>异常重启之后数据不丢失。</li><li><code>sync_binlog</code>：设置成1的时候，表示每次事务的<code>binlog</code>都持久化到磁盘。建议设置成1，这样可以保证 <code>MySQL</code>异常重启之后<code>binlog</code>不丢失。</li></ul><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql45讲学习总结（一）—初试&quot;&gt;&lt;a href=&quot;#mysql45讲学习总结（一）—初试&quot; class=&quot;headerlink&quot; title=&quot;mysql45讲学习总结（一）—初试&quot;&gt;&lt;/a&gt;mysql45讲学习总结（一）—初试&lt;/h1&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​    感觉自身对于&lt;code&gt;MYSQL&lt;/code&gt;的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说&lt;code&gt;MYSQL&lt;/code&gt;45讲对&lt;code&gt;MYSQL&lt;/code&gt;介绍比较细致，所以希望通过学习&lt;code&gt;MYSQL&lt;/code&gt;45讲让自己的&lt;code&gt;MYSQL&lt;/code&gt;形成知识网络。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA插件开发</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2022-09-19T13:51:58.000Z</published>
    <updated>2022-09-22T01:47:29.721Z</updated>
    
    <content type="html"><![CDATA[<p>​    公司中提交<code>MYSQL</code>脚本有相应的规范，需要编写为<code>groovy</code>文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在<code>console</code>控制台上交互，使用上有点繁琐，偶然看到关于<code>IDEA</code>插件开发的博客，想着是否可以通过<code>IDEA</code>插件来写一个<code>UI</code>，生成逻辑直接使用原有代码移植过来。同时记录在开发<code>IntelliJ IDEA</code>插件过程中遇到的一些问题和踩到的一些坑。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>​    <code>IntelliJ IDEA</code>插件开发有两种方式，一种是直接引入<code>Plugin DevKit</code>，然后配置<code>IntelliJ Platform Plugin SDK</code>进行开发，另一种是使用<code>gradle</code>构建项目并引入<code>IDEA</code>插件开发包。使用<code>gradle</code>的好处是同时也可以引入一些其他的库进行使用。</p><p>​    在<code>IDEA 2021.3</code>以及之后的版本，开发需要使用<code>JDK 11</code>进行开发，在我开发的时候我本地也没有<code>JDK 11</code>(一台电脑可以支持多个版本的<code>JDK</code>，问题在于环境变量配置的是哪个版本而已。因为目前只有这里插件开发我才会用到<code>JDK 11</code>，所以没有将它添加到环境变量中，仅通过<code>IDEA</code>工具添加了<code>JDK</code>路径)。</p><p>​    我使用的是<code>gradle</code>的方式进行插件的开发。<code>gradle</code>导入之后，在<code>Libraries</code>下会有一个<code>com.jetbrains:ideaIC:2021.3</code>，这就是<code>IDEA</code>插件的开发包。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// IDEA的插件开发包</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;1.8.1&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// 设置阿里云maven仓库 </span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;cn.hutool:hutool-all:5.6.7&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.alibaba:fastjson:1.2.28&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-core:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-jul:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-slf4j-impl:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.25&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.9.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.9.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idea的使用版本</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    version = <span class="string">&#x27;2021.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">patchPluginXml &#123;</span><br><span class="line">    changeNotes = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Add change notes here.&lt;br&gt;</span></span><br><span class="line"><span class="string">      &lt;em&gt;most HTML tags may be used&lt;/em&gt;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gradle</code>中一些常用项：</p><p><code>intellij -&gt; runIde</code>：这时会新启动一个<code>IDEA</code>工具，可以进行调试插件。</p><p><code>intellij -&gt; buildPlugin</code>：构建插件，用来完成之后将代码打包成<code>.zip</code>。(路径为<code>build/distributions</code>)。</p><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p>点击<code>Help -&gt; Edit Custom Properties...</code>，添加以下配置后重启<code>IDEA</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">idea.is.internal</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>在<code>Tool</code>下会出现<code>Interal Actions</code>和<code>View PSI Structure...</code>按钮。</p><p><img src="https://s2.loli.net/2022/09/20/xouELJspl16qTnj.png" alt="ideaInternal.png"></p><p>参考面板：<code>Internal Actions -&gt; UI -&gt; Show Standard Panels</code>：会弹出一个<code>UI</code>面板，结合<code>UI Debug</code>就可以参考到对应的源码。</p><p><img src="https://s2.loli.net/2022/09/20/p46q5sldBj7Q3cn.png" alt="standPanel.png"></p><p>通过<code>Internal Actions -&gt;UI Debugger</code>可以监控在<code>IDEA</code>中鼠标操作对应的<code>Action</code>。比如创建一个类，在<code>UI Debugger</code>面板上可以看到一个<code>CreateClassAction</code>的类，就可以看到这个创建一个类的源码，如果功能类似甚至可以直接复用。</p><p>与<code>PSI</code>相关<code>API</code>目前占时没有使用，具体如果需要插件能实现在代码里根据某种规则生成内容，则就需要通过<code>PSI</code>相关内容进行处理。</p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idea-plugin</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">    └── main</span><br><span class="line">          └── resources</span><br><span class="line">          │     └── META-INF</span><br><span class="line">          │          └── plugin.xml</span><br><span class="line">          └── java</span><br><span class="line">              └── cn<span class="selector-class">.com</span>.xiaocainiao</span><br><span class="line">                       └── MyWindowFactory<span class="selector-class">.java</span>  </span><br></pre></td></tr></table></figure><h2 id="plugin-xml配置"><a href="#plugin-xml配置" class="headerlink" title="plugin.xml配置"></a>plugin.xml配置</h2><p>我使用的是<code>ToolWindowFactory</code>创建右侧窗体。若是创建<code>Action</code>，可以直接通过<code>New -&gt; Plugin DevKit -&gt; Action</code>进行创建，通过这种方式创建，会自动在<code>plugin.xml</code>文件中添加<code>&lt;action&gt;</code>的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>org.example.SecondIdeaPlugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SecondIdeaPlugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;xiaocainiaoya@foxmail.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://xxx.com&quot;</span>&gt;</span>bosssoft<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">        For simple and quick generation of SQL script files&lt;br&gt;</span><br><span class="line">        &lt;em&gt;Tools that are easy to use&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- please see https://plugins.jetbrains.com/docs/intellij/plugin-compatibility.html</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">toolWindow</span> <span class="attr">id</span>=<span class="string">&quot;generatorSQL&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">secondary</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">anchor</span>=<span class="string">&quot;right&quot;</span> <span class="attr">factoryClass</span>=<span class="string">&quot;cn.com.xiaocainiaoya.MyWindowFactory&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">toolWindow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>​    由于<code>IDEA</code>插件的<code>UI</code>采用的是<code>Swing</code>、<code>Awt</code>来进行窗体开发，当知道使用的是<code>Swing</code>一度想要放弃掉，确实是使用<code>Swing</code>是一件比较痛苦的事情。后借助于<code>IDEA</code>的<code>Swing UI Designer</code>功能通过拖拽简单组件的方式，硬着头皮画出了<code>UI</code>界面。</p><p><img src="https://s2.loli.net/2022/09/19/sTRPS3cQYnVABFD.png" alt="ideaSwing.png"></p><h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><h2 id="1-路径"><a href="#1-路径" class="headerlink" title="1.路径"></a>1.路径</h2><p>​    可能由于项目有别于常用的<code>java</code>项目、<code>spring</code>项目，所以在获取资源文件(<code>/resources/**</code>)时，总是感觉摸不着头脑。参考了一些其他博主写的<code>IDEA</code>插件项目，获取资源文件的方式，与<code>java</code>项目、<code>Spring</code>项目并无差别，但是我在获取资源文件时，一直提交获取不到资源文件，也有可能是<code>velocity</code>组件的问题。</p><p>​    原本使用<code>velocity</code>模板引擎来加载对应模板文件，但是一直报错获取不到对应资源文件之后，将这种动作修改为代码层获取到资源文件内容，在将模板内容提交给<code>velocity</code>模板引擎。</p><p>注：<code>velocity</code>组件和<code>groovy</code>库相关包在<code>com.jetbrains:ideaIC:20201.3</code>中已经存在，所以不能由自身再引入。</p><p>在调试开发过程中，<code>velocity</code>正常使用，但是打包成插件之后，通过插件的方式运行，一直报一个日志相关的异常。</p><p>添加<code>velocity.proerties</code>配置文件相关配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">runtime.log.logsystem.class</span>=<span class="string">org.apache.velocity.runtime.log.SimpleLog4JLogSystem</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.category</span>=<span class="string">velocity</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.logger</span>=<span class="string">velocity</span></span><br></pre></td></tr></table></figure><p>因为在调试过程的运行和实际插件方式运行是对应的相对路径是不一致的，所以在使用系统级有关的相对路径是需通过使用<code>com.intellij.openapi.application.PathManager</code>类来获取对应的路径：</p><p>比如使用<code>PathManager.getBinPath()</code>：</p><p>在调试运行获取到的路劲为：<code>/usr/local/Cellar/gradle/7.3.1/caches/modules-2/files-2.1/com.jetbrains.intellij.idea/ideaIC/2021.3/75777e10a0e2880bc02945066dda2480a696c3d9/ideaIC-2021.3/bin</code></p><p>在实际插件方式允许获取的路径为：<code>/Applications/IntelliJ IDEA.app/Contents/bin</code></p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://zhuanlan.zhihu.com/p/400059601" target="_blank">IntelliJ IDEA 插件开发指南</a></p><p><a href="https://plugins.jetbrains.com/docs/intellij/welcome.html" target="_blank">插件入门官网</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    公司中提交&lt;code&gt;MYSQL&lt;/code&gt;脚本有相应的规范，需要编写为&lt;code&gt;groovy&lt;/code&gt;文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在&lt;code&gt;console&lt;/code&gt;控制台上交互，使用上有点繁琐，偶然看到关于&lt;code&gt;IDEA&lt;/code&gt;插件开发的博客，想着是否可以通过&lt;code&gt;IDEA&lt;/code&gt;插件来写一个&lt;code&gt;UI&lt;/code&gt;，生成逻辑直接使用原有代码移植过来。同时记录在开发&lt;code&gt;IntelliJ IDEA&lt;/code&gt;插件过程中遇到的一些问题和踩到的一些坑。&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="插件" scheme="http://xiaocainiaoya.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本基础</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-13T13:51:58.000Z</published>
    <updated>2022-09-22T01:47:37.209Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。</p></blockquote><span id="more"></span><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>最精简的<code>if</code>语句：<code>condition</code>是判断条件，<code>statement</code>判断条件为真时的执行语句。在<code>shell</code>脚本中不是通过大括号<code>&#123;&#125;</code>开标识代码的开始与结束。而是通过<code>fi</code>来闭合。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>也可以写成：当<code>condition</code>和<code>then</code>在同一行时，需要使用分号隔开，否则报语法错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition; <span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>结合<code>else</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statement2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>再结合<code>else if</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statementn</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>判断表达式：</p><blockquote><p>-e filename 如果 filename存在，则为真<br>-d filename 如果 filename为目录，则为真<br>-f filename 如果 filename为常规文件，则为真<br>-L filename 如果 filename为符号链接，则为真<br>-r filename 如果 filename可读，则为真<br>-w filename 如果 filename可写，则为真<br>-x filename 如果 filename可执行，则为真<br>-s filename 如果文件长度不为0，则为真<br>-h filename 如果文件是软链接，则为真<br>filename1 -nt filename2 如果 filename1比 filename2新，则为真。<br>filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</p></blockquote><p>整数变量表达式：</p><blockquote><p>-eq 等于<br>-ne 不等于<br>-gt 大于<br>-ge 大于等于<br>-lt 小于<br>-le 小于等于</p></blockquote><p>字符串变量表达式：</p><blockquote><p>If  [ $a = $b ]         如果string1等于string2，则为真<br>if  [ $string1 !=  $string2 ]  如果string1不等于string2，则为真<br>if  [ -n $string  ]       如果string 非空(非0），返回0(true)<br>if  [ -z $string  ]       如果string 为空，则为真<br>if  [ $sting ]          如果string 非空，返回0 (和-n类似) </p></blockquote><p>逻辑符号：</p><blockquote><p>逻辑非 !     if [ ! 表达式 ]<br>if [ ! -d $num ]         如果不存在目录$num</p><p>逻辑与 –a          条件表达式的并列(类似其他语言的<code>&amp;&amp;</code>)<br>if [ 表达式1  –a  表达式2 ]</p><p>  逻辑或 -o          条件表达式的或(类似其他语言的<code>||</code> )<br>if [ 表达式1  –o 表达式2 ]</p></blockquote><h4 id="2-循环"><a href="#2-循环" class="headerlink" title="2.循环"></a>2.循环</h4><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="shell" scheme="http://xiaocainiaoya.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>markdown记录</title>
    <link href="http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/"/>
    <id>http://xiaocainiaoya.github.io/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/</id>
    <published>2022-09-13T13:51:58.000Z</published>
    <updated>2022-09-27T09:19:50.493Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><table><thead><tr><th>符号</th><th>说明</th><th>编码(使用时移除’+’号)</th></tr></thead><tbody><tr><td>←</td><td>左箭头</td><td>&amp;+larr;</td></tr><tr><td>→</td><td>右箭头</td><td>&amp;+rarr;</td></tr><tr><td>↑</td><td>上箭头</td><td>&amp;+uarr;</td></tr><tr><td>↓</td><td>下箭头</td><td>&amp;+darr;</td></tr><tr><td>↔</td><td>水平箭头</td><td>&amp;+harr;</td></tr><tr><td>↕</td><td>竖直箭头</td><td>&amp;+varr;</td></tr><tr><td>⇐</td><td>双线左箭头</td><td>&amp;+lArr;</td></tr><tr><td>⇒</td><td>双线右箭头</td><td>&amp;+rArr;</td></tr><tr><td>⇑</td><td>双线上箭头</td><td>&amp;+uArr;</td></tr><tr><td>⇓</td><td>双线上箭头</td><td>&amp;+dArr;</td></tr><tr><td>⇔</td><td>双线水平双箭头</td><td>&amp;+hArr;</td></tr><tr><td>⇕</td><td>双线竖直箭头</td><td>&amp;+vArr;</td></tr></tbody></table><h1 id="跳转方式"><a href="#跳转方式" class="headerlink" title="跳转方式"></a>跳转方式</h1><p><strong>1.页内定位：</strong></p><ol><li>定义一个锚(id)：<code>&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</code></li><li>使用markdown语法：<code>[点击跳转](#jump)</code></li></ol><p><strong>2.重定向</strong></p><blockquote><p>[描述] (地址)</p></blockquote><p><strong>3.新标签页打开：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>显示字眼<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="表格内换行"><a href="#表格内换行" class="headerlink" title="表格内换行"></a>表格内换行</h1><p>使用<code>&lt;br&gt;</code></p><h1 id="黑体"><a href="#黑体" class="headerlink" title="黑体"></a>黑体</h1><p>部分<code>markdown</code>渲染器无法识别<code>****</code>，可以使用<code>&lt;b&gt;&lt;/b&gt;</code>的<code>html</code>标签来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;箭头&quot;&gt;&lt;a href=&quot;#箭头&quot; class=&quot;headerlink&quot; title=&quot;箭头&quot;&gt;&lt;/a&gt;箭头&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    <category term="杂七杂八" scheme="http://xiaocainiaoya.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="markdown" scheme="http://xiaocainiaoya.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Spock实践（一）</title>
    <link href="http://xiaocainiaoya.github.io/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiaocainiaoya.github.io/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-05T13:04:58.000Z</published>
    <updated>2022-08-05T09:24:23.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spock实践（一）"><a href="#Spock实践（一）" class="headerlink" title="Spock实践（一）"></a>Spock实践（一）</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在<code>Spring</code>体系中，常用的单元测试框架就是基于<code>PowerMock</code>或者<code>MockTo</code>等，由于这些框架依赖<code>Spring</code>容器，所以在编写过程需要频繁的启动<code>Spring</code>容器进行单元测试的测试，导致过程比较繁琐。<span id="more"></span></p><p>​    最近看到一篇美团的2021博客点击率<code>TOP10</code>中的一篇<a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">Spock单元测试框架介绍以及在美团优选的实践</a>，使用全新的<code>Spock</code>框架来进行单元测试，这个框架的好处，无需依赖<code>Spring</code>容器来进行单元测试，并且结合<code>groovy</code>动态语言的特点，提供了一些标签，并采用简单、通用、结构化的描述语言，让编写测试代码更加简洁、高效。具体细节参考美团的那篇技术博客。</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><h4 id="对于dao层抽象"><a href="#对于dao层抽象" class="headerlink" title="对于dao层抽象"></a>对于dao层抽象</h4><p>​    在将这篇博客中的一些例子简单跑过之后，<code>Spock</code>确实在单元测试的编写上比较简单且直观，但是由于它不依赖于<code>Spring</code>容器，导致了原来<code>Spring</code>框架为我们封装的一些特性无法使用，比如在我们应用中，到处都是通过<code>tk.mybatis</code>或者<code>mybatis plus</code>的一些通过接口<code>api</code>来动态化<code>SQL</code>，而无需进行手动编写<code>SQL</code>。这些特性实际上是通过<code>Spring</code>容器中在创建特定<code>bean</code>对象时通过<code>spring</code>的扩展点进行处理的。在美团的那篇博客中也提到了如果想测试<code>dao</code>层，可以通过<code>MyBatis的SqlSession</code>启动<code>mapper</code>实例，但是这种方式仅仅获取到的是最基础的<code>ibatis</code>的代理对象，没有了<code>tk</code>或者是<code>mp</code>相关的增强。</p><p>​    由于目前只是想简单的引入<code>Spock</code>到某一个服务中，在实际的业务逻辑中，并不确定引入<code>Spock</code>对单元测试的编写是否会有提高，所以这里仅仅研究了如何在不依赖<code>spring</code>容器的情况下，伪造<code>tk.mybatis</code>查询时的<code>mapper</code>对象。</p><p>​    跟踪<code>Springbean</code>对象的创建过程，发现<code>tk.mybatis</code>主要是靠<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>(注意包路径，<code>ibatis</code>包下有一个同名类)来进行一些增强处理。所以创建一个工具类，专门用来获取对应的<code>mapper</code>代理对象。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用mapper工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * @date 2022/7/30 16:11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapperUtil</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MapperHelper mapperHelper = <span class="keyword">new</span> MapperHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config config = <span class="keyword">new</span> Config()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapperHelper.setConfig(config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">def</span> getMapper(Class clazz)&#123;</span><br><span class="line">        ClassLoader classLoader = MapperUtil.<span class="keyword">class</span>.getClassLoader()</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(classLoader.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟tk.mybatis相关创建过程</span></span><br><span class="line">        MapperFactoryBean mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean(clazz)</span><br><span class="line">        mapperFactoryBean.setSqlSessionFactory(sqlSessionFactory)</span><br><span class="line">        mapperFactoryBean.setMapperHelper(mapperHelper)</span><br><span class="line">        mapperFactoryBean.afterPropertiesSet()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperFactoryBean.getObject()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="H2内存数据库"><a href="#H2内存数据库" class="headerlink" title="H2内存数据库"></a>H2内存数据库</h4><p>​    在美团的这篇博客中，推荐使用<code>H2</code>数据库进行数据的隔离，在对<code>H2</code>进行一些了解后发现<code>H2</code>对<code>mysql</code>的一些语句并不支持，比如建表时的索引之类，所以需要修改原本的建表脚本，在进行一些字段迭代时，可能会比较繁琐。</p><p>通过直接使用<code>java.sql.Connection</code>对象来创建数据库连接，并执行建表语句。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AUTO_SERVER=TRUE 默认情况下只能单个连接，这个配置用来开启多个连接</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:h2:~/test;MODE=MySQL;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;AUTO_SERVER=TRUE</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><p>执行处理代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> executeSql(String sqlPath) &#123;</span><br><span class="line">    <span class="comment">// 执行sql文件</span></span><br><span class="line">    File sqlFile = <span class="keyword">new</span> File(sqlPath)</span><br><span class="line">    <span class="keyword">if</span>(!sqlFile.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;sql文件不存在&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Statement statement = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        statement = CONNECTION.createStatement();</span><br><span class="line">        <span class="keyword">boolean</span> success = statement.execute(sqlFile.text)</span><br><span class="line">        <span class="comment">// 这里有点不解，无论是脚本执行成功还是执行失败，这里好像返回的都是false</span></span><br><span class="line">        <span class="comment">// 目前不影响使用，没有进行深究</span></span><br><span class="line">        success ? println(<span class="string">&quot;执行sql文件成功&quot;</span>) : println(<span class="string">&quot;执行sql文件失败&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DbUnit的使用"><a href="#DbUnit的使用" class="headerlink" title="DbUnit的使用"></a>DbUnit的使用</h4><p>​    根据美团的这篇博客中，使用<code>DbUnit</code>来进行数据层数据的访问控制，也就是在初始化某个单元测试接口时进行的一些准备数据脚本的执行，</p><h5 id="基于xml脚本文件"><a href="#基于xml脚本文件" class="headerlink" title="基于xml脚本文件"></a>基于xml脚本文件</h5><p>​    在经过测试发现，<code>DbUnit</code>是通过<code>xml</code>文件来编写插入数据的脚本，这就导致写<code>xml</code>插入数据脚本文件也会花费一些工作量。以下为一个示例，假设要为某个接口准备几十条数据，估计准备数据的过程要疯，后期可以看看<code>DbUnit</code>有没有接口可以通过<code>SQL</code>转换为这个<code>xml</code>文件，或者自己实现一个接口，将<code>SQL</code>转换为<code>xml</code>文件来减少工作流。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataset</span>&gt;</span></span><br><span class="line">    &lt;gpfa_process_business</span><br><span class="line">            id=&quot;10007&quot;</span><br><span class="line">            test_id=&quot;1&quot;</span><br><span class="line">            name=&quot;2&quot;</span><br><span class="line">            value = &quot;1&quot;</span><br><span class="line">            mark = &quot;测试&quot;</span><br><span class="line">            create_time = &quot;2018-01-01&quot;</span><br><span class="line">            /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="基于csv脚本文件"><a href="#基于csv脚本文件" class="headerlink" title="基于csv脚本文件"></a>基于csv脚本文件</h5><p>​    <code>DbUnit</code>还支持通过<code>.csv</code>文件进行数据准备，但是比较繁琐的是它好像不能执行具体的文件，需要执行一个目录，并且目录下需要创建一个<code>table-ordering.txt</code>文件，内容为此目录下要执行的<code>csv</code>文件名称，同时<code>csv</code>文件的名称需与表名保持一致。</p><h4 id="自定义查询SQL语句"><a href="#自定义查询SQL语句" class="headerlink" title="自定义查询SQL语句"></a>自定义查询SQL语句</h4><p>​    对于在<code>xxxMapper.xml</code>文件中的查询语句，目前不知道因为什么原因，字段值无法赋值到实体上，需要通过<code>as</code>关键字将下划线字段别名为驼峰形式才可在实体中获取到，这个问题无疑是致命的，导致基本上所有的<code>mapper.xml</code>文件都无法进行单元测试。</p><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spock实践（一）&quot;&gt;&lt;a href=&quot;#Spock实践（一）&quot; class=&quot;headerlink&quot; title=&quot;Spock实践（一）&quot;&gt;&lt;/a&gt;Spock实践（一）&lt;/h1&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在&lt;code&gt;Spring&lt;/code&gt;体系中，常用的单元测试框架就是基于&lt;code&gt;PowerMock&lt;/code&gt;或者&lt;code&gt;MockTo&lt;/code&gt;等，由于这些框架依赖&lt;code&gt;Spring&lt;/code&gt;容器，所以在编写过程需要频繁的启动&lt;code&gt;Spring&lt;/code&gt;容器进行单元测试的测试，导致过程比较繁琐。</summary>
    
    
    
    <category term="Spock" scheme="http://xiaocainiaoya.github.io/categories/Spock/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引优化</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</id>
    <published>2022-07-29T14:13:58.000Z</published>
    <updated>2022-10-17T09:11:42.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql索引优化"><a href="#mysql索引优化" class="headerlink" title="mysql索引优化"></a>mysql索引优化</h1><p>​    描述使用<code>explain</code>命令中的每列所代表的含义，以及出现某些慢查询时的一些优化。</p><span id="more"></span><p>通过<code>explain</code>命令可以知道<code>MySQL</code>是怎么执行语句，包括有关如何连接表以及连接表的顺序、扫描的行数、是否使用索引、排序使用的是内存排序还是磁盘排序等等。所以一般的语句优化手段都是通过<code>explain</code>来查询语句的处理过程，修改全表扫描的语句，优化查询效率。</p><p><img src="https://s2.loli.net/2022/10/17/mPcMZU9QsSJ5z7K.png" alt="简单expain示例.png"></p><p><b>上图是一个最简单的<code>explain select * from xxx</code>的执行结果，以下依次解释每一项的含义</b></p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>假设执行语句为<code>explain select * from words where id in (select id from words where word like &#39;aa%&#39;)</code><br>输出结果为:<br><img src="https://s2.loli.net/2022/10/17/5LAeJ2RofKDiMVS.png" alt="expain查询id示例.png"></p><p>这里的<code>id</code>值有两个1和2，实际上对于这条查询语句来说，是先执行了括号内的查询，在将括号内的结果赋予外层查询语句进行第二次查询，所以在<code>expian</code>结果有两条记录，id值越高越先执行，id值相同时从上往下执行。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>表示查询的类型：</p><ol><li><code>SIMPLE</code>: 简单语句，比如<code>select * from xxx </code>。</li><li><code>SUBQUERY</code>: 子查询</li><li><code>PRIMARY</code>: 主查询，最外层查询，表示最后一个到它</li><li><code>DERIVED</code>: 衍生表，查询语句中会生成新的表，比如<code>select * from words as t1, (select false) as t2</code></li><li><code>UNION</code>: 连接表</li><li><code>UNION RESULT</code>: 连接结果，一般与<code>UNION</code>配套出现</li></ol><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示某一个子查询使用到的表是什么，一般的查询语句直接就是某一个表，但是一些特殊处理，比如<code>select * from words as t1, (select false) as t2</code>这里的<code>table</code>就是空，因为它是临时生成的不是数据库中存在的表结构，再或者是使用<code>union</code>联合的时候，<code>select_type=UNION RESULT</code>的子查询是将两个查询结果联合，所以会标识是那两个id值所对应的查询进行联合<code>&lt;union id1, id2&gt;</code></p><p><img src="https://s2.loli.net/2022/10/17/7yjJrwtMZKVvqGh.png" alt="explain衍生表示例.png"></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type表示连接类型，查看索引执行情况的一个重要指标。以下性能从好到坏依次：<br><code>system  &gt; const &gt; eq_ref &gt; ref  &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p><ol><li><code>system</code>：这种类型要求数据库表中只有一条数据，是const类型的一个特例，一般情况下是不会出现的。</li><li><code>const</code>：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，速度非常快。</li><li><code>eq_ref</code>：常用于主键或唯一索引扫描，一般指使用主键的关联查询</li><li><code>ref</code>：常用于非主键和唯一索引扫描。</li><li><code>ref_or_null</code>：这种连接类型类似于ref，区别在于MySQL会额外搜索包含NULL值的行</li><li><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</li><li><code>unique_subquery</code>：类似于eq_ref，条件用了in子查询</li><li><code>index_subquery</code>：区别于unique_subquery，用于非唯一索引，可以返回重复值。</li><li><code>range</code>：常用于范围查询，比如：between … and 或 In 等操作，如果是这个类型需要注意，可能会因为数据量的原因导致索引失效</li><li><code>index</code>：全索引扫描</li><li><code>ALL</code>：全表扫描</li></ol><h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p><code>possible_key</code>这个一般来说用不上，意思就是理论上可能会使用到的索引，但是实际执行时可能会用不上，说了等于没说。<br><code>key</code>表示使用到的索引。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>使用的到的索引长度，<code>key_len</code>可以衡量索引的好坏，<code>key_len</code>越小，索引的效果越好，但是要注意如果索引是建立在一个字符串字段上，且字符串字段长度比较长，进行索引时可能会将字符串截断，也就是这一列的前n个字符参与索引。<br><code>MySQL innodb</code>引擎对于索引的长度是有限制的，最大为767字节，不同字符编码方式对应的字节数不一样，比如最常用的<code>utf8mb4</code>字符集是4字节字符集，767/4=191，所以在字符串上创建索引的前191字符才会参与索引。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列被使用了，如果是<code>where word = &#39;name&#39;</code>，那么显示的就是<code>const</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于<code>InnoDB</code>表，此数字是估计值，并非一定是个准确值，<code>InnoDB</code>的优化器也会通过需要扫描的行数来判断选择哪个索引。可以通过<code>analyze table t</code>命令，来重新统计索引信息。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>Using filesort</code>：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现。一般见于order by语句<br><code>Using index</code> ：表示是否用了覆盖索引。<br><code>Using temporary</code>： 表示是否使用了临时表,性能特别差，需要重点优化。一般多见于group by语句，或者union语句。<br><code>Using where</code> ： 表示使用了where条件过滤.<br><code>Using index condition</code>：MySQL5.6之后新增的索引下推。在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</p><h1 id="常用优化手段"><a href="#常用优化手段" class="headerlink" title="常用优化手段"></a>常用优化手段</h1><h3 id="1-in内容过多"><a href="#1-in内容过多" class="headerlink" title="1. in内容过多"></a>1. in内容过多</h3><p>使用<code>in</code>查询最好内容不要超过200个，因为<code>in</code>查询底层是通过<code>n*m</code>的方式去搜索，也就是每一个条件逐条遍历，默认临界值<code>eq_range_index_dive_limit=200</code>，如果超过这个值，可能会导致代价计算存在问题，从而导致<code>mySQL</code>选择的索引不准确。</p><h3 id="2-磁盘排序"><a href="#2-磁盘排序" class="headerlink" title="2. 磁盘排序"></a>2. 磁盘排序</h3><p>如果查询语句中存在<code>order by</code>但是<code>Extra</code>中没有<code>Using filesort</code>那么恭喜你，你的排序命中了索引，沿用了索引已然有序的特性直接查询出数据。但是实际情况并不是这么刚好，不命中索引的情况下，排序下的<code>Extra</code>的结果为<code>Using filesort</code>。排序分为全字段排序和<code>rowid</code>排序。至于是使用全字段排序和<code>rowid</code>排序主要影响因素是<code>max_length_for_sort_data</code>参数，当单行长度超过这个参数值时使用的就是<code>rowid</code>排序。<code>rowid</code>需要回表，查询性能比全字段查询差。</p><h3 id="3-不等号"><a href="#3-不等号" class="headerlink" title="3.不等号"></a>3.不等号</h3><p>查询使用不等号或者是<code>not in</code>这些时，索引形同虚设，这其实是被优化器处理了，因为优化器认为即便是走索引，还是需要扫描很多行，所以它觉得不划算，所以直接不走索引。还有<code>NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE</code>都会导致索引失效。</p><h3 id="4-group-by"><a href="#4-group-by" class="headerlink" title="4.group by"></a>4.group by</h3><blockquote><p>explain select wrod, num from words group by word</p></blockquote><p><img src="https://s2.loli.net/2022/10/17/2aLHIpAiF6oYWuN.png" alt="排序explain.png"><br>可以看到在<code>Extra</code>中有<code>Using filesort</code>和<code>Using temporary</code>，表示使用到了排序和临时表。<br><code>group by</code>的执行流程：</p><ol><li>创建内存临时表，表里设置字段<code>(word, num)</code></li><li>全表扫描<code>words</code>，依次取出<code>word</code>的值，判断临时表中是否有这个值，如果没有就插入<code>（word, 1）</code>，如果有就对这一行的<code>num</code>加一。</li><li>遍历完成后，再对<code>word</code>排序后返回结果。</li></ol><p><b>优化方式：</b>可以对<code>group by</code>后面的字段添加索引，提高步骤1的执行效率；使用<code>order by null</code>，既然默认是要排序，那么手动设置为不要排序，提高步骤3的执行效率。</p><h3 id="5-delete-in"><a href="#5-delete-in" class="headerlink" title="5. delete + in"></a>5. delete + in</h3><p><code>delete form xx where xx in (xx)</code>这个删除语句不会命中索引，但是<code>select * form xx where xx in (xx) </code>这个是会命中索引的，原因是对于这个查询语句实际上将<code>SQL</code>优化为可以命中索引的方式。</p><h3 id="6-asc和desc"><a href="#6-asc和desc" class="headerlink" title="6. asc和desc"></a>6. asc和desc</h3><p>如果出现<code>asc</code>和<code>desc</code>混用，也会导致索引失效。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql索引优化&quot;&gt;&lt;a href=&quot;#mysql索引优化&quot; class=&quot;headerlink&quot; title=&quot;mysql索引优化&quot;&gt;&lt;/a&gt;mysql索引优化&lt;/h1&gt;&lt;p&gt;​    描述使用&lt;code&gt;explain&lt;/code&gt;命令中的每列所代表的含义，以及出现某些慢查询时的一些优化。&lt;/p&gt;</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>tk.mybaits动态表名</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/</id>
    <published>2022-07-27T14:13:58.000Z</published>
    <updated>2022-07-27T13:49:50.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits动态表名"><a href="#tk-mybaits动态表名" class="headerlink" title="tk.mybaits动态表名"></a>tk.mybaits动态表名</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以<code>ORDER_</code>开头。且一些二次开发的组件中也有使用<code>mysql</code>进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。 <span id="more"></span>    </p><h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>​    <code>tk.mybatis</code>的大致处理逻辑：</p><p><img src="https://s2.loli.net/2022/07/27/XcaJ5jdZ2omVnP1.png" alt="tk相关处理过程.png"></p><ol><li>扫描器会将所有被<code>@Mapper</code>标记的类通过<code>SpringBean</code>的创建对象流程中，然后创建相应的对象后，添加到<code>SpringBean</code>容器中。</li><li>将这个标记的类对象包装为<code>MapperFactoryBean</code>对象</li><li>待到创建<code>bean</code>流程的最后，也就是经过了初始化、后置处理器列表等扩展点的相关处理之后，通过包装对象<code>MapperFactoryBean#afterPropertiesSet()</code>进行<code>tk.mybatis</code>对象的二次处理。</li><li>通过这个后置方法，解析出这个<code>@Mapper</code>对象所对应的表实体的表名和其他一些在创建<code>SQL</code>所需要的配置信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在这个map中 实体类 =&gt; 表对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, EntityTable&gt; entityTableMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EntityTable&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>根据这个标记对象所继承的上层接口，逐个解析出对应的<code>SQL</code>语句。以下方代码为例，这里的上层接口<code>CommonMapper</code>继承于<code>Mapper</code>，而<code>Mapper</code>又继承于很多的上层接口，其中就有<code>selectOne</code>接口，那么在这一步就会根据第四步骤中解析出来的表信息和字段信息等，构建一个基于变量的<code>SQL</code>语句，如果业务层调用该方法时，仅将相关参数填充后就形成一条完整的<code>SQL</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxxMapper</span> <span class="keyword">extends</span> <span class="title">CommonMapper</span>&lt;<span class="title">XxxAttachment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">ExampleMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">RowBoundsMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">Marker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectOneMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = &quot;dynamicSQL&quot;)</span></span><br><span class="line">    <span class="function">T <span class="title">selectOne</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>​    根据以上的步骤，可以得出一个结论，如果想要动态（这个动态是指创建时动态，并不是指运行时动态）的修改表名，那么需要在第四步之后，第五步之前将<code>entityTableMap</code>中对应的表名修改为想要的表名。</p><p>​    根据<code>Springbean</code>创建对象的逻辑，在初始化后置方法之前，会经过后置处理器列表，所以可以通过模拟一个后置处理器列表，提前对<code>entityTableMap</code>相关信息进行解析并缓存。</p><p><code>MapperFactoryBean</code> 进行处理的主要逻辑：</p><ol><li><p>根据<code>XxxMapper</code>类获取到对应的表实体</p></li><li><p>通过<code>EntityHelper.initEntityNameMap()</code>方法解析出这个表实体的相关信息，并缓存。</p></li><li><p>将<code>XxxMapper.selectExample() </code>等等内置的通用接口解析为动态SQL语句，缓存在某个地方(这个我没有去找在哪里)</p></li></ol><p>综上：只要能在 第3步之前将<code>EntityHelper</code>中的这个缓存中的<code>EntityTable</code>的表名称修改为相应的值，就能实现将表名动态化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TablePrefixBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * tk.mybatis 在 MapperFactoryBean 进行相关的逻辑处理，所以通过BeanPostProcessor，在执行MapperFactoryBean.afterPropertiesSet()方法之前，</span></span><br><span class="line"><span class="comment">    * 进行一次预处理，将表相关信息通过EntityHelper.initEntityNameMap()方法提前添加到对应的entityTableMap&lt;Class, EntityTable&gt;缓存之后，</span></span><br><span class="line"><span class="comment">    * 然后马上将这个实体所对应的EntityTable的表名进行需要的业务处理。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/7/27 16:04:01</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.lang.Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean.getClass() != <span class="keyword">null</span> &amp;&amp; bean.getClass().toString().contains(<span class="string">&quot;tk.mybatis.spring.mapper.MapperFactoryBean&quot;</span>))&#123;</span><br><span class="line">            Class&lt;?&gt; mapperClass = ((MapperFactoryBean)bean).getMapperInterface();</span><br><span class="line">            Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) types[<span class="number">0</span>];</span><br><span class="line">            Class&lt;?&gt; returnType = (Class&lt;?&gt;)  parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取mapperHelper</span></span><br><span class="line">            MapperHelper mapperHelper = (MapperHelper) ReflectUtil.getFieldValue(bean, <span class="string">&quot;mapperHelper&quot;</span>);</span><br><span class="line">            <span class="comment">// 提前解析这个bean所对应的表实体的相关信息</span></span><br><span class="line">            EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否需要修改表名</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                EntityTable entityTable = EntityHelper.getEntityTable(returnType);</span><br><span class="line">                entityTable.setName(<span class="string">&quot;prefix&quot;</span> + entityTable.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码中的最后的判断语句可以根据相应的规则，比如说自定义一个注解，并且在注解中指定一个前缀的参数，标记在实体上，这里可以通过获取这个注解进行是否需要添加前缀的逻辑处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    实际上以上这种场景应该在真是情况中少之又少，一般情况下并不会说想要统一某个服务中的所有表名前缀，但是在解决的问题的过程中，其实对<code>springBean</code>创建实体的流程，以及<code>tk.mybatis</code>对实体解析的相关逻辑都大致的过了一遍，加强了框架中一些细节处理的印象，对于后续如果出现一些<code>bug</code>可以尽快的定位到问题。</p><p>​    实际上我并不是一下子就想到这么做，在想到这么做之前，我也经过了其他的尝试，比方说我最先想到的是通过写<code>mybatis</code>插件的方式，拦截出<code>BoundSql</code>具体的<code>SQL</code>语句，通过修改这个<code>SQL</code>语句达到目的，但是发现不同类型的<code>SQL</code>判断方式略有不同，操作难度大，所以一直往上层追溯，发现<code>BoundSql</code>中的语句是在<code>Bean</code>初始化过程就已经生成，后面才一点一点整理出上述步骤流程，从而找到下手的地方。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits动态表名&quot;&gt;&lt;a href=&quot;#tk-mybaits动态表名&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits动态表名&quot;&gt;&lt;/a&gt;tk.mybaits动态表名&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以&lt;code&gt;ORDER_&lt;/code&gt;开头。且一些二次开发的组件中也有使用&lt;code&gt;mysql&lt;/code&gt;进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>tk.mybaits和mybatisPlus兼容性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/</id>
    <published>2022-07-21T14:13:58.000Z</published>
    <updated>2022-07-22T03:29:40.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tk-mybaits和mybatisPlus兼容性"><a href="#tk-mybaits和mybatisPlus兼容性" class="headerlink" title="tk.mybaits和mybatisPlus兼容性"></a>tk.mybaits和mybatisPlus兼容性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    项目早期建设时底层采用了<code>tk.mybatis</code>方式来对数据访问层进行数据处理，而后再更新<code>Springboot</code>的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实<code>tk.mybatis</code>官网已经没有维护了）又在底层引入了<code>mybatisPlus</code>，所以新代码采用<code>mybatisPlus</code>编写，旧模块任然使用<code>tk.mybatis</code>编写。<span id="more"></span>    </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    今天同事在移植项目中的一个功能模块时，报了一个错<code>No qualifying bean of type &#39;com.xxxx&#39;..</code>。乍一看猜测大概是因为对应的<code>xxxMapper</code>接口文件没有被扫描到<code>Spring</code>容器中，导致<code>tk.mybatis</code>的表集合中没有该实体。排查发现，启动类中并没有显示使用<code>@MapperScan</code>指定扫描路径，果然，使用的是启动类及以下的包结构，由于是搬迁的功能模块，不想调整原来包结构，故使用<code>@MapperScan</code>来指定扫描路径。</p><p>​    在启动类上通过<code>@MapperScan</code>指定了扫描路径之后可以正常启动，但是在调用接口发现又报错了<strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>，如果对<code>tk.mybatis</code>比较熟悉就知道，这里是因为<code>tk.mybatis</code>会将所有的表信息都缓存到一个集合中，仔细检查了指定的路径，也没有发现问题。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    经过一段时间的排查，终于找到了原因，在这里记录下，避免以后又遇到同样的问题，以下仅为个人观点，可能存在理解错误，请带着批判的视角阅读。</p><p>​    原来是在<code>tk.mybatis</code>中也有一个同名的<code>tk.mybatis.spring.annotation.MapperScan</code>，若使用<code>org.mybatis.spring.annotation.MapperScan</code>是不会对扫描到的对象进行一些<code>tk.mybatis</code>相关的处理，所以直接将注解更换为前者，再次启动，又报出了新的错误：</p><p>定位进去发现就是<code>tk.mybatis</code>处理对应接口缓存的时候报了类型转换异常：</p><blockquote><p>Caused by: java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getEntityClass(MappedStatement ms) &#123;</span><br><span class="line">    String msId = ms.getId();</span><br><span class="line">    <span class="keyword">if</span> (entityClassMap.containsKey(msId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> entityClassMap.get(msId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; mapperClass = getMapperClass(msId);</span><br><span class="line">        Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType t = (ParameterizedType) type;</span><br><span class="line">                <span class="keyword">if</span> (t.getRawType() == <span class="keyword">this</span>.mapperClass || <span class="keyword">this</span>.mapperClass.isAssignableFrom((Class&lt;?&gt;) t.getRawType())) &#123;</span><br><span class="line">                    <span class="comment">// 报错报在这里</span></span><br><span class="line">                    Class&lt;?&gt; returnType = (Class&lt;?&gt;) t.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取该类型后，第一次对该类型进行初始化</span></span><br><span class="line">                    EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line">                    entityClassMap.put(msId, returnType);</span><br><span class="line">                    <span class="keyword">return</span> returnType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MapperException(<span class="string">&quot;无法获取 &quot;</span> + msId + <span class="string">&quot; 方法的泛型信息!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里直接下结论：</strong>报这个错的原因是因为指定扫描的路径范围太大了，导致扫描到了底层中的二次封装类<code>public interface CommonMapper&lt;T&gt; extends Mapper&lt;T&gt;</code>，结合以上代码不难发现，是取出了<code>T</code>泛型进行强转之后报错，所以只需要将扫描路径的范围缩小即可。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在最后发现问题之后，解决起来就很轻松了，但是在排查的过程中，就非常的痛苦。因为报错的这个地方并没有显式的指明是某个类强转失败，而项目中又存在<code>mybatisPlus</code>和<code>tk.mybatis</code>共存的情况，乍一看代码以为是兼容性的问题，因为对于这两种方式来说，数据访问层接口采用的是不同的继承接口。</p><p>一个是<code>tk.mybatis.mapper.common.Mapper</code><T>，一个是<code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code>，所以一看到这个类型转换异常，就误以为是因为需要通过<code>tk.mybatis</code>来解析的<code>xxxMapper</code>被<code>mybatisPlus</code>接管导致。</p><p>​    在排查跟踪源码的过程中，对<code>tk.mybatis</code>和<code>mybatisPlus</code>相关的一些处理有了进一步的了解，在此做了记录。</p><p><code>tk.mybatis</code>通过<code>tk.mybatis.spring.mapper.ClassPathMapperScanner</code>扫描器将对应的表实体收集到一个集合中，注意<code>mybatis</code>也有自己的扫描器<code>org.mybatis.spring.mapper.ClassPathMapperScanner</code>，也就是说在项目启动过程中，实际上是经过了两次的扫描，并且<code>tk.mybatis</code>的扫描器在<code>mybatis</code>的扫描器之前，至于是怎么插到<code>mybatis</code>之前的，猜测是通过<code>spring</code>的某个后置接口，这个与本篇主题无关，不进一步详解。</p><p>​    其实<code>tk.mybatis</code>的扫描器主要是将指定路径(默认是启动类所在包及子包)中被<code>@Mapper</code>标记的类，解析成<code>BeanDefinition</code>，添加到<code>Spring</code>对应集合中，用于后续将其实例化为具体的<code>bean</code>对象到容器中。这些的主要逻辑在这两个扫描器的父类<code>ClassPathBeanDefinitionScanner#doScan</code>。经过<code>tk.mybatis</code>扫描器处理后的表实体，同样也会在<code>mybatis</code>扫描器被作为候选对象<code>candidate</code>被扫描到。但它会从<code>Spring</code>中查询一次，查看是否存在该<code>BeanDefinition</code>，若存在则打印<code>Skipping MapperFactoryBean with name &#39;xxxMapper&#39; and &#39;com.xx.xxx....mapper.XxxMapper&#39; mapperInterface. Bean already defined with the same name!</code>，大概意思就是这个类已经存在<code>BeanDefinition</code>，当前处理跳过该类的处理，也就是说在指定路径下的实体表只会被这两个扫描器中的其中一个扫描并进行相关处理。</p><p>​    <code>tk.mybatis</code>扫描器中在创建<code>BeanDefinition</code>时，将它的<code>resolvedTargetType</code>和<code>beanClass</code>字段都标记为了<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>，而<code>mybatis</code>扫描器扫描器中这两个字段标记的是<code>org.mybatis.spring.mapper.MapperFactoryBean</code>，这就导致在真正实例化<code>Spring bean</code>对象时调用了不同的后置接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#invokeInitMethods</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最后会调用初始化的后置接口</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着跟踪下进入到不同的后置接口的调用方式，继承关系如下代码所示，从上面的代码中的最后调用<code>bean</code>对象的<code>afterPropertiesSet</code>方法，到下面代码中是由于二者的上层接口中<code>DaoSupport</code>实现了<code>InitializingBean</code>方法。且这个后置初始化方法中仅调用了<code>checkDaoConfig</code>和<code>initDao</code>方法，均由具体的子类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tk.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoSupport</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, BeanInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">// Let abstract subclasses check their configuration.</span></span><br><span class="line">        checkDaoConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let concrete implementations initialize themselves.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initDao();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Initialization of DAO failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tk.mybatis.spring.mapper.MapperFactoryBean</code>具体的实现：核心的处理在这里，刚刚上文说到，<code>tk.mybatis</code>会将指定路径下的所有<code>@Mapper</code>类的<code>BeanDefinition</code>中的<code>resolvedTargetType</code>和<code>beanClass</code>都标记为<code>tk.MapperFactoryBean</code>，那么也就是说指定路径下的所有<code>@Mapper</code>都会被识别为是<code>tk.mybatis</code>的<code>mapper</code>？其实不是，这里有一个判断<code>mapperHelper.isExtendCommonMapper()</code>，这个判断的主要逻辑是获取这个<code>XxxMapper</code>接口及所有上层父类接口是否有<code>tk.mybatis.mapper.annotation.RegisterMapper</code>注解，如果没有，则不采用<code>tk.mybatis</code>的方式进行解析。到这，应该就可以解答前面提出的问题，所以如果需要用<code>mybatisPlus</code>，那么它的<code>XxxMapper</code>接口的所有上传父类接口必然不会存在<code>tk.RegisterMapper</code>注解，也就不会进行<code>tk.mybatis</code>相关的处理(<code>tk.mybatis</code>这里的处理是将表实体和<code>xxxMapper</code>接口的一些方法等信息缓存起来)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasMapper(<span class="keyword">this</span>.mapperInterface) &amp;&amp; mapperHelper != <span class="keyword">null</span> &amp;&amp; mapperHelper.isExtendCommonMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">        mapperHelper.processConfiguration(getSqlSession().getConfiguration(), <span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>No qualifying bean of type &#39;com.xxxx&#39;..</code>的实际原因是移植的功能模块类路径不落在默认扫描路径范围内（启动类所在的包及子包）</li><li><strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>是因为通过<code>org.mybatis.spring.annotation.MapperScan</code>指定了<code>mybatis</code>的扫描路径，但没有指定<code>tk.MapperScan</code>，导致<code>tk</code>的扫描器使用默认值(默认值为启动类所在的包及子包)，恰好移植的功能模块不属于启动类的包及子包中，所以移植功能中的所有<code>xxxMapper</code>都被解析为了<code>mybatis</code>类型(也就是前面说的<code>beanDefinition</code>中的那两个属性被赋值为了<code>mybatis</code>对应的类)，最后导致在初始化<code>bean</code>对象时，没有进入到<code>tk.mybaits</code>对应类的后置处理器，也就没有将这些表实体相关信息缓存，从而导致以上报错。</li><li>类型转换异常的报错，是因为指定<code>tk.MapperScan</code>设置扫描范围太大，导致扫描到了底层二次封装的抽象父类，导致在获取接口层参数获取到了泛型参数<code>T</code>，泛型参数以<code>T</code>进行类型转换为<code>Class</code>从而导致了报错。</li><li>在都不指定<code>@MapperScan</code>的情况下，二者扫描器的默认扫描路径都是启动类所在的包以及子包，当指定了<code>tk.@MapperScan</code>之后那么<code>tk.mybatis</code>的扫描路径变成了这个具体的指定路径，<code>mybatis</code>的扫描路径还是默认的启动类所在的包极其子包，也就是说两个扫描器的扫描路径是互不影响的、各自维护，这个很重要，如果不明白这个，在排查的过程中，会影响对问题的判断。</li><li>引入<code>tk.mybatis</code>一定会经过两次扫描器，一次是<code>tk.mybatis</code>的扫描器，一次是<code>mybatis</code>原生的扫描器，如果某个<code>mapper</code>对象被<code>tk.mybatis</code>扫描生成了<code>BeanDefinition</code>，<code>mybatis</code>的扫描器会跳过该类，同样的，某个<code>xxxMapper</code>若想使用<code>mybatisPlus</code>的方式进行数据访问层的处理，虽然它在扫描阶段被认为是以<code>tk.mybatis</code>的方式解析，但是在具体创建<code>spring bean</code>对象的时候，<code>kt.mybatis</code>的后置接口中有相应的逻辑判断(所有上层接口是否有标记<code>RegisterMapper</code>)，来控制是否进行相应处理。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tk-mybaits和mybatisPlus兼容性&quot;&gt;&lt;a href=&quot;#tk-mybaits和mybatisPlus兼容性&quot; class=&quot;headerlink&quot; title=&quot;tk.mybaits和mybatisPlus兼容性&quot;&gt;&lt;/a&gt;tk.mybaits和mybatisPlus兼容性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    项目早期建设时底层采用了&lt;code&gt;tk.mybatis&lt;/code&gt;方式来对数据访问层进行数据处理，而后再更新&lt;code&gt;Springboot&lt;/code&gt;的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实&lt;code&gt;tk.mybatis&lt;/code&gt;官网已经没有维护了）又在底层引入了&lt;code&gt;mybatisPlus&lt;/code&gt;，所以新代码采用&lt;code&gt;mybatisPlus&lt;/code&gt;编写，旧模块任然使用&lt;code&gt;tk.mybatis&lt;/code&gt;编写。</summary>
    
    
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/categories/mybatis/"/>
    
    
    <category term="问题和方案" scheme="http://xiaocainiaoya.github.io/tags/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="坑" scheme="http://xiaocainiaoya.github.io/tags/%E5%9D%91/"/>
    
    <category term="mybatis" scheme="http://xiaocainiaoya.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>数据库和缓存双写一致性</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-07-20T12:50:58.000Z</published>
    <updated>2022-07-20T08:42:46.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库和缓存双写一致性"><a href="#数据库和缓存双写一致性" class="headerlink" title="数据库和缓存双写一致性"></a>数据库和缓存双写一致性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。<span id="more"></span></p><p><img src="https://s2.loli.net/2022/07/20/m6zT1AH2oZvSwa8.png" alt="双写一致性.png"></p><p>通常来说，常见的应用场景为：</p><ol><li>用户请求查询某些数据，先进入缓存查看是否存在</li><li>存在则直接返回数据</li><li>不存在则查数据库，查到则将数据添加一份到缓存中，再返回，使得下次查询可以直接从缓存中获取，从而提高系统的响应速度。</li></ol><h2 id="双写的四种场景"><a href="#双写的四种场景" class="headerlink" title="双写的四种场景"></a>双写的四种场景</h2><ol><li>先更新缓存，再更新数据库</li></ol><p>​    如果采用这种方式，极易产生数据不一致的情况。因为先更新缓存，如果因为某些原因出现数据写入失败，比如主键冲突、非空字段未填值、数据库宕机等等情况导致数据库写入失败，这时就出现了缓存中是新值，数据库中是旧值，造成了数据库和缓存数据不一致。</p><ol start="2"><li>先更新数据库，再更新缓存</li></ol><p>​    假设更新数据库的操作和更新缓存的操作在同一个事务中，那么更新数据库之后，再更新缓存，如果出现缓存更新失败，那么事务回滚，保证了数据的一致性。但由于数据库和缓存实际上都是采用远程链接的方式读写数据，所以一般来说只有在低并发的场景下，才会将二者放在同一个事务中，否则若写缓存过慢，直接导致数据库事务时间被拉长，而形成长事务。如果二者不在同一个事务中，若数据库更新数据成功，缓存中更新数据失败，就会导致数据的不一致。</p><p>​    假设在高并发场景下，且更新缓存和更新数据库不在同一个事务中执行。假设有两个写操作，当写操作A更新数据库之后，在将数据写入缓存的过程中出现网络拥堵等情况，这时写操作B，也更新了数据库，拿着更新之后的值，写入到缓存中，同时写操作A的网络不拥堵了，写操作A又更新了缓存，这时数据库中是写操作B的值，缓存中是写操作A的值，从而造成了数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/rq9LGBjQ4EfCvRh.png" alt="先更新数据库再更新缓存.png"></p><ol start="3"><li>先删除缓存，再更新数据库</li></ol><p>​    同样在高并发下，如果请求A在删除缓存之后，写入数据库之前的这段时间内，如果有请求B进行获取数据，这是它从缓存中获取不到，则从数据库中获取，由于这时A还未将数据写入到数据库中，请求B读到的是旧值，而请求B又将读到的旧值写入到缓存中，之后请求A又将新值写入到数据库中，造成了数据库和缓存数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/lZQImSBoycYAO5b.png" alt="先删缓存再写库.png"></p><p>可以通过<strong>缓存双删</strong>的方式解决这个问题，写操作A在写入数据库之后，再删除一次缓存，这时又有一个新的问题，如果写操作A在一更新数据库之后，就去删缓存，可能存在某些线程中已经获取了旧值，只不过还没写入到缓存中，也就是上图的步骤7和步骤8。所以一般是在更新数据库之后一段时间之后进行缓存删除，比如500ms。</p><ol start="4"><li>先更新数据库，再删除缓存</li></ol><p>​    同样假设有两个请求，一个读请求A，一个写请求B。</p><ul><li>当写请求B先到，在更新数据库的过程中或者更新数据库后还未删除缓存时，读请求到达，读取了缓存中的数据，然后写请求B再删除缓存，对于这种场景仅读请求A读取了一次旧值。</li><li>当读请求A先到，读取到了缓存中的数据，直接返回了，这时写请求B在更新数据库，再删除缓存，同样对于这种场景，仅读请求A读取了一次旧值。</li></ul><p>但是还是有一种场景下，会导致数据不一致，也就是缓存过期了。</p><p>也就是当写操作A到达，在更新数据时出现拥堵，这时读操作B来读取缓存，刚好缓存过期，则从数据库中获取到了旧值，同时写操作A更新了数据库，且删除了缓存，然后读操作B再将旧值写入到缓存中，造成数据不一致。</p><p><img src="https://s2.loli.net/2022/07/20/jD6v2BzV7gylqRE.png" alt="写库再删缓存.png"></p><p>但是一般来说认为要造成上述场景需要满足两个条件：</p><ol><li>缓存刚好过期了</li><li>读操作B从数据库读到数据之后，更新缓存的耗时比写操作A更新数据库+删除缓存的耗时长。(一般来说对缓存的操作耗时要远小于对数据的操作耗时)</li></ol><p><strong>综上，一般来说还是需要采用先更新数据库再删除缓存的策略。</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实际上不论是方案3中的缓存双删还是方案4都存在一个问题，在二者操作不在同一个事务的前提下，如果删除缓存操作失败了，那么就会导致缓存和数据库数据不一致。</p><p>​    这时就需要引入重试机制，缓存删除失败之后进行重试。关于重试就可简单可复杂了，简单就是直接捕获异常进行重试操作，但这可能影响接口时效，也可以将设置专门线程池，将重试操作推给线程池，又或者引入一些任务调度或者是<code>MQ</code>的中间件来处理。在查资料的过程中，有看到有人说也可以通过订阅<code>mysql</code>的<code>binlog</code>，如果发现了更新数据请求，则删除对应的缓存，但是据我所知很多项目在生产环境甚至连<code>binlog</code>功能都没有开启[旺柴]。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库和缓存双写一致性&quot;&gt;&lt;a href=&quot;#数据库和缓存双写一致性&quot; class=&quot;headerlink&quot; title=&quot;数据库和缓存双写一致性&quot;&gt;&lt;/a&gt;数据库和缓存双写一致性&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志文件</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</id>
    <published>2022-07-14T14:13:58.000Z</published>
    <updated>2022-07-29T08:02:24.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql日志文件"><a href="#mysql日志文件" class="headerlink" title="mysql日志文件"></a>mysql日志文件</h1><p>​    <code>mysql</code>在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。<span id="more"></span></p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>​    错误日志<code>error_log</code>文件对<code>MYSQL</code>的启动、允许、关闭过程进行记录，在遇到问题时可以查看该文件进行问题的定位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>​    慢查询日志<code>slow log</code>文件，可以在<code>MYSQL</code>启动时设置一个阈值，将执行时间超过该值的<code>SQL</code>语句都记录到慢查询文件中，通过查看该文件中的<code>SQL</code>语句来对系统中的慢查询进行优化处理。</p><p>默认情况下，<code>MYSQL</code>不开启慢查询日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启慢查询日志</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span></span><br><span class="line"><span class="comment">-- 查看慢查询的时间，多久认为是慢SQL 大于long_query_time才会认为是慢查询</span></span><br><span class="line"><span class="comment">-- 5.1版本之后long_query_time的单位改为微秒，5.1之前是秒</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_slow_queries&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果与语句没有使用到索引，都认为是慢查询</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.6.5 版本之后才有的参数，用来表示每分钟允许记录的未使用索引的SQL次数</span></span><br><span class="line"><span class="comment">-- 默认值为0，表示没有限制；在生产环境下，若过多的SQL语句没有使用索引，会导致</span></span><br><span class="line"><span class="comment">-- 频繁的将SQL记录到slow log表中，消耗性能和占用资源</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_throttle_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.1 之后允许将慢查询SQL记录到TABLE中，便于开发者查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看记录的方式，默认是FILE</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_output&#x27;</span></span><br><span class="line"><span class="comment">-- 修改为TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;TABLE&#x27;</span></span><br><span class="line"><span class="comment">-- 通过MYSQL.slow_log 查看</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MYSQL.SLOW_LOG</span><br></pre></td></tr></table></figure><p>默认情况下<code>slow_log</code>表使用的是<code>CSV</code>引擎，如果数据量的情况下，查询效率可能不高，可以将<code>slow_log</code>表的引擎修改为<code>MyISAM</code>,并且对列<code>start_time</code>上添加索引来提交查询的效率。</p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志文件<code>bin log</code>记录对数据执行的所有操作，但不包含<code>select</code>等查询操作，因为本质上查询并不会对数据本身进行修改。</p><p>但非查询语句又对数据没有产生变化，这类还是会被记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 比如：数据库中并没有名为marry的数据</span></span><br><span class="line">update user_info <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;marry&#x27;</span></span><br></pre></td></tr></table></figure><p><code>bin log</code>的主要作用为：</p><ul><li>恢复：比如对某些数据进行<code>DELETE</code>操作，可以通过使用<code>mysqlbinlog</code>工具对<code>bin log</code>文件中的的某些事件的起止节点或者时间的起止进行数据的恢复。</li><li>复制：常用的场景为主从模式下，主节点通过将<code>bin log</code>文件传递给从节点，然后从节点通过读取<code>bin log</code>文件的数据保证主从数据一致性。</li><li>审计：通过<code>bin log</code>文件中的信息进行审计，判断是否有对数据库注入的攻击。</li></ul><p>默认情况下二进制文件<code>binlog</code>是关闭的，需要手动开启，逻辑上是存在一定的性能消耗，但是根据官方测试结果数据来看，开启仅消耗使得性能下降1%左右。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看binlog存放位置</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示缓存区大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_cache_size&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用了临时文件写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_disk_use&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用缓存区写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_use&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>配置文件中相应的配置参数</strong></p><ul><li><code>max_binlog_size</code>： 指定单个二进制文件的最大值。如果操作该值则产生新的二进制文件，<code>MYSQL5.0</code>之前默认值为<code>1.1G</code>，之后版本为<code>1G</code></li><li><code>binlog_cache_size</code>：在事务未提交的二进制日志会被记录到一个缓存区中，等到事务提交之后再写入到<code>binlog</code>中，缓存区默认大小为<code>32K</code>。且该参数是基于会话，也就是说当一个线程开启一个事务时，就会分配一个<code>binlog_cache_size</code>大小的缓存区。当事务中的记录容量超过该值时，<code>MySql</code>会将缓冲区中的日志写入到一个临时文件中。</li><li><code>sync_binlog</code>：默认情况下，并不是每次写的时候都将日志内容写入到磁盘中，所以当数据库发生宕机时，可能有部分缓存区的数据还未写入到磁盘中。<code>sync_binlog</code>这个参数就是用来控制写入到缓存多少次后将缓存中的日志数据同步到磁盘中。默认值为0</li><li><code> binlog_do-db</code>：表示需要写入那些库的日志</li><li> <code>binlog-ignore-db</code>：表示需要忽略那些库的日志</li></ul><p><strong>binlog_format</strong>：这个参数比较重要，单独罗列出来，表示记录到<code>binlog</code>日志的数据格式，在<code>MySql5.1</code>版本之后才有该参数。可选参数有：</p><ul><li><p><code>STATEMENT</code>：基于<code>SQL</code>语句记录。存在两个问题：</p><ul><li><p>如果主服务器使用了一些生成函数，比如<code>uuid</code>等，这时从服务器得到主服务器的<code>binlog</code>进行回放后会导致主从数据不一致。</p></li><li><p>由于<code>MySql</code>的<code>INnoDB</code>存储引擎的默认事务隔离级别是<code>RR(REPEATABLE READ)可重复读</code>。如果事务隔离级别不是<code>RR</code>,会出现一种情况是：</p><p>假设事务隔离级别为<code>RC</code>且有一个<code>user_info（id， name）</code>表和两个字段，且有两条数据<code>(1, &#39;tom&#39;), (2, &#39;marry&#39;)</code>，下表的两个事务执行之后的数据为<code>(3, &#39;tom&#39;), (2, &#39;tom&#39;)</code>，但是从服务器获取到的<code>binlog</code>中，由于事务B先提交，那么会先回放事务B的<code>SQL</code>语句，结果就变成了<code>(3, &#39;tom&#39;), (3, &#39;marry&#39;)</code>,从而导致主从数据不一致。所以有些人说<code>MySQL</code>为了避免这种情况，将事务的隔离级别默认设置为<code>RR</code>，但<code>Oracle</code>的默认事务隔离级别为<code>RC</code></p><table><thead><tr><th>顺序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>update T set id=3 where name=’tom’</td><td></td></tr><tr><td>2</td><td></td><td>Update T set name=’tom’ where name=’marry’</td></tr><tr><td>3</td><td></td><td>commit</td></tr><tr><td>4</td><td>commit</td><td></td></tr></tbody></table></li></ul></li><li><p><code>ROW</code>：不是简单的<code>SQL</code>语句，而是记录表所对应行数据的变化，也就是从某某修改为某某。假设<code>name=tom</code>的数据有1w条，那么采用<code>STATEMENT</code>仅记录一条<code>DELETE</code>语句，采用<code>ROW</code>则记录1w条日志记录，显然后者需要更大的磁盘空间。</p></li><li><p><code>MIXED</code>：混合模式，默认采用<code>STATEMENT</code>格式，指定一些情况使用<code>ROW</code>格式，比如使用了<code>uuid()</code>等生成函数，在<code>innodb</code>对表的数据进行增删改操作等等。</p></li></ul><p><strong>binlog的写入机制</strong></p><ol><li><code>binlog</code>的写入是利用事件触发执行机制，根据<code>binlog_format</code>格式和操作的类型触发<code>Log Event</code>事件。</li><li>将事务在执行过程中产生的所有<code>Log Event</code>写入到缓存区中，一个执行语句不一定都只对应一个<code>Log Event</code>，每个事务线程都有独立的缓存区。</li><li>事务提交后会将缓存区中的<code>Log Event</code>写入到<code>bin log</code>文件中。事务的写入是串行的方式，也就是说一个事务在写入的中间不会穿插其他事务的<code>Log Event</code>。</li></ol><h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><blockquote><p>重做日志redo log</p></blockquote><h3 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h3><p>​        </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mysql日志文件&quot;&gt;&lt;a href=&quot;#mysql日志文件&quot; class=&quot;headerlink&quot; title=&quot;mysql日志文件&quot;&gt;&lt;/a&gt;mysql日志文件&lt;/h1&gt;&lt;p&gt;​    &lt;code&gt;mysql&lt;/code&gt;在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。</summary>
    
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://xiaocainiaoya.github.io/tags/mysql/"/>
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记(二)</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</id>
    <published>2022-07-12T13:39:58.000Z</published>
    <updated>2022-07-20T01:28:53.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis学习笔记-二"><a href="#redis学习笔记-二" class="headerlink" title="redis学习笔记(二)"></a>redis学习笔记(二)</h1><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>​    主从复制是将一台<code>redis</code>服务器设置为主服务器<code>master</code>，复制到其他多台从服务<code>slave</code>上，主服务器负责读写操作，从服务器只能读。<strong>数据的复制只能是主服务器到从服务器。</strong>当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。<strong>主从服务器之间通过心跳的机制检查服务器间的连接状态</strong><span id="more"></span></p><p><strong>主从服务之间的数据复制通过全量复制和部分复制。</strong></p><ol><li><p><strong>全量复制</strong> </p><p>​    分为两步操作：①主节点接收到从节点的全量复制命令，执行<code>gbsave</code>，在后台生成<code>RDB</code>文件，同时将此刻之后的写操作命令添加到复制缓冲区中。②将<code>RDB</code>文件发送给从节点，从节点先清除本身数据后加载<code>RDB</code>文件，然后在将主节点的复制缓冲区写命令依次执行。从而保证了从节点和主节点的数据一致。</p></li><li><p><strong>部分复制</strong></p><ul><li>复制偏移量：主从节点分别维护一个<code>offset</code>偏移量，主节点每次向从节点发送多少数据，修改<code>offset</code>偏移量值；同理，从节点每次从主节点接收多少数据，也会修改<code>offset</code>偏移量值。</li><li>复制积压缓冲区：主节点内部维护一个长度固定的<code>FIFO</code>队列作为复制积压缓冲区，默认大小是<code>1M</code>，在进行命令同步时，不仅会将写命令同步到从节点，同时会将写命令写入复制积压缓冲区，由于长度固定，写入比较早的命令会被挤出缓冲区，所以当主从的<code>offset</code>差距大于缓冲区长度时，无法进行部分复制，只能执行全量复制。</li><li>服务器运行<code>ID</code>(<code>runId</code>)：每个节点都有运行<code>ID</code>，运行<code>ID</code>在节点启动时自动生成，主节点会将自己的<code>runId</code>发送给从节点，从节点保存起来，出现从节点断线重连：①若若从节点中保存的主<code>runId</code>=主<code>runId</code>则之前同步过该主节点数据，会首先尝试部分复制。②若从节点中保存的主<code>runId</code>!=现主<code>runId</code>，则只能全量复制。</li></ul></li></ol><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>​    在主从复制模式下，若出现主服务器宕机，则需要运维人员手动修改从服务器为主服务器，不能良好的支持高可用。哨兵模式从出现就是为了解决这个问题，所以哨兵模式其实就是高可用的主从复制模式。可以由至少一个哨兵(哨兵可以集群)，监听任意多个主从服务器，当主服务器出现异常，导致宕机的时候，由哨兵投票将某个从服务器选举为主服务器，这样就可以保证主从服务之间的高可用。</p><blockquote><p>启动哨兵：redis-sentinel /path/to/sentinel.conf</p></blockquote><ul><li><code>Subjectively Down(SDOWN)</code>：主观下线，单个哨兵做出下线的判断。</li><li><code>Objectively Down(ODOWN)</code>：客观下线，多个哨兵实例对同一客户端做出下线判断。</li></ul><p><strong>客观下线只适用于主服务器，其他从服务器或者哨兵只会主观下线。哨兵在判定它们为下线前不需要进行协商，所以从服务器或者哨兵永远不会达到客观下线的条件。</strong>理论上，主观下线的作用就是当主服务器出现客观下线时，哨兵进行选举的从服务器不会从主观下线的从服务器中选举。</p><p><strong><code>redis</code>集群</strong></p><p>​    集群是为了解决单机<code>redis</code>容量有限的问题，将数据按一定的规则分配到多台机器中，也叫数据分片，集群不需要哨兵。</p><p>使用<code>redis</code>分片会遇到一个问题是如果将所有数据都均匀的分布到每一台服务器上，如果仅仅只通过<code>key</code>的哈希值取服务器数量的模有可能出现两个问题：</p><ul><li><p>大量的哈希碰撞导致大量数据存储在了某一台或者某几台服务器上。</p></li><li><p>当出现服务器增加一台或者减少一台时，需要迁移大量的数据。</p></li></ul><p><strong>解决方案</strong></p><p>采用一致性哈希算法进行处理。</p><p>如下图设置一个从0~2^32-1头尾相连的环。将目前集群中的服务器的<code>ip</code>进行哈希运算后对<code>2^23</code>进行取模后，得到结果一定落在这个环上的某个位置。</p><p><img src="https://s2.loli.net/2022/07/12/fb96c7TK3knjGdv.png" alt="一致性哈希图1.png"></p><p>假设现在集群中有三台服务器，分别进行<code>hash(ip)%2^23</code>运算之后，落在环上的位置，同时对一些需要存储在服务器中的数据进行<code>hash(key)%2^23</code>运算之后的值也会落在这个环上。根据顺时针，将对应的键归于某台服务器上，比如下图中<code>key1</code>落在<code>S1</code>服务器上，<code>key4</code>落在<code>S2</code>服务器上，<code>key2</code>和<code>key3</code>落在<code>S3</code>服务器上。</p><p><img src="https://s2.loli.net/2022/07/12/BujMksDNmw5Hx9z.png" alt="一致性哈希2.png"></p><p>假设这时需要添加一台服务器<code>S4</code>，那么只需要将<code>S4</code>在这个环上左侧部分的数据迁移到<code>S4</code>服务器上，其他服务器不需要进行迁移操作，删除服务器类似，所以不论是添加或者删除服务器，仅需要集群中的两台服务器进行迁移处理。</p><p><img src="https://s2.loli.net/2022/07/12/n8CoMD6u7KBAp2O.png" alt="一致性哈希3.png"></p><p>到这实际上已经解决了使用缓存集群进行分片在扩展和收缩时牵一发而动全身的数据迁移情况，但是在上面的例子中，服务的分布过于理想化，有可能出现一种场景是集群中就两台服务器，且两台服务器在这个环上距离非常靠近。业界称为<strong>数据倾斜</strong>：在存储集群中意思为大部分数据存储在少来服务器上，在计算集群中意思为大部分数据由少量服务器进行计算。</p><p>这里可以通过为服务器创建虚拟的节点，来扩大服务器在环上的分布，比如由每台服务器仅经过一次<code>hash(ip)%2^23</code>运算修改为<code>ip#1</code>、<code>ip#2</code>进行编号后在进行运算，使得一台服务器在环上存在多个节点，达到尽可能将数据均匀分布到各个服务器上的目的。</p><h4 id="缓冲穿透、击穿、雪崩"><a href="#缓冲穿透、击穿、雪崩" class="headerlink" title="缓冲穿透、击穿、雪崩"></a>缓冲穿透、击穿、雪崩</h4><p><strong>缓存穿透</strong>：当某一个<code>key</code>对应数据在缓存中不存在同时在持久层也不存在时，如果大量的请求涌入，会造成数据库的压力，这种现象称为缓存穿透。</p><p><strong>解决方案</strong></p><ul><li>布隆过滤器：将所有数据都打入布隆过滤器中，当通过布隆过滤器查询某个值时，若返回<code>false</code>则一定不存在该数据，若返回<code>true</code>则可能存在数据(有一定误判率)，进入<code>redis</code>查询，若没有命中，在进入持久层查询。</li><li>缓存空对象：这种做法比较粗暴，当出现数据查询不到时，将空对象缓存，一般会设置一个较短的缓存时间。</li></ul><p><strong>缓存击穿</strong>：当某一时刻，某一个<code>key</code>对应的缓存时间过期导致失效，如果大量的请求涌入，导致所有的请求都到持久层，会造成数据库压力，这种现象称为缓存击穿。</p><p><strong>解决方案</strong></p><ul><li>使用互斥锁：使用<code>mutex</code>，当缓存失效时，获取锁，在进入持久层，查询到数据后再添加到缓存中，也就是说若缓存中查询不到值，需要获取锁之后，才能进入持久层。</li></ul><p><strong>缓存雪崩</strong>：在某一个时刻，多个<code>key</code>对应的缓存时间过期，导致这些<code>key</code>全部失效，如果大量的请求涌入，导致所有的请求都到达持久层，会造成数据库压力，这种现象称为缓存雪崩。</p><p><strong>解决方案</strong></p><ul><li>缓存失效随机值，尽量避免多个<code>key</code>扎堆在同一时刻失效。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis学习笔记-二&quot;&gt;&lt;a href=&quot;#redis学习笔记-二&quot; class=&quot;headerlink&quot; title=&quot;redis学习笔记(二)&quot;&gt;&lt;/a&gt;redis学习笔记(二)&lt;/h1&gt;&lt;h4 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h4&gt;&lt;p&gt;​    主从复制是将一台&lt;code&gt;redis&lt;/code&gt;服务器设置为主服务器&lt;code&gt;master&lt;/code&gt;，复制到其他多台从服务&lt;code&gt;slave&lt;/code&gt;上，主服务器负责读写操作，从服务器只能读。&lt;strong&gt;数据的复制只能是主服务器到从服务器。&lt;/strong&gt;当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。&lt;strong&gt;主从服务器之间通过心跳的机制检查服务器间的连接状态&lt;/strong&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记(一)</title>
    <link href="http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://xiaocainiaoya.github.io/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2022-07-12T12:50:58.000Z</published>
    <updated>2022-07-12T13:39:30.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis学习笔记-一"><a href="#redis学习笔记-一" class="headerlink" title="redis学习笔记(一)"></a>redis学习笔记(一)</h3><h4 id="一、非关系数据库"><a href="#一、非关系数据库" class="headerlink" title="一、非关系数据库"></a>一、非关系数据库</h4><blockquote><p><code>not only Sql</code>是非关系型数据库</p></blockquote><span id="more"></span><h5 id="1-NoSQL的特点"><a href="#1-NoSQL的特点" class="headerlink" title="1.NoSQL的特点"></a>1.NoSQL的特点</h5><ul><li><p>方便扩展（数据之间没有关系，很好扩展）</p></li><li><p>大数据高性能（8w写，11w读）</p></li><li><p>数据类型多样性（无需事先设计数据库，随取随用）</p></li></ul><h5 id="2-传统RDBMS和NoSQL"><a href="#2-传统RDBMS和NoSQL" class="headerlink" title="2.传统RDBMS和NoSQL"></a>2.传统RDBMS和NoSQL</h5><p>​    传统的<code>RDBMS</code>是结构化组织、建立在<code>SQL</code>语句之上，数据和数据间的关系存储在表中，严格的一致性，事务等。</p><p>​    非关系型数据库<code>NoSQL</code>是没有固定的查询语言，有列存储、键值对存储、图像数据库、文件存储，强调最终一致性，建立在<code>CAP</code>定理和<code>BASE</code>理论，具有高性能、高可用、高可扩。</p><blockquote><p>大数据时代的3V(海量Volume，多样Variety，实时Velocity)+3高(高并发、高可用、高性能)</p></blockquote><h5 id="3-四大分类"><a href="#3-四大分类" class="headerlink" title="3.四大分类"></a>3.四大分类</h5><ol><li><p><strong>KV键值对</strong></p><p>代表性的有<code>redis</code>、<code>memecache</code></p></li><li><p><strong>文档型数据库</strong></p><p><code>MongoDB</code>一个基于分布式文件存储的数据库，<code>C++</code>编写，主要用来处理大量的文档，是一个介于关系型数据库和非关系型数据库的中间产品，<code>MongoDB</code>是非关系型数据库中功能最丰富，最像关系型数据库的。</p></li><li><p><strong>列存储数据库</strong></p><ul><li><code>Hbase</code></li><li>分布式文件系统</li></ul></li><li><p><strong>图关系数据库</strong></p><ul><li>存储拓扑图关系，比如朋友圈社交网络、广告推荐！(<code>Neo4j、infoGrid</code>)</li></ul></li></ol><h4 id="二、redis简介"><a href="#二、redis简介" class="headerlink" title="二、redis简介"></a>二、redis简介</h4><p>​    <code>Redis</code>是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串<code>String</code>， 散列<code>hashes</code>， 列表<code>lists</code>， 集合<code>sets</code>， 有序集合<code>sorted sets</code>与范围查询， <code>bitmaps</code>， <code>hyperloglogs</code>和地理空间<code>geospatial</code>索引半径查询。<code>Redis</code> 内置了复制，<code>LUA</code>脚本，<code>LRU</code>驱动事件，事务<code>transactions</code>和不同级别的磁盘持久化<code>persistence</code>， 并通过<code>Redis</code>哨兵<code>Sentinel</code>和自动分区<code>Cluster</code>提供高可用性<code>high availability</code>。</p><blockquote><p><code>Redis</code> 官方发布效率8w写，11万读 （mysql在300w数据之后需要加索引）</p></blockquote><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><ol><li>内存存储、持久化，内存是断电即失，所以持久化很重要(<code>AOP</code>、<code>RDB</code>)</li><li>效率高可用用于高速缓存。</li><li>发布订阅系统。</li><li>地图信息分析。</li><li>计时器、计数器(浏览量、点赞数、发布数)</li></ol><h5 id="2-单线程"><a href="#2-单线程" class="headerlink" title="2. 单线程"></a>2. 单线程</h5><p><code>redis</code>是单线程，官方表示<code>redis</code>是基于内存操作，<code>CPU</code>不是<code>redis</code>性能瓶颈，<code>redis</code>的性能瓶颈是根据机器的内存和网络带宽。</p><p><strong>redis是单线程为什么还这么快?</strong></p><p>两个误区：高性能服务器一定是多线程？多线程一定比单线程效率高？</p><p>核心是：<code>redis</code>是将所有数据全部存放在内存中，所以使用单线程去操作效率就是最高的，减少了<code>CPU</code>上下文切换的时间，多线程会引发上下文切换，对于内存系统来说，如果没有上下文切换效率就是最高的。而且<code>redis</code>是基于<code>reactor</code>模型，使用的是<code>I/O</code>多路复用的<code>IO</code>模型。</p><p><strong><code>I/O</code>多路复用：</strong>在<code>I/O</code>多路复用模型中，最重要的函数调用就是<code>select</code>，该方法能同时监控多个文件描述符的可读可写情况，当其中某个文件描述符可读或可写时，<code>select</code>方法就会返回可读以及可写的文件描述符个数，<code>netty</code>的底层采用的也是<code>I/O</code>多路复用的模型。</p><h4 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h4><p>​    <code>redis</code>是内存数据库，如果不将内存中的数据保存在硬盘中，若出现断电或者宕机等情况，内存中保存的数据也会丢失。</p><h5 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h5><p>​    <code>RDB</code>全称是<code>Redis DataBase</code>，在指定的时间间隔内将内存中的数据集快照<code>Shapshot</code>写入磁盘，恢复时只需要将快照加载入内存即可，默认保存的文件名为<code>dump.rdb</code>。</p><p>​    <code>redis</code>会通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有内存数据写入到一个临时文件中，待持久化结束后，会替换掉上一次持久化好的文件。整个过程，主进程不进行任何<code>I/O</code>操作，确保了极高的性能。并且<code>.rdb</code>是二进制文件，比较轻量，灾难之后的恢复会快一些。</p><p><strong>两种方式</strong></p><ul><li><code>save</code>：阻塞主线程，使得主线程不能继续对外提供请求，若数据量小，将数据写入备份文件快，则没有多大影响，若数据量大，写入备份文件时间长，则写多长时间就会停机多长时间。</li><li><code>bgsave</code>：主线程<code>fork</code>子进程，子进程进行数据的备份，主进程在<code>fork</code>子进程时阻塞，之后不会阻塞，相比于<code>save</code>方式，阻塞时间可以忽略不计。</li></ul><p><strong><code>bgsave</code>的原理</strong></p><p>​    主进程在<code>fork()</code>子进程之后，内核把主进程所有的内存页的权限都设置为<code>read-only</code>，然后将子进程的地址空间指向主进程。所以这里两个进程共享了同一块内存空间，最极端的情况当子进程在备份数据时，主进程接收到写请求，这时由于内存页的权限是<code>read-only</code>，会触发页异常中断后，会将这个数据的内存页复制一份，并且主进程指向该内存页。所以可以得出，在某一个时间节点触发了<code>bgsave</code>，则它只会备份那个时间节点的数据，那个时间节点只有的写操作，它都无法处理到。从一般设计来说，缓存中都是使用频繁且读多写少的数据，所以这一机制并不会使得在备份时频繁带来内存页数据异常导致的性能问题。</p><h5 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h5><p>​    <code>AOF</code>全称是<code>Append only file</code>，以日志的形式来记录每个写操作(默认情况是关闭)，将<code>redis</code>执行过的所有写操作命令备份下来，会把写操作命令一直追加到文件中。恢复时，默认会读取<code>appendonly.aof</code>文件中的命令，逐个执行命令，使得数据恢复。</p><p>​    <code>redis</code>通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有<code>AOF</code>缓冲区的命令同步到<code>appendonly.aof</code>文件中。</p><p><strong><code>AOF</code>的配置项</strong></p><ul><li><code>appendonly on</code>：默认是关闭状态</li><li><code>appendfilename &quot;appendonly.aof&quot;</code>：默认的持久化文件名称</li><li><code>appendfsync always</code>：同步策略，有三种<code>always</code>(每次修改都会同步)，<code>everysec</code>(每秒同步一次)，<code>no</code>由操作系统控制同步，默认是<code>everysec</code></li></ul><p><strong><code>AOF</code>重写</strong></p><p>​    <code>AOF</code>重写会在保持最终数据一致的前提下，将一些多条命令，整合成一条命令来代替多条命令。<code>AOF</code>重写是通过子进程的方式进行，使用子进程不会阻塞父进程，使得父进程还是可以处理客户端请求，并且子进程可以继承父进程资源，并且这种继承采取<code>copy-on-write</code>的策略，所以<code>AOF</code>重写无需关心由于客户端写请求导致数据不一致问题。</p><p>​    <code>AOF</code>重写的写命令不仅要写入到<code>AOF</code>缓冲区，还会写入<code>AOF</code>重写缓冲区，写入原<code>AOF</code>缓冲区是为了避免若重写失败导致数据丢失；写入<code>AOF</code>重写缓冲区是为了子进程在进行<code>AOF</code>重写期间还是在继续处理命令请求。</p><p>​    子进程在重写完毕后会发送一个信号给父进程，父进程收到信号后，会将<code>AOF</code>重写缓冲区的所有内容写入到新的<code>AOF</code>文件中，并且采用原子操作覆盖现有<code>AOF</code>文件，完成新旧文件的替换。</p><p><strong>小结</strong></p><p>​    如果需要大规模恢复数据，且对数据恢复的完整性不是非常敏感，那么<code>RDB</code>比<code>AOF</code>方式更加有效，<code>RDB</code>的缺点是最后一次持久化可能会丢失一部分数据。若从安全性来说，<code>AOF</code>会比较高一点，<code>AOF</code>最多丢失1秒的数据(采用默认配置的话)，而<code>RDB</code>丢失上一次备份与宕机时间差之间的数据。在<code>redis</code>服务器开启<code>AOF</code>持久化功能时，会采用<code>AOF</code>文件来恢复数据，若没有开启<code>AOF</code>功能时，才会使用<code>RDB</code>来恢复数据。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;redis学习笔记-一&quot;&gt;&lt;a href=&quot;#redis学习笔记-一&quot; class=&quot;headerlink&quot; title=&quot;redis学习笔记(一)&quot;&gt;&lt;/a&gt;redis学习笔记(一)&lt;/h3&gt;&lt;h4 id=&quot;一、非关系数据库&quot;&gt;&lt;a href=&quot;#一、非关系数据库&quot; class=&quot;headerlink&quot; title=&quot;一、非关系数据库&quot;&gt;&lt;/a&gt;一、非关系数据库&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;not only Sql&lt;/code&gt;是非关系型数据库&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/categories/redis/"/>
    
    
    <category term="笔记" scheme="http://xiaocainiaoya.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="redis" scheme="http://xiaocainiaoya.github.io/tags/redis/"/>
    
  </entry>
  
</feed>
