<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rancher入门（一）</title>
    <url>/2023/06/12/CI:CD/Rancher%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Rancher入门（一）"><a href="#Rancher入门（一）" class="headerlink" title="Rancher入门（一）"></a>Rancher入门（一）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    公司内网的服务是通过<code>Rancher</code>进行编排，<code>Rancher</code>有<code>V1</code>和<code>V2</code>两个版本，都是提供容器调度与编排，在<code>V1</code>版本中可选不同的编排模式，比如<code>cattle</code>、<code>swarm</code>、<code>kubernetes</code>。所以<code>V1</code>时代，它给自己的定位是各种编排工具的上层，通过它去管理编排工具。由于<code>k8s</code>后来发展势不可挡，所以<code>V2</code>版本诞生，移除了其他类型的编排工具，只剩下<code>k8s</code>，所以<code>Rancher</code>的底层是采用<code>k8s</code>编排，并对其功能进行了一些扩展和提供一些便捷工具，包括执行命令行，管理多个<code>k8s</code>集群等。</p>
<span id="more"></span>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>我这里是在<code>docker.hub</code>上搜索了一个<code>rancher/rancher</code>容器，直接在本机部署拉取这个容器。</p>
<blockquote>
<p>docker pull rancher/rancher</p>
</blockquote>
<p>启动这个容器：</p>
<blockquote>
<p> sudo docker run -d –restart=unless-stopped -p 80:80 -p 443:443 –privileged rancher/rancher</p>
</blockquote>
<ul>
<li><code>--restar</code>：表示指定容器的重启策略，可选值为<code>no</code>、<code>on-failure</code>、<code>always</code>、<code>unless-stopped</code><ul>
<li><code>no</code>：默认值，表示容器退出时，<code>docker</code>不自动重启容器</li>
<li><code>on-failure</code>：若容器的退出状态非0，则docker自动重启容器，还可以指定重启次数，若超过指定次数未能启动容器则放弃</li>
<li><code>always</code>：容器退出时总是重启</li>
<li><code>unless-stopped</code>：容器退出时总是重启，但不考虑<code>docker</code>守护进程启动时就已经停止的容器</li>
</ul>
</li>
<li><code>--privileged</code>：表示容器内的<code>root</code>拥有的权限，如果<code>=true</code>表示容器内的<code>root</code>拥有真正的<code>root</code>权限，否则容器内的<code>root</code>只是外部的一个普通用户权限，通过<code>--privileged</code>启动的容器，可以看到很多<code>host</code>宿主机上的设备，并且可以执行<code>mount</code>，甚至允许在这个容器中启动新的容器等等。(<code>rancher/rancher</code>这个镜像必须添加这个命令才可以启动)</li>
</ul>
<p>默认映射了<code>80</code>和<code>443</code>端口，通过<code>127.0.0.1:80</code>实际上是<code>127.0.0.1</code>就可以直接访问<code>rancher</code>。由于未使用授信证书，会有报警，忽略即可。</p>
]]></content>
      <categories>
        <category>rancher</category>
      </categories>
      <tags>
        <tag>rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter无法进入全局异常捕获</title>
    <url>/2023/10/09/Spring/Filter%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<h1 id="Filter无法进入全局异常捕获"><a href="#Filter无法进入全局异常捕获" class="headerlink" title="Filter无法进入全局异常捕获"></a>Filter无法进入全局异常捕获</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    我接手的一个服务没有依赖于公司建设项目一体化体系中的认证中心，导致这个服务自身需要支持认证授权模块，由于需求上只需要一个简单的登录模块，所以引入了<code>spring-security</code>模块来进行认证授权相关处理。早上收到一个测试提出的<code>bug</code>，服务在使用一段时间不使用后，再操作，会出现警告异常提示。定位问题发现是由于<code>token</code>失效导致后端校验报错，由于这个校验是在<code>filter</code>中处理，导致全局异常无法捕获，前端获取的异常结构与标准结构（约定异常体结构&lt;msg,code,info&gt;等）不符，导致前端也无法解析具体异常信息，所以界面上显示的是直接抛出的异常信息。</p>
<span id="more"></span>

<p>​    为什么<code>filter</code>中抛出的异常无法被全局异常处理器捕获？这是因为安全校验模块，不论是<code>spring-security</code>或者<code>shiro</code>这类，都是基于<code>javax.servlet.filter</code>过滤器来拦截请求，进行认证处理。而全局异常处理器<code>@ControllerAdvice</code>是对<code>Controller</code>控制层进行拦截，也就是说请求都还没有到达控制层已经抛出异常了，所以全局异常处理器无法捕获。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    我查询了一些资料，大多数人都从两个解决方案出发解决这个问题。</p>
<p><b>方案一：</b>在<code>filter</code>中直接将异常信息写到<code>response</code>流中。这里有一个小细节，我个人建议具体的异常信息还是由全局异常处理器生成，而不是自己通过<code>map</code>或者异常类手动生成一个异常对象，虽然说一般情况下，异常结构与前端有约定不会随意更改，但是如果出现非一般情况，变更了异常结构，但<code>filter</code>中的异常没有相应更改，出现的问题往往是致命的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseErrorHandle</span><span class="params">(HttpServletResponse response, BusinessException businessException)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ErrorResponse&lt;?&gt; result = globalDefaultExceptionHandler.processBusinessException(businessException, response);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(result);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>方案二 ：</b>通过转发到控制层，再由控制层抛出具体的异常信息。（这个方案我个人不推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在filter中如果出现异常，通过getRequestDispatcher转发到抛出异常的控制层接口中。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/common/throwException&quot;</span>).forward(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getThrowException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getThrowException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/postThrowException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">postThrowException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/throwException&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreAuth</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">throwException</span><span class="params">(<span class="meta">@RequestParam</span> String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> BusinessException.buildAlter(ErrorEnum.VERIFICATION_CREATE_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我不推荐这个方案的原因是：</p>
<ol>
<li>通过<code>getRequestDispatcher().forward()</code>这个是请求转发，在<code>filter</code>中无法设置请求参数，而一般应用系统自定义的异常信息不只是只有提示信息，有时也伴随着一下其他参数，比如异常编码、异常等级、告警方式等等，这些内容由于无法通过<code>parameter</code>传递，所以只能通过<code>restful</code>风格，通过地址栏参数来进行传递，比如<code>/common/throwException/&#123;code&#125;</code>，这种方式传参比较有限，且后期可能不容易扩展。</li>
<li>由于是转发请求，所以请求方式取决于原请求，也就是假设浏览器（客户端）发起的请求是<code>post</code>，那么转发的请求就是<code>post</code>；如果浏览器发起的请求是<code>get</code>，那么转发的请求就是<code>get</code>。这就转发的目标控制层接口，不能使用<code>@PostMapping</code>或者<code>GetMapping</code>单一接口来标记，而必须使用<code>RequestMapping</code>，且设置<code>method</code>属性值为<code>get</code>、<code>post</code>数组。</li>
</ol>
<p>综上，我比较推荐方案一的方式进行<code>filter</code>中的异常信息抛出，并且尽可能通过全局异常处理器来生成对应的异常结构，便于扩展。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Lock4j的锁代理浅析</title>
    <url>/2021/12/29/Spring/Lock4j%E7%9A%84%E9%94%81%E4%BB%A3%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Lock4j的锁代理浅析"><a href="#Lock4j的锁代理浅析" class="headerlink" title="Lock4j的锁代理浅析"></a>Lock4j的锁代理浅析</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>​    工作项目中使用<code>baomidou</code>的<code>lock4j</code>来进行分布式锁相关处理。在使用中还是出现了一些状况, 不得不稍微理解下<code>lock4j</code>中的一些基本设计思路和方式。<span id="more"></span></p>
<h3 id="二、基本知识"><a href="#二、基本知识" class="headerlink" title="二、基本知识"></a>二、基本知识</h3><p>​    在<code>Spring</code>中使用<code>AOP</code>实际上有好几种方式: 通过@AspectJ注解方式、通过<code>xml</code>配置文件方式、通过实现开放的一些抽象接口或者具体的实现方式。不论是使用哪种方式, 都需要指定出<code>AOP</code>中一些必备的结构。<br>这里简单描述下一些必需创建的结构:</p>
<ul>
<li>增强(<code>Advice</code>): 很多地方称为通知, 但实际上理解为增强更为准确. 用于表示具体的增强逻辑, 这里以日志前置增强为例, 前置增强顾名思义就是在某个逻辑之前添加保存日志的增强逻辑, 这里的日志保存逻辑即前置增强需要处理的逻辑, 所以前置增强的逻辑实际上就是一段处理逻辑代码, 和具体的目标逻辑之间没有关系. </li>
<li>切入点(<code>Pointcut</code>): 用于表示具体要切入的地方, 以上述前置增强为例, 在编写好日志增强的逻辑代码之后, 要应用到多少个地方, 也就是多少个地方需要添加这个日志前置增强, 这里就需要由切入点来标记具体需要切入的地方。</li>
<li>切面(<code>Aspect</code>): 切面可以简单理解为增强<code>Advice</code>和切入点<code>Pointcut</code>的组合.</li>
<li>目标对象(<code>Target Object</code>): 用于表示具体被增强的对象, 因为在<code>Spring</code>中是通过动态代理来实现切面处理, 故被增强对象就是目标对象.</li>
<li>代理对象(<code>AOP Proxy</code>): 用于表示将切面应用到目标对象而创建的代理对象。</li>
</ul>
<h3 id="三、浅析"><a href="#三、浅析" class="headerlink" title="三、浅析"></a>三、浅析</h3><p>​    在<code>lock4j</code>项目中, 大致的锁代理机制为创建一个基于<code>LockInterceptor</code>环绕增强的<code>Advice</code>和<code>@Lock4j</code>注解标记的切点<code>Pointcut</code>的<code>LockAnnotationAdvisor</code>切面。 </p>
<ol>
<li><p>环绕增强<code>Advice</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LockTemplate lockTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockInterceptor</span><span class="params">(LockTemplate lockTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockTemplate = lockTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的环绕增强逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/12/29 11:31:23</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LockInfo lockInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Lock4j lock4j = invocation.getMethod().getAnnotation(Lock4j.class);</span><br><span class="line">            Lock4jConfig lock4JConfig = Lock4jConfig.builder().client(lock4j.client()).type(lock4j.type())</span><br><span class="line">                    .keys(lock4j.keys()).lockKeyBuilder(lock4j.keyBuilder()).acquireTimeout(lock4j.acquireTimeout())</span><br><span class="line">                    .expire(lock4j.expire()).lockFailureStrategy(lock4j.lockFailureStrategy()).build();</span><br><span class="line">            LockTemplate lockTemplateProxy = (LockTemplate) <span class="keyword">new</span> Lock4jProxyFactory(lockTemplate).getProxyInstance();</span><br><span class="line">            lockInfo = lockTemplateProxy.lock(invocation, lock4JConfig);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockInfo) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockInfo) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;[@Lock4j] releaseLock , current lockKey = &#123;&#125; &quot;</span>,lockInfo.getLockKey());</span><br><span class="line">                lockTemplate.releaseLock(lockInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>切点<code>Pointcut</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记在方法上标记Lock4j注解的方法即为此aop的切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut = AnnotationMatchingPointcut.forMethodAnnotation(Lock4j.class);</span><br></pre></td></tr></table></figure></li>
<li><p>切面<code>LockAnnotationAdvisor</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Advice advice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记在方法上标记Lock4j注解的方法即为此aop的切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pointcut pointcut = AnnotationMatchingPointcut.forMethodAnnotation(Lock4j.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockAnnotationAdvisor</span><span class="params">(<span class="meta">@NonNull</span> LockInterceptor lockInterceptor, <span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advice = lockInterceptor;</span><br><span class="line">        setOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pointcut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.advice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在增强中加入了bean工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/12/29</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advice <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) <span class="keyword">this</span>.advice).setBeanFactory(beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上就实现了若在方法上标记了<code>@Lock4j</code>注解就会进入到<code>LockInterceptor</code>的增强逻辑上进行具体的加锁逻辑。</strong><br>所以此实现采用的是<code>Advice</code>+<code>methodInterceptor</code>组合实现一个切面<code>Advisor</code>来实现<code>AOP</code>的逻辑。实际上此实现也可以通过<code>@Aspect</code>注解来实现, 在实际的工作过程中我感觉使用<code>@Aspect</code>注解的方式更为简单, 更容易让人理解。</p>
<p><strong>若在某个方法上同时使用<code>@Transactional</code>和<code>@Lock4j</code>那么锁对事物会不会有所影响？</strong><br>这边先下结论: 1.上锁 -&gt; 2.开启事务 -&gt; 3.执行逻辑 -&gt; 4.提交/回滚事务 -&gt; 5.释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里标记这个切面的order = HIGHEST_PRECEDENCE = Integer.MIN_VALUE;(最小值)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/12/29 11:44:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LockAnnotationAdvisor <span class="title">lockAnnotationAdvisor</span><span class="params">(LockInterceptor lockInterceptor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LockAnnotationAdvisor(lockInterceptor, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建锁切面对象时设置了<code>Order</code>排序号为最小值, 所以若在某个方法上同时使用<code>@Transactional</code>和<code>@Lock4j</code>, 在代理类的<code>advisors</code>列表中的第一个元素就是<code>LockAnnotationAdvisor</code>, 第二个元素才是事物处理增强。<br><img src="https://s2.loli.net/2021/12/29/8aKTRhwdom1Q37X.png" alt="锁代理.png"></p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>BeanFactoryProcessor</title>
    <url>/2021/07/07/Spring/BeanFactoryProcessor/</url>
    <content><![CDATA[<h1 id="BeanFactoryProcessor"><a href="#BeanFactoryProcessor" class="headerlink" title="BeanFactoryProcessor"></a>BeanFactoryProcessor</h1><p>​    <code>BeanFactoryPostProcessor</code>是<code>spring</code>中一个很重要的扩展点，它与<code>BeanPostProcessor</code>长相类似，触发点略有不同。<code>BeanFactoryPostProcessor</code>的作用时期是在所有<code>bean</code>实例化之前。所以它的作用是加载<code>BeanDefinition</code>。或者可以动态的修改或者是新增<code>BeanDefinition</code>。<span id="more"></span></p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><code>BeanFactoryPostProcessor</code>有一个扩展接口，这个扩展接口的方法会优先与<code>BeanFactoryPostProcessor</code>的方法执行。</p>
<p><img src="https://i.loli.net/2021/07/07/dU1jTIlg8Kr4YHs.png" alt="BeanFactoryPostProcessor类图.png"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>​    还是从<code>spring</code>的核心方法<code>refresh</code>入手。其中的<code>invokeBeanFactoryPostProcessors(beanFactory);</code>就是用来处理<code>BeanFactoryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">// 准备刷新容器操作(设置一些状态位,监听器、事件器)</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">// 实例化一个Bean工厂(DefaultListableBeanFactory)</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="comment">// 初始化BeanFactory, 进行一些属性的初始化赋值</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">        <span class="comment">// 空方法扩展点(springboot中有使用到)</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        <span class="comment">// 调用BeanFactoryPostProcessor ---&gt; (在这里执行!!!)</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">        <span class="comment">// 注册所有的BeanPostProcessor</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">        <span class="comment">// 国际化</span></span><br><span class="line">        initMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">        <span class="comment">// 初始化事件广播器</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">        <span class="comment">// 扩展点, 由子类实现</span></span><br><span class="line">        onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">        <span class="comment">// 注册事件监听器</span></span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        <span class="comment">// 实例化所有的非懒加载的单例对象</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        destroyBeans();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">        cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">        <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">        resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心的处理方法在<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</code>，源码处已有一些注释。这里简单描述一下整个流程。</p>
<p>第一步：参数中传递进来的 <code>beanFactoryPostProcessors</code>，由上述可知，这里可能是<code>BeanDefinitionRegistryPostProcessor</code>也可能是<code>BeanFactoryPostProcessor</code>的实现类。所以定义两个集合<code>regularPostProcessors</code>和<code>registryProcessors</code>用于将二者分离开。这里会执行参数中传递进来的<code>BeanDefinitionRegistryPostProcessor</code>类型的接口。(在<code>springboot</code>中，可以在启动类的启动方法中添加)</p>
<p>第二步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，挑选出包含实现了<code>PriorityOrdered</code>接口的类，根据特定的排序规则进行排序后逐一执行。(在默认的情况下，这里仅会获取到<code>ConfigurationClassPostProcessor</code>，这里类的作用是处理配置类，将配置类[也就是开发者标记<code>@Configuration</code>、<code>@Component</code>、<code>@ImportSelector</code>等等]添加到容器中。)</p>
<p>第三步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，挑选出包含实现了<code>Ordered</code>接口的类，过滤执行过<code>BeanDefinitionRegistryPostProcessor</code>(若某个接口同时实现<code>Ordered</code>和<code>PriorityOrdered</code>，则应该在第二步中执行)，根据特定的排序规则进行排序后逐一执行。</p>
<p>第四步：获取容器中所有的<code>BeanDefinitionRegistryPostProcessor</code>，过滤已经执行过的，将剩下未执行的所有类，根据特定的排序规则进行排序后逐一执行。(这里使用死循环的原因：可能出现套娃情况，某个<code>BeanDefinitionRegistryPostProcessor</code>的实现方法中又创建了一个新的<code>BeanDefinitionRegistryPostProcessor</code>。)</p>
<p><strong>以上便已经执行了容器中所有<code>BeanDefinitionRegistryPostProcessor</code>的扩展点。接下来就是执行<code>BeanFactoryPostPostProcessor</code>扩展点。</strong></p>
<p>第五步：执行上述所有步骤中的<code>BeanDefinitionRegistryPostProcessor</code>的<code>BeanFactoryPostProcessor</code>的实现接口。(就是扩展接口中的扩展方法已经都执行完了，在这个地方统一执行父接口中的实现方法。)</p>
<p>第六步：执行参数中传递进来的<code>beanFactoryPostProcessors</code>中仅实现<code>BeanFactoryPostProcessor</code>的实现接口。</p>
<p>第七步：(<code>BeanFactoryPostPostProcessor</code>的执行比较简单，用一步概括)，获取容器中所有实现了<code>BeanFactoryPostProcessor</code>的类，将它们分为三类<code>PriorityOrdered</code>、<code>Ordered</code>、和没有实现这两个接口的。然后分别根据排序规则进行排序后逐一执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行BeanFactoryPostProcessor扩展点</span></span><br><span class="line"><span class="comment"> * 	1. 执行BeanDefinitionRegistryPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> * 		1.1. 执行参数beanFactoryPostProcessors中是BeanDefinitionRegistryPostProcessor的实现类的扩展点</span></span><br><span class="line"><span class="comment"> * 		1.2. 执行spring容器中的BeanDefinitionRegistryPostProcessor的实现且依次<span class="doctag">@PriorityOrdered</span>、<span class="doctag">@Ordered</span></span></span><br><span class="line"><span class="comment"> * 		1.3. 执行容器中还存在BeanDefinitionRegistryPostProcessor实现但未加入已执行集合(registryProcessors)中的实现类</span></span><br><span class="line"><span class="comment"> *	2. 执行BeanDefinitionPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> *		2.1. 执行非直接实现BeanDefinitionRegistryPostProcessor集合(registryProcessors)的BeanFactoryPostProcessor的扩展点</span></span><br><span class="line"><span class="comment"> *		2.2. 执行直接实现BeanFactoryPostProcessor集合(regularPostProcessors)的BeanFactoryPostProcessor的扩展点(这个集合中若存在</span></span><br><span class="line"><span class="comment"> *				元素, 则是开发者通过调用参数携带进来, 在第一步骤执行是分离出来)</span></span><br><span class="line"><span class="comment"> *		2.3. 执行spring容器中还未执行的BeanFactoryPostProcessor、顺序依次为<span class="doctag">@PriorityOrdered</span>、<span class="doctag">@Ordered</span>、最后是没有标记前者两注解的</span></span><br><span class="line"><span class="comment"> *			BeanFactoryPostProcessor的实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/09 10:05:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactoryPostProcessors 这个是自定义的beanFactoryPostProcessors, 默认是空的, 除非自己扩展</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">	<span class="comment">//处理过的BeanDefinitionRegistryPostProcessors类型的bean名字集合</span></span><br><span class="line">	Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">		<span class="comment">// 常规postProcessor(直接实现BeanFactoryPostProcessor的实现类)集合</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">// registryProcessor(非直接实现BeanFactoryPostProcessor的实现类)且已经调用过扩展点的集合</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// BeanFactoryPostProcessor是BeanDefinitionRegistryPostProcessor的父接口, 执行beanFactoryPostProcessors中的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">		<span class="comment">// 并将执行过后的BeanDefinitionRegistryPostProcessor放置在registryProcessors, 将未执行的BeanFactoryPostProcessor添加到regularPostProcessors</span></span><br><span class="line">		<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">				BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">				<span class="comment">// 调用BeanDefinitionRegistryPostProcessor扩展点</span></span><br><span class="line">				registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">				registryProcessors.add(registryProcessor);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 直接实现了BeanFactoryPostProcessor接口的实现</span></span><br><span class="line">				regularPostProcessors.add(postProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">		<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">		<span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">		<span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">		<span class="comment">// 放内部的BeanDefinitionRegistryPostProcessor后置处理器</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">		<span class="comment">// 首先, 调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">		<span class="comment">// (若没有改造或者二次开发过, 此处只会返回ConfigurationClassPostProcessor类</span></span><br><span class="line">		<span class="comment">//  ConfigurationClassPostProcessor类的作用是加载配置类)</span></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		<span class="comment">// 执行BeanDefinitionRegistryPostProcessors扩展点</span></span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">		<span class="comment">// 其次, 调用仅实现了Ordered接口的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="comment">// 过滤调用过的processedBean</span></span><br><span class="line">			<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">		<span class="comment">// 最后, 调用processedBeans中没有标记过的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">		<span class="comment">// 这个while循环是由于可能出现套娃的情况: 比如A类实现了BeanDefinitionRegistryPostProcessor, 在调用A的</span></span><br><span class="line">    <span class="comment">//postProcessBeanDefinitionRegistry中又添加了一个BeanDefinitionRegistryPostProcessor类B。</span></span><br><span class="line">		<span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">			reiterate = <span class="keyword">false</span>;</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">					reiterate = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">	<span class="comment">// 不要在此处初始化 FactoryBeans：我们需要保留所有未初始化的常规bean，让 bean 工厂后处理器应用于它们！</span></span><br><span class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">	<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">			<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">	<span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">	beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>​    从<code>spring</code>的生命周期看<code>BeanFactoryPostProcessor</code>的执行时机就是在<code>BeanPostProcessor</code>注册之前，甚至可以说是在大部分的<code>bean</code>注入之前。但若大量使用<code>BeanFactoryPostProcessor</code>进行扩展，若有重叠区域，则需考虑执行的先后顺序。比如后期的扩展是否需要控制新的<code>BeanFactoryPostProcessor</code>要在旧<code>BeanFactoryPostProcessor</code>之前或者之后？这个执行顺序是一个很容易忽略的<strong>关键点</strong>(自定义的<code>BeanFactoryPostProcessor</code>可以通过实现<code>Order</code>接口控制执行顺序)</p>
<p><strong>实例1</strong></p>
<p>​    可以通过<code>BeanDefinitionRegistryPostProcessor</code>修改<code>BeanDefinition</code>，比如在业务场景中有非常多的地方使用的是名称注入的方式，现要让这个名称注入容器中的类由新类，替换旧类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 替换class</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 获取扫描路径下的旧类 </span></span><br><span class="line">      BeanDefinition beanDefinition = registry.getBeanDefinition(<span class="string">&quot;roomService&quot;</span>);</span><br><span class="line">      <span class="comment">// 使其指向新类</span></span><br><span class="line">      beanDefinition.setBeanClassName(<span class="string">&quot;cn.com.xiaocainiaoya.service.NewRoomService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例2</strong></p>
<p>​    <code>springframwork</code>的扫描工作中比较核心的类<code>ConfigurationClassPostProcessor</code>，这个类的作用就是扫描配置类，扫描指定路径下的各种配置注解<code>@Configuration</code>、<code>Component</code>、<code>ComponentScan</code>等等。将这些类解析后添加到<code>BeanDefinition</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从注册表中的配置类派生进一步的 bean 定义。简单说根据BeanDefinition将配置类添加到spring容器中</span></span><br><span class="line"><span class="comment"> * 	1. 完成扫描</span></span><br><span class="line"><span class="comment"> * 	2. 对配置类的定义, 完成对配置类的标记</span></span><br><span class="line"><span class="comment"> * 	3. 对import的处理</span></span><br><span class="line"><span class="comment"> * 		3.1 ImportSelector(在springboot中自动装配典型使用)</span></span><br><span class="line"><span class="comment"> * 		3.2 ImportBeanDefinitionRegistrar(在mybatis中典型使用)</span></span><br><span class="line"><span class="comment"> * 		3.3 普通类</span></span><br><span class="line"><span class="comment"> * 			3.3.1 没有任何特殊注解</span></span><br><span class="line"><span class="comment"> * 			3.3.2 加了Import</span></span><br><span class="line"><span class="comment"> * 		3.4 ImportResource</span></span><br><span class="line"><span class="comment"> * 	4. <span class="doctag">@Bean</span>的处理</span></span><br><span class="line"><span class="comment"> * 	5. 接口当中的<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> * 	6. <span class="doctag">@PropertySource</span>的处理</span></span><br><span class="line"><span class="comment"> * 	7. 内部类的处理</span></span><br><span class="line"><span class="comment"> * 	8. 父类的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Derive further bean definitions from the configuration classes in the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 生成一个id，放置后面再重复执行</span></span><br><span class="line">	<span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若重复执行  就抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表示此registry里的BeanDefinition收集动作，已经做了  避免再重复收集此registry</span></span><br><span class="line">	<span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据配置类，收集到所有的bd信息,并且做出mark标注：是Full模式还是Lite模式</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>​    <code>BeanFactoryPostProcessor</code>算是<code>spring</code>给予开发者很高的权限去处理<code>BeanDefinitions</code>，但使用的过程中还需遵守<code>spring</code>的规范，不可将<code>bean</code>实例化，即不可在<code>BeanFactoryPostProcessor</code>中触发<code>bean</code>实例化的操作。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">// 这个getBeansOfType调用会触发getBean方法，会导致Bean提前注入，而在生命周期的这个节点</span></span><br><span class="line">      <span class="comment">// 自动注入的BeanPostProcessor还没有注入，还不会作用在bean的创建过程中，所以会导致</span></span><br><span class="line">      <span class="comment">// RoomService的属性注入会失效。</span></span><br><span class="line">      Map&lt;String, RoomService&gt; map = beanFactory.getBeansOfType(RoomService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以，在<code>BeanFactoryPostProcessor</code>的使用中切记要确保不会触发<code>Bean</code>的提前实例化。</strong></p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>SpringAop浅析</title>
    <url>/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="SpringAop浅析"><a href="#SpringAop浅析" class="headerlink" title="SpringAop浅析"></a>SpringAop浅析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>AOP</code>面向切面编程。在运行时，动态的将代码织入到类的指定方法，指定位置上的思想。实际上<code>AOP</code>不一定都像<code>Spring Aop</code>那样实现，<code>Spring Aop</code>是通过在运行时生成代理对象来进行织入。还有其他的方式，比如<code>AspectJ</code>是在编译期、类加载期织入。本篇文章就来介绍，<code>Spring Aop</code>在运行时生成代理对象的时期和过程。</p>
<span id="more"></span>

<h2 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h2><p>​    若想使用<code>SpringAop</code>可以通过两种方式，一种是声明式，通过调用<code>Api</code>的方式；一种是通过注解方式。两者在真正触发生成代理对象的点略有不同。</p>
<h3 id="1-声明式"><a href="#1-声明式" class="headerlink" title="1.声明式"></a>1.声明式</h3><p>​    这里只做简单介绍，首先需要实现某种通知类型的接口，再实现切点接口(<code>Pointcut</code>)，如果是环绕通知，需将通知实现类和切点实现类绑定<code>DefaultPointcutAdvisor</code>，最后在客户代码中将通知、目标类等信息添加到<code>ProxyFactory</code>实例中后，通过<code>ProxyFactorygetProxy();</code>获取代理对象，从而实现<code>SpringAop</code>。</p>
<h3 id="2-注解式"><a href="#2-注解式" class="headerlink" title="2.注解式"></a>2.注解式</h3><p>​    通过<code>@Aspect</code>标记一个类为切面类，并通过<code>@Pointcut</code>注解标记一个切点，最后通过注解标记通知类型，比如环绕通知使用<code>@Around</code>进行<code>Aop</code>的业务处理。</p>
<p><strong>那么<code>Spring</code>如何去解析这些注解？在什么时机解析？</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="1-开启SpringAop"><a href="#1-开启SpringAop" class="headerlink" title="1.开启SpringAop"></a>1.开启<code>SpringAop</code></h3><p>​    在<code>Spring</code>中提供一个开启<code>SpringAop</code>的配置注解<code>@EnableAspectJAutoProxy</code>(在<code>springboot</code>中一般标记在启动类上)，在这个注解上使用<code>@Import</code>注解引入<code>SpringAop</code>配置类<code>AspectJAutoProxyRegistrar</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 为true的话开启cglib代理，默认为jdk代理</span></span><br><span class="line"><span class="comment">    * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">    * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否将代理对象暴露到线程上下文中 </span></span><br><span class="line"><span class="comment">    * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">    * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">    * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AspectJAutoProxyRegistrar</code>实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>接口，在<code>Spring</code>启动扫描配置类后会调用该接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">    * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重点在这: 会注册AnnotationAwareAspectJAutoProxyCreator到BeanDefinitionMap中</span></span><br><span class="line">        <span class="comment">// AnnotationAwareAspectJAutoProxyCreator是一个BeanPostProcessor后置处理器</span></span><br><span class="line">        <span class="comment">// 这个方法比较简单, 可自行跟进去看一眼。</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">        <span class="comment">// 解析注解的属性</span></span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Aop代理对象的生成"><a href="#2-Aop代理对象的生成" class="headerlink" title="2.Aop代理对象的生成"></a>2.<code>Aop</code>代理对象的生成</h3><p>​    在开启<code>SpringAop</code>时添加了一个<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>Spring</code>容器中，在<code>Spring</code>启动的生命周期中，会在适时调用它的实现方法。</p>
<p>​    看一下这个类的类图，<code>AnnotationAwareAspectJAutoProxyCreator</code>实现了<code>AbstractAutoProxyCreator</code>抽象类，在这个抽象类中，实现了<code>BeanPostProcessor</code>生命周期接口。</p>
<p><img src="https://i.loli.net/2021/06/27/eKqWCVnJTcGjiYS.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean实例化之前调用接口:用于提前生成代理对象</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line">    <span class="comment">// this.advisedBeans用于标记某个key是否需要进行AOP代理</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line">    <span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line">    <span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="comment">// 若用户没有自定义，默认情况下是targetSource是空的</span></span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在Bean初始化之后调用接口:这个接口的调用点是在Bean对象初始化之后, 也就是Bean对象基本</span></span><br><span class="line"><span class="comment">* 上走完了初始化流程。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanClass</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="comment">// 一般情况下remove(cacheKey) != bean肯定会成立，因为前者remove方法返回null</span></span><br><span class="line">            <span class="comment">// 只有在循环依赖时，可能会出现提前暴露的bean对象与当前bean不等</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>wrapIfNecessary</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经完成代理了，那么直接返回这个代理的对象</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若这个Bean对象被标记无需AOP代理, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不需要代理，直接返回，且标记为无需AOP代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 获取通知可以作用在这个Bean上的通知</span></span><br><span class="line">    <span class="comment">// 主要逻辑在AnnotationAwareAspectJAutoProxyCreator#findCandidateAddvisors方法</span></span><br><span class="line">    <span class="comment">// 首先获取容器中类型为Advisor的Bean, 再从容器中获取@Aspect注解标记的Bean后, 将二者结合。</span></span><br><span class="line">    <span class="comment">// 最后筛选出可以作用到这个Bean的通知。</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="comment">// 标记这个Bean需要进行AOP代理</span></span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建代理对象, 这里是重点</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>createProxy</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建代理工厂类</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将Interceptors转化为具体的Advisor子类的类型</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* createAopProxy():根据一定的配置规则获取动态代理工厂的实现类(jdk动态代理或者是cglib动态代理)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>: 2021/06/27 21:55:15</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这边跟踪下来<code>createAopProxy()</code>返回的是<code>cglib</code>动态代理的实现，所以以<code>cglib</code>动态代理为例，继续往下走。进入<code>CglibAopProxy#getProxy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取正在包装的bean的类型</span></span><br><span class="line">    Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">    Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">    <span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">      proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">      Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">    validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">    Enhancer enhancer = createEnhancer();</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      enhancer.setClassLoader(classLoader);</span><br><span class="line">      <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">          ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">        enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">    <span class="comment">// 设置需要代理的接口</span></span><br><span class="line">    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">    Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">      types[x] = callbacks[x].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">    enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">      <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">    enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">    <span class="comment">// 创建具体的代理对象实例</span></span><br><span class="line">    <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,ex);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-代理对象的调用"><a href="#3-代理对象的调用" class="headerlink" title="3.代理对象的调用"></a>3.代理对象的调用</h3><p><code>DynamicAdvisedInterceptor#intercept</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取匹配该方法的通知列表</span></span><br><span class="line">        <span class="comment">// 主要逻辑在DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice方法中</span></span><br><span class="line">        <span class="comment">// 根据advised中的通知列表，对当前调用方法进行匹配，将匹配成功的通知转为拦截器链返回。</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">        <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">            <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">            <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">            <span class="comment">// 实例化CglibMethodInvocation后执行proceed方法</span></span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行拦截器链<code>proceed()</code>，进入<code>ReflectiveMethodInvocation#proceed</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="comment">// 表明执行到链尾, 直接通过反射调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到下一个要执行的拦截器</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice = <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="comment">// 调用拦截器中的invoke方法，可以看到这里将this作为参数传入了，这里是一种拦截器链的典型用法</span></span><br><span class="line">        <span class="comment">// 在我之前有篇[从myBatis Plugin看责任链模式]中有两种拦截器链的典型用法，二者的区别就是</span></span><br><span class="line">        <span class="comment">// 有没有携带链对象，这里明显是携带链对象，从而达到拦截器链逐个执行的目的。</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的是根据通知类型的不同会进入到不同的具体实现中，比如我的测试代码是环绕通知类型，这里进入环绕通知的具体实现中<code>AspectJAroundAdvice#invoke</code>去执行当前链节点的<code>invoke</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">  &#125;</span><br><span class="line">  ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">  <span class="comment">// 这里只是将链对象包装了一层</span></span><br><span class="line">  ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">  JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethod</span><span class="params">(JoinPoint jp, <span class="meta">@Nullable</span> JoinPointMatch jpMatch,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="meta">@Nullable</span> Object returnValue, <span class="meta">@Nullable</span> Throwable t)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Object[] actualArgs = args;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    actualArgs = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 反射调用通知方法</span></span><br><span class="line">    ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">    <span class="comment">// TODO AopUtils.invokeJoinpointUsingReflection</span></span><br><span class="line">    <span class="comment">// 把链对象封装在了这个arctualArgs(MethodInvocationProceedingJoinPoint)中了,</span></span><br><span class="line">    <span class="comment">// 所以切面方法中通过jointPoint.process()方法实际调用方法是与链对象挂钩的, 如果执行</span></span><br><span class="line">    <span class="comment">// 到链尾这调用目标对象, 若非链尾, 则继续进入链节点对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;Mismatch on arguments to advice method [&quot;</span> +</span><br><span class="line">                                     <span class="keyword">this</span>.aspectJAdviceMethod + <span class="string">&quot;]; pointcut expression [&quot;</span> +</span><br><span class="line">                                     <span class="keyword">this</span>.pointcut.getPointcutExpression() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以我的测试代码为例，环绕通知<code>@Around(&quot;testPointcut()&quot;)</code>的标记实现方法中，一般在前置执行一些业务代码之后，会调用<code>ProceedingJoinPoint#process()</code>方法，后再调用后置的业务代码。</p>
<p>而<code>ProceedingJoinPoint#process()</code>方法就是转入下一个拦截器链的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MethodInvocationProceedingJoinPoint</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 这个proceed()方法就回到了上面的ReflectiveMethodInvocation#proceed，且</span></span><br><span class="line">    <span class="comment">// 链下标不是-1, 而是下一个链节点的下标。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.methodInvocation.invocableClone().proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong>我这里使用的是<code>springboot</code>项目，仅在项目启动类上添加了一个<code>@EnableAspectJAutoProxy</code>，且默认情况下该注解的<code>proxyTargetClass()</code>属性为<code>false</code>，那么为什么我在调试的时候会进入到<code>Cglib</code>动态代理的实现中，逻辑上应该是使用<code>jdk</code>动态代理？</p>
<p>​    这是因为<code>springboot</code>的自动装配<code>AopAutoConfiguration</code>中，配置的是<code>cglib</code>动态代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 采用jdk动态代理的配置:需明确指定配置项spring.aop.proxy-target-class=false</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,matchIfMissing = false)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 采用cglib动态代理的配置:明确指定配置项spring.aop.proxy-target-class=true或者无该配置项时</span></span><br><span class="line"><span class="comment">        * 启用cglib动态代理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line">        ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这里只是对<code>SpringAop</code>做了个很浅的分析，主要是明确<code>SpringAop</code>的大致创建时机、创建流程和基本的调用流程。<code>SpringAop</code>是采用动态代理的方式实现，通过<code>@EnableAspectJAutoProxy</code>的方式开启，开启的原理为添加<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanDefinitionMap</code>中；在<code>Bean</code>对象实例化之前可以通过用户自定义的方式进行提前生成代理对象。或者是在<code>Bean</code>对象初始化之后，通过上述后置处理器的<code>postProcessAfterInitialization</code>方法，将<code>Bean</code>对象转为代理对象。</p>
<p>​    在业务中调用代理对象的某个方法时，进入对应的拦截方法<code>intercept</code>方法，该方法会去获取匹配当前被调用方法的拦截器链，进入链对象后，通过反射调用对应的切面方法后，通过链对象调用下一个链节点，从而遍历整个拦截器链列表，这是一种典型的拦截器设计，我之前也有写一篇文章<a href="https://xiaocainiaoya.github.io/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank">这里</a>，简单的介绍了拦截器的两种使用方式。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot的jar包如何启动</title>
    <url>/2021/04/13/Spring/SpringBoot%E7%9A%84jar%E5%8C%85%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h4 id="SpringBoot的jar包如何启动"><a href="#SpringBoot的jar包如何启动" class="headerlink" title="SpringBoot的jar包如何启动"></a>SpringBoot的jar包如何启动</h4><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>​    使用过<code>SprongBoot</code>打过<code>jar</code>包的都应该知道，目标文件一般都会生成两个文件，一个是以<code>.jar</code>的包，一个是<code>.jar.original</code>文件。那么使用<code>SpringBoot</code>会打出两个包，而<code>.jar.original</code>的作用是什么呢？还有就是<code>java -jar</code>是如何将一个<code>SpringBoot</code>项目启动，之间都进行了那些的操作？</p>
<p>​    其实<code>.jar.original</code>是<code>maven</code>在<code>SpringBoot</code>重新打包之前的原始<code>jar</code>包，内部只包含了项目的用户类，不包含其他的依赖<code>jar</code>包，生成之后，<code>SpringBoot</code>重新打包之后，最后生成<code>.jar</code>包，内部包含了原始<code>jar</code>包以及其他的引用依赖。以下提及的<code>jar</code>包都是<code>SpringBoot</code>二次加工打的包。</p>
<span id="more"></span>

<h4 id="二、jar包的内部结构"><a href="#二、jar包的内部结构" class="headerlink" title="二、jar包的内部结构"></a>二、jar包的内部结构</h4><blockquote>
<p><code>SpringBoot</code>打出的<code>jar</code>包，可以直接通过解压的方式查看内部的构造。一般情况下有三个目录。</p>
</blockquote>
<ul>
<li><code>BOOT-INF</code>：这个文件夹下有两个文件夹<code>classes</code>用来存放用户类，也就是原始<code>jar.original</code>里的类；还有一个是<code>lib</code>，就是这个原始<code>jar.original</code>引用的依赖。</li>
<li><code>META-INF</code>：这里是通过<code>java -jar</code>启动的入口信息，记录了入口类的位置等信息。</li>
<li><code>org</code>:<code>Springboot loader</code>的代码，通过它来启动。</li>
</ul>
<p><strong>这里主要介绍一下<code>/BOOT-INF/MANIFEST.MF</code>文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="meta">Implementation-Title</span>: <span class="string">springboot-server</span></span><br><span class="line"><span class="meta">Implementation-Version</span>: <span class="string">0.0.1-SNAPSHOT</span></span><br><span class="line"><span class="meta">Archiver-Version</span>: <span class="string">Plexus Archiver</span></span><br><span class="line"><span class="meta">Built-By</span>: <span class="string">Administrator</span></span><br><span class="line"><span class="meta">Implementation-Vendor-Id</span>: <span class="string">cn.com.springboot</span></span><br><span class="line"><span class="meta">Spring-Boot-Version</span>: <span class="string">1.5.13.RELEASE</span></span><br><span class="line"><span class="meta">Implementation-Vendor</span>: <span class="string">Pivotal Software, Inc.</span></span><br><span class="line"><span class="meta">Main-Class</span>: <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"><span class="meta">Start-Class</span>: <span class="string">cn.com.springboot.center.AuthEenterBootstrap</span></span><br><span class="line"><span class="meta">Spring-Boot-Classes</span>: <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="meta">Spring-Boot-Lib</span>: <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="meta">Created-By</span>: <span class="string">Apache Maven 3.6.1</span></span><br><span class="line"><span class="meta">Build-Jdk</span>: <span class="string">1.8.0_241</span></span><br><span class="line"><span class="meta">Implementation-URL</span>: <span class="string">http://projects.spring.io/spring-boot/auth-server/</span></span><br></pre></td></tr></table></figure>

<p>**<code>Main-Class</code>**：记录了<code>java -jar</code>的启动入口，当使用该命令启动时就会调用这个入口类的<code>main</code>方法，显然可以看出，<code>Springboot</code>转移了启动的入口，不是用户编写的<code>xxx.xxx.BootStrap</code>的那个入口类。</p>
<p>**<code>Start-Class</code>**：记录了用户编写的<code>xxx.xxx.BootStrap</code>的那个入口类，当内嵌的<code>jar</code>包加载完成之后，会使用<code>LaunchedURLClassLoader</code>线程加载类来加载这个用户编写的入口类。</p>
<h4 id="三、加载过程"><a href="#三、加载过程" class="headerlink" title="三、加载过程"></a>三、加载过程</h4><h5 id="1-使用到的一些类"><a href="#1-使用到的一些类" class="headerlink" title="1.使用到的一些类"></a>1.使用到的一些类</h5><p><strong>3.1.1 Archive</strong></p>
<p>​    归档文件接口，实现迭代器接口，它有两个子类，一个是<code>JarFileArchive</code>对<code>jar</code>包文件使用，提供了返回这个<code>jar</code>文件对应的<code>url</code>、或者这个<code>jar</code>文件的<code>MANIFEST</code>文件数据信息等操作。是<code>ExplodedArchive</code>是文件目录的使用也有获取这个目录<code>url</code>的方法，以及获取这个目录下的所有<code>Archive</code>文件方法。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1faa8d1fb220b5b1b466cd0b27d62e30.png"></p>
<p><strong>3.1.2 Launcher</strong></p>
<p>​    启动程序的基类，这边最后是通过<code>JarLauncher#main()</code>来启动。<code>ExecutableArchiveLauncher</code>是抽象类，提供了获取<code>Start-Class</code>类路径的方法，以及是否还有内嵌对应文件的判断方法和获取到内嵌对应文件集合的后置处理方法的抽象，由子类<code>JarLauncher</code>和<code>WarLauncher</code>自行实现。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d5ef4fccc5146602dccccc0c53b4e074.png"></p>
<p><strong>3.1.3 Spring.loader下的JarFile和JarEntry</strong></p>
<p>​    <code>jarFile</code>继承于<code>jar.util.jar.JarFile</code>，<code>JarEntry</code>继承于<code>java.util.jar.JarEntry</code>，对原始的一些方法进行重写覆盖。每一个<code>JarFileArchive</code>都拥有一个<code>JarFile</code>方法，用于存储这个<code>jar</code>包对应的文件，而每一个<code>JarFile</code>都有一个<code>JarFileEntries</code>,<code>JarFileEntries</code>是一个迭代器。总的来说，在解析<code>jar</code>包时，会将<code>jar</code>包内的文件封装成<code>JarEntry</code>对象后由<code>JarFile</code>对象保存文件列表的迭代器。所以<code>JarFileArchive</code>和<code>JarFileEntries</code>之间是通过<code>JarFile</code>连接，二者都可以获取到<code>JarFile</code>对象。</p>
<h5 id="2-过程分析"><a href="#2-过程分析" class="headerlink" title="2.过程分析"></a>2.过程分析</h5><p>从<code>MANIFEST.MF</code>文件中的<code>Main-class</code>指向入口开始。</p>
<p>创建<code>JarLauncher</code>并且通过它的<code>launch()</code>方法开始加载<code>jar</code>包内部信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JarLauncher</code>的空构造方法时一个空实现，刚开始看的时候还懵了一下，以为是在后续的操作中去加载的文件，其实不然，在创建时由父类<code>ExecutableArchiveLauncher</code>的构造方法去加载的文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutableArchiveLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载为归档文件对象</span></span><br><span class="line">    <span class="keyword">this</span>.archive = createArchive();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 具体的加载方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">  CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">  URI location = (codeSource == <span class="keyword">null</span> ? <span class="keyword">null</span> : codeSource.getLocation().toURI());</span><br><span class="line">  String path = (location == <span class="keyword">null</span> ? <span class="keyword">null</span> : location.getSchemeSpecificPart());</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to determine code source archive&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  File root = <span class="keyword">new</span> File(path);</span><br><span class="line">  <span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;Unable to determine code source archive from &quot;</span> + root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断路径是否是一个文件夹，是则返回ExplodedArchive对象，否则返回JarFileArchive</span></span><br><span class="line">  <span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root): <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== JarFileArchive =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFileArchive</span> <span class="keyword">implements</span> <span class="title">Archive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFileArchive</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(file, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFileArchive</span><span class="params">(File file, URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过这个new方法创建JarFile对象</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> JarFile(file));</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== JarFile =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarFile</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">jar</span>.<span class="title">JarFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JarFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RandomAccessDataFile读取文件信息</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> RandomAccessDataFile(file));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>jarLauncher#launch()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 注册URL协议的处理器，没有指定时，默认指向org.springframework.boot.loader包路径</span></span><br><span class="line">  JarFile.registerUrlProtocolHandler();</span><br><span class="line">  <span class="comment">// 获取类路径下的归档文件Archive并通过这些归档文件的URL，创建线程上下文类加载器LaunchedURLClassLoader</span></span><br><span class="line">  ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">  <span class="comment">// 使用类加载器和用户编写的启动入口类，通过反射调用它的main方法。</span></span><br><span class="line">  launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JarLauncher</code>的<code>getClassPathArchives()</code>是在<code>ExecutableArchiveLauncher</code>中实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Archive&gt; <span class="title">getClassPathArchives</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  List&lt;Archive&gt; archives = <span class="keyword">new</span> ArrayList&lt;Archive&gt;(</span><br><span class="line">    <span class="comment">// 获取归档文件中满足EntryFilterg过滤器的项，isNestedArchive()方法由具体</span></span><br><span class="line">    <span class="comment">// 的之类实现。</span></span><br><span class="line">    <span class="keyword">this</span>.archive.getNestedArchives(<span class="keyword">new</span> EntryFilter() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isNestedArchive(entry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;));</span><br><span class="line">  <span class="comment">// 获取到当前归档文件下的所有子归档文件之后的后置操作，是一个扩展点。在JarLauncher</span></span><br><span class="line">  <span class="comment">// 中是一个空实现。</span></span><br><span class="line">  postProcessClassPathArchives(archives);</span><br><span class="line">  <span class="keyword">return</span> archives;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JarLauncher的具体实现，这里通过判断是否在BOOT-INF/lib/包下返回true</span></span><br><span class="line"><span class="comment"> * 也就是说只会把jar包下的BOOT-INF/lib/下的文件加载为Archive对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JarFileArchive</code>的<code>getNestedArchives</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Archive&gt; <span class="title">getNestedArchives</span><span class="params">(EntryFilter filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	List&lt;Archive&gt; nestedArchives = <span class="keyword">new</span> ArrayList&lt;Archive&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Entry entry : <span class="keyword">this</span>) &#123;</span><br><span class="line">		  <span class="comment">// 若匹配器匹配获取内嵌归档文件</span></span><br><span class="line">			<span class="keyword">if</span> (filter.matches(entry)) &#123;</span><br><span class="line">				nestedArchives.add(getNestedArchive(entry));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> Collections.unmodifiableList(nestedArchives);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Archive <span class="title">getNestedArchive</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	JarEntry jarEntry = ((JarFileEntry) entry).getJarEntry();</span><br><span class="line">	<span class="keyword">if</span> (jarEntry.getComment().startsWith(UNPACK_MARKER)) &#123;</span><br><span class="line">		<span class="keyword">return</span> getUnpackedNestedArchive(jarEntry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 根据具体的Entry对象，创建JarFile对象</span></span><br><span class="line">		JarFile jarFile = <span class="keyword">this</span>.jarFile.getNestedJarFile(jarEntry);</span><br><span class="line">		<span class="comment">// 封装成归档文件对象后返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JarFileArchive(jarFile);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get nested  entry&quot;</span>+entry.getName(),ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> JarFile <span class="title">getNestedJarFile</span><span class="params">(<span class="keyword">final</span> ZipEntry entry)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getNestedJarFile((JarEntry) entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> JarFile <span class="title">getNestedJarFile</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		 <span class="comment">// 根据具体的Entry对象，创建JarFile对象</span></span><br><span class="line">		 <span class="keyword">return</span> createJarFileFromEntry(entry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException( <span class="string">&quot;Unable to open nested jar file&#x27;&quot;</span>+entry.getName()+<span class="string">&quot;&#x27;&quot;</span>,ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JarFile <span class="title">createJarFileFromEntry</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">		<span class="keyword">return</span> createJarFileFromDirectoryEntry(entry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> createJarFileFromFileEntry(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JarFile <span class="title">createJarFileFromFileEntry</span><span class="params">(JarEntry entry)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (entry.getMethod() != ZipEntry.STORED) &#123;</span><br><span class="line">	  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to open nested entry &#x27;&quot;</span></span><br><span class="line">	  + entry.getName() + <span class="string">&quot;&#x27;. It has been compressed and nested &quot;</span></span><br><span class="line">	  + <span class="string">&quot;jar files must be stored without compression. Please check the &quot;</span></span><br><span class="line">	   + <span class="string">&quot;mechanism used to create your executable jar file&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取到参数entry对应的RandomAccessData对象</span></span><br><span class="line">	RandomAccessData entryData = <span class="keyword">this</span>.entries.getEntryData(entry.getName());</span><br><span class="line">	<span class="comment">// 这里根据springboot扩展的url协议，在父路径的基础上添加!/来标记子包</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> JarFile(<span class="keyword">this</span>.rootFile, <span class="keyword">this</span>.pathFromRoot + <span class="string">&quot;!/&quot;</span> + entry.getName(),</span><br><span class="line">	                   entryData, JarFileType.NESTED_JAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这基本上读取<code>jar</code>内部信息，加载为对应归档文件对象的大概过程已经讲完了，接下来分析一下在获取到了整个<code>jar</code>的归档文件对象后的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过归档文件对象列表，获取对应的url信息，并通过url信息创建LaunchedURLClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(List&lt;Archive&gt; archives)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;(archives.size());</span><br><span class="line">	<span class="keyword">for</span> (Archive archive : archives) &#123;</span><br><span class="line">		urls.add(archive.getUrl());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> createClassLoader(urls.toArray(<span class="keyword">new</span> URL[urls.size()]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(URL[] urls)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> LaunchedURLClassLoader(urls, getClass().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到对应的<code>LaunchedUrlClassLoader</code>类加载器之后，设置线程的上下文类加载器为该加载器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">	<span class="comment">// 根据MANIFI.MF文件中的start-classs信息创建项目启动入口主类对象，并通过run方法启动</span></span><br><span class="line">	createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== MainMethodRunner ================</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String mainClassName;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MainMethodRunner</span><span class="params">(String mainClass, String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mainClassName = mainClass;</span><br><span class="line">		<span class="keyword">this</span>.args = (args == <span class="keyword">null</span> ? <span class="keyword">null</span> : args.clone());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">				.loadClass(<span class="keyword">this</span>.mainClassName);</span><br><span class="line">    <span class="comment">// 通过反射调用启动项目启动类的main方法</span></span><br><span class="line">		Method mainMethod = mainClass.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">		mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来说一下这个<code>LaunchedURLClassLoader</code>，它继承于<code>URLClassLoader</code>，并重写了<code>loadClass</code>方法</p>
<p><code>LaunchedClassLoader</code>的<code>loadClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   Handler.setUseFastConnectionExceptions(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         definePackageIfNecessary(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (getPackage(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Package &quot;</span> + name + <span class="string">&quot; has already been &quot;</span></span><br><span class="line">                  + <span class="string">&quot;defined but it could not be found&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// 调用父类loadClass方法，走正常委派流程，最终会被LaunchURLClassLoader</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      Handler.setUseFastConnectionExceptions(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ============URLClassLoader =====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)<span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = AccessController.doPrivileged(</span><br><span class="line">      <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">          <span class="comment">// 根据name，将路径转化为以.class结尾的/分隔的格式。</span></span><br><span class="line">          String path = name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">          <span class="comment">// 通过UrlClassPath对象根据路径获取资源类文件</span></span><br><span class="line">          Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">          <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, acc);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    <code>Springboot</code>主要实现了对<code>URL</code>加载方式进行了扩展，并且对一些对象<code>Archive</code>、<code>JarFile</code>、<code>Entry</code>等进行了抽象和扩展，最后使用<code>LaunchedUrlClassLoader</code>来进行处理。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMvc请求参数的二次处理</title>
    <url>/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="SpringMvc请求参数的二次处理"><a href="#SpringMvc请求参数的二次处理" class="headerlink" title="SpringMvc请求参数的二次处理"></a>SpringMvc请求参数的二次处理</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在一个项目中原来服务端是采用<code>WebService</code>的进行客户端和服务进行交互，现根据需要调整为直接使用<code>HHTP</code>方式访问。仅修改访问的方式，其数据的访问结构等不变。</p>
<span id="more"></span>

<h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><h3 id="1-HandlerMethodArgumentResolver"><a href="#1-HandlerMethodArgumentResolver" class="headerlink" title="1.HandlerMethodArgumentResolver"></a>1.HandlerMethodArgumentResolver</h3><ol>
<li>原数据结构：在旧项目的设计中，<code>data</code>数据是采用<code>GBK</code>的<code>base64</code>编码，在本次改造中，希望同时将解码的过程也统一处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3033941769749731426L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ApiModelProperty(&quot;请求数据(basic64)&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第一时间想到的就是<code>SpringMvc</code>的参数处理器<code>HandlerMethodArgumentResolver</code>。直接上手开干。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义参数解析器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDateParamMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否支持本自定义参数解析器</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/06/21 22:09:57</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ModelAndViewContainer mavContainer, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数解析器添加到spring容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDateParamMethodArgumentResolver <span class="title">requestDateParamMethodArgumentResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestDateParamMethodArgumentResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        argumentResolvers.add(requestDateParamMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.本以为可以完美解决，断点打在<code>resolveArgument</code>，正想启动后根据断点查询对应的参数信息，在进一步完善代码。测试发现，根本就没有进入断点。</p>
<p>4.虽说对参数解析器的执行过程不是非常的了解，但是大概知道参数解析器的处理是在适配器<code>Adapter</code>查找对应的<code>HandlerMethod</code>之后执行，所以根据调用栈，查找关键代码。</p>
<p><img src="https://i.loli.net/2021/06/21/qghUHGrXaeABRNp.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 所以在内置的很多参数处理器中，只会选择一种进行处理，由于上述的写法中没有自定义注解，</span></span><br><span class="line">   <span class="comment">// 尽管supportsParameter方法的返回值为true，用户自定义的参数处理器也是排在内置处理器之后。</span></span><br><span class="line">	HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line">			<span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">				result = resolver;</span><br><span class="line">				<span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">				<span class="comment">// 获取到一种匹配的参数处理器之后就跳出了</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以：</strong>若需要使用参数处理器进行处理，需要自定义一个注解后，标记在方法的属性处，而改造的本意还是希望业务代码层无需关心解码这一行为，若需要在每个方法处都标记一个注解，与初衷相悖。</p>
<h3 id="2-InitBinder"><a href="#2-InitBinder" class="headerlink" title="2. @InitBinder"></a>2. @InitBinder</h3><p>这种方式是比较细粒度的控制方式，仅控制单个<code>Controller</code>，在这个<code>Controller</code>中，的参数会被拦截进行数据的二次处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentResolverController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder webDataBinder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(webDataBinder.getTarget() <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User)webDataBinder.getTarget();</span><br><span class="line">            log.info(user.getUsername());</span><br><span class="line">            user.setPassword(<span class="string">&quot;updatePassword&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;setUserInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">      	<span class="comment">// 这里打印的password是updatePassword,是被修改之后的值, 所以解码可以放在@InitBinder中。</span></span><br><span class="line">        log.info(<span class="string">&quot;user: &#123;&#125;,&#123;&#125;&quot;</span>,user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-RequestBodyAdvice"><a href="#3-RequestBodyAdvice" class="headerlink" title="3. RequestBodyAdvice"></a>3. RequestBodyAdvice</h3><p>经过尝试<code>ArgumentAdvice</code>可以解决这个问题，通过<code>afterBodyRead</code>方法可以在参数解析器处理之后获取到对应的解析实体，再根据该实体的类型，进行<code>basic64</code>解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  请求参数增强处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/21 22:37:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;cn.com.xiaocainiaoya.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgumentAdvice</span> <span class="keyword">implements</span> <span class="title">RequestBodyAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter methodParameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpInputMessage <span class="title">beforeBodyRead</span><span class="params">(HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">             MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">             Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">                                MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                                Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(body <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            ((User) body).setPassword(<span class="string">&quot;12312&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleEmptyBody</span><span class="params">(Object body, HttpInputMessage inputMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    虽然最后没有没有通过参数处理器来解决这个问题，但是在测试过程中也发现了自己对参数解析器的理解不足，原以为只要<code>supportsParameter</code>方法为<code>true</code>，就可以进行参数处理，而我在完善代码时只需要抽象一个顶层属性接口做是否是某种类型的判断即可。</p>
<p>​    <code>@InitBinder</code>和<code>RequestBodyAdvice</code>都是可取的方案，取决于需求是需全局(某个包下的所有<code>Controller</code>)的参数都需要进行某种统一处理，或者是仅仅只需针对某一个<code>Controller</code>进行参数处理。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Springbean的生命周期</title>
    <url>/2021/07/04/Spring/Springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Springbean的生命周期"><a href="#Springbean的生命周期" class="headerlink" title="Springbean的生命周期"></a>Springbean的生命周期</h1><p>​    虽然大概知道<code>springbean</code>的生命周期的过程，但怕这老年人记忆，过段时间就忘了，故本篇将记录一下常用生命周期节点，以及事件的一些节点。<span id="more"></span></p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>下图为<code>BeanPostProcessor</code>的接口方法以及它的扩展接口的方法，这些接口就是贯穿<code>spring</code>一个<code>bean</code>创建完成的全过程。</p>
<p><img src="https://i.loli.net/2021/07/04/b932EyxHtVz4G1X.png" alt="BeanPostProcessor扩展点.png"></p>
<p>简单看一下这些接口的方法。</p>
<ol>
<li><code>BeanPostProcessor</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化之前调用方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化之后调用方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>MergedBeanDefinitionPostProcessor</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MergedBeanDefinitionPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 合并RootBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A notification that the bean definition for the specified name has been reset,</span></span><br><span class="line"><span class="comment">	 * and that this post-processor should clear any metadata for the affected bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation is empty.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> DefaultListableBeanFactory#resetBeanDefinition</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">resetBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>InstantiationAwareBeanPostProcessor</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实例化之前的操作, 用于创建一个bean对象可能是一个代理用于替代目标对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否允许注入校验</span></span><br><span class="line"><span class="comment">	 * 实例化之后的操作, 在populateBean方法中，如果返回false表示不允许进行注入，直接跳出方法</span></span><br><span class="line"><span class="comment">	 * 相当于populateBean的前置校验方法，若跳出则表示什么都没有注入。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 主要就是处理 通过注解注入属性的一系列操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 弃用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>SmartInstantiationAwareBeanPostProcessor</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 推断构造函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName)<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理循环依赖时使用，获取提前暴露对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体在<code>bean</code>创建过程中的哪一个环节中使用到。</strong></p>
<p><img src="https://i.loli.net/2021/07/04/NckDGq61TmasItW.png" alt="BeanPostProcessor具体调用点.png"></p>
<ol>
<li>这里判断正要实例化的<code>bean</code>是否需要被代理，也就是这个扩展点允许开发者干预<code>springbean</code>的创建流程，若开发者实现这个方法并返回代理对象，这是仅是调用<code>BeanPostProcessor#postProcessAfterInitialization</code>后就将对象打入容器中，不会走<code>springbean</code>的创建流程。</li>
<li>这个扩展点就是为了第1点中的情况结合使用。</li>
<li>推断构造函数，在没有指定构造函数时，可以通过这个扩展点，进行推断构造函数，<code>@PostConstruct</code>注解就是通过实现这个扩展点实现。</li>
<li>这个扩展点用于动态修改<code>BeanDefinition</code>后进行合并父子<code>BeanDefinition</code>。</li>
<li>这个扩展点在<code>populateBean()</code>方法的较前位置，主要判断这个<code>bean</code>是否允许进行属性的依赖注入，若这个扩展方法返回<code>false</code>，则表示不允许进行依赖注入，所以就不注入属性依赖，直接返回原对象。</li>
<li>这里先执行<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessProperties</code>方法，若这个接口返回值为空时，则执行<code>postProcessPropertyValues</code>方法。<code>@Autowired</code>和<code>@Resource</code>注解就是通过实现这个扩展点进行属性注入。</li>
<li>这个扩展点是在处理循环依赖时，当正在创建的<code>beanA</code>需要注入还未创建的<code>beanB</code>时，通过这个扩展点来获取<code>beanB</code>，这时可以通过这个扩展点对<code>beanB</code>对象进行一些处理，比如<code>SpringAOP</code>就是在这个扩展点上对<code>beanB</code>实现了代理对象，将代理对象注入到正在创建的<code>beanA</code>中。</li>
<li>这个扩展点就是顶层接口<code>BeanPostProcessor</code>后置处理器的<code>postProcessorBeforeInitialization</code>。比如<code>CommonAnnotationBeanPostProcessor</code>的父类<code>InitDestroyAnnotationBeanPostProcessor</code>实现了这个方法，在这个方法中处理<code>@PostConstruct</code>注解标记方法的反射调用。</li>
<li>这个扩展点就是顶层接口<code>BeanPostProcessor</code>后置处理器的<code>postProcessorAfterInitialization</code>。比如<code>AbstractAutoProxyCreator</code>使用这个方法对创建完成的<code>bean</code>进行<code>AOP</code>代理。</li>
</ol>
<h2 id="事件机制的生命周期"><a href="#事件机制的生命周期" class="headerlink" title="事件机制的生命周期"></a>事件机制的生命周期</h2><p><code>spring</code>的事件机制实际上就是发布订阅模式的实现，且<code>spring</code>内置就有好几个伴随着<code>spring</code>容器生命周期的事件，但好像使用比较多的是被<code>springboot</code>扩展的事件，<code>springboot</code>通过实现<code>ApplicationEvent</code>抽象类，又扩展了一些事件。</p>
<p><strong><code>springboot</code>中的事件</strong>：<code>SpringApplicationEvent</code>是<code>springboot</code>的所有事件接口的抽象父接口</p>
<p><img src="https://i.loli.net/2021/07/06/dVxezH5KOCEgUBY.png" alt="springboot事件监听类继承关系.png"></p>
<ol>
<li><code>ApplicationStartingEvent</code>：框架启动发送事件，在<code>springboot</code>的启动方法中，当调用<code>run</code>方法后，随之就发送该事件。</li>
<li><code>ApplicationEnvironmentPreparedEvent</code>：环境准备完成发送事件，在步骤1事件发送之后，<code>springboot</code>就进行读取启动命令行参数以及<code>environment</code>的处理，完成该处理后发生时间。</li>
<li><code>ApplicationContextInitializedEvent</code>：Spring上下文初始化完成且在加载bean之前发送，在<code>SpringApplication#prepareContext</code>方法中触发该事件。</li>
<li><code>ApplicationPreparedEvent</code>：Spring上下文准备完成且Bean尚未加载完成，在<code>SpringApplication#prepareContext</code>的最后触发该事件，这个事件发送之后就进入<code>spring</code>的核心方法<code>refresh</code>。</li>
<li><code>ApplicationStartedEvent</code>：在<code>spring</code>的<code>refresh</code>方法执行完毕之后发送该事件，表示容器启动完成。</li>
<li><code>ApplicationReadyEvent</code>：在<code>SpringApplication#run</code>方法的最后，发送该事件。</li>
</ol>
<p>以上6个事件是依次执行，根据上述信息可得，<code>spring</code>内置的事件的执行时期，应该是在第四步骤中。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Springboot请求响应乱码</title>
    <url>/2022/07/10/Spring/Springboot%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Springboot请求响应乱码"><a href="#Springboot请求响应乱码" class="headerlink" title="Springboot请求响应乱码"></a>Springboot请求响应乱码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在一个项目中出现了一个比较棘手的问题，情况是这样的：由于项目场景的需要，引入了公司技术架构部门在<code>activiti</code>工作流的基础上进行二次开发的工作流组件，使用该组件，需要实现几个获取岗位信息、人员信息相关的接口，工作流组件通过<code>restTemplate</code>调用这些接口来获取对应的人员、岗位信息用于工作流服务的节点信息显示，在开发过程中一切正常且部署到开发环境中调试过程中也是一切正常，但是当部署到测试环境后，发现接口出现乱码。</p>
<span id="more"></span>

<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>​    由于工作流服务采用的是<code>tomcat</code>方式部署，第一反应是修改<code>tomcat</code>中的相关配置文件<code>web.xml</code>和<code>server.xml</code>的相关配置，但是修改之后发现并无效果。又尝试在测试环境使用开发环境的正常使用的镜像，还是出现乱码，到这个时候真的是一点头绪都没有了，不知从何下手。在不断的排查过程中，发现仅仅是通过<code>restTemplate</code>请求业务服务的岗位信息、人员信息接口出现了乱码问题，其他接口并无异常。</p>
<p>​    而后发现开发环境和测试环境的同一个接口，响应时的<code>Content-Type</code>中，测试环境少了<code>charset=UTF-8</code>，马上使用<code>@RequestMapping</code>的<code>produces = &quot;application/json;charset=UTF-8&quot;</code>指定编码方式，经测试，正常解决乱码问题！！！</p>
<p><img src="https://s2.loli.net/2022/07/10/7YJc9hMUXdjStWg.png" alt="测试环境工作流请求返回.png"></p>
<p><img src="https://s2.loli.net/2022/07/10/PWksefL5D4HZN6a.png" alt="开发环境工作流返回.png"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>​    在解决这个乱码问题之后，其实还是很疑惑的，为什么在开发环境和测试环境出现了不同的<code>Content-Type</code>响应头信息，测试环境响应头中的<code>charset=UTF-8</code>为什么会消失？由于我们是采用指定了<code>@RequestMapping</code>注解的<code>produces</code>属性才解决问题，那么具体的情况还得从它入手，如果不指定值，那么它默认的处理逻辑是什么？</p>
<p>跟踪源码发现：在<code>HeaderContentNegotiationStrategy</code>进行了<code>api</code>媒体类型的相关处理，主要逻辑是获取请求头中的<code>accept</code>属性值，若为空，则指定<code>*/*</code>为结果值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MediaType&gt; <span class="title">resolveMediaTypes</span><span class="params">(NativeWebRequest request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取请求头中的accept属性</span></span><br><span class="line">    String[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT);</span><br><span class="line">    <span class="keyword">if</span> (headerValueArray == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若为空，则返回所有 -&gt; 实际值就是: */*</span></span><br><span class="line">        <span class="keyword">return</span> MEDIA_TYPE_ALL_LIST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; headerValues = Arrays.asList(headerValueArray);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues);</span><br><span class="line">        MediaType.sortBySpecificityAndQuality(mediaTypes);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotAcceptableException(</span><br><span class="line">                <span class="string">&quot;Could not parse &#x27;Accept&#x27; header &quot;</span> + headerValues + <span class="string">&quot;: &quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会进入<code>AbstractMessageConverterMethodProcessor#getProducibleMediaTypes</code>这个返回主要用于返回响应的媒体类型，主要会通过响应的返回值的数据类型根据具体的媒体转换器的<code>canWrite</code>方法来获取支持的媒体类型。</p>
<p>根据测试发现，如果在<code>accept</code>或者是<code>@RequestMapping</code>指定了<code>produces</code>属性值，那么这里直接获取到对应的值之后就返回了，而下面的通过默认的消息转换器中获取到的媒体类型都是不带具体的编码格式的，比如我的这个接口返回的主要就是<code>application/json</code>、<code>application/*+json</code>两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;MediaType&gt; <span class="title">getProducibleMediaTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, Class&lt;?&gt; valueClass, <span class="meta">@Nullable</span> Type targetType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这里获取不到媒体的类型的情况下，进入下面的消息转换器获取，</span></span><br><span class="line">    <span class="comment">// 如果在@RequestMapping中指定了produces或者是原本请求头中的accept中指定了值，这里直接就是获取到指定的那个值    </span></span><br><span class="line">    Set&lt;MediaType&gt; mediaTypes =</span><br><span class="line">            (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(mediaTypes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(mediaTypes);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allSupportedMediaTypes.isEmpty()) &#123;</span><br><span class="line">        List&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">            <span class="comment">// 通过消息转换器获取响应结果支持的媒体类型</span></span><br><span class="line">            <span class="comment">// 比如接口的返回类型是List，则这里会获取到application/json、application/*+json</span></span><br><span class="line">            <span class="comment">// 返回类型是String，可能会有其他的媒体类型之类</span></span><br><span class="line">            <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter &amp;&amp; targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((GenericHttpMessageConverter&lt;?&gt;) converter).canWrite(targetType, valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    result.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (converter.canWrite(valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                result.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(MediaType.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    在我们公司其实研发也是获取不到开发环境、测试环境的服务器登录等相关权限，都是需要告诉运维人员要操作什么，或者获取到对应的配置文件信息，然后进行更改，所以现在尽管知道了可能是请求头中的<code>accept</code>在测试环境中存在丢失的情况，也没有办法进入测试环境进行具体问题的排查，仅通过这一问题，对请求、响应的相关细节有了进一步的了解。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring循环依赖(上)</title>
    <url>/2021/06/29/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="Spring循环依赖-上"><a href="#Spring循环依赖-上" class="headerlink" title="Spring循环依赖(上)"></a>Spring循环依赖(上)</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    今天在开发过程中，同事在一个<code>xxxService</code>中的某个方法上添加了<code>@Async</code>注解，本意是希望这个方法可以异步执行，但是添加注解之后，发现启动报错。</p>
<span id="more"></span>

<p>报错信息如下：</p>
<blockquote>
<p>Bean with name ‘xxxService’ has been injected into other beans [xxxAService,xxxBService,xxxCService,xxxDService,xxxEService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using ‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.</p>
</blockquote>
<p>从报错信息中可以明显的知道，是因为<code>spring bean</code>之间出现了循环依赖。以往只记得一个结论，<code>spring</code>是支持循环依赖，且<code>spring</code>中通过三级缓存来解决循环依赖出现的问题。正好借这个问题，且最近刚好在开<code>spring</code>启动流程，对<code>bean</code>的生命周期有大概的了解。</p>
<h2 id="Bean的创建过程"><a href="#Bean的创建过程" class="headerlink" title="Bean的创建过程"></a>Bean的创建过程</h2><p>​    实际上一个<code>Spring Bean</code>的创建包含了三个过程：实例化、注入依赖项、初始化，在<code>spring</code>中分别对应的是<code>instantiation</code>、<code>populate</code>、<code>initialization</code>。在没有看<code>spring</code>之前，我一度以为实例化和初始化是一个意思，一直以为两个单词是一个意思。</p>
<ul>
<li>实例化(<code>instantiation</code>)：通过指定的静态函数或者实例化对象的某个函数，或者是无参构造函数等方式创建一个空对象。</li>
<li>注入依赖项(<code>populate</code>)：比如实现了<code>BeanPostProcessor</code>的<code>InstantiationAwareBeanPostProcessor</code>开放的扩展点进行特定情况的依赖项注入，比如在属性上标记的<code>@Autowird</code>，则是通过<code>AutowiredAnnotationBeanPostProcessor</code>进行注入处理。</li>
<li>初始化(<code>initilization</code>)：注入依赖项之后的一些操作，比如指定了初始化<code>initMethod</code>方法，或者是<code>BeanPostProcessor#postProcessBeforeInitialization</code>接口等。</li>
</ul>
<p><code>Spring</code>的<code>bean</code>的创建过程，主要是从<code>AbstractApplicationContext#refresh</code>方法说起，这个方法涉及到了<code>Spring bean</code>的整个生命周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备刷新容器操作(设置一些状态位,监听器、事件器)</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 实例化一个Bean工厂(DefaultListableBeanFactory)</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 初始化BeanFactory, 进行一些属性的初始化赋值</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 空方法扩展点(springboot中有使用到)</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用BeanFactoryPostProcessor</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 注册所有的BeanPostProcessor</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 初始化事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 扩展点, 由子类实现</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 注册事件监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 实例化所有的非懒加载的单例对象</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建<code>Bean</code>的三个过程，在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法中均有体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ①实例化对象</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">// bean是否需要提前暴露: 需满足三个条件 -&gt; 1.是单例; 2.支持循环依赖; 3.bean正在创建中(在singletonsCurrentlyInCreation中能获取到)</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加三级缓存工厂</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ②填充属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// ③初始化对象:填充属性之后进行初始化及一些扩展点的操作</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面逐个来简单分析下。</p>
<h3 id="1-实例化对象"><a href="#1-实例化对象" class="headerlink" title="1.实例化对象"></a>1.实例化对象</h3><p>通过以下代码分析，实例化其实就是通过这几种方式，创建了一个空对象，并获取这个对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取这个bean的class属性，确保beanDefinition中beanClass属性已经完成解析</span></span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过beanDefinition中的supplier实例化这个bean，一般情况下不会通过这种方式创建</span></span><br><span class="line">    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">    <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通过FactoryMethod实例化这个bean</span></span><br><span class="line">    <span class="comment">// 通过工厂方式实例化(包含静态工厂和实例工厂)</span></span><br><span class="line">    <span class="comment">// @Bean是通过实例工厂(实例工厂也被spring容器管理[获取对应Bean之后通过反射调用实例化对象])来实例化对象</span></span><br><span class="line">    <span class="comment">// xml方式中可以指定class为静态类factory-method为静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.下面这段代码都是在通过构造函数实例化这个Bean,分两种情况，一种是通过默认的无参构造，一种是通过推断出来的构造函数</span></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Candidate constructors for autowiring? 获取构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">    ctors = mbd.getPreferredConstructors();</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-注入依赖项"><a href="#2-注入依赖项" class="headerlink" title="2.注入依赖项"></a>2.注入依赖项</h3><p>主要的逻辑就是根据<code>BeanPostProcessor</code>扩展点的接口，或者实现它的二次扩展接口。通过这些扩展接口的实现，来进行特殊方式的注入，比如使用<code>@Autowird</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 是否允许注入校验, 如果postProcessAfterInstantiation返回false则表示不允许注入</span></span><br><span class="line">                <span class="comment">// 直接跳出populateBean方法</span></span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 执行InstantiationAwareBeanPostProcessor#postProcessProperties</span></span><br><span class="line">                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pvs = pvsToUse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-初始化对象"><a href="#3-初始化对象" class="headerlink" title="3.初始化对象"></a>3.初始化对象</h3><p>主要逻辑就是在注入依赖项之后，进行一些对象完善，可以通过制定初始化方法<code>initMethod</code>或者通过实现<code>BeanPostProcessor</code>后置处理器来处理一些操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 调用aware扩展点方法</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 2. 执行BeanPostProcessor#postProcessBeforeInitialization</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 执行指定的初始化initMethod方法</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// 4. 执行BeanPostProcessor#postProcessAfterInitialization</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong>从大方向来说，<code>spring</code>创建<code>bean</code>的过程就是以上三个过程。而循环依赖的主要处理逻辑应该是在注入依赖项这一环，判定是否循环依赖是在初始化方法之后进行判定。</p>
<h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>在<code>spring</code>中通过三级缓存来解决循环依赖，三级缓存分别为：</p>
<ul>
<li><code>singletonObjects</code>：一级缓存，保存的是初始化完成的单例<code>Bean</code>对象</li>
<li><code>earlySingletonObjects</code>：二级缓存，保存的是实例化之后，注入依赖项之前的对象，换句话说就是一个空对象的引用。</li>
<li><code>singletonFactories</code>：三级缓存，保存的是需要提前暴露的对象的单例工厂，二级缓存中的对象引用，是由这个工厂生成。</li>
</ul>
<p>在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法的，实例化对象之后，注入依赖项之前，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bean是否需要提前暴露: 需满足三个条件 -&gt; 1.是单例; 2.支持循环依赖; 3.bean正在创建中</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加三级缓存工厂</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultSingletonBeanRegistry#addSingletonFactory</span></span><br><span class="line"><span class="comment">// 这里会将这个实例化bean的工厂添加到三级缓存中。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">    <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">    <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化bean的工厂方法</span></span><br><span class="line"><span class="comment">// 这个方法大致的作用就是对传入的这个bean对象, 进行满足一下条件的BeanPostProcessor的处理</span></span><br><span class="line"><span class="comment">// 默认情况下只有AOP的一个BeanPostProcessor。在目标bean无需AOP的情况下, 返回的其实就是传入的bean</span></span><br><span class="line"><span class="comment">// 也就是仅仅只经过实例化的bean。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举一个简单的例子，来演示<code>spring</code>创建<code>bean</code>过程中三级缓存的变化。假设需要往<code>spring</code>容器中添加两个对象<code>A、B</code>，且这两个对象相互依赖，且<code>spring</code>先处理<code>A</code>在处理<code>B</code>。</p>
<p><img src="https://i.loli.net/2021/06/29/95yxZlftYqKW2Rz.png"></p>
<p>简单通过文字描述下整个流程(当然了三级缓存中的一级缓存中的创建完成的<code>bean</code>不止这两个对象，还包含<code>spring</code>内置的一些对象)：</p>
<p><strong>A对象的创建过程</strong></p>
<ol>
<li><p>A对象实例化：这时仅通过A对象的无参构造函数，创建了一个空对象。</p>
</li>
<li><p>将A提前暴露的工厂添加到第三级缓存中：通过<code>addSingletonFactory()</code>方法，这个方法的第二个参数，是个函数式接口，核心逻辑就是使得在第一步实例化的这个空对象提前被满足条件的<code>BeanPostProcessor</code>处理后暴露出来。(所以经过这一步骤后三级缓存中的第三级缓存工厂中添加了一个提交暴露A对象的工厂方法。)</p>
</li>
<li><p>A对象依赖注入：假设A对象需要引入的B对象是通过<code>@Autowird</code>属性注入的方式注入的，那么这时会进入到<code>AutowiredAnnotationBeanPostProcessor#postProcessProperties</code>进行属性遍历解析后注入，而在这个时间节点，B对象还未创建，所以进入B对象的创建流程。</p>
<p><strong>B对象的创建过程</strong></p>
<p>3.1 B对象实例化：这时仅通过B对象的无参构造函数创建了一个空的B对象。</p>
<p>3.2 添加B对象的提前暴露工厂：同理步骤2。(所以经过这一步骤后三级缓存中的第三级缓存工厂中又添加了一个提交暴露B对象的工厂方法。在这个时间节点，这个工厂列表中就有两个元素)。</p>
<p>3.3 B对象依赖注入：同理步骤3的前半步骤。由于这个时候去三级缓存中的一级和二级缓存中获取不到A对象，则进入第三级缓存，通过第三级缓存，获取到了A对象的提前暴露对象，同时移除第三级缓存中A的工厂对象。(这时第二级缓存中存在一个A的提前暴露对象，第三级缓存中仅剩B对象的提前暴露工厂)</p>
<p>3.4 B对象的初始化：执行一些指定初始化方法，<code>aware</code>方法等。(这时第一级缓存中就有一个创建完成的B对象，第二级缓存中存在一个A的提前暴露对象，第三级缓存中无元素) ==&gt;准确的说这个第一级缓存的添加B对象和第三级缓存中的移除提前暴露B对象的工厂操作并不是在初始化(<code>initializeBean</code>)方法中，而是在获取到B对象之后，有一个是否创建了实例的校验。具体代码在<code>DefaultSingletonBeanRegistry#getSingleton</code></p>
<p>方法的<code>finally</code>之后，有兴趣可以自行查看。</p>
<p>这时回到了A对象的注入流程，而A对象就可以获取到创建好的B对象，将B通过反射注入到自身属性中。(所以经过这一步骤后第二级缓存中存在一个A的提前暴露对象，第三级缓存中仅剩B对象的提前暴露工厂)</p>
</li>
<li><p>最后A对象的实例化：与3.4步骤同理。最后三级缓存中仅有一级缓存中存在两个元素。</p>
</li>
</ol>
<p><strong>小结：</strong>其实分析下来，整个过程并不难理解，提前暴露到二级缓存中的空对象，其实是每个<code>bean</code>创建的第一步，也就是每个<code>bean</code>都首先会经过一次创建空对象的过程，然后将这个空对象是否需要暴露的决定权，添加到第三级缓存的工厂对象中，如果出现其他对象引用的时候，则提交暴露这个空对象，让依赖对象主体持有这个空对象的引用，这样并不会影响到被依赖对象后续的注入与初始化。</p>
<p><strong>上述的创建流程是最理想的情况，而比较复杂的情况是3.3步骤中，通过第三级缓存中获取到A对象，有可能并不是在步骤1中创建的空对象 ，而是经过一些<code>BeanPostProcessor</code>处理过的代理对象，比如<code>AOP</code>代理。</strong></p>
<p>在看两个个例子：</p>
<ol>
<li>A与B分别通过<code>@Autowired</code>注入对方，且B被<code>LogAspect</code>进行<code>AOP</code>处理。这种情况下，在3.3步骤B去获取A的提前暴露对象后，B在初始化方法中经过<code>AOP</code>变成一个代理对象返回给A对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.com.xiaocainiaoya.cyclic.B.printHelloWorld(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect before&quot;</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>A与B分别通过<code>@Autowired</code>注入对方，且A被<code>LogAspect</code>进行<code>AOP</code>处理。这种情况下，在3.3步骤B去获取A的提前暴露对象时，获取的是一个代理对象，B将这个代理对象的引用挂在自身声明的A属性处后，将B对象返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.com.xiaocainiaoya.cyclic.A.printHelloWorld(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect before&quot;</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判定规则"><a href="#判定规则" class="headerlink" title="判定规则"></a>判定规则</h2><p>​    其实判定是否是循环依赖报错并不是在上面说的创建过程三个步骤中，而是在每一个对象经过这三个步骤后，要添加到<code>spring</code>容器中之前有一个判断逻辑，来进行判定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory#doCreateBean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 从三级缓存中获取提前暴露对象</span></span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 若存在, 有可能是一级缓存也有可能是二级缓存</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 比较经过实例化创建的bean和经过初始化之后的exposeObject是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            <span class="comment">// 若相等 --&gt; 将提前暴露的对象注入到容器中</span></span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">            <span class="comment">// 判断这个beanName对应的bean的依赖是否都创建完成</span></span><br><span class="line">            <span class="comment">// 若依赖都创建完成, 则将初始化的exposedObject注入到容器中</span></span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                    actualDependentBeans.add(dependentBean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                        <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                        StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                        <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Spring循环依赖(下)</title>
    <url>/2021/07/04/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="Spring循环依赖-下"><a href="#Spring循环依赖-下" class="headerlink" title="Spring循环依赖(下)"></a>Spring循环依赖(下)</h1><p>​    上文中把<code>springbean</code>的创建过程大致整理了一下，但是似乎还没有回答上文<strong>背景</strong>中提出的问题，为什么在某个方法上加了一个<code>@Async</code>注解之后，导致出现了循环依赖报错，而上文中有两个简单小例子，其中使用了<code>AOP</code>，却没有出现循环依赖报错？(如果对<code>spring</code>中的<code>AOP</code>和<code>@Async</code>实现方式有一个大概了解的话，应该知道二者都是通过生成代理对象的方式实现。)</p>
<span id="more"></span>

<p>这里举两个个例子：</p>
<ol>
<li>A对象和B对象相互依赖，且A对象中的<code>printHelloWorld</code>标记<code>@Async</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>A对象和B对象相互依赖，且A对象中的<code>printHelloWorld</code>被<code>AOP</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * cn.com.xiaocainiaoya.cyclic.A.printHelloWorld(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testPointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;testPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect before&quot;</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在第一个例子中，在创建B对象时，B通过第三级缓存中的提前暴露对象工厂获得的A对象是A在创建过程中的空对象。当A的经过初始化之后(在<code>initialization()</code>方法中会执行实现了<code>BeanPostProcessor</code>后置处理器中的<code>postProcessAfterInitialization</code>方法，而<code>@Async</code>的实现就是<code>AsyncAnnotationBeanPostProcessor</code>，经过该方法后生成的代理对象为<code>proxyA</code>)，所以就导致A对象提前暴露给B对象注入的对象与最后初始化生成的对象不一致，根据上文说的判定逻辑，最终导致循环依赖报错。</p>
<p><img src="https://i.loli.net/2021/07/04/BaP8rXsQo1Zfwdi.png" alt="循环依赖2.png"></p>
<p>​    在第二个例子中，在创建B对象时，B通过第三级缓存中的提前暴露对象工厂获取的A对象是经过<code>BeanPostProcessor</code>后置处理器的一个子扩展接口<code>SmartInstantiationAwareBeanPostProcessor</code>的<code>getEarlyBeanReference</code>方法，处理之后变为代理对象<code>proxyA</code>，(这里通过提前暴露对象的工厂获取到的就是代理对象，也就是提前暴露的对象就是代理对象)，所以进入上文的判定逻辑，正常返回。</p>
<p><img src="https://i.loli.net/2021/07/04/tjRu7AGEqvhrQL1.png" alt="循环依赖2-1.png"></p>
<p><strong>注意：</strong>二者之前的差别就是提前暴露的对象是不是代理对象。获取说是代理对象的暴露时机有所不同。那么为什么二者暴露代理对象的时机有所不同？二者都是通过<code>BeanPostProcessor</code>的实现进行处理，<code>AOP</code>实现类和<code>@Async</code>的实现类<code>AnnotationAwareAspectJAutoProxyCreator</code>和<code>AsyncAnnotationBeanPostProcessor</code>有一个很大的区别是前者实现了<code>SmartInstantiationAwareBeanPostProcessor</code>接口，在提前暴露对象工厂中，只会执行实现了这个接口的<code>getEarlyBeanReference</code>方法来获取提前暴露对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><h4 id="1-代理对象的作用范围"><a href="#1-代理对象的作用范围" class="headerlink" title="1. 代理对象的作用范围"></a>1. <strong>代理对象的作用范围</strong></h4><ul>
<li><strong><code>AsyncAnnotationBeanPostProcessor</code></strong>:<ul>
<li>它为标注了 <code>@Async</code> 的方法创建代理对象，仅拦截这些方法的调用。</li>
<li>代理的目标是实现异步执行，与整个 bean 的生命周期管理无关。</li>
<li>代理对象的创建发生在 bean 初始化后，仅用于增强方法行为，不影响依赖注入。</li>
</ul>
</li>
<li><strong><code>AbstractAutoProxyCreator</code></strong>:<ul>
<li>它的代理通常覆盖整个 bean，拦截所有方法调用。</li>
<li>它的目的是实现 AOP 功能（如事务管理、权限验证等），可能影响依赖注入。</li>
<li>代理对象需要提前暴露，以确保循环依赖场景下，其他 bean 引用的是代理对象。</li>
</ul>
</li>
</ul>
<h4 id="2-代理创建时机"><a href="#2-代理创建时机" class="headerlink" title="2. 代理创建时机"></a>2. <strong>代理创建时机</strong></h4><ul>
<li><strong><code>AsyncAnnotationBeanPostProcessor</code></strong>:<ul>
<li>创建代理发生在 <code>postProcessAfterInitialization</code> 阶段。此时，bean 已经完成了依赖注入和初始化。</li>
<li>不涉及循环依赖，因为它仅修改方法调用，不影响 bean 的结构或生命周期。</li>
</ul>
</li>
<li><strong><code>AbstractAutoProxyCreator</code></strong>:<ul>
<li>代理创建发生在 <code>postProcessBeforeInstantiation</code> 或 <code>getEarlyBeanReference</code> 阶段，以确保在循环依赖场景下，能够提前暴露代理对象。</li>
<li>需要通过 <code>SmartInstantiationAwareBeanPostProcessor</code> 来参与三级缓存的管理，确保依赖注入过程中代理对象被正确使用。</li>
</ul>
</li>
</ul>
<h4 id="3-是否需要支持循环依赖"><a href="#3-是否需要支持循环依赖" class="headerlink" title="3. 是否需要支持循环依赖"></a>3. <strong>是否需要支持循环依赖</strong></h4><ul>
<li><strong><code>AsyncAnnotationBeanPostProcessor</code></strong>:<ul>
<li>不需要支持循环依赖。异步方法的功能是在运行时拦截，而不是在依赖注入阶段。</li>
<li>因此，它无需实现 <code>SmartInstantiationAwareBeanPostProcessor</code> 或 <code>getEarlyBeanReference</code>。</li>
</ul>
</li>
<li><strong><code>AbstractAutoProxyCreator</code></strong>:<ul>
<li>必须支持循环依赖，确保代理对象在注入过程中被正确引用。</li>
<li>如果不实现 <code>SmartInstantiationAwareBeanPostProcessor</code>，在循环依赖场景中，注入的对象将是原始对象而非代理对象，从而导致 AOP 功能失效。</li>
</ul>
</li>
</ul>
<h4 id="4-功能的复杂性和设计目标"><a href="#4-功能的复杂性和设计目标" class="headerlink" title="4. 功能的复杂性和设计目标"></a>4. <strong>功能的复杂性和设计目标</strong></h4><ul>
<li><strong><code>AsyncAnnotationBeanPostProcessor</code></strong>:<ul>
<li>其设计目标是简单、专注于异步方法的增强。它不需要处理复杂的依赖注入逻辑，也不需要参与 Spring 的三级缓存机制。</li>
<li>通过后处理阶段（<code>postProcessAfterInitialization</code>）创建代理，已经足够满足其功能需求。</li>
</ul>
</li>
<li><strong><code>AbstractAutoProxyCreator</code></strong>:<ul>
<li>它是 Spring AOP 的核心组件，必须适应各种复杂场景，包括循环依赖、动态代理、BeanFactory 后处理等。</li>
<li>实现 <code>SmartInstantiationAwareBeanPostProcessor</code> 是为了更通用地处理代理对象的提前暴露问题。</li>
</ul>
</li>
</ul>
<h3 id="为什么设计如此"><a href="#为什么设计如此" class="headerlink" title="为什么设计如此"></a>为什么设计如此</h3><p><code>AsyncAnnotationBeanPostProcessor</code> 的设计默认假设使用异步方法的场景通常不会涉及循环依赖。这种假设在大多数实际应用中是成立的：</p>
<ul>
<li>通常，<code>@Async</code> 的方法会在较独立的组件中定义，而这些组件一般不会与其他 bean 存在复杂的相互依赖关系。</li>
<li>异步方法的调用者和被调用者通常是解耦的，调用者通过 Spring 的线程池机制执行异步任务，而不是直接依赖被调用者。</li>
</ul>
<h3 id="3-如何解决循环依赖问题"><a href="#3-如何解决循环依赖问题" class="headerlink" title="3. 如何解决循环依赖问题"></a>3. 如何解决循环依赖问题</h3><p>如果在使用 <code>@Async</code> 时确实遇到循环依赖的问题，有几种解决方法：</p>
<h4 id="方法-1-通过重构解除循环依赖"><a href="#方法-1-通过重构解除循环依赖" class="headerlink" title="方法 1: 通过重构解除循环依赖"></a>方法 1: 通过重构解除循环依赖</h4><ul>
<li>重新设计 bean 的依赖关系，减少相互依赖。</li>
<li>将 <code>@Async</code> 方法抽取到一个独立的组件中，确保其与其他依赖分离。</li>
</ul>
<h4 id="方法-2-手动提前暴露代理对象"><a href="#方法-2-手动提前暴露代理对象" class="headerlink" title="方法 2: 手动提前暴露代理对象"></a>方法 2: 手动提前暴露代理对象</h4><ul>
<li>使用 <code>@Lazy</code> 注解延迟加载其中一个依赖，避免循环依赖。</li>
<li>或者在某些特殊情况下，可以通过自定义 <code>BeanPostProcessor</code> 提前创建代理对象，但这种做法会增加复杂性。</li>
</ul>
<h4 id="方法-3-使用其他异步实现"><a href="#方法-3-使用其他异步实现" class="headerlink" title="方法 3: 使用其他异步实现"></a>方法 3: 使用其他异步实现</h4><ul>
<li>如果循环依赖问题无法避免，可以考虑使用其他异步调用机制（如直接使用 <code>ExecutorService</code>），避免 <code>@Async</code> 带来的代理问题。</li>
</ul>
<h4 id="方法-4-引入显式的分层设计"><a href="#方法-4-引入显式的分层设计" class="headerlink" title="方法 4: 引入显式的分层设计"></a>方法 4: 引入显式的分层设计</h4><ul>
<li>将异步逻辑和依赖逻辑分离到不同的服务层，减少交叉依赖。</li>
</ul>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Spring注解</title>
    <url>/2021/08/30/Spring/Spring%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>​    <code>spring</code>为了减少过多<code>xml</code>的配置，减轻开发者的配置负担，提供了通过注解的方式进行<code>bean</code>对象的加载。并且在单一注解的基础上增加了一些模式上的约定。</p>
<span id="more"></span>

<p>​    比如<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>，实际上它们的作用都是将标记的类生成对应的<code>bean</code>对象之后添加到<code>IOC</code>容器中，通过精细注解的方式，为注解带来一些语义。使得可以更直观的看出一些分层行为。再比如<code>springboot</code>中扩展了<code>spring</code>的<code>@Condition</code>注解，通过<code>@OnXXXConditon</code>的方式标记某个类是否需要进行加载到<code>IOC</code>容器。</p>
<h2 id="二、注解"><a href="#二、注解" class="headerlink" title="二、注解"></a>二、注解</h2><p>​    在注解上标记的注解称为元注解。比如在<code>@Service</code>注解之上标记<code>@Component</code>注解。使得<code>@Service</code>拥有将标记类加载为<code>Bean</code>对象后添加到<code>IOC</code>容器中的能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-AliasFor"><a href="#2-1-AliasFor" class="headerlink" title="2.1 AliasFor"></a>2.1 AliasFor</h3><p>别名注解，在注解创建时，有的时候为了加深语义以及向前兼容的原则，可以通过别名的方式进行创建新字段。比如以下例子，<code>value</code>和<code>path</code>互为别名。在日常使用中<code>path</code>更能体现访问路径的语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">  String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-使用"><a href="#2-1-1-使用" class="headerlink" title="2.1.1 使用"></a>2.1.1 使用</h4><p>​    在使用上基本上是标记两个注解属性互为别名，但若使用不当，仅在一方上标记为另一方的别名，这时实际上效果和互相标记一致，只是这样就降低了可读性，所以为了提高可读性和隐式别名带来的值覆盖，还是应该遵守规范，进行相互标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@AliasFor</span> 别名注解测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/08/30 22:24:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AliaForAnnotation &#123;</span><br><span class="line">    <span class="meta">@AliasFor(value = &quot;path&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@AliasFor(value = &quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  AliaForAnnotation aliaForAnnotation = AnnotationUtils.getAnnotation(SpringMvcStart.class, AliaForAnnotation.class);</span><br><span class="line">  System.out.println(<span class="string">&quot;value:&quot;</span> + aliaForAnnotation.value());</span><br><span class="line">  System.out.println(<span class="string">&quot;path:&quot;</span> + aliaForAnnotation.path());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>spring</code>中除了在一个注解中相互标记互为注解之外，还可以对组合注解进行相互标记，同时别名具有传递性。</p>
<ol>
<li>显示标记：标记一个注解中的两个注解属性互为别名</li>
<li>隐式标记：<code>A</code>注解的<code>a</code>属性标记为<code>C</code>注解的<code>c</code>的别名，<code>B</code>注解的<code>b</code>属性标记为<code>C</code>注解的<code>c</code>的别名，那么可以得出<code>A</code>注解的<code>a</code>属性也是<code>B</code>注解的<code>b</code>属性的别名。</li>
</ol>
<p>在<code>PostMapping</code>注解中，<code>name</code>属性就是<code>RequestMapping</code>注解中<code>name</code>的别名，<code>value</code>属性就是<code>RequestMapping</code>注解中<code>value</code>的别名，所以当在声明<code>@PostMapping(value = &quot;/xx/x&quot;)</code>的时候，不论是直接获取<code>PostMapping</code>注解后获取<code>value</code>值，还是通过元注解获取<code>RequestMapping</code>后获取它的<code>value</code>值，都为<code>/xx/x</code>。在更为复杂的场景下，不会别名链有多长，若存在隐式标记都可能存在值的传递性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostMapping &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#name&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Alias for &#123;<span class="doctag">@link</span> RequestMapping#value&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@AliasFor(annotation = RequestMapping.class)</span></span><br><span class="line">  String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Conditional"><a href="#2-2-Conditional" class="headerlink" title="2.2 Conditional"></a>2.2 Conditional</h3><p>在<code>spring</code>中提供了条件注解<code>@Conditional</code>，用于判断在某种场景下是否需要加载某个类为<code>Bean</code>对象。在<code>springboot</code>中将其扩展之后，使用上更为方便。</p>
<h4 id="2-2-1-使用"><a href="#2-2-1-使用" class="headerlink" title="2.2.1 使用"></a>2.2.1 使用</h4><p>创建一个注解<code>ConditionalOnDev</code>，且使用<code>@Conditional</code>指定条件类为<code>DevCondition</code>。当<code>ConditionalOnEnviroment</code>配置类被加载，要创建<code>enviroment</code>对象之前，会进入条件类的<code>matches</code>方法，若该方法返回<code>true</code>则表示允许将这个<code>bean</code>对象添加到<code>IOC</code>容器中，反之不处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(DevCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnDev &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单演示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalOnEnviroment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnDev(value = &quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Environment <span class="title">enviroment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dev();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上示例，若对<code>springboot</code>有所了解，应该知道<code>springboot</code>中存在大量的<code>@OnXxxCondition</code>，它就是利用<code>spring</code>提供的条件控制注解的方式。比如在<code>springboot</code>中有<code>@OnBeanCondition</code>、<code>@OnClassCondition</code>、<code>@OnResourceCondition</code>等等。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok的@SneakyThrows详解</title>
    <url>/2021/04/13/Spring/lombok%E7%9A%84@SneakyThrows%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="Lombok的-SneakyThrows详解"><a href="#Lombok的-SneakyThrows详解" class="headerlink" title="Lombok的@SneakyThrows详解"></a>Lombok的@SneakyThrows详解</h4><p>[TOC]</p>
<h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>​    在<code>java</code>的异常体系中<code>Exception</code>异常有两个分支，一个是运行时异常<code>RuntimeException</code>，一个是编译时异常，在<code>Exception</code>下的所有非<code>RuntimeException</code>异常，比如<code>IOException</code>、<code>SQLException</code>等；所有的运行时异常不捕获，编译时异常是一定要捕获，否则编译会报错。<code>@SneakyThrows</code>就是利用了这一机制，将当前方法抛出的异常，包装成<code>RuntimeException</code>，骗过编译器，使得调用点可以不用显示处理异常信息。</p>
<span id="more"></span>

<h4 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 若不使用@SneakyThrows注解，newInsstance方法会要求抛出InstantiationException, </span></span><br><span class="line"><span class="comment"> * IllegalAccessException异常，且调用sneakyThrowsTest()的地方需要捕获这些异常，</span></span><br><span class="line"><span class="comment"> * 加上@SneakyThrows注解之后就不需要捕获异常信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SneakyThrowsDemo.class.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如下为反编译之后的结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HelloController.class.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="comment">// 调用Lombok方法转化为RuntimeException</span></span><br><span class="line">      <span class="keyword">throw</span> Lombok.sneakyThrow(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== ombok =========</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">sneakyThrow</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Lombok.&lt;RuntimeException&gt;sneakyThrow0(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个方法是关键，这里对入参类型的约束为&lt;T extends Throwable&gt;，而调用点将异常强转为</span></span><br><span class="line"><span class="comment"> * RuntimeException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function">T <span class="title">sneakyThrow0</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> (T)t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，为什么这个地方可以对原来的异常进行强转为<code>RuntimeExcption</code>？以下为直接强转的代码，显然运行之后报类型转换异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sneakyThrowsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		<span class="comment">// 直接将e强转为RuntimeException，运行到这里会报类型转换异常。</span></span><br><span class="line">    <span class="keyword">throw</span> (RuntimeException)e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这种做法是一种通过泛型欺骗了编译器，让编译器在编译期不报错(报警告)，而最后在<code>JVM</code>虚拟机中执行的字节码的并没有区别编译时异常和运行时异常，只有是不是和抛不抛异常而已。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-statemachine入门</title>
    <url>/2023/07/15/Spring/spring-statemachine%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="spring-statemachine入门"><a href="#spring-statemachine入门" class="headerlink" title="spring-statemachine入门"></a>spring-statemachine入门</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring-statemachine</code>是<code>spring</code>设计于处理状态的变化，以及定义状态之间的转换规则。</p>
<span id="more"></span>

<p><strong>状态机的基本组成</strong></p>
<p>状态机主要由4要素组成：</p>
<ul>
<li>现态：当前所处的状态。</li>
<li>条件：或者称为“事件”，在状态转换图中使用箭头标识，当满足某个条件（触发某个事件）之后，由一个状态转移到另一个状态。比如下图中“支付”这个箭头。</li>
<li>动作：表示由现态转换到次态之后，需要执行的动作，不是必须的，可以是转换转换后不执行任何动作。比如下图中从[待收货]转换到[已收货]是否设置某个动作。</li>
<li>次态：下一环状态。</li>
</ul>
<p>​    比如一个支付下单流程的状态转换图：</p>
<p><img src="https://s2.loli.net/2023/07/15/a71AErSKG2TLFNw.png" alt="状态装换图.png"></p>
<p>​    订单的开始状态为[待支付]，当用户支付之后状态流转为[已支付]，这个地方是个分支节点，当状态流转到[已支付]后，根据一些业务规则，将状态流转到[待收货]或者[待开票]，若是[待收货]，通过收货行为，使状态流转到[结束];若是[待开票]状态，通过投递行为，使状态流转到[结束]。</p>
<h2 id="Spring-stateMachine"><a href="#Spring-stateMachine" class="headerlink" title="Spring stateMachine"></a>Spring stateMachine</h2><p><code>Spring StateMachine</code>是一个基于 <code>Spring</code>框架的状态机框架，使用<code>Spring StateMachine</code>可以方便地在 <code>Java</code>应用中实现状态机功能，并可以与<code>Spring</code>框架的其他功能结合使用。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><b>1.添加依赖</b></p>
<p>我这里使用的是<code>springboot</code>工程，最好先引入官方提供的<code>spring-statemachine-bom</code>，这样基本上不会出现与<code>spring framework</code>版本不对应，出现的一些无法解释的坑。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><b>2.订单状态枚举类</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StateEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UNPAID(<span class="string">&quot;unpaid&quot;</span>,<span class="string">&quot;待支付&quot;</span>),</span><br><span class="line">    PAID(<span class="string">&quot;paid&quot;</span>,<span class="string">&quot;已支付&quot;</span>),</span><br><span class="line">    WAITING_FOR_RECEIVE(<span class="string">&quot;waitingForReceive&quot;</span>,<span class="string">&quot;待收货&quot;</span>),</span><br><span class="line">    DONE(<span class="string">&quot;done&quot;</span>,<span class="string">&quot;结束&quot;</span>),</span><br><span class="line">    INVOICE(<span class="string">&quot;invoice&quot;</span>, <span class="string">&quot;开票&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    StateEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StateEnum <span class="title">getByState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (StateEnum stateEnum : StateEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stateEnum.getType().equals(state)) &#123;</span><br><span class="line">                <span class="keyword">return</span> stateEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>3.事件枚举类</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EventEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PAY(<span class="string">&quot;pay&quot;</span>,<span class="string">&quot;支付&quot;</span>),</span><br><span class="line">    RECEIVE(<span class="string">&quot;receive&quot;</span>,<span class="string">&quot;收货&quot;</span>),</span><br><span class="line">    DELIVERY(<span class="string">&quot;delivery&quot;</span>,<span class="string">&quot;发货&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    EventEnum(String type, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>4.状态机配置</b></p>
<p>状态机配置类中包含状态配置、状态转换事件关系配置、监听器配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 这里最好手动设置name， 如果不设置, 默认使用stateMachineFactory这个名字, 由于这个类</span></span><br><span class="line"><span class="comment">// 需要注入到spring容器中, 如果需要创建两个不一样的状态机会出现重名的冲突。</span></span><br><span class="line"><span class="meta">@EnableStateMachineFactory(name = &quot;feeStateMachineFactory&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeeStateMachineConfig</span> <span class="keyword">extends</span> <span class="title">StateMachineConfigurerAdapter</span>&lt;<span class="title">StateEnum</span>, <span class="title">EventEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态: 初始状态、</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineStateConfigurer&lt;StateEnum, EventEnum&gt; states)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        states.withStates()</span><br><span class="line">            <span class="comment">// 初始状态</span></span><br><span class="line">            .initial(StateEnum.UNPAID)</span><br><span class="line">            <span class="comment">// 分支节点, 如果存在分支节点, 必须要在这里声明</span></span><br><span class="line">            .choice(StateEnum.PAID)</span><br><span class="line">            <span class="comment">// 状态的所有值</span></span><br><span class="line">            .states(EnumSet.allOf(StateEnum.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态机监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2023/7/14 16:04:34</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineConfigurationConfigurer&lt;StateEnum, EventEnum&gt; config)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        config.withConfiguration()</span><br><span class="line">            <span class="comment">// 设置全局监听器</span></span><br><span class="line">            .listener(listener())</span><br><span class="line">            <span class="comment">// 设置状态机的ID, 可以认为是状态机的名称，在通过StateMachineFactory.getStateMachine()需要通过这个名称获取</span></span><br><span class="line">            <span class="comment">// 在测试的过程中发现, 有些人写的文章里没有设置这个名称, 然后在使用StateMachineFactory.getStateMachine(machineId)</span></span><br><span class="line">            <span class="comment">// 中的machineId使用的是数据库中查出的订单ID, 这样的写法在不使用OnTransition相关监听注解是不会有问题，但是如果</span></span><br><span class="line">            <span class="comment">// 需要使用到@OnTransition相关注解就会导致无法进入到这个注解标记的方法中。</span></span><br><span class="line">            .machineId(<span class="string">&quot;stateMachine&quot;</span>)</span><br><span class="line">            .autoStartup(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置状态转换和事件的转换关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transitions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(StateMachineTransitionConfigurer&lt;StateEnum, EventEnum&gt; transitions)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        transitions</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.UNPAID)</span><br><span class="line">            .target(StateEnum.PAID)</span><br><span class="line">            .event(EventEnum.PAY)</span><br><span class="line">            <span class="comment">// guard()守卫函数，状态转移后进入, 如果返回的是true, 才进入到action方法中。</span></span><br><span class="line">            .guard(<span class="keyword">new</span> Guard&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(StateContext&lt;StateEnum, EventEnum&gt; context)</span> </span>&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;进入订单守卫函数&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.UNPAID.getValue(), StateEnum.PAID.getValue()))</span><br><span class="line">        .and()</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">            .target(StateEnum.DONE)</span><br><span class="line">            .event(EventEnum.RECEIVE)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.WAITING_FOR_RECEIVE.getValue(), StateEnum.DONE.getValue()))</span><br><span class="line">        .and()</span><br><span class="line">            <span class="comment">// 表示分支</span></span><br><span class="line">            .withChoice()</span><br><span class="line">            .source(StateEnum.PAID)</span><br><span class="line">            <span class="comment">// 类似于 if(first的第二个参数的方法如果是true)则进入到first第一个参数的状态，并进入first第三个参数的action</span></span><br><span class="line">            <span class="comment">// 如果first的第二个参数返回的是false，则进入到last的第一个参数状态，并进入到first第二个参数的atction</span></span><br><span class="line">            .first(StateEnum.INVOICE, ctx -&gt; (<span class="keyword">boolean</span>) Optional.ofNullable(ctx.getMessage().getHeaders().get(<span class="string">&quot;invoice&quot;</span>)).orElse(<span class="keyword">true</span>), ctx -&gt; log.info(<span class="string">&quot;进入发票分支&quot;</span>))</span><br><span class="line">            .last(StateEnum.WAITING_FOR_RECEIVE, ctx -&gt; log.info(<span class="string">&quot;进入收货分支&quot;</span>))</span><br><span class="line">        .and()</span><br><span class="line">            .withExternal()</span><br><span class="line">            .source(StateEnum.INVOICE)</span><br><span class="line">            .target(StateEnum.WAITING_FOR_RECEIVE)</span><br><span class="line">            .event(EventEnum.DELIVERY)</span><br><span class="line">            .action(ctx -&gt; log.info(<span class="string">&quot;action状态变更:&#123;&#125; -&gt; &#123;&#125;.&quot;</span>, StateEnum.INVOICE.getValue(), StateEnum.WAITING_FOR_RECEIVE.getValue()))</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StateMachineListener&lt;StateEnum, EventEnum&gt; <span class="title">listener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StateMachineListenerAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当状态的转移在configure方法配置中时，会走到该方法。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;StateEnum, EventEnum&gt; transition)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;listener[&#123;&#125;]状态变更:&#123;&#125; -&gt; &#123;&#125;&quot;</span>, transition.getKind().name(),</span><br><span class="line">                    transition.getSource() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getSource().getId()),</span><br><span class="line">                    transition.getTarget() == <span class="keyword">null</span> ? <span class="string">&quot;NULL&quot;</span> : ofNullableState(transition.getTarget().getId()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当发生的状态转移不在configure方法配置中时，会走到该方法，此处打印error日志，方便排查状态转移问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;EventEnum&gt; event)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;事件未收到: &#123;&#125;&quot;</span>, event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> Object <span class="title">ofNullableState</span><span class="params">(StateEnum s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.ofNullable(s)</span><br><span class="line">                    .map(StateEnum::getValue)</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><b>4.测试调用</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.sendEvent(MessageBuilder.withPayload(EventEnum.PAY)</span><br><span class="line">                    .setHeader(JSON_STR, JSON.toJSONString(feeOrder))</span><br><span class="line">                    .build())</span><br></pre></td></tr></table></figure>

<h3 id="使用注解方式配置监听器"><a href="#使用注解方式配置监听器" class="headerlink" title="使用注解方式配置监听器"></a>使用注解方式配置监听器</h3><p>​    前面说到，如果需要使用注解方式配置监听器，一定一定要注意<code>machineId</code>的赋值。因为可以通过多种方式来处理状态转移之后的监听，所以并不一定所有人在使用时都会使用这种方式，但是使用这种方式就是一定要注意<code>machineId</code>的赋值问题。(可以在定义配置时就设置<code>action</code>也可以达到状态转移后进入某个函数进行相关处理。)</p>
<p>​    <code>spring stateMachine</code>中设置的监听，这些监听都有设置对应的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateMachineListener</span>&lt;<span class="title">S</span>,<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(State&lt;S,E&gt; from, State&lt;S,E&gt; to)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateEntered</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateExited</span><span class="params">(State&lt;S,E&gt; state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eventNotAccepted</span><span class="params">(Message&lt;E&gt; event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transition</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transitionStarted</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transitionEnded</span><span class="params">(Transition&lt;S, E&gt; transition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineStarted</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineStopped</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateMachineError</span><span class="params">(StateMachine&lt;S, E&gt; stateMachine, Exception exception)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extendedStateChanged</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateContext</span><span class="params">(StateContext&lt;S, E&gt; stateContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过注解的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> :xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/7/15 09:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@WithStateMachine</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnTransition(target = &quot;UNPAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@StatesOnTransition</span></span><br><span class="line">    <span class="meta">@OnTransition(source = &quot;UNPAID&quot;, target = &quot;PAID&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Message&lt;EventEnum&gt; obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取消息中的订单对象</span></span><br><span class="line">        <span class="comment">//Order order = (Order) message.getHeaders().get(&quot;order&quot;);</span></span><br><span class="line">        <span class="comment">// 设置新状态</span></span><br><span class="line">        <span class="comment">//order.setStates(States.WAITING_FOR_RECEIVE);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户支付完毕，状态机反馈信息：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>​    一般来说，我们的处理逻辑为从状态机工程中获取到一个状态机，但是不一定说每一台状态机都是从初始状态开始走，有可能订单目前处在某个状态，但是由于一些原因重启了服务，那么这是如果重新创建状态机那么状态需要从头开始走，这显然不符合逻辑，所以在获取到状态机之后，需要为这台状态机重新赋状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从状态机工厂获取一个状态机</span></span><br><span class="line">stateMachine = feeStateMachineFactory.getStateMachine(<span class="string">&quot;stateMachine&quot;</span>);</span><br><span class="line">stateMachine.stop();</span><br><span class="line">stateMachine.getStateMachineAccessor().doWithAllRegions(sma -&gt; &#123;</span><br><span class="line">    <span class="comment">//配置状态机拦截器，当状态发生转移时，会走到该拦截器中</span></span><br><span class="line">    sma.addStateMachineInterceptor(<span class="keyword">new</span> StateMachineInterceptorAdapter&lt;StateEnum, EventEnum&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preStateChange</span><span class="params">(State&lt;StateEnum, EventEnum&gt; state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Message&lt;EventEnum&gt; message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Transition&lt;StateEnum, EventEnum&gt; transition,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; stateMachine,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    StateMachine&lt;StateEnum, EventEnum&gt; rootStateMachine)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;preStateChange&quot;</span>);</span><br><span class="line">            FeeOrder result = JSON.parseObject(String.class.cast(message.getHeaders().get(JSON_STR)), FeeOrder.class);</span><br><span class="line">            <span class="comment">//更新状态机转移后的状态</span></span><br><span class="line">            result.setOrderStatus(state.getId().getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//将状态机的初始状态配置为DB中对应状态</span></span><br><span class="line">    sma.resetStateMachine(<span class="keyword">new</span> DefaultStateMachineContext&lt;&gt;(stateEnum, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;stateMachine&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动状态机</span></span><br><span class="line">stateMachine.start();</span><br></pre></td></tr></table></figure>

<p>​    尽管可以手动对状态机赋状态，但是这种方式也解决不了根本问题，以订单为例子，如果用户在发起创建订单之后，订单处在待支付状态，然后用户一直没有去支付，这时出现需要重启服务器的情况；或者如果部署了多个实例，某一台实例中状态机处在待支付状态，而用户去支付时请求走到了另一台服务器，这时在另一台服务器上状态走到了待开票，如果开票的请求又走到了原本处在待支付状态的服务器上呢？所以这里就变成必须与数据库中的订单状态实时校验？</p>
<p>所以这里引入的持久化。主要针对于故障恢复、可恢复性、长时间运行等情况。</p>
<p>持久化有多种方式，基于内存、基于<code>db</code>、基于<code>redis</code>、基于<code>MongoDB</code>等，这里以<code>redis</code>为例。</p>
<p><b>1.引入依赖</b></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.statemachine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-statemachine-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><b>2.redis配置</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachinePersisterConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Redis持久化配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisStateMachinePersister&lt;StateEnum, EventEnum&gt; <span class="title">persister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt; repository</span><br><span class="line">            = <span class="keyword">new</span> RedisStateMachineContextRepository&lt;StateEnum, EventEnum&gt;(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisStateMachinePersister&lt;&gt;(<span class="keyword">new</span> RepositoryStateMachinePersist&lt;&gt;(repository));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>3.使用redis进行持久化</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sendEvent</span><span class="params">(Events changeEvent, Order order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      stateMachine.start();</span><br><span class="line">      <span class="comment">//尝试恢复状态机状态</span></span><br><span class="line">      stateMachineMemPersister.restore(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">      Message message = MessageBuilder.withPayload(changeEvent)</span><br><span class="line">              .setHeader(<span class="string">&quot;order&quot;</span>, order).build();</span><br><span class="line">      result = stateMachine.sendEvent(message);</span><br><span class="line">      <span class="comment">//持久化状态机状态</span></span><br><span class="line">      stateMachineMemPersister.persist(stateMachine, String.valueOf(order.getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;操作失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      stateMachine.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    <code>spring stateMachine</code>在简单实用之后感觉虽然在一定层度上对状态装换过程的代码编写风格进行了解耦，但是感觉由于<code>spring stateMachine</code>有点过于重量化，导致如果使用不当容易出现一些不可预判、出乎意料之外的问题。就比如之前提到的版本不对应监听注解失效的问题，在使用过程中它也不会报错，仅仅是始终无法进入到对应的注解中；还比如<code>choice</code>分支的问题、状态机不持久化带来的问题、若使用了持久化，持久化带来的问题等。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>spring事件监听机制</title>
    <url>/2021/09/12/Spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="spring事件监听机制"><a href="#spring事件监听机制" class="headerlink" title="spring事件监听机制"></a>spring事件监听机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>spring</code>事件监听机制实际上就是一个典型的观察者模式，在观察者模式的基础之上进行的抽象和处理。使得开发者可以根据自己的业务特点依附于<code>spring</code>容器进行事件的注册、发布、处理。</p>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>1.创建一个类继承于顶层事件类<code>ApplicationEvent</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendNotificationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SendNotificationVo sendNotificationVo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendNotificationEvent</span><span class="params">(ApplicationContext source, SendNotificationVo sendNotificationVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.sendNotificationVo = sendNotificationVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.监听到对应的事件后的业务处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.调用点发送具体的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>以上就是最简单的<code>spring</code>事件监听的使用。在具体的应用场景中，并不会这么简单的使用，因为若在业务逻辑上需要解耦，大部分还是希望是异步的方式进行事件的处理，然而在默认的情况下，这种模式是同步机制，也就是说待到具体的事件监听处理完成之后，才会继续执行调用点的业务逻辑。</p>
<h2 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h2><h3 id="1-广播器异步"><a href="#1-广播器异步" class="headerlink" title="1.广播器异步"></a>1.广播器异步</h3><p>​    在<code>spring</code>的事件监听机制中已经考虑到异步的情况，所以在事件发送器发送事件时，会判断是否存在广播器，当存在广播器时，会将具体的监听执行逻辑转移到广播器对应的线程池中。来跟踪一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        publishEvent((Object) event);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体子类实现接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现在<code>AbstractApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取广播器, 并调用广播器对应的发送事件处理</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认仅有一个广播器的实现<code>SimpleApplicationEventMulticaster</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 获取对应的广播器线程池</span></span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="comment">// 获取这个event对应类型的所有监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="comment">// 若是配置了线程池, 则将监听任务转移到线程池中执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若是没有配置线程池, 执行执行监听任务, 所以在默认情况下与具体的业务逻辑是同步执行。</span></span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体事件监听的执行逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 具体执行监听逻辑</span></span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实际上就是ApplicationListener的onApplicationEvent方法</span></span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        String msg = ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">            Log logger = LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚上面介绍的最简单的使用方式中采用的<code>@EventListener</code>的方式来标记监听器的位置，实际上在初始化这个<code>bean</code>对象时，扫描到<code>@EventListener</code>后会将这个对应的方式转化为<code>ApplicationListenerMethodAdapter</code>类，该类中包含了<code>bean</code>名称、类名称、监听处理<code>method</code>等等，待到接收到事件时，通过反射调用对应的监听处理方法。</p>
<h3 id="2-Async注解异步"><a href="#2-Async注解异步" class="headerlink" title="2.@Async注解异步"></a>2.@Async注解异步</h3><p>​    虽然在事件发送器中内置了广播器线程池，但是若不进行配置，则它还是同步的方式执行，在它同步执行的基础上，若是利用<code>spring</code>的异步机制，也可以达到异步的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotificationEventListener</span><span class="params">(SendNotificationEvent event)</span> </span>&#123;</span><br><span class="line">        SendNotificationVo sendNotificationVo = event.getSendNotificationVo();</span><br><span class="line">        <span class="comment">// 具体的监听到事件之后的业务处理。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，在<code>spring</code>容器初始化时，扫描到这个<code>bean</code>对象并进行初始化时，会为这个<code>bean</code>创建一个代理类，由这个代理类来执行相应的异步逻辑。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>以上看似已经解决的异步的问题，但是在实际的使用过程中又发现如果事件发送点存在事务管理，就会导致事件中获取不到事件发送点的某些数据。(由于事件监听处理触发时，事件发送点还未提交事务。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪代码, 在事件监听的处理中, 通过id=123可能存在获取不到这条数据的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/09/12 13:54:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SendNotificationVo sendNotificationVo = SendNotificationVo.builder()</span><br><span class="line">            .id(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">            .status(<span class="string">&quot;200&quot;</span>).build();</span><br><span class="line">    mapper.insert(sendNotificationVo);</span><br><span class="line">    SendNotificationEvent event = <span class="keyword">new</span> SendNotificationEvent(springApplicationUtil.applicationContext, sendNotificationVo);</span><br><span class="line">    springApplicationUtil.applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是、但是、但是这种情况<code>spring</code>也考虑到了，<code>spring</code>监听机制中通过使用<code>@TransactionalEventListener</code></p>
<p>来解决这个问题。<code>@TransactionalEventListener</code>它的元注解为<code>@EventListener</code>，所以本质上也是个<code>@EventListener</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 事件触发阶段: 比如事务提交之前、事务提交之后等, 默认是在事务提交之后</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function">TransactionPhase <span class="title">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 若调用点无事务管理也触发, 默认情况下若调用点无事务接管, 该监听处理不会触发</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Alias for &#123;<span class="doctag">@link</span> #classes&#125;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The event classes that this listener handles.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚上面说到在<code>spring</code>扫描到对应的监听器处理<code>bean</code>时，会根据方法上标记的注解将监听器转换为对应的处理类。根据不同的两个注解<code>@TransactionalEventListener</code>和<code>EventListener</code>对应两个不同的生成监听类工厂<code>DefaultEventListenerFactory</code>和<code>TransactionalEventListenerFactory</code>，由它们来创建具体的监听处理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp; AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp; !isSpringContainerClass(targetType)) &#123;</span><br><span class="line">        Map&lt;Method, EventListener&gt; annotatedMethods = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从bean的class对象中找出含有@EventListener注解的方法, 存在Map&lt;Method, EventListener&gt;中</span></span><br><span class="line">            <span class="comment">// @TransactionListener方法也会被匹配, 因为它的元注解是@EventListener</span></span><br><span class="line">            annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">                    (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">                            AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// An unresolvable type in a method signature, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Could not resolve methods for bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No @EventListener annotations found on bean class: &quot;</span> + targetType.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Non-empty set of methods</span></span><br><span class="line">            ConfigurableApplicationContext context = <span class="keyword">this</span>.applicationContext;</span><br><span class="line">            Assert.state(context != <span class="keyword">null</span>, <span class="string">&quot;No ApplicationContext set&quot;</span>);</span><br><span class="line">            List&lt;EventListenerFactory&gt; factories = <span class="keyword">this</span>.eventListenerFactories;</span><br><span class="line">            Assert.state(factories != <span class="keyword">null</span>, <span class="string">&quot;EventListenerFactory List not initialized&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">                <span class="comment">// 获取监听工厂, 这里有两个工厂:DefaultEventListenerFactory和TransactionalEventListenerFactory</span></span><br><span class="line">                <span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">                    <span class="comment">// 判断这个被标记的方法适配哪个工厂</span></span><br><span class="line">                    <span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line">                        Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                        <span class="comment">// 使用工厂创建对应的监听器对象</span></span><br><span class="line">                        ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                        <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">                            ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="keyword">this</span>.evaluator);</span><br><span class="line">                        &#125;</span><br><span class="line">                        context.addApplicationListener(applicationListener);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(annotatedMethods.size() + <span class="string">&quot; @EventListener methods processed on bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + annotatedMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这两个工厂生成出来的监听类，实际上是两个适配器，<code>ApplicationListenerMethodAdapter</code>和<code>ApplicationListenerMethodTransactionalAdapter</code>，由这两个适配器来执行相应的处理逻辑。这里要感叹下<code>spring</code>设计的精妙，一环扣一环，扩展性极强。</p>
<p>这里分析下<code>ApplicationListenerMethodTransactionalAdapter</code>中对应的监听触发方法<code>onApplicationEvent</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// publish事件时: 创建一个TransactionSynchronization对象, 这个对象持有event</span></span><br><span class="line">        <span class="comment">// 创建TransactionSynchronizationEventAdapter</span></span><br><span class="line">        TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event);</span><br><span class="line">        <span class="comment">// 注册到事务管理器中</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Processing &quot;</span> + event + <span class="string">&quot; as a fallback execution on AFTER_ROLLBACK phase&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反射调用进行事件的处理</span></span><br><span class="line">        processEvent(event);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No transactional event execution at all</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;No transaction is active - skipping &quot;</span> + event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本以为采用这种方式之后，就解决了对应的异步+调用点事务的问题。在测试中发现：若采用广播器实现异步，极大可能获取不到调用点事务内数据；而采用<code>@Async</code>实现异步百分百可以获取到调用点事务内数据。</p>
<p>简单跟踪发现：</p>
<ul>
<li>广播器方式实现异步，是将<code>onApplicationEvent</code>方法的触发丢入线程池。</li>
<li><code>@Async</code>方式实现异步，走下方<code>else</code>逻辑，在事件发送器中走同步逻辑，是直接执行<code>onApplicationEvent</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// invokeListener()返回最后的逻辑是去调用ApplicationListener.onApplicationEvent()</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的是否对<code>onApplicationEvent</code>方法执行执行起到了关键性的作用，因为在事务监听处理器适配器中会判断是否是否存在事务。第一种情况，由线程池内线程来执行该方法，这时事务是绑定在原线程上，所以会导致这个判断结果为<code>false</code>。第二种情况，由事件发送线程执行该方法，这时与事务在同一线程，则这个判断的结果为<code>true</code>，将对应的事件处理方法注册到事务管理器中，待到执行改事件监听处理方法时，是异步进行处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp; TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">		<span class="comment">// 省略以下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    整体使用下来，发现其中的道道还是很多的，这需要对所有的组合情况、问题情况、原理都掌握的情况下，否则随意组合，可能在某一场景下能达到需要的效果，但是就像是埋下了定时炸弹。当然了<code>spring</code>的事件监听机制毕竟只是基于内存，若对应的生产环境并没有升级停机钩子处理，或者是金丝雀升级等方式，需停机升级，有可能会导致部分监听未执行的情况，所以建议生产环境还是通过一些<code>mq</code>组件进行发布监听事件的处理。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>认识SpEL</title>
    <url>/2021/04/20/Spring/%E8%AE%A4%E8%AF%86SpEL/</url>
    <content><![CDATA[<h3 id="认识SpEL表达式"><a href="#认识SpEL表达式" class="headerlink" title="认识SpEL表达式"></a>认识SpEL表达式</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>最近项目接入苞米豆的<code>lock4j</code>用于分布式的锁控制，良好的控制在多台服务器下请求分流导致的数据重复问题，使用上也比较简单，在需要分布式锁的方法上添加一个<code>@Lock4j</code>注解并添加相应的参数即可，在使用中发现其中有一个属性<code>keys = &#123;&quot;#userId&quot;, &quot;#user.sex&quot;&#125;</code>，并且支持自定义重写分布式锁键的生成策略。在好奇心的驱使下，查看了默认实现的分布式锁键生成策略是通过<code>SpEL</code>的方式解析参数信息。</p>
</blockquote>
<span id="more"></span>

<h4 id="SpEL概述"><a href="#SpEL概述" class="headerlink" title="SpEL概述"></a>SpEL概述</h4><p><code>Spring</code>表达式语言的全拼为<code>Spring Expression Language</code>，缩写为<code>SpEL</code>。并且<code>SpEL</code>属于<code>spring-core</code>模块，不直接与<code>Spring</code>绑定，是一个独立模块，不依赖于其他模块，可以单独使用。</p>
<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><ol>
<li>解析器<code>ExpressionParser</code>，用于将字符串表达式转换为<code>Expression</code>表达式对象。</li>
<li>表达式<code>Expression</code>，最后通过它的<code>getValute</code>方法对表达式进行计算取值。</li>
<li>上下文<code>EvaluationContext</code>，通过上下文对象结合表达式来计算最后的结果。</li>
</ol>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  Expression expression = parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>);</span><br><span class="line">  <span class="comment">// 计算求值</span></span><br><span class="line">  System.out.println(expression.getValue(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进行一些简单的运算</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建解析器</span></span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  <span class="comment">// 解析表达式为Expression对象</span></span><br><span class="line">  <span class="comment">// 进行字符串的拼接</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;&#x27;Hello&#x27; + &#x27;World&#x27;&quot;</span>).getValue(String.class));</span><br><span class="line">  <span class="comment">// 简单的运算</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1+2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 简单的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;1&gt;2&quot;</span>).getValue());</span><br><span class="line">  <span class="comment">// 稍微复杂一点的比较</span></span><br><span class="line">  System.out.println(parser.parseExpression(<span class="string">&quot;2&gt;1 and (!true)&quot;</span>).getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过<code>ParseContext</code>对象设置自定义的解析规则</strong>：这里设置表达式的解析前缀为<code>#&#123;</code>解析后缀为<code>&#125;</code>，最后通过表达式对象<code>expression.getValue()</code>获取到表达式中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">  ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;#&#123;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  String template = <span class="string">&quot;#&#123;&#x27;Hello&#x27;&#125;#&#123;&#x27;World!&#x27;&#125;&quot;</span>;</span><br><span class="line">  Expression expression = parser.parseExpression(template, parserContext);</span><br><span class="line">  System.out.println(expression.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有很多不同的取值方式，比如参数(上下文)是个对象，获取这个对象中的某个属性；或者参数是一个<code>List</code>获取某一个索引值；又或者是一个<code>Map</code>对象，根据某个<code>Key</code>获取对应的值等等。</p>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>​    如果平时有使用<code>Spring</code>框架应该都会有用到比如<code>@Value</code>注解，就是通过<code>SpEL</code>方式进行赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 获取字符串tom </span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;tom&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 获取bean对象的属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;user.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在比如接触过<code>Spring Security</code>或者<code>Shiro</code>等身份验证和授权的框架中，对不同的角色有不同的接口权限，会使用到如下场景，其中对<code>@PreAuthorize(&quot;hasAuthority(&#39;ROLE_DMIN&#39;))</code>中<code>hasAuthority(&#39;ROLE_ADMIN&#39;)</code>就是通过<code>SpEL</code>进行参数解析后，对当前用户的角色进行校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拥有管理员权限可查看任何用户信息,否则只能查看自己的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ROLE_ADMIN&#x27;))</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/getUserById/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;SysUser&gt;&gt; getUserById(String userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;&gt;(userFacade.getUserById(userId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h4><p>​    之前在项目中记录系统中一些敏感接口的请求日志信息，采用的是<code>AOP</code>的方式，在请求进入控制层之前拦截进入<code>AOP</code>的切面方法，但是记录的日志部分关键信息需要从请求的参数中获取，在之前的实现中是通过约定一种表达式，对应列表<code>List</code>、<code>Map</code>、<code>bean</code>对象的取值是自实现，且仅仅支持二级取值，确实在使用上有很大的缺陷。这种场景下，就可以使用<code>SpEL</code>进行方法参数解析，省了重复造轮子的过程，且使用上更为灵活。</p>
<p><strong><code>SpEL</code>结合<code>AOP</code>重构请求日志保存</strong>，这边只做简单的通过<code>SpEL</code>方式进行对象等取值处理，不考虑具体实际场景中的复杂业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:06:06</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;basic&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicVersionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;测试&quot;,notes=&quot;测试&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@ControllerMethodLog(name = &quot;测试保存请求日志&quot;, description = &quot;测试保存请求日志&quot;)</span></span><br><span class="line">    <span class="meta">@LogAssistParams(value=&#123;</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;projectName&quot;,objField=&quot;#bidProjectInfo.id&quot;),</span></span><br><span class="line"><span class="meta">            @LogAssistParam(logField=&quot;id&quot;,objField=&quot;#bidProjectInfo.projectName&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestResponse&lt;BidPackageInvitationVo&gt; <span class="title">test</span><span class="params">(<span class="meta">@RequestBody</span> ProjectInfo projectInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AOP</code>切面类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/20 23:08:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationTestLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OperationLogFacade operationLogFacade;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 此处的切点是注解的方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="meta">@Pointcut(&quot;@annotation(cn.com.xiaocainiaoya.annotation.ControllerMethodLog)&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;operationLog()&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      OperationLog operationLog = <span class="keyword">new</span> OperationLog();</span><br><span class="line">      operationLog.setStatus(<span class="number">1</span>);<span class="comment">// 默认调用成功，异常时修改为调用失败</span></span><br><span class="line"></span><br><span class="line">      Object thing = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行切入方法内容</span></span><br><span class="line">         thing = joinPoint.proceed();</span><br><span class="line">         operationLog.setOperEndTime(DateTime.now().toJdkDate());</span><br><span class="line">         <span class="keyword">return</span> thing;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         log.error(e.getMessage(), e);</span><br><span class="line">         operationLog.setStatus(<span class="number">0</span>);<span class="comment">//发生异常时定义为调用失败</span></span><br><span class="line">         operationLog.setResultContext(e.getMessage());</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         insertOperationLog(operationLog, joinPoint, thing);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ParameterNameDiscoverer NAME_DISCOVERER = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExpressionParser PARSER = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *   插入操作日志</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span>: 2021/04/20 23:11:28</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> operationLog 日志基础信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> joinPoint 拦截切入点信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> thing 拦截函数返回值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertOperationLog</span><span class="params">(OperationLog operationLog, ProceedingJoinPoint joinPoint, Object thing)</span> </span>&#123;</span><br><span class="line">      MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">      ControllerMethodLog methodAnnotation = signature.getMethod().getAnnotation(ControllerMethodLog.class);</span><br><span class="line">      Api typeAnnotation = (Api) signature.getDeclaringType().getAnnotation(Api.class);</span><br><span class="line">      <span class="comment">//注释不完整不进行日志记录操作</span></span><br><span class="line">      <span class="keyword">if</span> (methodAnnotation == <span class="keyword">null</span> || typeAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParams logAssistParams = signature.getMethod().getAnnotation(LogAssistParams.class);</span><br><span class="line">      <span class="keyword">if</span>(methodAnnotation == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      LogAssistParam[] assistParams = logAssistParams.value();</span><br><span class="line">      <span class="keyword">if</span>(ObjectUtil.isNull(assistParams) || assistParams.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; assistParams.length; i++)&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 重点在这，通过MethodBasedEvaluationContext构建解析器ExpressionParser的上下文, 底层逻辑也是通过ParameterNameDiscoverer反射获取对应的属性值</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         EvaluationContext context = <span class="keyword">new</span> MethodBasedEvaluationContext((Object) <span class="keyword">null</span>, signature.getMethod(), joinPoint.getArgs(), NAME_DISCOVERER);</span><br><span class="line">         String value = (String)PARSER.parseExpression(assistParams[i].objField()).getValue(context);</span><br><span class="line">         ReflectUtil.setFieldValue(operationLog, assistParams[i].logField(), value);</span><br><span class="line">      &#125;</span><br><span class="line">      operationLogFacade.insertSelective(operationLog);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p>
<p>联系方式：<a href="mailto:&#120;&#105;&#97;&#111;&#x63;&#x61;&#x69;&#x6e;&#x69;&#x61;&#111;&#121;&#x61;&#64;&#102;&#111;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;">&#120;&#105;&#97;&#111;&#x63;&#x61;&#x69;&#x6e;&#x69;&#x61;&#111;&#121;&#x61;&#64;&#102;&#111;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#109;</a></p>
<p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>SpEL</tag>
      </tags>
  </entry>
  <entry>
    <title>DispatcherServlet</title>
    <url>/2021/08/15/SpringMvc/DispatcherServlet/</url>
    <content><![CDATA[<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>DispatcherServlet</code>是一个<code>Servlet</code>，在<code>springmvc</code>中被称为前端控制器，根据请求的路径、类型等进行请求的分发。</p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>DispatcherServlet</code>类图</p>
<p><img src="https://i.loli.net/2021/08/15/OrjQ6AYMb7R2Pd1.png" alt="DispatcherServlet类图.png"></p>
<p>​    上图中的红色部分为<code>Servlet</code>接口，在<code>Springmvc</code>中实现并扩展了该<code>Servlet</code>接口。在我最早学<code>javaweb</code>开发时，并不是上来就使用各种<code>MVC</code>框架，而是从编写简单的<code>Servlet</code>开始，就是继承<code>HttpServlet</code>后，重写它的<code>service</code>方法。而<code>Springmvc</code>的设计同理，它也继承了<code>HttpServlet</code>并重写它的<code>service</code>方法，同时配置该<code>servlet</code>拦截所有的请求，从而实现了由<code>DispatcherServlet</code>来分发所有的请求。</p>
<h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>​    因为<code>DispatcherServlet</code>实际上是一个<code>Servlet</code>，所以当配置它生效时它同时也就遵循<code>Servlet</code>的生命周期。在<code>Servlet</code>的生命周期有三个阶段：</p>
<ul>
<li><code>init()</code>：初始化请求</li>
<li><code>service()</code>：获取到请求后的业务处理以及跳转</li>
<li><code>distory()</code>：请求处理完成之后的销毁</li>
</ul>
<p>所以当<code>tomcat</code>容器(<code>servlet</code>容器)启动时，会触发<code>servlet</code>的初始化方法。<code>HttpServletBean</code>实现了该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实际的处理在这, 由子类FrameworkServlet实现</span></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FrameworkServlet</code>的<code>initServletBean</code>方法，真正核心的地方在于<code>initWebApplicationContext()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Initializing Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化web容器上下文</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">                <span class="string">&quot;shown which may lead to unsafe logging of potentially sensitive data&quot;</span> :</span><br><span class="line">                <span class="string">&quot;masked to prevent unsafe logging of potentially sensitive data&quot;</span>;</span><br><span class="line">        logger.debug(<span class="string">&quot;enableLoggingRequestDetails=&#x27;&quot;</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                <span class="string">&quot;&#x27;: request parameters and headers will be &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Completed initialization in &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取由ContextLoaderListener初始化并注册在ServletContext中的根上下文，记为rootContext</span></span><br><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 2.如果webApplicationContext已经不为空，表示这个Servlet类是通过编程式注册到容器中的（Servlet 3.0+中的ServletContext.addServlet() ），</span></span><br><span class="line">    <span class="comment">// 上下文也由编程式传入。若这个传入的上下文还没被初始化，将rootContext上下文设置为它的父上下文，然后将其初始化，否则直接使用。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.通过wac变量的引用是否为null，判断第2步中是否已经完成上下文的设置（即上下文是否已经用编程式方式传入），如果wac==null成立，说明该Servlet不是</span></span><br><span class="line">    <span class="comment">// 由编程式注册到容器中的。此时以contextAttribute属性的值为键，在ServletContext中查找上下文，查找得到，说明上下文已经以别的方式初始化并注册在contextAttribute下，直接使用。</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.检查wac变量的引用是否为null，如果wac==null成立，说明2、3两步中的上下文初始化策略都没成功，此时调用createWebApplicationContext(rootContext)，建立一个全新的以rootContext</span></span><br><span class="line">    <span class="comment">// 为父上下文的上下文，作为SpringMVC配置元素的容器上下文。大多数情况下我们所使用的上下文，就是这个新建的上下文。</span></span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建成功之后会调用spring的refresh方法</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.以上三种初始化上下文的策略，都会回调onRefresh(ApplicationContext context)方法（回调的方式根据不同策略有不同），onRefresh方法在DispatcherServlet类中被覆写，</span></span><br><span class="line">    <span class="comment">// 以上面得到的上下文为依托，完成SpringMVC中默认实现类的初始化。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// onRefresh方法在DispatcherServlet类中被覆写，所以从这里可以知道先创建spring容器, 在springBean都创建成功之后, 再通过onRefresh方法进行DispatcherServlet的初始化。</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.最后，将这个上下文发布到ServletContext中，也就是将上下文以一个和Servlet类在web.xml中注册名字有关的值为键，设置为ServletContext的一个属性。你可以通过改变</span></span><br><span class="line">    <span class="comment">// publishContext的值来决定是否发布到ServletContext中，默认为true。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>onRefresh(wac)</code>方法，调用到子类<code>DispatcherServlet</code>具体的初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化DispatcherServlet策略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化DispatcherServlet策略(九大组件)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上传组件处理器</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 处理器映射器</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 处理器适配器</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">// 处理器异常整理器</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 视图处理器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-分发逻辑"><a href="#2-分发逻辑" class="headerlink" title="2. 分发逻辑"></a>2. 分发逻辑</h4><p><img src="https://i.loli.net/2021/08/15/Eh6UipmYNGXSPDo.png" alt="springmvc流程图.png"></p>
<ul>
<li>当客户端发起请求，请求进入<code>DispatcherServlet</code>，由它来进行处理器<code>Handler</code>的查找。</li>
<li>首先根据请求信息<code>HttpServletRequest</code>，遍历已注册的所有<code>handlerMappings</code>。返回的结构为<code>HandlerExecutionChain</code>，是包含了具体的处理器<code>handler</code>和拦截器<code>interceptor</code>的结构。</li>
<li>获取到<code>HandlerExcecutionChain</code>后，根据具体的处理器，遍历所有的<code>handlerAdapters</code>，返回支持的<code>HandlerAdapter</code>。</li>
<li>在获取到<code>HandlerAdapter</code>之后，执行具体的<code>handler</code>之前，会先遍历执行<code>HandlerExecutionChain</code>中的拦截器的前置拦截方法<code>preHandle()</code>，**若出现某个拦截器的前置方法执行后方法<code>false</code>，则直接从当前节点开始往前执行<code>afterCompletion()</code>**，执行完毕后直接终止请求。</li>
<li>根据<code>HandlerAdapter</code>处理器适配器执行具体的处理器<code>Handler</code>逻辑。</li>
<li>在执行完成具体的<code>handler</code>之后，会遍历执行<code>HandlerExecutionChain</code>中拦截器的<code>postHandle</code>方法。</li>
<li><code>Handler</code>执行完毕之后会返回<code>ModeAndView</code>。</li>
<li>执行正常的情况下，在渲染模板后，请求返回前，会遍历执行<code>HandlerExecutionChain</code>中拦截器的<code>afterCompletion</code>方法。</li>
</ul>
<h4 id="3-设置springmvc容器"><a href="#3-设置springmvc容器" class="headerlink" title="3.设置springmvc容器"></a>3.设置springmvc容器</h4><p>​    根据类图可知<code>DispatcherServlet</code>也是实现了<code>ApplicationContextAware</code>接口，而<code>xxxAware</code>接口，是在<code>springbean</code>初始化时的一个<code>postProcessBeforeInitialization</code>扩展点，由类<code>ApplicationContextAwareProcessor</code>去执行具体的逻辑，简单来说就是将<code>ApplicationContext</code>通过<code>setApplicationContext</code>的方法传递给正在初始化的这个<code>bean</code>。</p>
<p>​    在<code>springboot</code>中就是通过这个方法，将<code>spring</code>容器(<code>applicationContext</code>)传给<code>DispatcherServlet</code>，待到真正去执行<code>DispatcherServlet</code>的初始化方法时<code>this.applicationContext</code>就不为空，所以在<code>initWebApplicationContext()</code>方法中，就走第一个<code>if</code>的逻辑，这也是<code>springboot</code>最终不会产生父子容器的原因。</p>
]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerMethod</title>
    <url>/2021/08/19/SpringMvc/Handler/</url>
    <content><![CDATA[<h3 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMethod</code>是一个基于方法的处理器结构，包含了处理器方法所对应的类和处理器方法，并提供了一些方法参数的访问接口。</p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMethod顶层接口"><a href="#1-HandlerMethod顶层接口" class="headerlink" title="1. HandlerMethod顶层接口"></a>1. HandlerMethod顶层接口</h4><p><img src="https://i.loli.net/2021/08/19/7ITf8eNah9YEn4c.png" alt="HandlerMethod类图.png"></p>
<p>​    <code>HandlerMethod</code>整体的结构比较简单，但是<code>HandlerMethod</code>并不是设计成接口，直接设计为类，主要用于封装对应的处理方法信息<code>method</code>和这个处理器方法所对应的类信息、这个方法上的所有注解信息等。而真正的处理器方法的处理交由子类<code>InvocableHandlerMethod</code>，这里类包含了参数解析器和参数名称解析器的处理，用于在真正方法调用前进行参数解析。最后底层实现类<code>ServletInvocableHandlerMethod</code>包含了返回值处理器链，用于处理执行处理器方法之后的返回值。</p>
<h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h4><p>​    在顶层类<code>HandlerMethod</code>中，主要的实现就是一些构造函数，为了应对不同场景下使用不同的参数对具体的的执行方法进行包装，比如记录具体执行方法的参数、对应的类、对应类的类型、<code>bean</code>工厂、桥接方法等。</p>
<p>​    在次顶层类<code>InvocableHandlerMethod</code>中，主要添加了参数解析器列表和参数名称解析器列表，用于在支持<code>support()=true</code>的情况下，对参数进行一些个性化处理。并且包含了具体执行方法的反射调用处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 参数处理</span></span><br><span class="line">    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际处理请求的方法</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体的执行方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行该方法</span></span><br><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">        String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(text, args), ex);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">        Throwable targetException = ex.getTargetException();</span><br><span class="line">        <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在<code>ServletInvocableHandlerMethod</code>类中，主要的当处理器方法执行结束后，对返回值的进行一些定制化的特殊处理。<code>springmvc</code>在异步调用的处理上就是通过返回值处理器，当返回值类型为<code>Callable</code>时，进行一些特殊的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 选择具体的返回值处理器(获取首次匹配成功的返回值处理器)</span></span><br><span class="line">    <span class="comment">// 举个异步处理的方式Callable, 由CallableMethodReturnValueHandler进行处理</span></span><br><span class="line">    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体的执行逻辑</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>参数解析器和返回值处理器在获取时，是获取列表中第一个匹配成功的那个解析器或者处理器，也就是说如果希望定制化的解析器或者处理器被执行到，需要确保它所在的位置之前没有其他的解析器或者处理器会被命中。</p>
]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerAdapter</title>
    <url>/2021/08/18/SpringMvc/HandlerAdapter/</url>
    <content><![CDATA[<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerAdapter</code>是<code>Handler</code>的适配器，每种类型的<code>Handler</code>都对应一个<code>HandlerAdapter</code>。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在顶层接口<code>HandlerAdapter</code>的实现中，基本上都是直接具体的实现。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2021/08/18/PksoX39nvUDiZHB.png" alt="HandlerAdapter类图png.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前 HandlerAdapter 是否支持这个 Handler</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler the handler object to check</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 利用 Handler 处理请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment">  * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以<code>AbstractHandlerMethodAdapter</code>为例进行分析。这个抽象类也比较简答，仅仅是将顶层接口中的参数进行具象化，再调用本类的模板方法，供子类直接使用，所以子类就不需要在进行类型装换等操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果handler是HandlerMethod, 直接强转后调用模板方法</span></span><br><span class="line">    <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">supportsInternal</span><span class="params">(HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 仅仅是强转了类型之后, 直接调用模板方法</span></span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>具体实现<strong>RequestMappingHandlerAdapter</strong></p>
<p>​    <code>RequestMappingHandlerAdapter</code>是<code>HandlerAdapter</code>体系中最复杂的类，包含了具体<code>Handler</code>执行前后需要特殊处理或者是一些开放的扩展点的处理。比如有参数处理器、参数名称处理器、<code>HttpMessageConverter</code>、结果处理器等等。</p>
<p><strong>1.初始化</strong></p>
<p>​    <code>RequestMappingHandlerAdapter</code>的初始化分为两步，一步是在构造函数中进行默认<code>HttpMessageConvert</code>的添加，另一步是通过<code>afterPropertiesSet</code>进行一些全局处理的缓存和一些组件的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;&gt;());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        <span class="comment">// Ignore when no TransformerFactory implementation is available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化全局的三个变量modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line">    initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数解析器argumentResolvers参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getDefaultArgumentResolvers()中定义了一些常用的参数解析器，同时支持添加用户自定义参数解析器</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化initBinder式参数绑定器initBinderArgumentResolvers</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过getDefaultInitBinderArgumentResolvers()获取默认的解析器，同时支持添加用户自定义参数绑定器</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">        <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化返回值处理器returnValueHandlers</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过getDefaultReturnValueHandlers()方法获取返回值解析器，同时支持添加用户自定义返回值处理器</span></span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化全局的三个变量modelAttributeAdviceCache、initBinderAdviceCache、requestResponseBodyAdvice</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2021/08/18 10:12:25</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initControllerAdviceCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取带有@ControllerAdvice的所有类</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">        Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">        <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在@ModelAttribute注解, 但不存在@RequestMapping注解的方法</span></span><br><span class="line">        Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在@InitBinder注解的方法</span></span><br><span class="line">        Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">        <span class="keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是RequestBodyAdvice或者是ResponseBodyAdvice的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">            requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若在上述解析过程中存在实现类, 则添加到最前面, 所以在requestResponseBodyAdvice中, 自定义的优先级高于默认</span></span><br><span class="line">    <span class="keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.requestResponseBodyAdvice.addAll(<span class="number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.实际处理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    <span class="comment">//判断是否支持当前request的方法，该方法在WebContentGenerator类中定义，通过内置的supportedMethods属性来进行判断</span></span><br><span class="line">    checkRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                <span class="comment">// 具体的执行方法</span></span><br><span class="line">                mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">            mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">            applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            prepareResponse(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取创建WebDataBinder实例的工厂类，其中WebDataBinder类用于绑定request参数到JavaBean对象</span></span><br><span class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 获取@ModelAttribute的非@RequestMapping方法</span></span><br><span class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ServletInvocableHandlerMethod是继承于HandlerMethod, 这里相当于只是将handlerMethod中的属性值赋值给invocableMethod, 仅仅只做了包了一层</span></span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        <span class="comment">// 为ServletInvocableHandlerMethod中的一些数据赋值, 增加了参数解析、处理器方法调用、返回值解析等逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">//设置参数名称处理器</span></span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建模型和视图容器</span></span><br><span class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">        <span class="comment">// 设置FlashMap中的值</span></span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        <span class="comment">// 初始化模型</span></span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步处理相关代码</span></span><br><span class="line">        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            Object result = asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">                String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体的执行方法</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="comment">// 若是异步方式, 这里就直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建ModelAndView实例</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServletInvocableHandlerMethod</code>就是具体的<code>HandlerMethod</code>的实现，所以在最后通过<code>invocableMethod.invokeAndHandle(webRequest, mavContainer)</code>调用到具体的实现。以下基本上就是具体<code>Handler</code>的调用前最后一步了，返回执行结果之后，由结果处理器进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 执行调用逻辑(这里会先经过参数解析器的处理之后，再通过反射调用到具体的方法)</span></span><br><span class="line">    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值处理器处理</span></span><br><span class="line">        <span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里想简要说明一下异步调用的场景：<code>Servlet3.0</code>支持服务器异步操作，在<code>springmvc</code>中也添加了响应的支持。整个请求的过程与同步类似，只是在具体的<code>handler</code>调用之后，如果是异步方式，假设是使用<code>Callable</code>，则这里获取到的返回值处理器就是<code>CallableMethodReturnValueHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue;</span><br><span class="line">    <span class="comment">// 进入Callable方式异步处理逻辑</span></span><br><span class="line">    WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(<span class="keyword">final</span> WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Assert.notNull(webAsyncTask, <span class="string">&quot;WebAsyncTask must not be null&quot;</span>);</span><br><span class="line">    Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">&quot;AsyncWebRequest must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    Long timeout = webAsyncTask.getTimeout();</span><br><span class="line">    <span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 设置异步线程池</span></span><br><span class="line"><span class="comment">      *   1. 默认情况下会创建DEFAULT_TASK_EXECUTOR -&gt; SimpleAsyncTaskExecutor线程池</span></span><br><span class="line"><span class="comment">      *   2. 一般来说, 在RequestMappingHandlerAdapter中, 创建的WebAsyncManager时会传入它的this.taskExecutor</span></span><br><span class="line"><span class="comment">      *      2.1 而RequestMappingHandlerAdapter也会创建一个默认的SimpleAsyncTaskExecutor(名称前缀为MvcAsync)</span></span><br><span class="line"><span class="comment">      *        2.1.1 但是在springmvc中, 初始化Bean RequestMappingHandlerAdapter时为它添加了单一线程池Executor.newSingleThreadExecutor</span></span><br><span class="line"><span class="comment">      *        2.1.2 但是在springboot中, 初始化Bean RequestMappingHandlerAdapter时为它添加了一个名为applicationTaskExecutor的线程池</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    AsyncTaskExecutor executor = webAsyncTask.getExecutor();</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskExecutor = executor;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        logExecutorWarning();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置拦截器</span></span><br><span class="line">    List&lt;CallableProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.add(webAsyncTask.getInterceptor());</span><br><span class="line">    interceptors.addAll(<span class="keyword">this</span>.callableInterceptors.values());</span><br><span class="line">    interceptors.add(timeoutCallableInterceptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取具体的callable</span></span><br><span class="line">    <span class="keyword">final</span> Callable&lt;?&gt; callable = webAsyncTask.getCallable();</span><br><span class="line">    <span class="comment">// 创建拦截器链对象, 拦截器链对象一般情况下都会包含拦截列表、具体执行对象以及具体执行到某个拦截器的下标值</span></span><br><span class="line">    <span class="keyword">final</span> CallableInterceptorChain interceptorChain = <span class="keyword">new</span> CallableInterceptorChain(interceptors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Async request timeout for &quot;</span> + formatRequestUri());</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = interceptorChain.triggerAfterTimeout(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">        <span class="keyword">if</span> (result != CallableProcessingInterceptor.RESULT_NONE) &#123;</span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置错误处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addErrorHandler(ex -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.errorHandlingInProgress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Async request error for &quot;</span> + formatRequestUri() + <span class="string">&quot;: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result = interceptorChain.triggerAfterError(<span class="keyword">this</span>.asyncWebRequest, callable, ex);</span><br><span class="line">            result = (result != CallableProcessingInterceptor.RESULT_NONE ? result : ex);</span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置正常完成处理器</span></span><br><span class="line">    <span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(() -&gt; interceptorChain.triggerAfterCompletion(<span class="keyword">this</span>.asyncWebRequest, callable));</span><br><span class="line"></span><br><span class="line">    interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">    <span class="comment">// 设置一些标志位为启动状态</span></span><br><span class="line">    startAsyncProcessing(processingContext);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将callable丢入线程池中</span></span><br><span class="line">        Future&lt;?&gt; future = <span class="keyword">this</span>.taskExecutor.submit(() -&gt; &#123;</span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interceptorChain.applyPreProcess(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">                result = callable.call();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = ex;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, callable, result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行完成之后进行结果的分发, 这个具体在不同容器有不同的实现(tomcat、undertow)</span></span><br><span class="line">            setConcurrentResultAndDispatch(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        interceptorChain.setTaskFuture(future);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        Object result = interceptorChain.applyPostProcess(<span class="keyword">this</span>.asyncWebRequest, callable, ex);</span><br><span class="line">        setConcurrentResultAndDispatch(result);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerMapping</title>
    <url>/2021/08/15/SpringMvc/HandlerMapping/</url>
    <content><![CDATA[<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <code>HandlerMapping</code>处理器映射器，是<code>SpringMvc</code>的核心组件之一，用来根据请求的<code>request</code>信息查询对应的<code>Handler</code>，在<code>web</code>环境中，每个请求都需要一个对应的<code>Handler</code>来处理，所以当接收到一个请求，需要哪一个<code>Handler</code>来处理，<code>HandlerMapping</code>的作用就是找到处理的那个<code>Handler</code>。</p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="1-HandlerMapping顶层接口"><a href="#1-HandlerMapping顶层接口" class="headerlink" title="1. HandlerMapping顶层接口"></a>1. HandlerMapping顶层接口</h4><p><img src="https://i.loli.net/2021/08/15/IObtEmouNveLT2y.png" alt="HandlerMapping类图.png"></p>
<p>以上为<code>HandlerMapping</code>的类图，在<code>HandlerMapping</code>接口中有一个公共的抽象类<code>AbstractHandlerMapping</code><br>所有的子孙都会继承它。该抽象类有两个子类<code>AbstractHandlerMethodMapping</code>表示基于方法的映射方法，这个方式就是我们日常使用的<code>Controller</code>的那种方式，<code>AbstractUrlHandlerMapping</code>表示根据<code>url</code>获取到对应的<code>Handler</code>。</p>
<p>这里分析一下公共抽象父类<strong>AbstractHandlerMapping</strong>。这个抽象类采用了模板方法的设计模式，编写了<code>HandlerMapping</code>的核心逻辑<code>getHandler()</code>方法，获取具体的<code>handler</code>由子类继承并实现<code>getHandlerInternal</code>方法，在获取到具体的<code>handler</code>之后，添加该请求匹配的拦截器列表，再返回<code>HandlerExecutionChain</code>结构，里面包含了具体的<code>handler</code>和拦截器列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法接口, 不同子类不同实现</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加匹配的拦截器</span></span><br><span class="line">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">        CorsConfiguration config = (<span class="keyword">this</span>.corsConfigurationSource != <span class="keyword">null</span> ? <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="keyword">null</span>);</span><br><span class="line">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">        config = (config != <span class="keyword">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里点一下初始化拦截器的方法。由于<code>AbstractHandlerMapping</code>间接继承于<code>ApplicationContextAware</code>接口，在<code>bean</code>初始化时会调用该接口进行<code>applicationContext</code>的赋值。而改方法中设置了一个模板方法接口，由具体子类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ApplicationObjectSupport</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * bean初始化时会调用这个接口(BeanPostProcessor)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span>: 2021/08/04 16:56:03</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">        <span class="comment">// Reset internal context state.</span></span><br><span class="line">        <span class="keyword">this</span>.applicationContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Initialize with passed-in context.</span></span><br><span class="line">        <span class="keyword">if</span> (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                    <span class="string">&quot;Invalid application context: needs to be of type [&quot;</span> + requiredContextClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = context;</span><br><span class="line">        <span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">new</span> MessageSourceAccessor(context);</span><br><span class="line">        initApplicationContext(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Ignore reinitialization if same context passed in.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != context) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                    <span class="string">&quot;Cannot reinitialize with different application context: current one is [&quot;</span> +</span><br><span class="line">                    <span class="keyword">this</span>.applicationContext + <span class="string">&quot;], passed-in one is [&quot;</span> + context + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  	<span class="comment">// 扩展点, 由子类自行实现</span></span><br><span class="line">    initApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractHandlerMapping#initApplicationContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主要是初始化拦截器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Initializes the interceptors.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #extendInterceptors(java.util.List)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #initInterceptors()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 空实现。</span></span><br><span class="line">    <span class="comment">// 子类可重写此方法以注册额外的拦截器</span></span><br><span class="line">    extendInterceptors(<span class="keyword">this</span>.interceptors);</span><br><span class="line">    <span class="comment">// 从上下文中查询拦截器并添加到拦截器列表中</span></span><br><span class="line">    detectMappedInterceptors(<span class="keyword">this</span>.adaptedInterceptors);</span><br><span class="line">    <span class="comment">// 初始化拦截器</span></span><br><span class="line">    initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以下代码可以得出一个简单的结论，拦截器的作用范围实际上是在<code>Handler</code>执行的前后，而过滤器<code>Filter</code>作用的范围应该是在请求进入到<code>servlet</code>的前和执行完<code>servlet</code>逻辑之后，套在<code>springmvc</code>中，<code>Filter</code>的作用范围是在请求进入到<code>DispatcherServlet</code>之前和执行完<code>DispatcherServlet</code>之后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将自定义bean设置到适配拦截器中，bean需实现HandlerInterceptor或WebRequestInterceptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setInterceptors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #adaptInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.interceptors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.interceptors.size(); i++) &#123;</span><br><span class="line">            Object interceptor = <span class="keyword">this</span>.interceptors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Entry number &quot;</span> + i + <span class="string">&quot; in interceptors array is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-AbstractHandlerMethodMapping"><a href="#2-AbstractHandlerMethodMapping" class="headerlink" title="2. AbstractHandlerMethodMapping"></a>2. AbstractHandlerMethodMapping</h4><p>​    <code>AbstractHandlerMethodMapping</code>这个就是<code>RequestMappingHandlerMapping</code>的抽象顶层父类，这种映射方式就是我们日常开发的那种，将标记有<code>@Controller</code>的类中的每个标记有<code>@RequestMapping</code>的方法都抽象为一个对应的<code>HandlerMethod</code>。</p>
<p><strong>简单罗列一下使用到的类：</strong></p>
<ol>
<li><strong>HandlerMethod：</strong>在初始化<code>RequestMappingHandlerMapping</code>会将<code>spring</code>容器中标记有<code>@Controller</code>的类中的<code>@RequestMapping</code>的方法都封装为<code>HandlerMethod</code>实体，包含了<code>Handler</code>对应的方法以及<code>ControllerBean</code>，并提供一些访问参数、方法返回值、获取注解等方法。</li>
<li><strong>RequestMappingInfo：</strong>在<code>@Controller</code>类上标记的<code>@RequestMaping</code>或者是在方法上标记的<code>@RequestMapping</code>最终都会加载到<code>RequestMappingInfo</code>实体中。</li>
<li><strong>MappingRegistration：</strong>主要记录<code>RequestMappingInfo</code>与<code>HandlerMethod</code>关系</li>
<li><strong>MappingRegistry：</strong>一个注册表，它维护到处理程序方法的所有映射，公开执行查找的方法并提供并发访问。</li>
</ol>
<p><strong>AbstractHandlerMethodMapping</strong>分支的类图：</p>
<p><img src="https://i.loli.net/2021/08/17/fCx685RjaIJiYwK.png" alt="RequestMappingHandlerMapping类图.png"></p>
<p>图中红框中的三个类，分别依次继承，我们日常开发所使用的就是<code>RequestMappingHandlerMapping</code>。</p>
<h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h5><p>​    在<code>springbean</code>容器启动后，当初始化类<code>RequestMappingHandlerMapping</code>完成时，由于它间接实现了初始化的后置方法<code>InitializingBean</code>，所以会进入<code>afterPropertiesSet</code>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RequestMappingHandlerMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化RequestMappingInfo构建配置</span></span><br><span class="line">    <span class="keyword">this</span>.config = <span class="keyword">new</span> RequestMappingInfo.BuilderConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.config.setUrlPathHelper(getUrlPathHelper());</span><br><span class="line">    <span class="keyword">this</span>.config.setPathMatcher(getPathMatcher());</span><br><span class="line">    <span class="keyword">this</span>.config.setSuffixPatternMatch(useSuffixPatternMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setTrailingSlashMatch(useTrailingSlashMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());</span><br><span class="line">    <span class="keyword">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法调用到父类的afterPropertiesSet, 从而调用到父类的initHandlerMethods方法(这个方法是完成映射的解析工作)</span></span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 后置初始化方法, 当这个Bean初始化完成之后调用, 获取容器中所有BeanDefinition</span></span><br><span class="line"><span class="comment"> * 中含有<span class="doctag">@RequestMapping</span>或者是<span class="doctag">@Controller</span>的Bean信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initHandlerMethods</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从容器中获取所有Bean的名称,默认只查找SpringMVC的IOC容器，不查找它的父容器Spring的IOC容器</span></span><br><span class="line">    <span class="comment">// 获取容器中所有Object.class类型的bean, 逐个遍历进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// 利用反射得到@ControllerBean中的Method并包装成HandlerMethod，然后放入注册表中</span></span><br><span class="line">            processCandidateBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCandidateBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的 isHandler()方法由子类(RequestMappingHandlerMapping)实现，判断是否拥有 @Controller 注解或 @RequestMapping 注解</span></span><br><span class="line">    <span class="comment">// 这个isHandler()是个抽象接口, 由子类实现来控制是否进行接下来的注册。</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">        <span class="comment">// 利用反射得到@ControllerBean中的Method并包装成HandlerMethod，然后放入注册表中</span></span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接下来就是将具体的<code>@Controller</code>标记的类中的方法进行解析，满足条件的<code>method</code>封装为<code>HandlerMethod</code>后，添加到注册表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用反射得到 Bean 中的 Method 并包装成 HandlerMethod，然后放入 Map 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Look for handler methods in the specified handler bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler either a bean name or an actual handler instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据字符串获取到对应的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ? obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若是代理对象获取目标类型</span></span><br><span class="line">        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">        <span class="comment">// 收集要封装的接口信息, 键为method的引用, 值为RequestMethodInfo的引用</span></span><br><span class="line">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 根据 Method 和它的 @RequestMapping 注解，创建 RequestMappingInfo 对象。</span></span><br><span class="line">                        <span class="comment">// 这里的 T 就是 RequestMappingInfo，它封装了 @RequestMapping 信息</span></span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> + userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line">        methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">            Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">            <span class="comment">// 注册到mappingRegistry中</span></span><br><span class="line">            registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;Method, T&gt; <span class="title">selectMethods</span><span class="params">(Class&lt;?&gt; targetType, <span class="keyword">final</span> MetadataLookup&lt;T&gt; metadataLookup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 收集要封装的接口信息, 键为method的引用, 值为RequestMethodInfo的引用</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Method, T&gt; methodMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; handlerTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; specificHandlerType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非代理类</span></span><br><span class="line">    <span class="keyword">if</span> (!Proxy.isProxyClass(targetType)) &#123;</span><br><span class="line">        specificHandlerType = ClassUtils.getUserClass(targetType);</span><br><span class="line">        handlerTypes.add(specificHandlerType);</span><br><span class="line">    &#125;</span><br><span class="line">    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; currentHandlerType : handlerTypes) &#123;</span><br><span class="line">        <span class="comment">// specificHandlerType若为空表示其为代理类, 则取currentHandlerType</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; targetClass = (specificHandlerType != <span class="keyword">null</span> ? specificHandlerType : currentHandlerType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式接口: 遍历currentHandlerType的所有methods, 并执行第二个函数引用</span></span><br><span class="line">        ReflectionUtils.doWithMethods(currentHandlerType, method -&gt; &#123;</span><br><span class="line">            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line">            <span class="comment">// 获取@RequestMapping信息</span></span><br><span class="line">            T result = metadataLookup.inspect(specificMethod);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line">                <span class="keyword">if</span> (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    methodMap.put(specificMethod, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methodMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用了两次的函数式接口，不同函数式接口可能看到这回有点吃力。第一个函数式接口的作用其实就是将某个<code>method</code>上标记的<code>@RequestMapping</code>信息和这个<code>method</code>所在类上标记的<code>@RequestMapping</code>信息拼接起来后包装为<code>RequestMappingInfo</code>后返回。第二个函数式接口的作用是将第一个函数式接口处理之后返回的<code>RequestMappingInfo</code>信息暂存到某个变量中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后将解析出来的所有RequestMappingInfo信息逐个遍历，通过调用以下方法，添加到注册表中。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Assert that the handler method is not a suspending one.</span></span><br><span class="line">    <span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass())) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> ((parameterTypes.length &gt; <span class="number">0</span>) &amp;&amp; <span class="string">&quot;kotlin.coroutines.Continuation&quot;</span>.equals(parameterTypes[parameterTypes.length - <span class="number">1</span>].getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported suspending handler method detected: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化一个HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">        <span class="comment">// 校验是否已经存在这个handlerMethod</span></span><br><span class="line">        validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">        <span class="comment">// 添加到mappingLookup查找器中</span></span><br><span class="line">        <span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">        <span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">            addMappingName(name, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取跨域的配置</span></span><br><span class="line">        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">        <span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注册跨域配置</span></span><br><span class="line">            <span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * getHandlerInternal()方法是由AbstractHandlerMapping抽象类定义的模板方法，具体细节由</span></span><br><span class="line"><span class="comment"> * 子类实现，用于获取对应的HandlerMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前请求获取“查找路径”</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前请求最佳匹配的处理方法（即Controller类的方法中）</span></span><br><span class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体是通过该方法获取HandlerMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从MappingRegistry.urlLookup属性中，获取lookupPath对应的mapping集合</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取匹配的mapping，添加到matches列表</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有匹配lookupPath的实例，则遍历所有的mapping，查找符合条件的mapping</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明存在符合条件的mapping</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 多个的情况</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//获取匹配条件的排序器，由抽象方法getMappingComparator()方法获取，该方法由子类实现</span></span><br><span class="line">          	<span class="comment">// 这个排序规则也是个模板方法, 由子类实现, 由子类控制当出现多个匹配的mapping</span></span><br><span class="line">          	<span class="comment">// 通过比较器排序后, 选择第一个为最匹配的mapping</span></span><br><span class="line">            Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">            matches.sort(comparator);</span><br><span class="line">            bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(matches.size() + <span class="string">&quot; matching mappings: &quot;</span> + matches);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                String uri = request.getRequestURI();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>认识SpringMvc</title>
    <url>/2021/08/09/SpringMvc/%E8%AE%A4%E8%AF%86SpringMvc/</url>
    <content><![CDATA[<h3 id="认识SpringMvc"><a href="#认识SpringMvc" class="headerlink" title="认识SpringMvc"></a>认识SpringMvc</h3><h2 id="认识SpringMvc-1"><a href="#认识SpringMvc-1" class="headerlink" title="认识SpringMvc"></a>认识SpringMvc</h2><p>​    <code>SpringMvc</code>是基于<code>spring</code>在<code>web</code>领域进行开发的框架，使得业务开发者无需关心<code>Servlet</code>组件的逻辑处理，让业务开发者仅需要关心业务逻辑的处理。<span id="more"></span></p>
<p>​    由于在我较为整体的学习<code>SpringMvc</code>源码时，市面上已经比较倾向于前后端分离的开发模式，已经少有这种传统的<code>jsp</code>的模板结构的模式了。所以基本上只会记录从请求到前端控制器<code>DispatcherServlet</code>以及<code>HandlerMapping</code>、<code>HandlerAdapter</code>等的处理，并不会记录视图解析器等与视图相关内容。</p>
<!--more-->

<p><strong>以下先简单罗列后续会比较重点介绍的部分。</strong></p>
<ul>
<li><code>DispathcerServlet</code>：前端控制器，实际是它就是一个<code>servlet</code>。若你学过最原生的写法，不依赖于任何<code>mvc</code>框架，应该是继承一个<code>HttpServlet</code>后，重写它的<code>service</code>方法，然后再通过请求方式的不同等进行不同的路由跳转或者重定向等操作。实际上<code>DispatcherServlet</code>也以此为主要逻辑，它就是控制请求的分发。</li>
<li><code>Handler</code>：处理器(具体的业务逻辑)，在项目启动时会将<code>@Controller</code>中的一个个<code>@RequestMapping</code>方法都抽象为这个接口的结构。</li>
<li><code>HandlerMapping</code>：处理器映射器，当请求来临时，根据请求的<code>url</code>等结构，寻找具体的<code>Handler</code>。</li>
<li><code>HanderApdater</code>：处理器适配器，会将<code>Handler</code>包装为处理器适配器，从而支持多种类型的处理器，通过它根据适配的结构调用正在的处理器的业务逻辑方法，完成功能处理。</li>
</ul>
<h4 id="1-spring、springmvc、springboot间父子容器的问题？"><a href="#1-spring、springmvc、springboot间父子容器的问题？" class="headerlink" title="1. spring、springmvc、springboot间父子容器的问题？"></a>1. <strong>spring、springmvc、springboot间父子容器的问题？</strong></h4><p><strong>对于传统的<code>springmvc</code>项目而言，可以通过<code>web.xml</code>文件配置来配置</strong></p>
<ol>
<li><p>仅配置了<code>&lt;servlet&gt;</code>(<code>DispatcherServlet</code>)。这时在启动项目时，在对<code>DispatcherServlet</code>进行初始化时，调用父类<code>FrameworkServlet</code>的<code>initWebApplicationContext</code>方法，在该方法中的设置父容器，是获取不到<code>spring</code>容器的，所以这种情况下整个项目仅有<code>springmvc</code>容器。</p>
</li>
<li><p>若配置了<code>&lt;listener&gt;</code>(<code>ContextLoaderListener</code>)和<code>&lt;servlet&gt;</code>(<code>DispatcherServlet</code>)，这时项目启动时，先通过监听器加载<code>spring</code>容器，待完成<code>spring</code>容器加载后，才会通过<code>DispatcherServlet</code>进行<code>springmvc</code>容器的加载。(<strong>为什么在加载<code>spring</code>容器的过程中不会加载<code>DispatcherServlet</code>：</strong>这时<code>spring</code>并不会识别到<code>DispatcherServlet</code>)，在<code>springmvc</code>容器加载时，可以获取到<code>spring</code>容器，并设置为<code>springmvc</code>容器的父容器。</p>
</li>
<li><p>仅配置<code>&lt;listener&gt;</code>(<code>ContextLoaderListener</code>)，这种情况就没得说了，如果不加载<code>DispathcerServlet</code>那根本就不是<code>springmvc</code>项目。</p>
</li>
</ol>
<p><strong>注意：</strong>以上第二种情况，需特别注意若是使用中出现事务、或者<code>AOP</code>等处理，需保证父子容器中都有对应的处理。</p>
<p><strong><code>springboot</code>是如何处理<code>springmvc</code>中的父子容器问题？</strong></p>
<p>​    我认为<code>springmvc</code>的这种父子容器思想(子容器可以访问父容器，父容器不可访问子容器)，是可以有效的进行框架层级边界的划分，比如<code>service</code>层一般放在<code>spring</code>容器中，而<code>web</code>层(<code>controller/Action</code>)等放在<code>springmvc</code>容器中，所以如果需要跟换<code>web</code>层框架，比如将<code>springmvc</code>更换为<code>struct</code>，仅仅只需要将<code>spring-servlet.xml</code>文件替换为<code>struct</code>的配置文件即可。</p>
<p>​    在<code>springboot</code>中，并没有延续<code>springmvc</code>的这种父子容器思想，从设计结构来说，<code>DispatcherServlet</code>的父接口中有<code>ApplicationContextAware</code>接口，也就是说，如果在<code>spring</code>容器初始化过程中，将<code>DispatcherServlet</code>识别为<code>bean</code>，那么就会通过后置接口为<code>DispatcherServlet</code>设置容器，所以真正调用<code>DispatcherServlet</code>的初始化方法时，<code>this.webApplicationContext</code>已经通过后置接口赋值，就就不会重新创建一个新的容器，<code>springboot</code>就是通过这种方式，来控制整个上下文仅使用一个容器。</p>
<h4 id="2-springmvc和servlet之间的关系？"><a href="#2-springmvc和servlet之间的关系？" class="headerlink" title="2. springmvc和servlet之间的关系？"></a>2. springmvc和servlet之间的关系？</h4><p>​    <code>web</code>端开发实际上就是客户端和服务端进行交换数据，而交换数据的过程中不可避免的需要经过建立连接、传输数据、业务逻辑处理、返回数据、关闭连接的过程。而在日常开发过程中，业务开发者并不需要关心整个过程，业务开发者只需要关注业务逻辑处理这一环节。这是因为<code>tomcat</code>处理了这些动作。</p>
<p>在<code>springmvc</code>中，通过<code>web.xml</code>配置文件来配置<code>DispatcherServlet</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/spring/SpringMVC-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这里配置说明拦截了所有请求--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际上<code>DispatcherServlet</code>就是一个<code>servlet</code>，这个配置文件配置了<code>DispathcerServlet</code>这个<code>Servlet</code>需要拦截的<code>url</code>地址，显然这个配置的是<code>/</code>，也就是入站的所有地址。也就是说当客户端发起请求时，先进入<code>tomcat</code>，由<code>tomcat</code>为其建立连接后将请求等信息传递给<code>DispatcherServlet</code>这个<code>servlet</code>。由这个<code>DispatcherServlet</code>来处理请求的分发，在<code>SpringMvc</code>中称它为前端控制器。</p>
]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch入门笔记(一)</title>
    <url>/2021/05/10/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="Elasticsearch入门笔记-一"><a href="#Elasticsearch入门笔记-一" class="headerlink" title="Elasticsearch入门笔记(一)"></a>Elasticsearch入门笔记(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    在工作的中使用到部分<code>ElasticSearch</code>沾边的东西，<code>ELK</code>日志实时分析系统，对<code>ElasticSearch</code>也略有耳闻，趁着最近有时间学习一下，并将学习过程中知识点记录下来。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>ElasticSearch</code>是基于<code>Luncene</code>的分布式高性能的全文搜索引擎，<code>Luncene</code>是使用<code>java</code>开发的一个全文搜索引擎工具包，而<code>ElasticSearch</code>它将<code>Luncene</code>的复杂性对用户屏蔽，提供简单易用的<code>Restful Api</code>，开发者只需要使用该<code>api</code>接口就可以使用全文搜索。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​    我使用的是<code>mac</code>电脑，使用的是<code>docker desktop for mac</code>工具，通过<code>Kitematic</code>工具直接搜索了<code>elasticSearch</code>进行安装，我安装的镜像是<code>blacktop/elasticsearch</code>版本是<code>7.10.1</code>，它只挂载了<code>data</code>目录，我本地通过容器管理工具将<code>plugins</code>路径也挂载出来，方便添加分词器。</p>
<p>​    同时还需要使用到<code>google</code>插件<code>elasticsearch-head</code>便于查看数据等情况；同样使用了<code>docker</code>安装了<code>blacktop/kibana</code>镜像,<code>kibana</code>内置了解析器，对<code>es</code>的<code>restful api</code>有对应的支持。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-集群"><a href="#1-集群" class="headerlink" title="1. 集群"></a>1. 集群</h3><p>​    <code>es</code>本质上就是一个分布式系统，允许多台服务器协同工作，可以在一台服务上部署多个<code>es</code>实例，每一个实例称为一个节点。本想模拟单机多节点的集群情况，花了很多时间发现各个节点之间就是无法访问到，不知道主要原因是不是由于<code>macos</code>的容器机制，导致宿主机无法直接访问容器<code>ip</code>导致。</p>
<h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><p>​    <code>es</code>的数据管理顶层单位称为索引<code>Index</code>，它类似于关系数据库中的库的概念，也就是每一个<code>Index</code>就是一个数据库，且规定<strong>名称必须为小写</strong>。</p>
<h3 id="3-类型"><a href="#3-类型" class="headerlink" title="3.类型"></a>3.类型</h3><p>​    索引<code>Index</code>下就是类型<code>Type</code>，类似于关系数据库中的表的概念，但是在<code>6.x</code>版本之后，一个<code>Index</code>值允许一个<code>Type</code>，所以类似于一个库中只允许一张表。</p>
<h3 id="4-文档"><a href="#4-文档" class="headerlink" title="4.文档"></a>4.文档</h3><p>​    <code>Type</code>下就是文档<code>Document</code>，一个<code>Type</code>包含多个<code>Document</code>，<code>document</code>类似于关系数据库中一行记录。</p>
<h3 id="5-分片"><a href="#5-分片" class="headerlink" title="5.分片"></a>5.分片</h3><p>​    <code>es</code>的数据是存储在节点上，每个索引的数据量不一样，需要的计算和处理数据的能力不一样，所以在创建每一个索引是可以同时创建的分片数，将数据处理分散到不同的节点。同时还分为主分片和副本分片，副本分片是主分片的一个备份，若主分片所在的节点宕机，启用改节点主分片的副本分片，所以主分片和副本分片将落在不同的节点。</p>
<p><strong>关系型数据库和es基本结构概念对比</strong></p>
<table>
<thead>
<tr>
<th>关系型数据库</th>
<th>es</th>
</tr>
</thead>
<tbody><tr>
<td>库</td>
<td>Index</td>
</tr>
<tr>
<td>表</td>
<td>Type</td>
</tr>
<tr>
<td>行</td>
<td>Document</td>
</tr>
<tr>
<td>一行中的某一列</td>
<td>Field(es是使用json表达数据)</td>
</tr>
<tr>
<td>索引</td>
<td>全文索引(这个地方有可能出现理解的误差，二者在各自结构中的意思都是加快查询数据的速度)</td>
</tr>
</tbody></table>
<h3 id="6-倒排索引"><a href="#6-倒排索引" class="headerlink" title="6.倒排索引"></a>6.倒排索引</h3><p>​    倒排索引是<code>es</code>中比较核心的一个概念，是指从文档的词项映射文档<code>ID</code>的一个过程。在关系型数据库中，一般采用的是正排索引，即从数据<code>ID</code>查询某个数据的关系。</p>
<p>比如有以下数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>10</td>
<td>福建省福州市</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>10</td>
<td>福建省莆田市</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>30</td>
<td>福建省泉州市</td>
</tr>
<tr>
<td>4</td>
<td>赵六</td>
<td>30</td>
<td>湖南省长沙市</td>
</tr>
<tr>
<td>5</td>
<td>孙七</td>
<td>30</td>
<td>福建省南平市</td>
</tr>
<tr>
<td>6</td>
<td>钱八</td>
<td>60</td>
<td>浙江省杭州市</td>
</tr>
</tbody></table>
<p>以上就是正排索引，当知道某个人的<code>ID</code>就可以通过主键<code>ID</code>去获取这个人的年龄和地址信息。</p>
<p>倒排索引结构：</p>
<p><strong>age</strong>字段</p>
<table>
<thead>
<tr>
<th>词项Term</th>
<th>文档列表</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>[1, 2]</td>
</tr>
<tr>
<td>30</td>
<td>[3, 4, 5]</td>
</tr>
<tr>
<td>60</td>
<td>6</td>
</tr>
</tbody></table>
<p><strong>address</strong>字段，当然这里的词项不一定只有<code>xx省</code>，也可以是<code>xx市</code>，这里只是简单举个例子。</p>
<table>
<thead>
<tr>
<th>词项Term</th>
<th>文档列表</th>
</tr>
</thead>
<tbody><tr>
<td>福建省</td>
<td>[1, 2, 3, 5]</td>
</tr>
<tr>
<td>湖南省</td>
<td>5</td>
</tr>
<tr>
<td>浙江省</td>
<td>6</td>
</tr>
</tbody></table>
<p>按以上的结构存储倒排索引之后，若需要查询福建省的所有人，就可以直接根据<code>福建省</code>的词项获取到<code>1,2,3,5</code>四个文档是符合条件，然后在结合正排索引，将这符合这四个<code>id</code>的文档找出。</p>
<p>​    当然了或许有人会说那不是直接<code>select * from table where address like %福建省%</code>就可以找出数据吗？在关系型数据库中模糊查询是无法命中索引的，也就是说模糊索引是需要全表扫描的，对于<code>es</code>的大数据定位而言是互斥的，所以增加倒排索引使得<code>es</code>的检索效率和性能显著提高。</p>
<h3 id="7-路由"><a href="#7-路由" class="headerlink" title="7.路由"></a>7.路由</h3><p>​    一个索引可以指定多个分片，且在多机的集群环境中，分片可能散落在不同的服务器上，在操作时可以将相关性数据存储在同一个分片上，提高检索效率。</p>
<blockquote>
<p>shard = hash(routing) % number_of_primary_shards</p>
<p>数据落在的分片编号 = 哈希函数(routing值)对分片数取余，默认routing值为文档id</p>
</blockquote>
<h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h2><p>​    分词器又叫分析器<code>Analyzer</code>，分词器的作用就是将文本经过分析之后转化为词项，在<code>es</code>搜索的最基本单元就是词项<code>Term</code>，通过词项来建立文档之间的映射。在<code>es</code>中又内置了多种基本的分词器，都是对英文的分词。</p>
<table>
<thead>
<tr>
<th>分词器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Standard Analyzer</td>
<td>英文标准分词器</td>
</tr>
<tr>
<td>Whitespace Analyzer</td>
<td>空格分词器</td>
</tr>
<tr>
<td>Pattern Analyzer</td>
<td>正则分词器</td>
</tr>
<tr>
<td>KeyWord Analyzer</td>
<td>关键词分词器</td>
</tr>
</tbody></table>
<p>目前使用的比较多的中文分词器应该是<code>elasticsearch-analysis-ik </code>，代码托管在<code>github</code>上，可以直接下载之后添加到<code>plugins</code>目录下。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch入门笔记(二)</title>
    <url>/2021/05/16/elasticsearch/ES%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="Elasticsearch入门笔记-二"><a href="#Elasticsearch入门笔记-二" class="headerlink" title="Elasticsearch入门笔记(二)"></a>Elasticsearch入门笔记(二)</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="1-1字符串类型"><a href="#1-1字符串类型" class="headerlink" title="1.1字符串类型"></a>1.1字符串类型</h4><h5 id="1-1-1-text"><a href="#1-1-1-text" class="headerlink" title="1.1.1 text"></a>1.1.1 text</h5><p>文本数据类型，使用之后该类型字段的值会被分词，生成倒排索引，用于全文检索。</p>
<span id="more"></span>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;, // 指定分词器</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;text&quot;,         // 设置类型为text</span></span><br><span class="line">        <span class="meta">&quot;fielddata&quot;</span>: <span class="string">true,      // 默认为false，该字段会启用内存空间进行一些排序、聚合操作</span></span><br><span class="line">        <span class="meta">&quot;fields&quot;</span>: <span class="string">&#123;             // 多类型，若某个字段既要满足能被搜索，又要满足能排序、聚合</span></span><br><span class="line">          <span class="meta">&quot;sort&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-keyword"><a href="#1-1-2-keyword" class="headerlink" title="1.1.2 keyword"></a>1.1.2 keyword</h5><p> 关键字类型，该字段不会被分词，只能按确切的值进行搜索，可以进行排序、聚合、过滤。一般使用在唯一性字段邮箱地址、<code>Mac</code>地址、身份证号之类不需要被分词的字段。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;ignore_above&quot;</span>: <span class="string">1024, // 指定查询的最大长度，超过则不会进行索引</span></span><br><span class="line">        <span class="meta">&quot;norms&quot;</span>: <span class="string">true         // 在进行查询评分时，是否需要考虑字段长度，默认为false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2数字类型"><a href="#1-2数字类型" class="headerlink" title="1.2数字类型"></a>1.2数字类型</h4><p>支持<code>long</code>、<code>integer</code>、<code>short</code>、<code>byte</code>、<code>double</code>、<code>float</code>、<code>half_float</code>(半精度浮点数)、<code>scaled_float</code>(带缩放因子浮点数)</p>
<p>scaled_float 举例：</p>
<p>在索引时会将原始值*缩放因子后四舍五入得到一个新值，将这个新值作为索引值(查询时返回的还是原值)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">      <span class="meta">&quot;price&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;scaled_float&quot;,</span></span><br><span class="line">        <span class="meta">&quot;scaling_factor&quot;</span>: <span class="string">100  # 需指定缩放因子</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>添加两条数据</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">book/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">10.1111 # 实际的索引值为1011</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">book/_doc/2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">11.1111 # 实际的索引值为1111</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>查询语句</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">book/_doc/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;match&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    	<span class="meta">&quot;price&quot;</span>: <span class="string">11.2222 # 11.2222 * 100再四舍五入后的值为1122,匹配不到文档</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3布尔类型"><a href="#1-3布尔类型" class="headerlink" title="1.3布尔类型"></a>1.3布尔类型</h4><p>布尔值，可以识别字符串的布尔值<code>&quot;true&quot;</code>，<code>&quot;false&quot;</code>，<code>true</code>，<code>false</code>。</p>
<h4 id="1-4日期类型"><a href="#1-4日期类型" class="headerlink" title="1.4日期类型"></a>1.4日期类型</h4><p>日期类型，由于在<code>json</code>中是没有具体的日期类型的表达，所以可以是日期格式化后的字符串，可以是毫秒数。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date&quot;,</span></span><br><span class="line">        <span class="meta">&quot;format&quot;</span>: <span class="string">&quot;yyyy-mm-dd||yyyy/mm/dd||epoch_millis&quot; //指定了三种格式的日期</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;aaa&quot;,</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2021-11-14&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加失败，日期格式不对</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;aaa&quot;,</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2021-11-14 14:20:20&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5范围类型"><a href="#1-5范围类型" class="headerlink" title="1.5范围类型"></a>1.5范围类型</h4><p>范围类型，表示一个区间，若指定该类型，字段值为一个对象。需使用到<code>gt</code>、<code>gle</code>、<code>lt</code>、<code>lte</code>等逻辑标识符表示。<code>integer_range</code>，<code>long_range</code>，<code>float_range</code>，<code>double_range</code>，<code>date_range</code>，<code>ip_range</code>(ip地址的范围)。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;price&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer_range&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">      <span class="meta">&quot;my_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date_range&quot;,</span></span><br><span class="line">        <span class="meta">&quot;format&quot;</span>: <span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;price&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;gt&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;lt&quot;</span>: <span class="string">10</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;my_date&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;gte&quot;</span>: <span class="string">&quot;2021-01-21&quot;,</span></span><br><span class="line">    <span class="meta">&quot;lte&quot;</span>: <span class="string">&quot;2021-05-22&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6地理类型"><a href="#1-6地理类型" class="headerlink" title="1.6地理类型"></a>1.6地理类型</h4><h5 id="1-6-1-geo-point"><a href="#1-6-1-geo-point" class="headerlink" title="1.6.1 geo_point"></a>1.6.1 geo_point</h5><p>表示一个坐标点。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建点结构</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.通过对象指定经纬度</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lat&quot;</span>: <span class="string">30,</span></span><br><span class="line">    <span class="meta">&quot;lon&quot;</span>: <span class="string">108</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.通过字符串“经度,维度”指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&quot;30,108&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.通过geohash指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&quot;wmkf9t74wmkf&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.通过数组[维度, 经度]指定</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">[108, 30]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">map/_doc/1</span></span><br></pre></td></tr></table></figure>

<h5 id="1-6-2-geo-shape"><a href="#1-6-2-geo-shape" class="headerlink" title="1.6.2 geo_shape"></a>1.6.2 geo_shape</h5><p>地理形状数据类型，使用<code>geoJson</code>表示。</p>
<table>
<thead>
<tr>
<th>geoJson</th>
<th>ElasticSearch Type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Point</td>
<td>point</td>
<td>单个地理坐标</td>
</tr>
<tr>
<td>LineString</td>
<td>lineString</td>
<td>两点或多点组成任意线</td>
</tr>
<tr>
<td>Polygon</td>
<td>polygon</td>
<td>一个闭合的多边形，其第一个点和最后一个点必须匹配。因此需要n+1个顶点来创建一个n边多边形，且最少4个顶点(构成三角形)</td>
</tr>
<tr>
<td>MultiPoint</td>
<td>multipoint</td>
<td>一组未连接但可能相关的点</td>
</tr>
<tr>
<td>MultiLineString</td>
<td>multilinestring</td>
<td>一组独立的线</td>
</tr>
<tr>
<td>MultiPolygon</td>
<td>multipolygon</td>
<td>一组独立的多边形</td>
</tr>
<tr>
<td>N/A</td>
<td>envelope</td>
<td>通过仅指定左上角和右下角构成的边界矩形</td>
</tr>
<tr>
<td>N/A</td>
<td>circle</td>
<td>由中心点和半径指定的圆，默认单位为m</td>
</tr>
</tbody></table>
<p><strong>例子</strong></p>
<blockquote>
<p>在线制作geojson -&gt; <a href="http://geojson.io/">http://geojson.io/</a></p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. point 单坐标,由[维度, 经度]组成</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;point&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[108, 30]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. lineString 地理线</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">  <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;lineString&quot;,</span></span><br><span class="line">  <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="meta">[108,</span> <span class="string">30],</span></span><br><span class="line">    <span class="meta">[120,</span> <span class="string">30]</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. polygon 闭合多边形，首位需要一致</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">      	<span class="meta">[108,</span> <span class="string">30],[120, 30],[120, 90],[108, 90],[108, 30]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个数组表示多边形外边界，第二个数组表示内边界</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;polygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[[106,28],[117,28],[117,34],[106,34],[106,28]],</span></span><br><span class="line">      <span class="attr">[[108,29],[115,29],[115,33],[108,33],[108,29]]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 4. multiPoint 多个点</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multiPoint&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">    	<span class="meta">[108,</span> <span class="string">30], [108, 31]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. multilinestring 多条线</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multilinestring&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="meta">[[108,</span> <span class="string">30],[120, 30]],</span></span><br><span class="line">      <span class="meta">[[109,</span> <span class="string">30],[121, 30]],</span></span><br><span class="line">      <span class="meta">[[110,</span> <span class="string">30],[122, 30]]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. multiPolygon 多个多边形</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;multipolygon&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">      	<span class="meta">[[108,</span> <span class="string">30],[120, 30],[120, 90],[108, 90],[108, 30]]</span></span><br><span class="line">      <span class="attr">],</span></span><br><span class="line">      <span class="attr">[</span></span><br><span class="line">        <span class="attr">[[106,28],[117,28],[117,34],[106,34],[106,28]],</span></span><br><span class="line">        <span class="attr">[[108,29],[115,29],[115,33],[108,33],[108,29]]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.envelope，指定形状的左上角和右下角的坐标，以表示边界矩形：</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;envelope&quot;,</span></span><br><span class="line">      <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[</span></span><br><span class="line">     	 <span class="attr">[110,39],[114,37]</span></span><br><span class="line">      <span class="attr">]</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 8. circle，添加一个圆，指定半径和中心点坐标</span></span><br><span class="line"><span class="comment"># 好像6版本之后不支持circle了，插入报错 circle geometry is not supported</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">map/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;circle&quot;,</span></span><br><span class="line">    <span class="meta">&quot;coordinates&quot;</span>: <span class="string">[110, 39],</span></span><br><span class="line">    <span class="meta">&quot;radius&quot;</span>: <span class="string">&quot;100km&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-7特殊类型"><a href="#1-7特殊类型" class="headerlink" title="1.7特殊类型"></a>1.7特殊类型</h4><h5 id="1-7-1-IP类型"><a href="#1-7-1-IP类型" class="headerlink" title="1.7.1 IP类型"></a>1.7.1 IP类型</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;ipAddress&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;ip&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address&quot;</span>:<span class="string">&quot;192.168.1.1&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 可以通过网段搜索</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;ipAddress&quot;</span>: <span class="string">&quot;192.168.0.0/16&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-8复合类型"><a href="#1-8复合类型" class="headerlink" title="1.8复合类型"></a>1.8复合类型</h4><h5 id="1-8-1数组"><a href="#1-8-1数组" class="headerlink" title="1.8.1数组"></a>1.8.1数组</h5><p>默认情况下任何字段都可以包含一个或多个值，当包含多个值时，就表示是一个数组，唯一要求是数组中的每个值的类型一致，不指定的情况下，以第一个值的类型为准。</p>
<h5 id="1-8-2对象类型"><a href="#1-8-2对象类型" class="headerlink" title="1.8.2对象类型"></a>1.8.2对象类型</h5><p>一个文档的一个属性可以是一个对象，这个对象的某一个属性可以在包含一个对象。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;,</span></span><br><span class="line">  <span class="meta">&quot;class&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;一班&quot;,</span></span><br><span class="line">    <span class="meta">&quot;location&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;province&quot;</span>: <span class="string">&quot;福建省&quot;,</span></span><br><span class="line">      <span class="meta">&quot;city&quot;</span>: <span class="string">&quot;福州市&quot;,</span></span><br><span class="line">      <span class="meta">&quot;county&quot;</span>: <span class="string">&quot;闽侯县&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="1-8-3嵌套类型"><a href="#1-8-3嵌套类型" class="headerlink" title="1.8.3嵌套类型"></a>1.8.3嵌套类型</h5><p><code>nested</code>类型。若文档的属性是一个对象数组。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address&quot;</span>: <span class="string">[</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;id&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;福建&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;id&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上例子，若使用对象类型保存，由于<code>luncene</code>没有内部对象的概念，所以<code>es</code>会将以上数据扁平化为简单的字段和值列表。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;address.id&quot;</span>: <span class="string">[1, 2],</span></span><br><span class="line">  <span class="meta">&quot;address.name&quot;</span>: <span class="string">[&quot;福建&quot;, &quot;北京&quot;]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这时若查询语句为查找<code>id=2,name=&quot;福建&quot;</code>也会被查询到。使用<code>nested</code>类型之后，将数组中的每一个对象作为独立文档来索引。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;address.id&quot;</span>: <span class="string">1,</span></span><br><span class="line">    <span class="meta">&quot;address.name&quot;</span>: <span class="string">&quot;福建&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">&quot;address.id&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;address.name&quot;</span>: <span class="string">&quot;北京&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-索引操作"><a href="#2-索引操作" class="headerlink" title="2.索引操作"></a>2.索引操作</h3><h4 id="2-1创建索引"><a href="#2-1创建索引" class="headerlink" title="2.1创建索引"></a>2.1创建索引</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/05/12/TfWvHkzdpNU8nO2.png"></p>
<h4 id="2-2删除索引"><a href="#2-2删除索引" class="headerlink" title="2.2删除索引"></a>2.2删除索引</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">DELETE</span> <span class="string">library</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3修改索引"><a href="#2-3修改索引" class="headerlink" title="2.3修改索引"></a>2.3修改索引</h4><p>可以修改索引的属性<code>Settings</code>，比如索引的分片数、副本数、路由、读写权限等。</p>
<p><strong>修改索引分片数和副本数都为2</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;settings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;number_of_shards&quot;</span>: <span class="string">2,</span></span><br><span class="line">    <span class="meta">&quot;number_of_replicas&quot;</span>: <span class="string">2</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4复制索引"><a href="#2-4复制索引" class="headerlink" title="2.4复制索引"></a>2.4复制索引</h4><p>复制索引时只会复制其中的数据，不会复制<code>setting</code>中的信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_reindex</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;source&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;dest&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library2&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-索引别名"><a href="#2-5-索引别名" class="headerlink" title="2.5 索引别名"></a>2.5 索引别名</h4><p>索引别名可以指向一个或者多个索引，也就是说多个索引可以共用一个别名。比如<code>library_log_20210514</code>和<code>library_log_20210515</code>两个索引都对它们设置索引别名为<code>library_log</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_aliases</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;actions&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_log_20210514&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_log&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_log_20210515&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_log&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置之后就可以通过一个名称来进行全文检索</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library_log/_search</span></span><br></pre></td></tr></table></figure>

<p><strong>通过别名创建视图</strong>，为<code>library</code>中作者是<code>tom</code>创建一个视图。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_aliases</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;actions&quot;</span>: <span class="string">[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library_alias&quot;,</span></span><br><span class="line">        <span class="meta">&quot;filter&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">          <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>索引别名其实类似关系数据库中视图的概念，只提供读操作，不能进行写操作。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取所有别名</span></span><br><span class="line"><span class="attr">GET</span>  <span class="string">_cat/aliases</span></span><br></pre></td></tr></table></figure>

<p>在真是环境中，索引的设计不可能呢一步到位，随着需求、业务的扩展，可能会修改索引的<code>mapping</code>的字段类型、或者是<code>setting</code>中的配置信息，若简单采用<code>reindex</code>操作，在实施运维操作更新这段时间内，有可能导致数据不可访问，所以可以通过指定别名的方式进行索引迁移。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 创建新索引结构</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library_new</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"> <span class="meta">...</span> <span class="string">// 索引结构等等</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用reindex进行索引数据迁移</span></span><br><span class="line"><span class="attr">POST</span>  <span class="string">_reindex</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;source&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;dest&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_new&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后在修改索引别名</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">_aliases?pretty</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">	<span class="attr">&quot;actions&quot;&quot;[</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;remove&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">&quot;add&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">&quot;library_new&quot;,</span></span><br><span class="line">        <span class="meta">&quot;alias&quot;</span>: <span class="string">&quot;library&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">	<span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-6关闭-开启索引"><a href="#2-6关闭-开启索引" class="headerlink" title="2.6关闭/开启索引"></a>2.6关闭/开启索引</h4><p>索引关闭后只能获取索引的<code>setting</code>信息，不能进行读写。</p>
<p>关闭索引：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">book/_close</span></span><br></pre></td></tr></table></figure>

<p>打开索引：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">book/_open</span></span><br></pre></td></tr></table></figure>

<h3 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h3><h4 id="3-1新增文档"><a href="#3-1新增文档" class="headerlink" title="3.1新增文档"></a>3.1新增文档</h4><p><code>6.*</code>版本之后一个索引只允许一个类型，所以路径上固定<code>索引名/_doc/id(可选)</code>，可以指定<code>id</code>，不指定会自动生成。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定id</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定id，由es生成</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c入门&quot;,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;marry&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>返回参数解析，其中<code>_shards</code>节点中<code>total</code>为2但是只有一个分片成功的原因是，我的环境是单机单节点，但是刚刚设置的时候又设置了两个分片，其实这种设置是不符合逻辑的。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;_index&quot;</span> : <span class="string">&quot;library&quot;,  // 对应的索引</span></span><br><span class="line">  <span class="meta">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;,			 // 文档类型</span></span><br><span class="line">  <span class="meta">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;,					 // 创建的文档id</span></span><br><span class="line">  <span class="meta">&quot;_version&quot;</span> : <span class="string">2,				 // 文档版本</span></span><br><span class="line">  <span class="meta">&quot;result&quot;</span> : <span class="string">&quot;created&quot;,  // 操作状态，有created、updated </span></span><br><span class="line">  <span class="meta">&quot;_shards&quot;</span> : <span class="string">&#123;          // 分片上的执行状态</span></span><br><span class="line">    <span class="meta">&quot;total&quot;</span> : <span class="string">2,				 // 分片数量</span></span><br><span class="line">    <span class="meta">&quot;successful&quot;</span> : <span class="string">1,    // 执行成功分片数量</span></span><br><span class="line">    <span class="meta">&quot;failed&quot;</span> : <span class="string">0         // 执行失败分片数量</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;_seq_no&quot;</span> : <span class="string">2,         // 索引写操作版本</span></span><br><span class="line">  <span class="meta">&quot;_primary_term&quot;</span> : <span class="string">1    // 文档所在分片</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    在<code>6.7</code>之前使用<code>_version</code>来做并发控制，每一个文档都维护各自的<code>_version</code>字段，每次多这个文档的写操作都会自增这个字段，当写操作之后<code>_version</code>字段进行自增后小于存储中的<code>_version</code>时，写操作所提交的内容会被拒绝。</p>
<p>​    在<code>6.7</code>之后使用<code>_seq_no</code>和<code>_primary_term</code>来做并发控制，<code>seq_no</code>类似于<code>_version</code>字段，但是它的生命周期是整个索引，而<code>_version</code>的生命周期是某一个文档。</p>
<h4 id="3-2修改文档"><a href="#3-2修改文档" class="headerlink" title="3.2修改文档"></a>3.2修改文档</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定id进行更新，这种更新会覆盖旧文档</span></span><br><span class="line"><span class="comment"># 原文档有name和author字段，经过以下更新后只剩name字段</span></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 更新指定字段</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">library/_update/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;script&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;,</span></span><br><span class="line"><span class="comment">    # 设置name为参数params中的name</span></span><br><span class="line">    <span class="meta">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.name=params.name&quot;,</span></span><br><span class="line">    <span class="meta">&quot;params&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>更新指定文档通过脚本的方式更新，<code>ctx</code>可以获取到上下对象，即通过<code>GET library/_doc/1</code>获取到的数据。上下文对象中的<code>_source</code>节点就是存储的数据。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;library&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;java入门&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过条件进行更新操作。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">library/_update_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;script&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;,</span></span><br><span class="line">    <span class="meta">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.name=params.name&quot;,</span></span><br><span class="line">    <span class="meta">&quot;params&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;c++&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3删除文档"><a href="#3-3删除文档" class="headerlink" title="3.3删除文档"></a>3.3删除文档</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定文档</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">library/_doc/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据查询条件删除</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">library/_delete_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;value&quot;</span>: <span class="string">&quot;java&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4批量操作"><a href="#3-4批量操作" class="headerlink" title="3.4批量操作"></a>3.4批量操作</h4><p>在<code>es</code>中通过<code>Bluk api</code>来执行批量操作。</p>
<p>1.可以通过<code>Kibana</code>来访问<code>Bluk</code>接口。批量操作的数据语法为一行操作(<code>auction</code>)，一行数据。</p>
<p>2.也可以通过请求直接执行。</p>
<blockquote>
<p>curl -XPOST “<a href="http://localhost:9200/library/_bulk&quot;">http://localhost:9200/library/_bulk&quot;</a> -H “content-type:application/json” –data-binary @es-pipeline.json</p>
</blockquote>
<p><strong>注意：</strong>结尾要空出一行。</p>
<p>否则会报错:</p>
<blockquote>
<p>{“error”:{“root_cause”:[{“type”:”illegal_argument_exception”,”reason”:”The bulk request must be terminated by a newline [\n]”}],”type”:”illegal_argument_exception”,”reason”:”The bulk request must be terminated by a newline [\n]”},”status”:400}%</p>
</blockquote>
<p><strong>注意：</strong>执行时需要添加<code>-H &quot;content-type:application/json&quot;</code></p>
<p>否则会报错</p>
<blockquote>
<p>{“error”:”Content-Type header [application/x-www-form-urlencoded] is not supported”,”status”:406}%</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">_bulk</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;1&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;c++入门&quot;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;2&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;java入门&quot;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;index&quot;</span>: <span class="string">&#123;&quot;_index&quot;: &quot;library&quot;, &quot;_id&quot;: &quot;3&quot;&#125;&#125;</span></span><br><span class="line"><span class="meta">&#123;&quot;name&quot;</span>: <span class="string">&quot;pyton入门&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-5查询文档"><a href="#3-5查询文档" class="headerlink" title="3.5查询文档"></a>3.5查询文档</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过id获取文档</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_doc/1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-6-数据迁移"><a href="#3-6-数据迁移" class="headerlink" title="3.6 数据迁移"></a>3.6 数据迁移</h4><p>​    在别名那里顺便提了<code>reindex</code>，通过该关键字进行索引间的数据拷贝，只拷贝数据，不拷贝<code>mapping</code>和<code>setting</code>信息。</p>
<h3 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4. 关键字"></a>4. 关键字</h3><h5 id="4-1-analyzer-search-analyzer"><a href="#4-1-analyzer-search-analyzer" class="headerlink" title="4.1 analyzer/search_analyzer"></a>4.1 analyzer/search_analyzer</h5><p>通过<code>analyzer</code>指定分词器，在查询时若没有通过<code>search_analyzer</code>指定分词器，默认使用该索引的<code>analyzer</code>分词器来进行分词。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;decr&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>:<span class="string">&quot;text&quot;,</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;  // 指定分词器</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-normailizer"><a href="#4-2-normailizer" class="headerlink" title="4.2 normailizer"></a>4.2 normailizer</h5><p>预处理，在查询前进行数据预处理。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;settings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;analysis&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;normalizer&quot;</span>: <span class="string">&#123;               // 创建一个预处理</span></span><br><span class="line">        <span class="meta">&quot;lowerNor&quot;</span>: <span class="string">&#123;               // 创建一个名为lowerNor的预处理器</span></span><br><span class="line">          <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;,         // 类型为自定义</span></span><br><span class="line">          <span class="meta">&quot;filter&quot;</span>: <span class="string">[&quot;lowercase&quot;]   // 过滤器:大小写转换</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;,</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;, </span></span><br><span class="line">        <span class="meta">&quot;normalizer&quot;</span>: <span class="string">&quot;lowerNor&quot;</span></span><br><span class="line">      <span class="attr">&#125;,</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-coerce"><a href="#4-3-coerce" class="headerlink" title="4.3 coerce"></a>4.3 coerce</h5><p>设置不进行类型转换。默认情况下，若指定字段类型为<code>integer</code>，插入数据时若插入为字符串<code>&quot;10&quot;</code>，也会插入成功。若不需要该类型自动转换，则标记该字段为<code>false</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;id&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;,</span></span><br><span class="line">        <span class="meta">&quot;coerce&quot;</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-4-enabled-index"><a href="#4-4-enabled-index" class="headerlink" title="4.4 enabled/index"></a>4.4 enabled/index</h5><p><code>enabled</code>表示若某字段仅存储，不需要进行全文检索。默认为<code>true</code>表示需要进行检索。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;enabled&quot;</span>: <span class="string">true</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询结果为空</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>index</code>指定一个字段是否被索引。<code>true</code>表示字段会被索引。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;date&quot;,</span></span><br><span class="line">        <span class="meta">&quot;index&quot;</span>: <span class="string">false</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2020&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接报错 </span></span><br><span class="line"><span class="comment"># failed to create query: Cannot search on field [publish_date] since it is not indexed.</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;publish_date&quot;</span>: <span class="string">&quot;2020&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-5-ignore-above"><a href="#4-5-ignore-above" class="headerlink" title="4.5 ignore_above"></a>4.5 ignore_above</h5><p>用于<code>keyword</code>类型，表示指定分词和索引字符串的最大长度，超过该长度将不会被索引。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;author&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;,</span></span><br><span class="line">        <span class="meta">&quot;ignore_above&quot;</span>: <span class="string">10</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-6-ignore-malformed"><a href="#4-6-ignore-malformed" class="headerlink" title="4.6 ignore_malformed"></a>4.6 ignore_malformed</h5><p>忽略不匹配类型数据。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">user</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;,</span></span><br><span class="line">        <span class="meta">&quot;ignore_malformed&quot;</span>: <span class="string">true // 标记允许</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">user/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;abc&quot;       // 不是integer乐西</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">user/_doc/1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;,</span></span><br><span class="line">  <span class="meta">&quot;_version&quot;</span> : <span class="string">1,</span></span><br><span class="line">  <span class="meta">&quot;_seq_no&quot;</span> : <span class="string">0,</span></span><br><span class="line">  <span class="meta">&quot;_primary_term&quot;</span> : <span class="string">1,</span></span><br><span class="line">  <span class="meta">&quot;_ignored&quot;</span> : <span class="string">[</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span></span><br><span class="line">  <span class="attr">],</span></span><br><span class="line">  <span class="meta">&quot;found&quot;</span> : <span class="string">true,</span></span><br><span class="line">  <span class="meta">&quot;_source&quot;</span> : <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;name&quot;</span> : <span class="string">&quot;abc&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-7-null-value"><a href="#4-7-null-value" class="headerlink" title="4.7 null_value"></a>4.7 null_value</h5><p>在 <code>es </code>中，值为 <code>nul</code> 的字段不索引也不可以被搜索，<code>null_value</code> 可以让值为<code>null </code>的字段显式的可索引、可搜索。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;,</span></span><br><span class="line">        <span class="meta">&quot;null_value&quot;</span>: <span class="string">&quot;nameNull&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;name&quot;</span>: <span class="string">null,</span></span><br><span class="line">  <span class="meta">&quot;author&quot;</span>: <span class="string">&quot;tom&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过null_value指定的值来进行查询。</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">users/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;name&quot;</span>: <span class="string">&quot;nameNull&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-8-fields"><a href="#4-8-fields" class="headerlink" title="4.8 fields"></a>4.8 fields</h5><p><code>fields</code>参数可以让同一字段有多种不同的索引方式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;text&quot;,</span></span><br><span class="line">        <span class="meta">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;, </span></span><br><span class="line">        <span class="meta">&quot;fields&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">          <span class="meta">&quot;raw&quot;</span>:<span class="string">&#123;</span></span><br><span class="line">            <span class="meta">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PUT</span> <span class="string">library/_doc/1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;describe&quot;</span>:<span class="string">&quot;这是一本中国人写的书&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe&quot;</span>: <span class="string">&quot;这是&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">GET</span> <span class="string">library/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;query&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;term&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;describe.raw&quot;</span>: <span class="string">&quot;这是一本中国人写的书&quot;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-9-Dynamic-templates"><a href="#4-9-Dynamic-templates" class="headerlink" title="4.9.Dynamic_templates"></a>4.9.Dynamic_templates</h5><p>映射模板，默认情况下，由<code>es</code>根据默认规则对数据进行预判对应的类型，若需要自定义规则，可以使用<code>Dynamic_templates</code>。</p>
<h5 id="4-10-dynamic"><a href="#4-10-dynamic" class="headerlink" title="4.10 dynamic"></a>4.10 dynamic</h5><p>用于检测新发现的字段。</p>
<ul>
<li>true: 默认，新发现的字段添加到映射中。</li>
<li>false: 必须显示指定新字段</li>
<li>strict:若检测到新字段，抛出异常。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">PUT</span> <span class="string">library</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">&quot;mappings&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">&quot;dynamic&quot;</span>: <span class="string">false,</span></span><br><span class="line">    <span class="meta">&quot;properties&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">&quot;username&quot;</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot的Spi机制</title>
    <url>/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="springboot的Spi机制"><a href="#springboot的Spi机制" class="headerlink" title="springboot的Spi机制"></a>springboot的Spi机制</h1><p>​    在与<code>Springboot</code>打交道的过程中，应该大家对<code>starter</code>都不会陌生，<code>springboot</code>中的各种<code>starter</code>其实就是利用了<code>springboot</code>的<code>SPI</code>机制。</p>
<span id="more"></span>

<p>​    在<code>springboot</code>中，会默认扫描<code>Applicatoin</code>启用类及其子包里面的配置类<code>Bean</code>(比如标记<code>@Configuration</code>，<code>@Component</code>，<code>@Server</code>等)然后进行初始化，那么如果你是为别人提供二方包，三方包的库，如果你的需要加载的类路径跟他的不一样，那么根据<code>Springboot</code>的<code>bean</code>加载机制是不会加载到的。</p>
<p><b>主工程：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── Application.java</span><br></pre></td></tr></table></figure>

<p><b>二方库A：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure>

<p><b>二方库B：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.xiaocainiaoya</span><br><span class="line">│           ├── MybatisXmlReloadConfig.java</span><br></pre></td></tr></table></figure>

<p>这时只有<b>二方库A</b>可以正确加载<code>MybatisXmlReloadConfig</code>这个<code>bean</code>，因为它的路径在<b>主工程</b>的<code>Application</code>的包以及子包下，那么就出现所有的二方库、三方库都需要与主工程的类路径一致？</p>
<p>这里<code>Springboot</code>就提供了<code>Spi</code>的机制用来获取二方库，三方库中需要加载的<code>Bean</code>对象。</p>
<p><code>注意</code>：一定要确保二方库、三方库的类路径不在主工程<code>Application</code>下的情况，在考虑<code>SPI</code>逻辑，我之前就掉入一个陷阱，因为我的二方库的类路径与主工程一致，但是那个时候我的<code>spring.factories</code>指向的路径是错的，导致一度怀疑自己理解的<code>SPI</code>有出入。</p>
<p><b>二方库、三方库类路径与主工程启动类路径不一致的情况下！！！(再次强调！)</b>如果使得主工程可以加载到对应库中的<code>bean</code>对象。</p>
<ol>
<li><p>创建<code>META-INF/spring.factories</code>文件。这个文件中是<code>k-v</code>的结构，一个<code>key</code>对应多个逗号分隔的<code>value</code>。对于这个文件来说，可以配置的<code>key</code>有很多，比如有<code>EnableAutoConfiguration</code>，<code>ApplicationContextInitializer</code>，<code>ApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li>
<li><p>在主工程启动时，会加载<code>META-INF/spring.factories</code>文件，对这个文件内指向的<code>bean</code>对象进行逐个加载。</p>
</li>
</ol>
<p>主要源码在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>注意：在<code>Springboot2.7</code>之后引入了新的<code>SPI</code>配置方式。</b></p>
<ol>
<li><p>创建<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件。这个文件的文件名是固定，文件内容是<code>value</code>，各个<code>value</code>之间通过回车分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.bosssoft.xiaocainiaoya.MyImportTest</span><br></pre></td></tr></table></figure></li>
</ol>
<p>主要源码同样是在<code>AutoConfigurationImportSelector#getCandidateConfigurations</code>中进行了兼容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 兼容</span></span><br><span class="line">    ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="@AutoConfiguration"></a>@AutoConfiguration</h3><p>​    在<code>Springboot</code>中可以直接使用<code>@AutoConfiguration</code>来启用<code>SPI</code>机制，这是一个组合注解，通过<code>@AliasFor</code>注解将值传递给<code>@Configuration</code>、<code>@AutoConfigureBefore</code>、<code>@AutoConfigureAfter</code>三个注解。</p>
<p><b>注：使用这个注解需要配合<code>META-INF/spring</code>中设置<code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件中配置全限定类名。</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureBefore.class, attribute = &quot;value&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureBefore.class, attribute = &quot;name&quot;)</span></span><br><span class="line">    String[] beforeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureAfter.class, attribute = &quot;value&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = AutoConfigureAfter.class, attribute = &quot;name&quot;)</span></span><br><span class="line">    String[] afterName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cn.com.xiaocainiaoya.config.MyAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><b>注：我之前进入一个误区，以为组合注解标记在某个类上就表明这个类拥有组合注解中的相关能力，其实这是错误的。</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AutoConfiguration测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaocainiao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/10 10:11:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AutoConfiguration()</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">house</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> House();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里我创建了类<code>MyAutoConfiguration</code>，标记了<code>@AutoConfiguration</code>注解，虽然这个注解是组合注解，也就是说实际上这个类也被<code>@AutoConfiguration</code>注解中的<code>@Configuration</code>标记，但是启动之后发现，在没有写<code>META-INF/spring</code>文件的情况下是不会加载，所以这里要解释一下，注解仅仅是标记了某个类，注解要起到什么作用取决于获取这个注解的动作的代码逻辑是如何。换句话说，标记了<code>@AutoConfiguration</code>实际上是可以具备<code>@Configuration</code>能力(不写<code>META-INF/spring</code>文件就可以被加载到容器中)，但是获取这个注解的处理端可以选择不赋予这种能力。<b>感觉还是没有说情况，文字表述不能很清楚的表达，上代码！</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当扫描到MyAutoConfiguration类需要进行容器化处理时肯定是需要进入某个处理器来进行处理</span></span><br><span class="line"><span class="comment">// 通过类对象来获取到对应标记的注解(这时其实只获取到@AutoConfiguration)</span></span><br><span class="line">Annotation[] annotations = MyAutoConfiguration.class.getAnnotations();</span><br><span class="line"><span class="comment">// 1.如果我的处理代码，仅仅是判断这个annotations中存不存在@Configuration来进行容器化，那么这个类就不会进行容器化。</span></span><br><span class="line"><span class="comment">// 2.如果我的处理代码，是如下代码，获取到当前类上的注解之后，逐个获取对应的组合注解中是否存在Configuration注解，再进行对应的处理，那么这个注解就会具备@Configuration的能力</span></span><br><span class="line"><span class="comment">// 所以在使用组合注解的情况下，主要是看处理注解的地方的判断方式，而不是组合注解上是否存在某注解！！</span></span><br><span class="line">Annotation[] annotations = MyAutoConfiguration.class.getAnnotations();</span><br><span class="line"><span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">    Configuration configuration = annotation.annotationType().getAnnotation(Configuration.class);</span><br><span class="line">    <span class="keyword">if</span>(ObjectUtils.isNotEmpty(configuration))&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hutool中有提供方法可以快速获取组合注解中的注解</span></span><br><span class="line">Configuration[] candidates = AnnotationUtil.getCombinationAnnotations(field, Configuration.class);</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot部分功能浅析</title>
    <url>/2023/04/26/Springboot/springboot%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="springboot部分功能浅析"><a href="#springboot部分功能浅析" class="headerlink" title="springboot部分功能浅析"></a>springboot部分功能浅析</h1><span id="more"></span>

<h2 id="1-绑定器"><a href="#1-绑定器" class="headerlink" title="1.绑定器"></a>1.绑定器</h2><p><code>org.springframework.boot.context.properties.bind.Binder</code>是<code>springboot</code>从<code>environment</code>对象中获取配置信息的绑定器，可以很方便的就获取到对应的配置值信息。</p>
<p>1.创建配置类(必须要提供<code>set</code>方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DtpProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.配置文件中的配置项</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.dynamic.enabledBanner</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.dynamic.apollo.namespace</span>=<span class="string">aaa</span></span><br></pre></td></tr></table></figure>

<p>2.通过<code>Binder</code>获取配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Binder.get(environment).bind(<span class="string">&quot;spring.dynamic&quot;</span>, Bindable.ofInstance(dtpProperties));</span><br></pre></td></tr></table></figure>

<h2 id="2-Import引入"><a href="#2-Import引入" class="headerlink" title="2.@Import引入"></a>2.@Import引入</h2><p>通过<code>@Import</code>引入将某些配置类或者扩展点接口添加到容器中。</p>
<p><b>示例：</b></p>
<p>1.创建一个注解<code>EnableMyConfig</code>，该注解使用<code>@Import</code>标记，并添加<code>MyConfigurationSelector.class</code>，这个类实现了<code>ImportSelector</code>顶层接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MyConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现<code>DeferredImportSelector#selectImports</code>接口，那么在<code>Spring</code>加载到这个引入类<code>MyConfigurationSelector</code>时就会将<code>MyBeanDefinitionRegistrar</code>类添加到<code>Spring</code>容器中，作用等同于为<code>MyBeanDefinitionRegistrar</code>添加<code>@Component</code>等自动注入注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;MyBeanDefinitionRegistrar.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.这个引入类一般以注册类居多，如果是配置类一般通过<code>@Component</code>或者<code>@Configuration</code>等注解就可自动注入，我这里的示例是一个注册类。实现于<code>ImportBeanDefinitionRegistrar</code>接口，<code>MyBeanDefinitionRegistrar</code>这个<code>spring</code>生命周期中会执行到<code>registerBeanDefinitions</code>，即为<code>MyProperties</code>类创建<code>BeanDefinition</code>对象，并将这个对象注入到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BeanDefinition对象构建器</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(DtpProperties.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注入属性键和属性值</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;enabledBanner&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里手动注册bean对象</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;myProperties&quot;</span>, builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>注意：<code>@EnableMyConfig</code>注解需要标记到某个类上，且这个类在扫描范围之内才会生效，我曾经深深陷入于这个注解已经是在扫描范围之内，为什么需要标记到某个类上，扫描到这个注解后这个注解不是被<code>@Import</code>标记吗，难道不能直接获取到<code>@Import</code>中的值。实际上还是需要通过标记的这个类上拥有<code>@Component</code>等自动注入的注解。</b></p>
<p>整个过程大致为：由<code>Spring</code>容器MapperScan入口<code>refresh</code>方法 &rArr;执行容器中实现<code>BeanDefinitionRegistryPostProcessor</code>的<code>bean</code>对象&rArr;<code>ConfigurationClassPostProcessor</code>是对<code>BeanDefinitionRegistryPostProcessor</code>的实现，主要处理逻辑在这个类中。&rArr;之后会执行实现<code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code>，也就是这时会执行<code>MyBeanDefinitionRegistrar</code>这个自定义类，在这个自定义类中又注册了新的<code>BeanDefinition</code>&rArr;之后<code>Spring</code>容器会创建这个<code>Bean</code>对象。</p>
<p>综上：从<code>Spring</code>容器的角度来说，<code>MyBeanDefinitionRegistrar</code>是在<code>ConfigurationClassPostProcessor</code>执行时加载的，<code>MyProperties</code>是在<code>MyBeanDefinitionRegistrar</code>加载之后加载。</p>
<p>​    目前在<code>Spring</code>的生态中一般都是通过<code>@EnableXX</code>注解标记<code>@Import</code>注解来引入某些配置的方式，进行动态的引入某些配置类。比如<code>EnableScheduling</code>，只有将这个注解标记在扫描配置类之上，才会通过<code>@Import</code>引入配置<code>SchedulingConfiguration</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Import</code>也可以配合<code>ImportSelector</code>实现类，进行动态创建类。比如<code>MapperScan</code>。在<code>MapperScannerRegistrar</code>中动态的创建 <code>MapperScannerConfigurer</code>对象并注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-配置类加载"><a href="#3-配置类加载" class="headerlink" title="3.配置类加载"></a>3.配置类加载</h2><p><code>EnableConfigurationProperties</code>注解配合<code>ConfigurationProperties</code>注解进行使用。</p>
<p>假设说创建了一个配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.dynamic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabledBanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Apollo apollo;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Apollo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String namespace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个类没有标记<code>@Configuration</code>注解，那么这个容器中不会有这个类的<code>Bean</code>对象。</p>
<p>所以将此配置类添加到容器中有两种方式，一种是直接添加注入容器注解<code>@Configuration</code>。第二种是通过<code>@EnableConfigurationProperties</code>注解指向这个配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBeanConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRegistry <span class="title">myRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当加载<code>DtpBaseBeanConfiguration</code>这个类时，会读取到<code>EnableConfigurationProperties</code>注解，这里又是一个<code>@Import</code>的应用，引入了<code>EnableConfigurationPropertiesRegistrar</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnableConfigurationPropertiesRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        registerInfrastructureBeans(registry);</span><br><span class="line">        registerMethodValidationExcludeFilter(registry);</span><br><span class="line">        ConfigurationPropertiesBeanRegistrar beanRegistrar = <span class="keyword">new</span> ConfigurationPropertiesBeanRegistrar(registry);</span><br><span class="line">        <span class="comment">// 获取到指向的配置类(这里是MyProperties),这里会将MyProperties转换为</span></span><br><span class="line">        <span class="comment">// BeanDefinition对象注册到容器中, 等到根据BeanDefinition创建具体的bean</span></span><br><span class="line">        <span class="comment">// 对象的时候，会读取到ConfigurationProperties注解进行配置属性值的绑定</span></span><br><span class="line">        getTypes(metadata).forEach(beanRegistrar::register);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>注意：这个<code>EnableConfigurationProperties</code>注解的作用仅仅是将某个配置类转换为<code>BeanDefinition</code>注册到<code>Spring</code>容器中，结合<code>@ConditionXXX</code>可以减少无用<code>bean</code>对象的创建。</b></p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>git多账号配置</title>
    <url>/2021/04/26/git/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="git多账号配置"><a href="#git多账号配置" class="headerlink" title="git多账号配置"></a>git多账号配置</h3><p>[TOC]</p>
<p><img src="https://i.loli.net/2021/04/26/joMvuTEkm7WZH3R.png" alt="Snipaste_2021-04-26_21-03-51.png"></p>
<h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    最近看了一些博客都是在推荐技术新人通过写博客的方式记录学习到的知识点和遇到的问题，好记性不如烂笔头，我也尝试开始写博客，在通过<code>github gitpage</code>搭建博客的时候发现需要在一台电脑中配置两个<code>git</code>账号，之前都是全局配置公司的<code>gitlib</code>账号。记录一下整个的配置过程，过程中也踩了不少坑。</p>
<span id="more"></span>

<h4 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h4><p>​    在电脑上配置两个<code>git</code>账号，一个是<code>gitlib</code>账号用来工作使用，一个是<code>github</code>账号用来博客推送。</p>
<h4 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h4><h5 id="3-1-清除全局配置"><a href="#3-1-清除全局配置" class="headerlink" title="3.1 清除全局配置"></a>3.1 清除全局配置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看全局配置;若存在用户名和邮箱则清除</span></span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除全局用户名和邮箱</span></span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure>

<h5 id="3-2-生成秘钥"><a href="#3-2-生成秘钥" class="headerlink" title="3.2 生成秘钥"></a>3.2 生成秘钥</h5><p>生成两个秘钥，一个用于公司工作，一个用于博客。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一路回车即可</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>我这边是把生成的两个秘钥对(总共四个文件)分类在两个文件夹下(<code>company</code>和<code>xiaocaioniaoya</code>)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">xiaocainiaoya@macBook-Pro-3&gt;</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line">xiaocainiaoya@macBook-Pro-3/.ssh&gt;ls</span><br><span class="line">company   config  known_hosts   xiaocainiaoya</span><br></pre></td></tr></table></figure>

<p>生成之后分别把<code>.pub</code>后缀公钥放置到远程服务器的<code>SSH keys</code>中。</p>
<h5 id="3-3-秘钥添加到本地"><a href="#3-3-秘钥添加到本地" class="headerlink" title="3.3 秘钥添加到本地"></a>3.3 秘钥添加到本地</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/company/id_rsa_company</span><br></pre></td></tr></table></figure>

<h5 id="3-4-创建config文件"><a href="#3-4-创建config文件" class="headerlink" title="3.4 创建config文件"></a>3.4 创建config文件</h5><p>一下是我的<code>config</code>配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">公司的 gitlib</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Host 可以随便起,只是一个命名而已</span></span><br><span class="line">Host company</span><br><span class="line">HostName xx.xx.xx.xx:xxx</span><br><span class="line">User xxx</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绝对路径</span></span><br><span class="line">IdentityFile ~/.ssh/company/id_rsa_company</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> xiaocainiaoya github</span></span><br><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">User xiaocainiaoya</span><br><span class="line">IdentityFile ~/.ssh/xiaocainiaoya/id_rsa_xiaocainiaoya</span><br></pre></td></tr></table></figure>

<h5 id="3-5-测试是否可以连接"><a href="#3-5-测试是否可以连接" class="headerlink" title="3.5 测试是否可以连接"></a>3.5 测试是否可以连接</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接就是这个命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ssh -T git@github</span></span><br><span class="line">Hi xiaocainiaoya! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原来还以为要替换成自己的用户名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh -T xiaocainiaoya@github</span></span><br></pre></td></tr></table></figure>

<h5 id="3-6-配置local级别用户名和邮箱"><a href="#3-6-配置local级别用户名和邮箱" class="headerlink" title="3.6 配置local级别用户名和邮箱"></a>3.6 配置<code>local</code>级别用户名和邮箱</h5><p>由于本地配置了多账号，在提交时根据不同的地址采用不同的用户名和邮箱，所以需要进入到某个项目配置当前项目的用户名和邮箱信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --local user.name &quot;xiaocainiaoya&quot;</span><br><span class="line">git config --local user.email &quot;xiaocainiaoya@foxmail.com&quot;</span><br></pre></td></tr></table></figure>

<h4 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h4><p>在配置完成之后，也测试可以提交之后没有太多关注具体的提交信息，在使用一段时间之后发现博客的提交记录中用户名是我的名字。由于用户名的级别<code>system</code>&gt;<code>global</code>&gt;<code>local</code>。在添加了<code>local</code>配置之后，后续提交的记录上用户名和邮箱正常了，那之前提交的那些用户名和邮箱怎么改？</p>
<p><strong>git filter-branch</strong></p>
<blockquote>
<p>git中最猛的后悔药，没有把握慎用。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git filter-branch -f --commit-filter &#x27;</span><br><span class="line">        if [ &quot;$GIT_COMMITTER_NAME&quot; = &quot;已提交的用户名&quot; ];</span><br><span class="line">        then</span><br><span class="line">                GIT_COMMITTER_NAME=&quot;想要变成的用户名&quot;;</span><br><span class="line">                GIT_AUTHOR_NAME=&quot;$GIT_COMMITTER_NAME&quot;;</span><br><span class="line">                GIT_COMMITTER_EMAIL=&quot;想要变成的邮箱&quot;;</span><br><span class="line">                GIT_AUTHOR_EMAIL=&quot;$GIT_COMMITTER_EMAIL&quot;;</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        else</span><br><span class="line">                git commit-tree &quot;$@&quot;;</span><br><span class="line">        fi&#x27; HEAD</span><br></pre></td></tr></table></figure>

<p>执行命令之后会发现用户名和邮箱都已经修改为想要变成的样子。再执行<strong>强制</strong>推向远程，要确保已经是最新的<code>HEAD</code>否则会覆盖他人编写的代码。(<code>HEAD</code>可以修改为<code>HEAD~5..HEAD</code>表示最近的5个提交)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure>

<p><code>git filter-branch</code>还有很多的其他的用法，有一个我觉得日常中可能会使用到的。</p>
<p>在某次提交时提交了某个大文件或者敏感文件，虽然可以在下次提交中删除该文件，或者把该文件添加到<code>.gitignore</code>中，但是如果回溯到某个提交时那个文件还是存在，现在想要将所有历史的提交中移出改文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 中间引号那一段是shell脚本</span></span><br><span class="line">git filter-branch --force --index-filter &#x27;git rm --cached --ignore-unmatch path&#x27; </span><br><span class="line">--prune-empty --tag-name-filter cat -- --all</span><br></pre></td></tr></table></figure>

<p><code>git filter-branch</code>执行之后都需要强制推向远程，可能会覆盖他人的提交，所以称为最猛的后悔药。</p>
<hr>
<p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p>
<p>联系方式：<a href="mailto:&#120;&#105;&#97;&#x6f;&#99;&#x61;&#105;&#110;&#x69;&#x61;&#x6f;&#x79;&#97;&#x40;&#102;&#111;&#x78;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;">&#120;&#105;&#97;&#x6f;&#99;&#x61;&#105;&#110;&#x69;&#x61;&#x6f;&#x79;&#97;&#x40;&#102;&#111;&#x78;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a></p>
<p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git记录</title>
    <url>/2022/01/10/git/git%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>旨在记录在使用<code>git</code>过程中出现的一些问题和使用上的一些操作记录、或者是<code>git</code>一些概念上的理解，防止重复踩坑。</p>
</blockquote>
<span id="more"></span>

<h4 id="1-强制回滚远程git仓库的某个提交"><a href="#1-强制回滚远程git仓库的某个提交" class="headerlink" title="1. 强制回滚远程git仓库的某个提交"></a>1. 强制回滚远程<code>git</code>仓库的某个提交</h4><span id="forceCommit"/>

<p>简单描述一下<code>git</code>的操作流程: </p>
<ol>
<li>工作区编写代码通过<code>add</code>命令添加到暂存区</li>
<li>暂存区通过<code>commit</code>命令添加到本地版本库</li>
<li>本地版本库通过<code>push</code>命令将本地代码推送到远程代码库</li>
</ol>
<p><code>git reset --soft HEAD^</code>  将本地仓库回滚为指定版本，且多余的提交回滚到暂存区</p>
<p><code>git reset --fixed HEAD^</code> 将本地仓库和暂存区回滚为指定版本</p>
<p><code>git reset --hard HEAD^</code> 将本地仓库、暂存区和工作区回滚为指定版本</p>
<p>强制回滚一个提交步骤:</p>
<ol>
<li>拉取需要修改的分支代码</li>
<li>通过<code>git reset --hard HEAD^</code>命令回滚一个提交</li>
<li>通过<code>git push --force</code>强制推送到远程代码库</li>
</ol>
<h4 id="2-在git中-和-的区别"><a href="#2-在git中-和-的区别" class="headerlink" title="2. 在git中~和^的区别"></a>2. 在<code>git</code>中<code>~</code>和<code>^</code>的区别</h4><p><code>HEAD^</code>, <code>HEAD^1</code>, <code>HEAD~</code>三个表达式都表示<code>HEAD</code>的父提交</p>
<p><code>HEAD^n</code>: 指的是<code>HEAD</code>的第<code>n</code>个父提交(有多个父提交的前提下[这里的父提交实际上是合并操作])<br><code>HEAD~n</code>: 指的是<code>HEAD</code>的第<code>n</code>个祖先提交(这里需要区分父提交和祖先提交的区别)，所以<code>HEAD~n=HEAD^^^(n个^)</code><br><img src="https://s2.loli.net/2022/01/10/q6iVtARvPXImlCZ.png" alt="git中^和~的区别.png"></p>
<h4 id="3-log和reflog的区别"><a href="#3-log和reflog的区别" class="headerlink" title="3. log和reflog的区别"></a>3. <code>log</code>和<code>reflog</code>的区别</h4><ul>
<li><code>reflog</code>: 可以查看所有分支的所有操作记录(包括已经删除的提交或者是重置的提交)</li>
<li><code>log</code>: 不能查看被删除的提交</li>
</ul>
<p>基于以上两个命令的区别<code>reflog</code>在一些场景下可以提供一些妙用。<br>比如:<br><strong>查看某个分支是基于那个分支迁出:</strong> <code>git reflog --date=local | grep &lt;分支名称&gt;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 输出信息</span><br><span class="line">077b02d HEAD@&#123;Fri Jan 7 17:03:26 2022&#125;: checkout: moving from 原分支名称 to 迁出后分支名称</span><br></pre></td></tr></table></figure>

<h4 id="4-revert"><a href="#4-revert" class="headerlink" title="4.revert"></a>4.revert</h4><p>​    <code>revert</code>是重做的意思，可以对推送到远程仓库的提交进行撤销。假设不小心将开发分支的功能合并到基线分支，这时就可以通过<code>revert</code>命令进行撤销操作。</p>
<p>这里以<code>gitlab</code>为例：</p>
<p><img src="https://s2.loli.net/2022/09/19/UfePvIbQJg6Rsta.png" alt="revert.png"></p>
<p>通过使用<code>gitlab</code>进入需要撤回的<code>merge</code>记录，选择右上角<code>options-&gt;Revert</code>，这时会生成一个<code>revert-xxxx</code>的分支，同时将该分支合并到基线分支，也就是将<code>revert</code>提交合并到基线分支。</p>
<p>这时基线分支撤销之后，当开发分支的功能开发完毕后，将开发分支合并到基线分支，会发现部分代码丢失，而丢失的正是之前<code>revert</code>操作撤销的那部分提交。所以只需要对之前的<code>revert</code>操作再次进行<code>revert</code>操作即可。简单来说就是负负得正的逻辑。</p>
<p><b>2023/07/24补充：</b></p>
<p>假设现在有两个分支的情况如下：<code>master</code>表主线分支，<code>dev</code>表开发分支</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">init -&gt; m1 -&gt; m2 -&gt; m3  (master)</span><br><span class="line">           \      </span><br><span class="line">            d1 -&gt; d2  (dev)</span><br></pre></td></tr></table></figure>

<p>这时<code>dev</code>分支以开发完成，所以将<code>dev</code>分支合并到<code>master</code>分支。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">init -&gt; m1 -&gt; m2 -&gt; m3 -- <span class="function">merge <span class="title">commit1</span> <span class="params">(master)</span></span></span><br><span class="line"><span class="function">           \            /</span></span><br><span class="line"><span class="function">            d1  --&gt;  <span class="title">d2</span>  <span class="params">(dev)</span></span></span><br></pre></td></tr></table></figure>

<p>合并之后就会产生一个合并的提交，使用<code>git log</code>命令可以看到这个提交信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">commit <span class="title">ced0a13d5d463b212a321f193ffb8f4608673920</span> <span class="params">(HEAD -&gt; dev1, origin/dev1)</span></span></span><br><span class="line"><span class="function">Merge: ef6cc16 8f1cad0</span></span><br><span class="line"><span class="function">Author: xiaocainiaoya &lt;xiaocainiaoyao@foxmail.com&gt;</span></span><br><span class="line"><span class="function">Date:   Mon Jul 24 15:41:19 2023 +0800</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    Merge branch &#x27;master&#x27; into dev1</span></span><br></pre></td></tr></table></figure>

<p>这个合并之后开发分支还在继续开发<code>dev</code>，同时其他开发完成的功能也会合并到<code>master</code>分支。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">init -&gt; m1 -&gt; m2 -&gt; m3 -- merge commit1 -&gt; m4 -&gt; <span class="function">merge <span class="title">commit2</span> <span class="params">(master)</span></span></span><br><span class="line"><span class="function">        \  \            /                     /</span></span><br><span class="line"><span class="function">         \  d1  --&gt;  d2  --&gt; d3 --&gt; <span class="title">d4</span>  <span class="params">(dev)</span>/</span></span><br><span class="line"><span class="function">          \                                 / </span></span><br><span class="line"><span class="function">           a1  --&gt;  a2 -------------------<span class="title">a3</span> <span class="params">(dev2)</span></span></span><br></pre></td></tr></table></figure>

<p>这时突然由于<code>dev</code>分支合并到<code>master</code>，导致<code>master</code>出现了一些<code>bug</code>，需要进行紧急回滚，但是不能将<code>dev2</code>已经提交的合并回滚。</p>
<p>使用<code>revert</code>命令，对<code>merge commit1</code>这个提交进行回滚。这里会报错，这是因为<code>git</code>在尝试撤销两个分支的合并的时候，不知道需要保留那个分支上的修改，<code>git</code>提供了<code>-m</code>命令来指定需要保留的分支修改。</p>
<p><code>-m</code>后面使用参数<code>1</code>表示：表示保留当前分支的更改，使用参数<code>2</code>表示：表示保留另一个分支的更改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert ced0a13d5d463b212a321f193ffb8f4608673920</span><br><span class="line">error: commit ced0a13d5d463b212a321f193ffb8f4608673920 is a merge but no -m option was given.</span><br><span class="line">fatal: revert failed</span><br></pre></td></tr></table></figure>

<p>这里我要保留<code>master</code>分支的修改，也就是在<code>master</code>分支的工作空间下执行<code>-m 1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert -m 1 ced0a13d5d463b212a321f193ffb8f4608673920</span><br></pre></td></tr></table></figure>

<p>之后，<code>git log</code>中就会多一个撤销的提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit f491e063ea4cd9fd4117eec888b29d7d4c45561a (HEAD -&gt; develop, origin/develop)</span><br><span class="line">Author: xiaocainiaoya &lt;xiaocainiaoya@foxmail.com&gt;</span><br><span class="line">Date:   Mon Jul 24 15:51:07 2023 +0800</span><br><span class="line"></span><br><span class="line">    Revert &quot;Merge branch &#x27;master&#x27; into dev1&quot;</span><br><span class="line">    </span><br><span class="line">    This reverts commit ced0a13d5d463b212a321f193ffb8f4608673920, reversing</span><br><span class="line">    changes made to ef6cc16eb85e64883b79c3b86e6475f488a40b93.</span><br></pre></td></tr></table></figure>

<p><b>注意：</b>之后，当<code>dev1</code>分支上修复了这个bug，需要重新合并到<code>master</code>之前，需要先将这个<code>f491e063</code>提交<code>revert</code>，这是因为<code>revert</code>是通过添加提交的方式，撤销某个或者某些提交，它并不是删除提交，所以在将<code>dev1</code>合并到<code>master</code>之前，需要对之前撤销的提交执行撤销命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git revert f491e063ea4cd9fd4117eec888b29d7d4c45561a</span><br></pre></td></tr></table></figure>

<p>这时又会产生一个新的提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 6f7f80c2d28ae17ae8679f1dc543a9b65fdd8559(HEAD -&gt; develop, origin/develop)</span><br><span class="line">Author: jiangjiamin &lt;jiangjiamin@bosssoft.com.cn&gt;</span><br><span class="line">Date:   Mon Jul 24 16:35:35 2023 +0800</span><br><span class="line">    ## 可以从这里看出, 对之前撤销的提交进行撤销操作</span><br><span class="line">    Revert &quot;Revert &quot;Merge branch &#x27;main&#x27; into develop&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    This reverts commit f491e063ea4cd9fd4117eec888b29d7d4c45561a.</span><br></pre></td></tr></table></figure>

<p><code>revert</code>不仅可以对<code>合并的提交</code>进行撤销，也可以对某个单独的提交进行撤销。</p>
<p>这里要有别于<code>reset</code>，如果你使用这个命令作用于某个提交上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reset commitId</span><br></pre></td></tr></table></figure>

<p>它的意思是将这个提交之后的所有提交都<b>移除</b>，也就是这个提交之后的所有提交都删掉了，也就查不到这个提交之后的<code>log</code>信息，这个命令用回滚这个词形容感觉更贴切。</p>
<p>当然<code>reset</code>有它的应用场景，对于一些提交，由于各种原因推向远程仓库，可以通过<code>reset</code>强制还原。<a href="#forceCommit">点击查看</a><code>reset</code>简单用法。</p>
<h4 id="5-映射"><a href="#5-映射" class="headerlink" title="5.映射"></a>5.映射</h4><blockquote>
<p>命令：git remote add <shortname> <url></p>
</blockquote>
<ul>
<li><code>shortname</code>：表示别名</li>
<li><code>url</code>：表示远程仓库地址(<a href="http://xxx/xxx.git">http://xxx/xxx.git</a>)</li>
</ul>
<p>表示将远程仓库<code>URL</code>映射成为本地仓库中对远程仓库的别名<code>shortname</code>。默认情况下一般使用<code>shortname=origin</code>。</p>
<p>可以通过<code>git remote -v</code>查看对本地仓库设置的别名和远程仓库之间的关系：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">testname   http://127.0.0.1:1000/xxx/xxx.git (fetch)</span><br><span class="line">testname   http://127.0.0.1:1000/xxx/xxx.git (push)</span><br><span class="line">origin  http://127.0.0.1:2000/xxx/xxx (fetch)</span><br><span class="line">origin  http://127.0.0.1:2000/xxx/xxx (push)</span><br></pre></td></tr></table></figure>

<h4 id="6-推送"><a href="#6-推送" class="headerlink" title="6.推送"></a>6.推送</h4><blockquote>
<p>命令：git push &lt;远程仓库名&gt;  &lt;本地分支名&gt;:&lt;远程分支名&gt;</p>
</blockquote>
<p><code>git push -u origin master</code>：首次推送添加<code>-u</code>参数，<code>git</code>会将本地<code>master</code>分支内容推送到远程的<code>master</code>分支，同时将本地<code>master</code>分支与远程<code>master</code>分支关联，之后的推送仅通过<code>git push</code>即可。(这里忽略了<code>:&lt;远程分支名&gt;</code>的情况下，默认远程分支名与本地分支名一致)</p>
<h4 id="7-跟换项目的远程仓库"><a href="#7-跟换项目的远程仓库" class="headerlink" title="7.跟换项目的远程仓库"></a>7.跟换项目的远程仓库</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##查看当前远程仓库</span></span><br><span class="line">git remote -v </span><br><span class="line"><span class="comment">## 删除远程仓库</span></span><br><span class="line">git remote rm origin</span><br><span class="line"><span class="comment">## 查看删除远程仓库操作是否成功</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment">## 把远程仓库和本地同步，并消除差异</span></span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<h4 id="8-清理本地仓库中远程仓库已经删除的分支"><a href="#8-清理本地仓库中远程仓库已经删除的分支" class="headerlink" title="8.清理本地仓库中远程仓库已经删除的分支"></a>8.清理本地仓库中远程仓库已经删除的分支</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅预览待清理分支（不实际执行）</span></span><br><span class="line">git remote prune origin --dry-run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步并清理无效远程追踪分支（推荐）</span></span><br><span class="line">git fetch --prune</span><br></pre></td></tr></table></figure>











<p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p>
<p>联系方式：<a href="mailto:&#x78;&#x69;&#x61;&#111;&#x63;&#97;&#x69;&#x6e;&#105;&#x61;&#111;&#121;&#x61;&#64;&#x66;&#x6f;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#x78;&#x69;&#x61;&#111;&#x63;&#97;&#x69;&#x6e;&#105;&#x61;&#111;&#121;&#x61;&#64;&#x66;&#x6f;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletableFuture任务编排</title>
    <url>/2023/06/02/java/CompletableFuture%E4%BB%BB%E5%8A%A1%E7%BC%96%E6%8E%92/</url>
    <content><![CDATA[<h1 id="CompletableFuture任务编排"><a href="#CompletableFuture任务编排" class="headerlink" title="CompletableFuture任务编排"></a>CompletableFuture任务编排</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    <code>CompletableFuture</code>是对<code>Future</code>的扩展，弥补了<code>Future</code>的局限性，同时又实现了对任务进行编排的能力。    </p>
<span id="more"></span>

<p>​    <code>CompletableFuture</code>实现于<code>Future</code>和<code>CompletionStage</code>，对于<code>Future</code>的扩展内容，都在<code>CompletionStage</code>接口中。在这个接口中定义了任务编排的方法，执行某个任务完成或者进行并行执行等操作的方法。</p>
<p><img src="https://s2.loli.net/2023/06/02/9GnaLSmQPoBFt3I.png" alt="CompletableFuture类图.png"></p>
<p>​    <code>CompletableFutrue</code>在对任务编排的基础上，结合<code>Futrue</code>的特性，做到可以将某个任务异步到其他线程执行，内部通过<code>Futrue</code>的阻塞相关接口来等待任务的完成，再执行编排的接下来任务。默认使用<code>ForkJoinPool</code>。</p>
<p><b>任务编排主要分为4大类</b></p>
<h3 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1.依赖关系"></a>1.依赖关系</h3><ul>
<li><code>thenApply()</code>：入参为以上一个任务的执行结果为入参的<code>Function</code>方法，也就是<code>thenApply()</code>中的<code>Function</code>方法的返回值是上一个任务执行结果的类型。</li>
<li><code>thenCompose()</code>：入参为以上一个任务的执行结果为<code>Function</code>方法的入参类型，以<code>CompletableFuture</code>为出参类型。也就是<code>thenCompose()</code>中的<code>Function</code>方法的返回值是<code>CompletableFuture</code>类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 结果转换，thenApply使用上一轮结果进行计算</span></span><br><span class="line">    <span class="comment">// thenApply 加不加async仅表示是否使用异步线程来完成任务(可指定线程池)</span></span><br><span class="line">    CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenApply(value -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenComposeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// thenCompose 与 thenApply 类似，但是thenCompose的返回值必须是CompletableFuture</span></span><br><span class="line">     <span class="comment">// thenCompose是将上一次计算的结果作为参数传进来，然后需要返回一个新的CompletableFuture</span></span><br><span class="line">     CompletableFuture&lt;String&gt; result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCompose(param -&gt; CompletableFuture.supplyAsync(() -&gt; param + <span class="string">&quot;d&quot;</span>));</span><br><span class="line">     System.out.println(result.join());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-合并关系"><a href="#2-合并关系" class="headerlink" title="2.合并关系"></a>2.合并关系</h3><p>合并A、B任务，当A、B任务完成之后执行C任务。</p>
<ul>
<li><code>thenCombine</code>：合并A、B任务，当A、B任务完成之后执行<code>thenCombine()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiFunction</code>方法，接收A、B任务的返回值作为入参，且有返回值。</li>
<li><code>thenAccepetBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>thenAccepetBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>BiConsumer</code>方法，接收A、B任务的返回值作为入参，且无返回值。</li>
<li><code>runAfterBoth</code>：合并A、B任务，当A、B任务完成之后执行<code>runAfterBoth()</code>方法的第二个参数对应的任务。第二个参数是个<code>Runnable</code>，不接收参数，且无返回值。</li>
</ul>
<p>综上：其实三个方法的主要却别在于第二个参数所使用的的是<code>BiFunction</code>、<code>BiConsumer</code>、<code>Runnable</code>来控制是否需要接收前面任务的参数、是否需要有返回值。其他核心逻辑并无二至。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombineTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 联合</span></span><br><span class="line">     CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">1000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         sleep(<span class="number">2000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">         System.out.println(s1 + s2);</span><br><span class="line">         System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hij&quot;</span>;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), (s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.println(s1 + s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterBothTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    &#125;).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    &#125;), () -&gt; &#123;</span><br><span class="line">        <span class="comment">//System.out.println(s1 + s2);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-并联关系"><a href="#3-并联关系" class="headerlink" title="3.并联关系"></a>3.并联关系</h3><p>A、B两个任务，只要有一个完成，就执行C任务。</p>
<ul>
<li><code>applyToEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>applyToEither()</code>的第二个参数是<code>Function</code>，表示使用前一个任务的返回值为入口参数，且有返回值。</li>
<li><code>acceptEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Consumer</code>，表示使用前一个任务的返回值为入口参数，无返回值。</li>
<li><code>runAfterEither()</code>：A、B两个任务，哪个任务先完成就用那个任务的结果执行C任务。<code>acceptEither()</code>的第二个参数是<code>Runnable</code>，表示AB任意一个任务完成后，就执行一个任务，这个任务无入参无返回值。</li>
</ul>
<p>综上：与<b>合并关系</b>其实差不多，三个方法上都是在对第二个函数式接口参数上做文章，主要为了用户在根据任务的参数需要和返回值需要选择特定的方法。</p>
<h3 id="4-并行关系"><a href="#4-并行关系" class="headerlink" title="4.并行关系"></a>4.并行关系</h3><p>多个任务时，多个任务都完成或者其中一个任务完成时，进行下一个任务的执行，返回的是新的<code>CompletableFuture</code>。</p>
<ul>
<li><code>allOf()</code>:当所有给定的<code>CompletableFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li>
<li><code>anyOf()</code>:当任何一个给定的<code>CompletablFuture</code>完成时，返回一个新的<code>CompletableFuture</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 只要有一个有结果就得到result, 但是存在一种情况，如果future1先完成，那么future2还是在执行，</span></span><br><span class="line">    <span class="comment">// 如果在future1执行完成后，future2执行完成前获取result的值，那么result的值就是future1的值</span></span><br><span class="line">    <span class="comment">// 获取值时如果都完成，那么由前往后取，也就是都完成的情况下，根据anyOf()方法参数定义的顺序获取。</span></span><br><span class="line">    CompletableFuture&lt;Object&gt; result = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 两个都完成了</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; result = CompletableFuture.allOf(future1, future2);</span><br><span class="line">    System.out.println(result.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-结果处理"><a href="#5-结果处理" class="headerlink" title="5.结果处理"></a>5.结果处理</h3><p>当任务执行结束可以对任务执行的结果或者任务抛出的异常进行处理。</p>
<ul>
<li><p><code>whenComplete</code>:当任务完成时，将使用结果(或<code>null</code>)和此阶段的异常(或<code>null</code>)执行给定操作</p>
</li>
<li><p><code>exceptionally</code>:为了捕获任务中抛出的异常进行处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当某个任务完成之后，进行下一个任务</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="comment">// 上一个任务若有异常则这里的s=null, throwable=异常; 若正常执行完成则s=上一个任务的返回值, throwable=null</span></span><br><span class="line">    <span class="comment">// async表示使用可能会去使用其他线程如果使用同一线程池也可能被同一个线程执行</span></span><br><span class="line">    <span class="comment">// 不指定线程池的情况下使用的是ForkJoinPool.commonPool()</span></span><br><span class="line">    .whenComplete((s, throwable) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;2:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exceptionallyTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正常结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.1</span>;</span><br><span class="line">    &#125;).thenApply(result -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply接收到的参数 = &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常：&quot;</span> + throwable.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终返回的结果 = &quot;</span> + future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>​    在<code>CompletableFuture</code>中针对<b>每个方法</b>都定义了两个<code>xxxAsync</code>接口，以<code>whenComplete</code>方法为了，如下所示，两个<code>xxxAsync</code>接口的区别在于是否显示指定使用的线程池。如果不使用<code>xxxAsync</code>接口，则使用当前线程执行任务，如果使用<code>xxxAysnc</code>没有显示指定线程池，则使用默认的<code>ForkJoinPool</code>提供的线程池。但<code>ForkJoinPool</code>是公共线程池，如果所有的<code>CompletableFuture</code>都共享一个线程池，如果某一些任务执行较慢，会导致线程池中的所有线程阻塞，造成线程饥饿，从而影响整个系统的性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在京东的开源框架<code>AsyncTool</code>，主要就是对<code>CompletableFuture</code>进行了组装和包装，使得任务的编排和回调在使用上变更更加方便。并对任务回调相关内容做了一个优化。比如在<code>CompletableFuture</code>中，如果你编排了多个任务，当前执行到那个任务，每一个任务的执行结果实际上是不知道的，只有等任务都执行完毕，最总汇总结果。<code>AysncTool</code>认为这种方式不是友好的，一个并行框架需要对每一步的执行有能进行监控，每一步无论执行成功与失败，都应该有一个回调，才算完整。比如在某些场景中，某些任务单元是需要被跳过不执行的，但是不执行的这个任务是不是也需要一个回调，进行类似于一些通知之类的动作？</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK9特性</title>
    <url>/2023/07/12/java/JDK9%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="JDK9特性"><a href="#JDK9特性" class="headerlink" title="JDK9特性"></a>JDK9特性</h1><span id="more"></span>

<h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><p>​    模块是代码、数据和资源的集合。它是一组相关的包和类型（类、抽象类、接口等），包含代码、数据文件和一些静态资源。说人话就是，<code>JDK9</code>在<code>JDK8</code>之上对<code>package</code>再进行了一层包装，以往的<code>JDK</code>中在<code>.jar</code>包中就是<code>package</code>包了，也就是说如果你在工程中引入了一个<code>.jar</code>，这么这整个<code>.jar</code>下的包都被引入到你的工程，在你的工程中就可以使用引入的这个<code>.jar</code>文件的所有包下的类。但是在<code>JDK9</code>模块化之后，在<code>.jar</code>下，<code>package</code>上，添加了一层<code>module</code>，也就是说，如果你在工程中引入一个<code>.jar</code>，这时也不能访问到<code>.jar</code>下的所有包，要看两个条件，一个条件是这个<code>.jar</code>是否将这个包开放访问，二是当前模块是否需要访问<code>.jar</code>中的某个包。</p>
<p><b>示例：</b></p>
<p>在工程中引入<code>lombok</code>，显然根据上面说的，如果在<code>JDK9</code>之前，这样就可以访问到<code>lombok</code>中的相关类资源。但是这里是访问不到的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.18.26&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>想要访问到<code>lombok</code>中的类资源，这时需要两个条件都满足，当前工程才可以使用<code>lombok</code>相关类。</p>
<ol>
<li><p><code>lombok</code>将自身的某些允许访问的包暴露。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> lombok &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.compiler;</span><br><span class="line">    <span class="keyword">requires</span> java.instrument;</span><br><span class="line">    <span class="keyword">requires</span> jdk.unsupported;</span><br><span class="line">    <span class="comment">// lombok中暴露 lombok 这个包</span></span><br><span class="line">    <span class="keyword">exports</span> lombok;</span><br><span class="line">    <span class="keyword">exports</span> lombok.experimental;</span><br><span class="line">    ... 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当前工程需要<code>lombok</code>中的某些包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="keyword">requires</span> common;</span><br><span class="line">    <span class="comment">// 当前工程中引入 lombok 包</span></span><br><span class="line">    <span class="keyword">requires</span> lombok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><b>这两个条件都需要在对应的<code>module-info.java</code>显示声明。</b></p>
<p>根据上面的例子可以看出，<code>JDK9</code>是通过在顶层类路径下添加<code>module-info.java</code>来控制模块化。这个文件称为<b>模块描述符</b>。可以通过反向的域名来定义模块名。</p>
<h3 id="1-模块描述符"><a href="#1-模块描述符" class="headerlink" title="1.模块描述符"></a>1.模块描述符</h3><p>1.需要引入某些模块，使用<code>requires</code>引入模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认情况是不支持透传, 也就是A -&gt; B, B -&gt; C, 下面这种写法A是不引用C的。</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传，也就是A -&gt; B, B -&gt; C, 下面这种写法A也是依赖于C</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> transitive <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态引入：编译的时候必须要包含这些类的jar包才能够编译通过。但是在运行的时候我们可能不会用到这些类</span></span><br><span class="line"><span class="comment">// 表示在编译时的依赖是强制的，但在运行时是可选的</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="keyword">static</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.需要暴露某些模块，供其他模块引入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将某个包暴露, 其他引用模块才可以通过requires关键字引入</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">   <span class="keyword">exports</span> <span class="keyword">module</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点对点暴露</span></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="keyword">exports</span> <span class="keyword">module</span>.nameA to <span class="keyword">module</span>.nameB, <span class="keyword">module</span>.nameC, <span class="keyword">module</span>.nameD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<p>A模块中有两个包路径：<code>xiaocainiao.common.entity</code>和<code>xiaocainiao.common.vo</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="comment">// 暴露A模块的其中一个包路径</span></span><br><span class="line">    <span class="keyword">exports</span> xiaocainiao.common.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B模块中有两个包路径：<code>xiaocainiao.user.entity</code>和<code>xiaocainiao.user.vo</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="comment">// B模块引用整个A模块</span></span><br><span class="line">    <span class="keyword">requires</span> common;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，B模块仍然也只能引用到A模块暴露出来的一个包，另一个没有暴露出来的包，B模块无法访问。这个时候对于B来说，是引用了整个A模块，当然也可以点对点引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将A模块修改为仅对B模块暴露, 其他模块引入A模块后将无法访问到cn.com.xiaocainiaoya.common.facade</span></span><br><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.facade to user_center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    我在学习<code>jdk9</code>模块化时，这里有一个小插曲，我先引入了<code>hutool5.7.20</code>的依赖，然后通过<code>requires cn.hutool; </code>发现无法引入，而在<code>idea</code>的<code>pom.xml</code>有个小提示，提示我引入最新版本的<code>hutool</code>，所以我尝试引入<code>hutool5.8.18</code>后，发现<code>requires cn.hutool;</code>生效了，但是我又观察了一下，<code>hutool5.8.18</code>中并没有<code>module-info.class</code>文件，这个时候我就很疑惑了，对比观察了下，发现两者的<code>MANIFEST.MF</code>中存在一点差异。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hutool 5.7.20</span></span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Built-By: looll</span><br><span class="line">Created-By: Apache Maven <span class="number">3.8</span><span class="number">.1</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_261</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hutool 5.8.18</span></span><br><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Implementation-Title: hutool-all</span><br><span class="line">Automatic-Module-Name: cn.hutool</span><br><span class="line">Implementation-Version: <span class="number">5.8</span><span class="number">.18</span></span><br><span class="line">Build-Timestamp: <span class="number">2023</span>-<span class="number">04</span>-16T15:<span class="number">40</span>:28Z</span><br><span class="line">Built-By: looll</span><br><span class="line">Build-OS: Windows <span class="number">11</span></span><br><span class="line">Build-Jdk-Spec: <span class="number">1.8</span></span><br><span class="line">Created-By: Maven JAR Plugin <span class="number">3.3</span><span class="number">.0</span></span><br><span class="line">Build-Jdk: <span class="number">1.8</span><span class="number">.0_333</span></span><br></pre></td></tr></table></figure>

<p>到这你应该有所发现，在高版本中有一个参数<code>Automatic-Module-Name</code>，属性是用来为自动模块指定一个模块名称的。通过声明这个属性，就可以为没有显式模块信息的 JAR 文件赋予一个模块名称，使其成为一个合法的模块。</p>
<p>然后进入<code>git</code>看了下源码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Automatic-Module-Name</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">Automatic-Module-Name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">index</span>&gt;</span>true<span class="tag">&lt;/<span class="name">index</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-OS</span>&gt;</span>$&#123;os.name&#125;<span class="tag">&lt;/<span class="name">Build-OS</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Built-By</span>&gt;</span>$&#123;user.name&#125;<span class="tag">&lt;/<span class="name">Built-By</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-Jdk</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">Build-Jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Build-Timestamp</span>&gt;</span>$&#123;maven.build.timestamp&#125;<span class="tag">&lt;/<span class="name">Build-Timestamp</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--通过maven打包工具，将这个属性添加到MANIFEST.MF中--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Automatic-Module-Name</span>&gt;</span>$&#123;Automatic-Module-Name&#125;<span class="tag">&lt;/<span class="name">Automatic-Module-Name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.开放更高访问权限，使用<code>open</code>关键字。</p>
<p>​    在模块化系统中，模块会隔离其内部的包，只有 <code>public</code> 修饰的包才能在模块外部访问。然而，有时候我们希望允许其他模块访问模块中的所有非 <code>public</code> 类型，而不用逐个包或类型地进行声明。这时可以使用 <code>open</code> 关键字来声明一个模块为 “开放模块”，这样其他模块就可以访问该模块中的所有非 <code>public</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用open只是为了提高访问权限, 改exports暴露的还是要暴露</span></span><br><span class="line"><span class="comment">// 整个模块open</span></span><br><span class="line">open <span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.entity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> common &#123;</span><br><span class="line">    <span class="comment">// 单独暴露这个包</span></span><br><span class="line">    opens cn.com.xiaocainiaoya.common.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>open</code>是运行时用于控制反射访问的权限，如果仅仅使用<code>open</code>声明，那么类是无法被引用到，也就是编译器都无法通过，所以还需要使用<code>exports</code>或者使用<code>require static</code>配合使用。</p>
<p>通过<code>open</code>引入模块后，使用反射操作是不需要<code>.setAccessible(true)</code>操作授权。</p>
<p>在<code>git</code>上看到一些<code>JDK9</code>的示例工程中出现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">module</span>.web &#123;</span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 开放权限给spring的部分模块, 由于目前我还没有引入spirng, 可能是在spring中对其进行</span></span><br><span class="line">    <span class="comment">// 反射之类的操作, 这里先记录下, 日后若遇到问题, 再进行详细的记录。</span></span><br><span class="line">    opens pers.darren to spring.beans, spring.core, spring.context;</span><br><span class="line">    opens pers.darren.controller.role to spring.beans, spring.core, spring.web;</span><br><span class="line">    opens pers.darren.controller.user to spring.beans, spring.core, spring.web;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.<code>uses</code> 和 <code>provides</code> 是模块化系统中用于服务（Service）的关键字。</p>
<p><code>uses</code> 关键字用于声明一个模块使用某个服务。服务是一种提供特定功能的接口或抽象类，它可以由一个或多个模块实现。通过 <code>uses</code> 关键字，我们可以在模块中声明对特定服务的依赖，以便在运行时获取该服务的实现。这样，模块就可以在不依赖具体实现类的情况下使用服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// common模块: 在facade包下有一个FeeFacade接口，在service包下有一个FeeService实现</span></span><br><span class="line"><span class="keyword">module</span> xiaocainiao.common &#123;</span><br><span class="line">    <span class="keyword">exports</span> cn.com.xiaocainiaoya.common.facade;</span><br><span class="line">    <span class="keyword">requires</span> transitive lombok;</span><br><span class="line"></span><br><span class="line">    provides cn.com.xiaocainiaoya.common.facade.FeeFacade with cn.com.xiaocainiaoya.common.service.FeeService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// userCenter模块, 通过uses可以使用ServiceLoader进行加载</span></span><br><span class="line"><span class="keyword">module</span> user_center &#123;</span><br><span class="line">    <span class="comment">// 引入common模块</span></span><br><span class="line">    <span class="keyword">requires</span> xiaocainiao.common;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> lombok;</span><br><span class="line"></span><br><span class="line">    uses cn.com.xiaocainiaoya.common.facade.FeeFacade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>user-center</code>模块中使用<code>ServiceLoader</code>进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;FeeFacade&gt; moduleServices = ServiceLoader</span><br><span class="line">    .load(FeeFacade.class).stream()</span><br><span class="line">    .map(ServiceLoader.Provider::get)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>​    接上面的<code>open</code>关键字说到，看到一些实例工程中使用<code>open</code>将包的权限开放给<code>spring</code>中的部分模块。许多库依赖于反射来发挥它们的魔力，默认情况下，在<code>JDK9</code>中只能访问到暴露包中的公共类、方法和字段，即使通过反射来访问非公共成员并调用<code>setAccessible(true)</code>，<b>也是无法访问到。</b>只能通过<code>open</code>、<code>opens</code>、<code>opens..to</code>的方式授予运行时访问权限。</p>
<h3 id="3-模块路径"><a href="#3-模块路径" class="headerlink" title="3.模块路径"></a>3.模块路径</h3><p>​    模块是从<code>modulePath</code>加载的，就像<code>jdk8</code>及之前的<code>jdk</code>的类是从类路径加载。所以你一定知道什么是类路径地狱，有时可能会出现在本地环境中可以成功启动项目，在其他环境无法启动成功，这是由于<code>java</code>对引用类的解析规则为第一次遇见策略，所以未知的排序依赖关系，可能会出现一些未知的问题。</p>
<p>​    从<code>java9</code>开始，将进入另一种地狱：<code>modulepath</code>地狱。</p>
<p>模块路径是一系列的模块：以文件夹或者<code>JAR</code>方式呈现，如果模块是文件夹格式，则表示该模块是分解模块的格式；如果是<code>jar</code>则是模块化的<code>jar</code>.模块和模块描述符提供的可靠配置有助于消除许多此类运行时类路径问题。每个模块都显式地声明其依赖项，这些依赖项作为应用程序启动来解析。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok注解</title>
    <url>/2022/04/18/java/Lombok%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Lombok注解"><a href="#Lombok注解" class="headerlink" title="Lombok注解"></a>Lombok注解</h1><span id="more"></span>

<h2 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h2><blockquote>
<p>对实体的<code>get/set</code>方法进行一下转换</p>
</blockquote>
<p>它有三个参数：</p>
<ul>
<li>fluent：默认为<code>false</code>，若设置为<code>true</code>，则获取对象属性是无需<code>getXX</code>,直接通过<code>a.xx</code>获取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="meta">@Accessors(fluent = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后B.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="comment">// 这里好像相当于同时开启了chain属性，set方法会返回当前对象</span></span><br><span class="line">    B bb = b.name(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    System.out.println(b.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>chain：默认为<code>false</code>，设置为<code>true</code>后，<code>set</code>方法会返回当前对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后，几乎和fluent=true编译生成一致，同样在set方法会返回当前对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>prefix：默认为<code>&#123;&#125;</code>，设置生成的<code>get/set</code>方法忽略前缀集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Accessors(prefix = &#123;&quot;test&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String testName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String testName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// set方法名上会忽略test字样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String testName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testName = testName;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// get方法名上会忽略test字样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.testName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h2><p>简化了一些@Autowired注解，可以减少@Autowired的书写，我们在写controller或者Service层的时候，需要注入很多的mapper接口或者另外的service接口，这时候就会写很多的@Autowired注解，代码看起来很繁琐。</p>
<p><b>不是用这个注解时:</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CService cService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DService dService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>使用这个注解：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AService aService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CService cService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DService dService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>注：</b>这个注解要生效，字段上需要使用<code>final</code>修饰或者标记<code>@NotNull</code>才可以生效。</p>
<p>编译后的文件为（会生成一个构造函数）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aService.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BService</span><span class="params">(<span class="keyword">final</span> AService aService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aService = aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h2><p><a href="https://xiaocainiaoya.github.io/2021/04/13/Spring/lombok%E7%9A%84@SneakyThrows%E8%AF%A6%E8%A7%A3/" target="_blank">Lombok的@SneakyThrows详解</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream基本使用</title>
    <url>/2021/12/15/java/Stream%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>​    <code>jdk8</code>中引入的函数式<code>lambda</code>表示式，同时引入了<code>Stream</code>流，这种流可以堆集合进行一些复杂查找、过滤、映射、规约等操作。一个<code>stream</code>是由三部分组成，<code>数据源流 -&gt;零个或多个中间操作 -&gt; 零个或一个终止操作</code>。中间操作是对数据的加工处理并且中间操作是懒<code>lazy</code>操作，并不会马上启动，需要等待终止操作允许到才会开始执行。<span id="more"></span></p>
<p><img src="https://s2.loli.net/2021/12/15/1SnxVPmy6G8sfth.png" alt="stream.png"></p>
<p><code>Stream</code>分为终端操作和中间操作。</p>
<ul>
<li>终端操作：也称为结束操作，即不能在继续处理数据。</li>
<li>中间操作：就是可以使用上一次处理的结果进行再次处理数据。</li>
</ul>
<p>终端操作又分为短路操作和非短路操作：</p>
<ul>
<li>短路操作：所有数据项不一定都需要处理完成即可结束。类似于<code>a || b</code>，这种判断语句只要某个数据项使得<code>a=true</code>即结束遍历。</li>
<li>非短路操作：所有数据项都需要遍历一遍方才结束。</li>
</ul>
<p>中间操作又分为有状态和无状态：</p>
<ul>
<li>有状态：表示改操作只有等待拿到所有元素后才能继续下去。</li>
<li>无状态：表示元素的处理不受其他元素的影响。</li>
</ul>
<p>比如：<code>sorted()</code>排序，需要获取到流中的所有元素后才能进行排序。而<code>filter()</code>只需要获取流中的一个元素就可以进行处理。</p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-终端操作"><a href="#2-1-终端操作" class="headerlink" title="2.1 终端操作"></a>2.1 终端操作</h3><h4 id="2-1-1-短路操作"><a href="#2-1-1-短路操作" class="headerlink" title="2.1.1 短路操作"></a>2.1.1 短路操作</h4><h5 id="2-1-1-1-匹配"><a href="#2-1-1-1-匹配" class="headerlink" title="2.1.1.1 匹配"></a>2.1.1.1 匹配</h5><p><strong>1.<code>find</code></strong></p>
<ul>
<li><p><code>findFirst</code>：获取数据流中的第一个元素</p>
</li>
<li><p><code>findAny</code> ：随机获取数据流中的一个元素(然而大部分情况下是返回第一个元素)</p>
</li>
</ul>
<p>通过<code>findFirst/findAny</code>返回的是一个<code>Optional&lt;T&gt;</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(list.stream().findFirst().get());</span><br><span class="line">    System.out.println(list.stream().findAny().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.<code>match</code></strong></p>
<ul>
<li><code>anyMatch</code>：数据流中仅有一个数据项满足<code>Predicate</code>即返回<code>true</code></li>
<li><code>allMatch</code>：数据流中所有数据项满足<code>Predicate</code>才返回<code>true</code></li>
<li><code>noneMatch</code>：数据流中所有数据项都不满足<code>Predicate</code>才返回<code>true</code></li>
</ul>
<p><strong>注意：</strong>当数据列表为空时, <code>allMatch</code>的返回值为<code>true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(list.stream().anyMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(list.stream().allMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(list.stream().noneMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 特殊情况, 数据列表为空</span></span><br><span class="line">    List&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    System.out.println(items.stream().anyMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(items.stream().allMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">    System.out.println(items.stream().noneMatch(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-非短路操作"><a href="#2-1-2-非短路操作" class="headerlink" title="2.1.2 非短路操作"></a>2.1.2 非短路操作</h4><h5 id="2-1-2-1-遍历"><a href="#2-1-2-1-遍历" class="headerlink" title="2.1.2.1 遍历"></a>2.1.2.1 遍历</h5><ul>
<li> 在<code>stream.forEach</code>中不能使用<code>break</code>和<code>continue</code>关键字, 但<code>stream.forEach</code>中<code>return</code>和 <code>continue</code>达到的效果一致。</li>
<li> 在<code>parallelStream.forEachOrdered</code>可以使得结果有序, 但同时牺牲了并行流的好处。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().forEach(item -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(item % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(item);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.parallelStream().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.parallelStream().forEachOrdered(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-2-聚合"><a href="#2-1-2-2-聚合" class="headerlink" title="2.1.2.2 聚合"></a>2.1.2.2 聚合</h5><blockquote>
<p>max/min/count</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aggregation</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自然排序</span></span><br><span class="line">    System.out.println(list.stream().max(Integer::compareTo).get());</span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    Integer max = list.stream().max(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).get();</span><br><span class="line">    System.out.println(max);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.stream().min(Integer::compareTo).get());</span><br><span class="line"></span><br><span class="line">    System.out.println(list.stream().count());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-3-规约"><a href="#2-1-2-3-规约" class="headerlink" title="2.1.2.3 规约"></a>2.1.2.3 规约</h5><p><strong><code>reduce</code></strong></p>
<blockquote>
<p>规约: 将一个流通过一些计算/逻辑规约为一个值</p>
</blockquote>
<p>第三个参数一般使用不到, 用处是在使用并行流(<code>parallelStream</code>)时, 最终将所有并行流的数据进行规约。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;求和: &quot;</span> + list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b));</span><br><span class="line">    System.out.println(<span class="string">&quot;求积: &quot;</span> + list.stream().reduce(<span class="number">1</span>, (a, b) -&gt; a * b));</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值: &quot;</span> + list.stream().reduce((a, b) -&gt; a &gt; b ? a : b).get());</span><br><span class="line">    <span class="comment">// reduce三个参数的方法</span></span><br><span class="line">    <span class="comment">// 这种情况下会输出最大值, 在stream流下并不会调用第三个参数。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;stream最大值: &quot;</span> + list.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a &gt; b ? a : b,  (a, b) -&gt; <span class="keyword">null</span>));</span><br><span class="line">    <span class="comment">// 这种情况输出结果为null, 因为在每个并行流中计算得到每个并行流中的最大值后, 通过第三个参数将并行流的结果合并。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;parallelStream最大值: &quot;</span> + list.parallelStream().reduce(<span class="number">0</span>, (a, b) -&gt; a &gt; b ? a : b,  (a, b) -&gt; <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-4-收集"><a href="#2-2-2-4-收集" class="headerlink" title="2.2.2.4 收集"></a>2.2.2.4 收集</h5><p><code>collect</code><br>在<code>stream</code>流中<code>collect</code>是功能最多的操作，可以将流中的数据收集为一个值或者一个集合。主要是依赖于<code>java.util.stream.Collectors</code>类内置的静态方法。</p>
<p><code>collect(Collector&lt;? super T, A, R&gt; collector)</code>中传入的是<code>Collector</code>对象, 主要使用为实现对象<code>java.util.stream.Collectors</code>。在<code>Collectors</code>中内置了很多具体收集的静态方法<br>而这些静态方法最终也都依赖于静态内部实现类<code>CollectorImpl&lt;T, A, R&gt;</code>。这里简单理解下<code>CollectorImpl&lt;T, A, R&gt;</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (T:输入元素类型, A:累加类型, R:最后返回的对象类型)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectorImpl</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 中间收集集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;A&gt; supplier;</span><br><span class="line">    <span class="comment">// 累加算法/收集算法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiConsumer&lt;A, T&gt; accumulator;</span><br><span class="line">    <span class="comment">// 规约(主要针对并行流下规约每个流中的数据)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryOperator&lt;A&gt; combiner;</span><br><span class="line">    <span class="comment">// 结果操作(比如joining操作, 是先将数据收集到StringBuilder中, 最后通过</span></span><br><span class="line">    <span class="comment">// stringBuilder.toString返回结果, 这里finisher=StringBuilder:toString)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, R&gt; finisher;</span><br><span class="line">    <span class="comment">// 收集器特性, 有三个</span></span><br><span class="line">    <span class="comment">// UNORDERED: 规约结果不受流中元素的遍历和累加的顺序影响</span></span><br><span class="line">    <span class="comment">// CONCURRENT: 该收集器可以并行规约流</span></span><br><span class="line">    <span class="comment">// IDENTITY_FINISH: 表明finisher是一个恒等函数, 可以跳过(累加器的结果就是收集的最终结果)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Characteristics&gt; characteristics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里举两个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入类型为T, 累加类型为?, 最后返回对象类型为List&lt;T&gt;。</span></span><br><span class="line"><span class="comment">// 假设调用为: students.stream().map(Student::getAge).collect(Collectors.toList())</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">        <span class="comment">// 创建一个中间收集容器</span></span><br><span class="line">        (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>,</span><br><span class="line">        <span class="comment">// 数据添加到容器中的算法/规则</span></span><br><span class="line">        List::add,</span><br><span class="line">        <span class="comment">// 并行流下的规约机制</span></span><br><span class="line">        (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">        <span class="comment">// 收集器特性</span></span><br><span class="line">        CH_ID</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            <span class="comment">// 新建了一个StringBuilder容器</span></span><br><span class="line">            StringBuilder::<span class="keyword">new</span>,</span><br><span class="line">            <span class="comment">// 设置这个数据的添加规则</span></span><br><span class="line">            StringBuilder::append,</span><br><span class="line">            <span class="comment">// 并行流下的规约规则</span></span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            <span class="comment">// 最后的输出规则</span></span><br><span class="line">            StringBuilder::toString,</span><br><span class="line">            <span class="comment">// 收集器特性</span></span><br><span class="line">            CH_NOID</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>归集: 将流中的数据收集为集合(<code>List</code>、<code>Set</code>、<code>Map</code>)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student tom = Student.builder().age(<span class="number">19</span>).name(<span class="string">&quot;tom&quot;</span>).number(<span class="number">10</span>).build();</span><br><span class="line">    Student marry = Student.builder().age(<span class="number">12</span>).name(<span class="string">&quot;marry&quot;</span>).number(<span class="number">15</span>).build();</span><br><span class="line">    Student jack = Student.builder().age(<span class="number">12</span>).name(<span class="string">&quot;jack&quot;</span>).number(<span class="number">20</span>).build();</span><br><span class="line">    List&lt;Student&gt; students = ListUtil.of(tom, marry, jack);</span><br><span class="line">    System.out.println(<span class="string">&quot;======== collect ========&quot;</span>);</span><br><span class="line">    <span class="comment">// 归集</span></span><br><span class="line">    System.out.println(students.stream().map(Student::getAge).collect(Collectors.toList()));</span><br><span class="line">    System.out.println(students.stream().map(Student::getAge).collect(Collectors.toSet()));</span><br><span class="line">    <span class="comment">// Student类的number为key, Student对象为value的Map</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getNumber, p -&gt; p)));</span><br><span class="line">    <span class="comment">// Function.identity() 是 p -&gt; p 简单写法, 表示返回对象本身</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getNumber, Function.identity())));</span><br><span class="line">    <span class="comment">// Student类的age为key, Student类的name为value(由于marry和jack的age都是12, 所以在规约为map是出现一个key对应两个值, 这时由第三个参数来处理冲突键情况)</span></span><br><span class="line">    <span class="comment">// 这里简单处理: 重复时获取第一个键所对应的值。</span></span><br><span class="line">    System.out.println(students.stream().collect(Collectors.toMap(Student::getAge, Student::getName, (key1, key2) -&gt; key2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>统计: 实际上就是聚合的那些操作(最大值、最小值、平均值、数量)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.counting()));</span><br><span class="line">System.out.println(students.stream().collect(Collectors.averagingInt(Student::getAge)));</span><br><span class="line">System.out.println(students.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compareTo)));</span><br><span class="line"><span class="comment">// 获取所有值, 返回IntSummaryStatistics对象(数量, 求和, 最小值, 平均值, 最大值)</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getAge)));</span><br></pre></td></tr></table></figure>

<ul>
<li>分组/分区: 分区是将流中的数据按照一定的规则分为两组数据(Map&lt;Boolean, List<Object>&gt;), 分组是将流中的数据按照一定的规则分成多组数据(Map&lt;String/Integer/…, List&lt;Object/String/Integer/…&gt;&gt;)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回键为boolean, 值为Student对象的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.partitioningBy(item -&gt; item.getAge() &gt; <span class="number">12</span>)));</span><br><span class="line"><span class="comment">// 返回键为student.age, 值为List&lt;Student&gt;的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getAge)));</span><br><span class="line"><span class="comment">// collectors.groupingBy的第二个参数表示下游收集器, 可以对上游收集到的value值进行处理。</span></span><br><span class="line"><span class="comment">// 返回键为student.age, 值为List&lt;String&gt; names 的map</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.mapping(Student::getName, Collectors.toList()))));</span><br><span class="line"><span class="comment">// 返回键为student.name, 值为相同name的年龄的平均值</span></span><br><span class="line">System.out.println(students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingInt(Student::getAge))));</span><br></pre></td></tr></table></figure>

<ul>
<li>连接: 将流中的数据通过某个分隔符、前缀字符串、后缀字符串进行连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接连接, 没有分隔符</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining()));</span><br><span class="line"><span class="comment">// 使用|分隔</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>)));</span><br><span class="line"><span class="comment">// 添加连接前缀和后缀</span></span><br><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;|&quot;</span>, <span class="string">&quot;name: [&quot;</span>, <span class="string">&quot;]&quot;</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="2-2-中间操作"><a href="#2-2-中间操作" class="headerlink" title="2.2 中间操作"></a>2.2 中间操作</h3><h4 id="2-2-1-有状态"><a href="#2-2-1-有状态" class="headerlink" title="2.2.1 有状态"></a>2.2.1 有状态</h4><h5 id="2-2-1-1-排序"><a href="#2-2-1-1-排序" class="headerlink" title="2.2.1.1 排序"></a>2.2.1.1 排序</h5><p>自定义排序仅需要实现<code>Comparator</code>中的<code>compareTo</code>方法即可。实际上一些简单的排序在<code>Comparator</code>中都有静态实现，只需要通过<code>lambda</code>调用即可，比如降序排列<code>Comparator::reversOrder()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sorted</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认是升序排列</span></span><br><span class="line">    list.stream().sorted().forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(Comparator.reverseOrder()).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(Integer::compareTo).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * o1 &gt; o2 返回大于0的数表示升序</span></span><br><span class="line"><span class="comment">            * o1 &lt; o2 返回大于0的数表示降序</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> o1</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@param</span> o2</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted(Comparator.comparing(Student::getAge)).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    <span class="comment">// 多次排序</span></span><br><span class="line">    list.stream().sorted(Comparator.comparing(Student::getNumber).thenComparing(Student::getAge)).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-2-去重"><a href="#2-2-1-2-去重" class="headerlink" title="2.2.1.2 去重"></a>2.2.1.2 去重</h5><p><strong><code>distinct</code></strong></p>
<p>通过流中元素的 <code>hashCode()</code> 和 <code>equals() </code>去除重复元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">distinct</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().distinct().forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-3-切片"><a href="#2-2-1-3-切片" class="headerlink" title="2.2.1.3 切片"></a>2.2.1.3 切片</h5><p><code>limit(n)</code>截取前<code>n</code>个元素，<code>skip(n)</code>跳过<code>n</code>个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">limitOrSkip</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().limit(<span class="number">5</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    System.out.println();</span><br><span class="line">    list.stream().skip(<span class="number">5</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-无状态"><a href="#2-2-2-无状态" class="headerlink" title="2.2.2 无状态"></a>2.2.2 无状态</h4><h5 id="2-2-2-1-映射"><a href="#2-2-2-1-映射" class="headerlink" title="2.2.2.1 映射"></a>2.2.2.1 映射</h5><p>可以将一个流中的元素按照一定的规则映射到另一个流中。</p>
<ul>
<li><code>map</code>：接收一个处理函数，这个函数会作用到每个元素上，并为处理后的结果生成一个新的流。</li>
<li><code>flatMap</code>：接收一个处理函数，这函数会将作用到每个元素上，<strong>并为每个处理后的元素生成一个流</strong>，然后把所有流合并为流。(也就是说处理之后得到的数据是一个流，且这个流中的每个元素也是流。)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().map(item -&gt; item + <span class="number">1</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">    list.stream().map(Student::getAge).forEach(item -&gt; System.out.print(item));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在flatMap执行完成之后, 实际上是将一个流两个元素&#123;&quot;hello World!&quot;, &quot;how are you&quot;&#125; 分解为</span></span><br><span class="line">    <span class="comment">// 两个流: 分别为 &#123;&quot;hello&quot;, &quot;World!&quot;&#125; 和 &#123;&quot;how&quot;, &quot;are&quot;, &quot;you&quot;&#125; 两个流。</span></span><br><span class="line">    <span class="comment">// 在forEach操作是对这两个流分别执行forEach操作。</span></span><br><span class="line">    List&lt;String&gt; strs = ListUtil.of(<span class="string">&quot;hello World!&quot;</span>, <span class="string">&quot;how are you&quot;</span>);</span><br><span class="line">    strs.stream().flatMap(item -&gt; &#123;</span><br><span class="line">        <span class="comment">// 返回一个新流</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(item.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;).forEach(item -&gt; System.out.println(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为<code>debug</code>模式下<code>flatMap</code>执行完成之后的结果。</p>
<p><img src="https://s2.loli.net/2021/12/15/dgjItYFBTOJrAvC.png" alt="image-20211214204808262.png"></p>
<h4 id="2-2-2-2-过滤"><a href="#2-2-2-2-过滤" class="headerlink" title="2.2.2.2 过滤"></a>2.2.2.2 过滤</h4><p><code>filter</code></p>
<p>在实际的开发过程中比较常用的一个操作，接收一个函数，通过改函数判断是否需要过滤到元素。(一般情况下会配合映射<code>map</code>使用)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n======== filter ========&quot;</span>);</span><br><span class="line">    list.stream().filter(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>).forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-3-消费"><a href="#2-2-2-3-消费" class="headerlink" title="2.2.2.3 消费"></a>2.2.2.3 消费</h5><p><code>peek</code></p>
<p>主要是在<code>debug</code>中使用。</p>
<p>先来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    list.stream().peek(System.out::print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后发现并没有任何输出。回到开头的介绍中，<code>peek</code>属于中间操作，在运行到终止操作时，此中间操作是不会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.filter(item -&gt; item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .peek(e -&gt; System.out.println(<span class="string">&quot;被2整除的数: &quot;</span> + item))</span><br><span class="line">        .map(item -&gt; item + <span class="number">1</span>)</span><br><span class="line">        .peek(item -&gt; System.out.println(<span class="string">&quot;结果: &quot;</span> + item))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>被2整除的数: 2<br>结果: 3<br>被2整除的数: 4<br>结果: 5</p>
</blockquote>
<p>以上输出了流执行的中间过程，所以实际上流操作是在获取到一个元素后就会继续往下执行。</p>
<p>这里要注意：<code>peek(func)</code>接收的函数是一个<code>Consumer</code>，它是仅处理并不返回处理结果到流中。所以以下代码实际上执行也是没有效果的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.peek(item -&gt; item + <span class="number">1</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Type接口</title>
    <url>/2021/06/22/java/Type%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="Type接口"><a href="#Type接口" class="headerlink" title="Type接口"></a>Type接口</h3><p>[TOC]</p>
<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    <code>Type</code>接口是<code>Java</code>中所有类型的公共高级接口，是由<code>JDK5</code>引入，主要是为了实现参数化类型(泛型)，<code>Class</code>类是该接口的直接实现类。</p>
<span id="more"></span>

<p>​    在日常开发过程中，一些公共抽象点需要使用泛型进行结构抽象，从而达到业务调用点灵活调用的目的。之前有一次由于不懂<code>Type</code>接口以及子类，导致部分抽象做的不够灵活，本篇主要记录<code>Type</code>接口下参数化类型<code>ParameterizedType</code>的一些<code>API</code>使用。</p>
<h4 id="二、子接口"><a href="#二、子接口" class="headerlink" title="二、子接口"></a>二、子接口</h4><p><img src="https://i.loli.net/2021/06/22/3LURqsICMOANz7e.png" alt="3LURqsICMOANz7e"></p>
<p>从左到右依次是直接实现类<code>Class</code>，数组类型接口<code>GenericArrayType</code>，参数化类型接口<code>ParameterizedType</code>，通配符表达式接口<code>WildcardType</code>，类型变量接口(泛指任何类)<code>TypeVariable</code>。大概知道了几个接口之间的关系之后，直接进入一个应用场景。</p>
<p>​    服务端与客户端交互是设计了一个数据固定的数据结构，其中该数据结构中的存在两个属性<code>String dataJson</code>和<code>T Data</code>，而客户端只会传输经过一定的编码或者加密处理<code>dataJson</code>字段，由服务端自行处理字符串数据。最理想的情况就是，服务端做一层统一处理，接收到该实体对象之后，根据服务端和客户端之间的约定，解析其中的<code>dataJson</code>为对应的<code>data</code>数据。前面有一篇专门来说这个参数解析<a href="https://xiaocainiaoya.github.io/2021/06/21/Spring/SpringMvc%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/#more" target="_blank">这里</a>。当时同事最开始提出这个问题的时候还并没有提出想将<code>json</code>转为实体，仅想通过某种统一处理，将<code>json</code>解码(客户端传输过来的是经过某种编码)。最终选择的方案是通过<code>RequestBodyAdvice</code>，当完成解码这个动作之后，同事发现，既然都通过统一处理<code>json</code>串解码了，那不就可以通过泛型的方式把<code>json</code>转换为对应的实体？我原本以为获取不到对应类的泛型，而恰巧(真的是巧)。<code>RequestBodyAdvice#afterBodyRead</code>方法上参数是<code>Type</code>类型，从而能通过它(如果是泛型则类型为<code>ParameterizedType</code>)就可以获取到对应类的泛型类型，从而进行转换为对应的实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, </span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodParameter parameter, Type targetType, </span></span></span><br><span class="line"><span class="function"><span class="params">                               Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span></span></span><br></pre></td></tr></table></figure>

<p>这里我想抛出我的问题：如果这里没有<code>Type</code>参数，可以看之前那篇文章的其他两种方式，比如现在的场景就是使用<code>@InitBuilder</code>的方式最合适，要怎么获取到<code>Type</code>，或者说获取到参数的<code>ParameterizedType</code>？</p>
<p>度娘了一下，对查到的一些写法的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 直接Class: 这种写法纯属骗人，从类图可以看出，就算用父接口引用，其实本质上还是Class类型</span></span><br><span class="line"><span class="comment">// 和ParameterizedType类型不符。</span></span><br><span class="line">DataEntity&lt;User&gt; dataEntity = <span class="keyword">new</span> DataEntity&lt;User&gt;();</span><br><span class="line">Type t = (Type)dataEntity.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过class.getGenericSuperclass():这种方式可以获取到的的确是ParameterizedType，</span></span><br><span class="line"><span class="comment">// 但那是父类的ParameterizedType(如果父类是泛型的情况)。</span></span><br><span class="line"><span class="comment">// 那么如果A继承B，B能获取到A的class, 再通过A的class获取到B的泛型参数, 虽然有点绕, 但也不失为一种方式。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">Type type =list.getClass().getGenericSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过反射获取: 反射是根据类来获取对应的属性，这种方式下获取的是泛型前的类型TypeVariable</span></span><br><span class="line"><span class="comment">// 如果某个方法中的参数是泛型类型, 通过method.getGenericParameterTypes()可以获取到ParameterizedType</span></span><br><span class="line">DataEntity&lt;User&gt; dataEntity = <span class="keyword">new</span> DataEntity&lt;User&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Field field = dataEntity.getClass().getField(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">  Type paraType = field.getGenericType();</span><br><span class="line">  System.out.println(paraType);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上的3种方法，1和3直接就不对。只有2沾点边。所以在设计上可以将A设计为泛型接口，B作为A的具体实现，这时就可以获取到对应的泛型类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  Type[] type = b.getClass().getGenericInterfaces();</span><br><span class="line">  System.out.println(((ParameterizedType)type[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(User data)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、常用API"><a href="#三、常用API" class="headerlink" title="三、常用API"></a>三、常用API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里要时刻注意获取的父类的的Type或者是Class。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *  class.getSuperclass() 返回直接继承的父类(类型擦除, 不显示泛型参数)</span></span><br><span class="line"><span class="comment"> *  class.getGenericSuperclass() 返回直接继承的父类(包含泛型参数)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  class.getInterfaces() 返回直接实现的接口</span></span><br><span class="line"><span class="comment"> *  class.getGenericInterface() 返回直接实现的接口(包含泛型参数)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * ParameterizedType:</span></span><br><span class="line"><span class="comment"> *   getActualTypeArguments() 返回参数化类型列表(比如DataEntity&lt;User&gt;, 通过该方法获取到的就是User)</span></span><br><span class="line"><span class="comment"> *   getOwnerType() 返回这个ParameterizedType所在类的Type</span></span><br><span class="line"><span class="comment"> *   	比如Map&lt;String, Object&gt;的getOwnerType=null,Map.Entry&lt;String,String&gt;的getOwnerType=Map)</span></span><br><span class="line"><span class="comment"> *   getRawType() 表示声明此类型的类或者接口</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/22 22:39:26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Type type =list.getClass().getGenericSuperclass();</span><br><span class="line">    System.out.println(list.getClass().getGenericSuperclass());</span><br><span class="line">    System.out.println(list.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] classes = list.getClass().getInterfaces();</span><br><span class="line">    Type[] types = list.getClass().getGenericInterfaces();</span><br><span class="line"></span><br><span class="line">    System.out.println(list.getClass().getInterfaces());</span><br><span class="line">    System.out.println(list.getClass().getGenericInterfaces());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ParameterizedType:</span></span><br><span class="line"><span class="comment"> *   getActualTypeArguments() 返回参数化类型列表(比如DataEntity&lt;User&gt;, 通过该方法获取到的就是User)</span></span><br><span class="line"><span class="comment"> *   getOwnerType() 返回这个ParameterizedType所在类的Type(一般来说是空的)</span></span><br><span class="line"><span class="comment"> *   	比如Map&lt;String, Object&gt;的getOwnerType=null,Map.Entry&lt;String,String&gt;的getOwnerType=Map)</span></span><br><span class="line"><span class="comment"> *   getRawType() 表示声明此类型的类或者接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/06/22 23:16:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Method method = TypeTest.class.getMethod(<span class="string">&quot;test&quot;</span>, Map.Entry.class, </span><br><span class="line">                                                 List.class, DataEntity.class);</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            System.out.println(parameterizedType.getOwnerType() + <span class="string">&quot; || &quot;</span> + </span><br><span class="line">                               parameterizedType.getRawType() + <span class="string">&quot; || &quot;</span> + </span><br><span class="line">                               Arrays.toString(parameterizedType.getActualTypeArguments()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface java.util.Map || interface java.util.Map$Entry || [class cn.com.xiaocainiaoya.entity.User, class java.lang.String]</span></span><br><span class="line"><span class="comment">//null || interface java.util.List || [class cn.com.xiaocainiaoya.entity.User]</span></span><br><span class="line"><span class="comment">//null || class cn.com.xiaocainiaoya.entity.DataEntity || [class //cn.com.xiaocainiaoya.entity.User]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Map.Entry&lt;User, String&gt; mapEntry, List&lt;User&gt; list, DataEntity&lt;User&gt; userDataEntity)</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java参数命令</title>
    <url>/2023/08/18/java/java%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="java参数命令"><a href="#java参数命令" class="headerlink" title="java参数命令"></a>java参数命令</h1><h3 id="java启动命令中-D和–的区别"><a href="#java启动命令中-D和–的区别" class="headerlink" title="java启动命令中-D和–的区别"></a>java启动命令中-D和–的区别</h3><p>两种方式都可以<b>直接覆盖</b><code>yaml</code>或者<code>properties</code>配置中的同名配置项。</p>
<ul>
<li><code>-D</code>（包括<code>-X</code>）表示添加的参数是<code>jvm</code>虚拟机变量。<code>java</code>应用中通过<code>System.getProperties(&quot;&quot;)</code>获取。</li>
<li><code>--</code>表示添加的参数是操作系统的环境变量。<code>java</code>应用中通过<code>System.getEnv(&quot;&quot;)</code>获取。</li>
</ul>
<p><code>-D</code>参数要放置在<code>-jar</code>命令之前，<code>--</code>参数要放置在<code>-jar</code>命令之后。</p>
<blockquote>
<p>java -Dserver.port=8080 -Xms128m <b>-jar</b> –server.name=myApp</p>
</blockquote>
<p>可通过<code>jps</code>命令查看<code>java</code>应用具体的参数值。</p>
<ul>
<li><code>jps -v</code>：可以查看<code>-D</code>、<code>-X</code>参数</li>
</ul>
<p>示例：<code>1 jar -Djava.util.Arrays.useLegacyMergeSort=true -Djava.security.egd=file:/dev/./urandom -Xms128m -Xmx512m</code></p>
<ul>
<li><code>jps -m</code>：可以查看<code>--</code>参数</li>
</ul>
<p>示例：<code>1 jar --spring.profiles.active=dev --logging.config=logback-spring.xml</code></p>
<h3 id="crf反编译工具"><a href="#crf反编译工具" class="headerlink" title="crf反编译工具"></a>crf反编译工具</h3><blockquote>
<p><a href="http://www.benf.org/other/cfr/">http://www.benf.org/other/cfr/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java的agent探针技术</title>
    <url>/2023/03/02/java/java%E7%9A%84agent%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="java的agent探针技术"><a href="#java的agent探针技术" class="headerlink" title="java的agent探针技术"></a>java的agent探针技术</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    <code>Java Agent</code>直译过来就是<code>java</code>代理或者有的地方叫做<code>java</code>探针。这个<code>jar</code>包不能独立运行，需要依附于目标<code>JVM</code>进程中。主要作用是通过对<code>JVM</code>进程进行代理，可以在目标<code>JVM</code>运行过程中获取到对应虚拟机中相关参数。</p>
<span id="more"></span>

<p>​    主要应用场景为：热部署、<code>IDEA</code>的<code>DEBUG</code>调试功能，<code>Arthas</code>线上诊断工具、性能监控等。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>java Agent</code>有两个入口，两个入口的执行时机有所不同，一个是在目标应用启动之前，一个是在目标应用运行过程中。</p>
<p><b>目标应用刚启动时：</b></p>
<p>​    通过在目标应用的启动参数中添加<code>-javaagent:xxx/xxx/xxxAgent.jar</code>的方式启动，在执行目标应用的<code>main</code>方法之前会进入到<code>xxxAgent.jar</code>的<code>premain()</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两个方法都存在的情况下，会进入这个方法，不会进入单个参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ premain方法，有一个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ premain方法，有一个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>注意：这种方式是在目标应用要执行<code>main</code>方法，之前进入这个<code>premain</code>方法，也就是说这时<code>jvm</code>虚拟机中并没有加载过多的类。由于这种加载逻辑，导致在基本上在类加载之后就无法修改字节码，所以这种方式存的灵活性存在一定的限制。</b></p>
<p><b>目标应用运行过程中：</b></p>
<p>​    通过中间程序动态附着到目标<code>JVM</code>中的方式启动，所以中间程序就可以做到动态化，也就是达到某个条件之后就附着。</p>
<p><code>agent.jar</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两个方法都存在的情况下，会进入这个方法，不会进入单个参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ agentmain方法 有两个入参 ------ agentArgs:&quot;</span> + agentArgs + <span class="string">&quot; inst:&quot;</span> + inst.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------ agentmain方法 有两个入参 ------ agentArgs:&quot;</span> + agentArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BridgeProject</code>（中间程序）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException </span>&#123;</span><br><span class="line">    VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(VirtualMachineDescriptor vmDescriptor : VirtualMachine.list())&#123;</span><br><span class="line">        <span class="keyword">if</span>(vmDescriptor.displayName().contains(<span class="string">&quot;XxxBootstrap&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入附着jvm&quot;</span>);</span><br><span class="line">            vm = VirtualMachine.attach(vmDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm.loadAgent(<span class="string">&quot;xxx/xxx/agent.jar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说拥有<code>XxxBootstrap</code>启动类的目标应用当前正处在运行状态，然后启动中间程序<code>BridgeProject#main</code>方法，它会获取<code>XxxBootstrap</code>对应的虚拟机之后，将<code>agent.jar</code>附着到该虚拟机上，这时就会进入到<code>agent.jar</code>包中的<code>agentmain</code>方法，就可以动态的进行一些处理。</p>
<p><code>Arthas</code>就是使用<code>agentmain</code>这种方式，它在首次使用的时候是仅下载这个中间程序<code>curl -O https://arthas.aliyun.com/arthas-boot.jar</code>，当通过<code>java -jar arthas-boot.jar</code>命令启动这个<code>springboot</code>程序之后，它会罗列当前环境中的虚拟机（如果你开多个应用，会有多个虚拟机）。当你选中某个应用之后，它会校验<code>arthasHome=~/.arthas/lib/</code>这个目录是否有<code>agent.jar</code>包，如果没有它会去下载<code>agent.jar</code>包，当然它的逻辑会更复杂，它不单单只有<code>agent.jar</code>包。也就是说实际上通过<code>curl</code>下载的<code>arthas-boot.jar</code>实际上是对上述中间程序的一个封装，做一些外围非核心逻辑的处理，当选中某个应用时，再去下载核心<code>agent.jar</code>包，进行探针修改字节码相关逻辑处理。</p>
<p><b><code>Instrumentation</code>相关接口:</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加一个Class文件的转换器，该转换器用于改变class二进制流的数据，</span></span><br><span class="line"><span class="comment"> * 参数canRetransform设置是否允许重新转换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addTransformer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载之前，重新定义class文件，ClassDefinition表示一个类新的定义，</span></span><br><span class="line"><span class="comment"> * 如果在类加载之后，需要用retransformClasses方法重新定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redefineClasses(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在类加载之后，重新定义class。事实上，该方法update了一个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">retransformClasses();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加jar文件到BootstrapClassLoader中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendToBootstrapClassLoaderSearch();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加jar文件到system class loader。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appendToSystemClassLoaderSearch();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加载的所有类数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getAllLoadedClasses();</span><br></pre></td></tr></table></figure>

<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="1-打包"><a href="#1-打包" class="headerlink" title="1.打包"></a>1.打包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span> <span class="comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 添加 mplementation-*和Specification-*配置项--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addDefaultImplementationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultImplementationEntries</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addDefaultSpecificationEntries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addDefaultSpecificationEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--指定premain方法所在的类--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Premain-Class</span>&gt;</span>cn.com.xiaocainiaoya.Agent<span class="tag">&lt;/<span class="name">Premain-Class</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--添加这个即可--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Agent-Class</span>&gt;</span>cn.com.xiaocainiaoya.Agent<span class="tag">&lt;/<span class="name">Agent-Class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Redefine-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Redefine-Classes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">Can-Retransform-Classes</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Can-Retransform-Classes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意这里的<code>descriptorRef</code>这是会将<code>pom</code>中的依赖打入到<code>agent.jar</code>包中，所以是否启动这个要取决于你的探针中需要的类库在目标程序中是否存在。比如我的目标程序中不存在<code>directory-watcher</code>依赖，但是<code>agent.jar</code>是需要这个依赖，所以我这里使用<code>descriptorRef</code>将这个依赖也打入到最终的<code>agent.jar</code>包中，如果不希望部分依赖打入到<code>agent.jar</code>包中(如果主工程中也存在这个依赖，会出现冲突的情况)，需要在<code>pom.xml</code>的依赖项中添加<code>&lt;scope&gt;</code>标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-tool-jar工具"><a href="#2-tool-jar工具" class="headerlink" title="2.tool.jar工具"></a>2.tool.jar工具</h3><p>其中<code>VirtualMachine</code>是<code>JDK</code>工具包下的类，如果系统环境变量没有配置，需要自己在<code>Maven</code>中引入本地文件。一般采用方案二时，动态附着需要使用到这些类。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.sun&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">    &lt;systemPath&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/lib/tools.jar&lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-ClassFileTransformer"><a href="#3-ClassFileTransformer" class="headerlink" title="3.ClassFileTransformer"></a>3.ClassFileTransformer</h3><p>通过实现这个类<code>ClassFileTransformer</code>，然后通过<code>Instrumentation</code>添加到类转换器中，即可对类进行动态修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inst.addTransformer(<span class="keyword">new</span> ProfilingTransformer());</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java的泛型</title>
    <url>/2021/04/13/java/java%E7%9A%84%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="java的泛型"><a href="#java的泛型" class="headerlink" title="java的泛型"></a>java的泛型</h3><p>[TOC]</p>
<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    泛型实现了参数化类型的概念，使代码可以应用于多种类型，设计的初衷应该是希望类或者方法能够具备最广泛的表达能力。在引入泛型之前，一般都是依赖于<code>Object</code>顶层对象实现类似泛型的功能，但是使用<code>Object</code>有一个缺陷是如果类型转换异常，编译器在编译期无法检测这种异常，只有在字节码的运行时期才会抛出类型转换异常。而<code>JDK 1.5</code>之后引入的泛型，在编译期就会对类型进行检查，使得问题可以及早发现。</p>
<span id="more"></span>

<h4 id="二、泛型方式"><a href="#二、泛型方式" class="headerlink" title="二、泛型方式"></a>二、泛型方式</h4><h5 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h5><blockquote>
<p>泛型类的写法是在类上指明参数，并在属性或者方法中使用。</p>
</blockquote>
<p>先来看一下在没有泛型之前的操作方式，采用<code>Object</code>的方式，使得调用点获取到这个对象，如果需要获取到对象自身实现的某个方法，就需要进行强制类型装换，所以可能会出现类型装换异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object animal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再泛型引入之后采用如下方式，调用点在通过<code>get</code>方法获取到对象时，直接是调用点设置的参数类型，所以无需进行强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T animal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T animal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2.泛型接口"></a>2.泛型接口</h5><blockquote>
<p>泛型也可以应用于接口，使用上与泛型类类似。</p>
</blockquote>
<p>泛型接口对调用点来说有两种方式，一种是实现类指定了参数类型，则调用点无需再参数化类型；另一种是实现类依旧采用泛型的方式继承，则调用点就需要参数化类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">implements</span> <span class="title">People</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;display: &quot;</span>+ str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">People</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;display:&quot;</span>+t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3.泛型方法"></a>3.泛型方法</h5><blockquote>
<p>泛型也可以应用于方法上，并且这个方法对应的类可以是泛型类也可以不是泛型类。定义泛型方法只需要将泛型列表置于返回值之前。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt;  <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显式的类型说明：</strong>对泛型方法的调用，可以显式的指明类型，语法是在点操作符与方法名之间插入尖括号，然后将类型置于尖括号中，这种方式广泛用于静态方法，使用<code>tk.mybatis</code>过都知道<code>Example</code>中创建的静态泛型方法，笔者刚开始进入公司写的时候都是按部就班，不知道泛型方法的具体逻辑，学了泛型才知道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ========= WeekendSqls ============</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeekendSqls</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">SqlsCriteria</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">WeekendSqls&lt;T&gt; <span class="title">custom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeekendSqls();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  WeekendSqls&lt;People&gt; weekendSql = WeekendSqls.&lt;People&gt;custom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、泛型擦除"><a href="#三、泛型擦除" class="headerlink" title="三、泛型擦除"></a>三、泛型擦除</h4><blockquote>
<p>java的泛型是使用擦除来实现的，所以在真正运行的时候，任何具体的类型都会被擦除，唯一知道的是，在使用某一对象，所以对以下例子而言，最后的输出结果为<code>true</code>，类型都为<code>java.util.ArrayList</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">  Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">  System.out.println(<span class="string">&quot;c1的类型为:&quot;</span> + c1 + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;c2的类型为&quot;</span> + c2);</span><br><span class="line">  System.out.println( c1 == c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-泛型数组"><a href="#1-泛型数组" class="headerlink" title="1. 泛型数组"></a>1. 泛型数组</h5><p>由于<code>Class&lt;T&gt;</code>在运行时已经被擦除，实际的结果为<code>Class</code>，而通过这个没有指定类型<code>Class</code>的<code>newInstance</code>方法不会产生具体的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMaker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayMaker</span><span class="params">(Class&lt;T&gt; kind)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.kind = kind;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T[] create(<span class="keyword">int</span> size)&#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(kind, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayMaker&lt;String&gt; stringArrayMaker =  <span class="keyword">new</span> ArrayMaker&lt;&gt;(String.class);</span><br><span class="line">    String[] stringArray = stringArrayMaker.create(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// 这里的输出结果为 [null, null, null, null, null, null, null, null, null]  </span></span><br><span class="line">    System.out.println(Arrays.toString(stringArray));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGeneric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 在编译时期是Generic&lt;Integer&gt;[]，在运行时期可以理解为Object[]</span></span><br><span class="line">  <span class="keyword">static</span> Generic&lt;Integer&gt;[] gia;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时只会报警告，运行时会抛出类型装换异常，因为从Object[]转Generic&lt;Integer&gt;[]</span></span><br><span class="line">    <span class="comment">// gia = (Generic&lt;Integer&gt;[]) new Object[SIZE];</span></span><br><span class="line">    <span class="comment">// 由于是Generic&lt;Integer&gt;[]强转Object[]，所以运行正常。</span></span><br><span class="line">    gia = (Generic&lt;Integer&gt;[]) <span class="keyword">new</span> Generic[SIZE];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一个更复杂一点的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从编译器层面来说，创建数组强制装换为T[]，只会报警告</span></span><br><span class="line">    <span class="comment">// 从运行层面来说，Object[]强制装换为Object[]，正常行为</span></span><br><span class="line">    array = (T[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span></span>&#123;</span><br><span class="line">    array[index] = item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T[] rep()&#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从编译器层面来说，获取到T[]赋值为Object[],正常行为</span></span><br><span class="line">    <span class="comment">// 从运行层面来说，Object[]赋值为Object[]，正常行为</span></span><br><span class="line">    Object[] oa = gai.rep();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的例子，在实际的编写代码中要考虑到编译器层面和运行层面，对编译器来说，需要保证类型的异常转换都在编译时期通过警告或者编译不通过的方式提示用户；对运行层面来说，由于参数化类型已经被擦除，有可能会导致出现类型转换异常。总之一句话，编译器在编译时就是尽可能的做类型检查，前置了异常的抛出时机，避免所有的类型转换异常都在运行时期抛出。</p>
<h5 id="2-边界"><a href="#2-边界" class="headerlink" title="2.边界"></a>2.边界</h5><p><strong>2.1上界</strong></p>
<blockquote>
<p>泛型上界采用<code>&lt;? extends T&gt;</code>表示当前泛型参数只能由<code>T</code>类型的子类构成。</p>
</blockquote>
<p><code>&lt;? extends T&gt;</code>指明了这个泛型类参数化类型的参数的只能是<code>T</code>的子类，且会影响到泛型类中<strong>入参</strong>为参数化类型的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="title">extend</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T item;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Plate&lt;? extends Fruit&gt; plate = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  <span class="comment">// 两个set方法均报错，由于限定了参数化类型的上界，而对于Fruit来说有很多子类</span></span><br><span class="line">  <span class="comment">// 编译器在这时不知道应该使用哪个类来创建引用。</span></span><br><span class="line">  plate.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  plate.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">  </span><br><span class="line">  Fruit f = plate.get();</span><br><span class="line">  <span class="comment">// 报错，只能通过上界类获取引用</span></span><br><span class="line">  Apple a = plate.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2下界</strong></p>
<blockquote>
<p>泛型下界采用<code>&lt;? super T&gt;</code>表示当前泛型的参数只能有<code>T</code>类型的父类构成。</p>
</blockquote>
<p><code>&lt;? super T&gt;</code>指明了这个泛型类参数化类型的参数的只能是<code>T</code>的父类，且会影响到泛型类中<strong>返回值</strong>为参数化类型的方法。还是上面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Plate&lt;? <span class="keyword">super</span> Fruit&gt; pf = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Fruit());</span><br><span class="line">  <span class="comment">// 由于限定参数类型为Fruit的超类，所以添加的元素只要是Fruit以及Fruit的</span></span><br><span class="line">  <span class="comment">// 子类都会成功</span></span><br><span class="line">  pf.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 报错，由于限定参数为Fruit的超类，不能用Fruit来引用，当然了就算是Food也不行</span></span><br><span class="line">  Fruit ff = pf.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3无界(<code>?</code>通配符)</strong></p>
<blockquote>
<p><code>?</code>称为无界通配符，表示的是一种未知类型，所以一般如果采用了<code>?</code>定义一个泛型，对其调用的是与具体类型无关的方法。最常用的应该是<code>Class&lt;?&gt;</code>，因为就算是使用泛型<code>Class&lt;T&gt;</code>也并没有依赖于<code>T</code></p>
</blockquote>
<p>如果看过<code>jdk</code>容器相关的源码，都应该知道在容器中有很多的方法都采用这种写法，即无需关心具体的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> c.isEmpty(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>?</code>表示的未知类型，相比于<code>Object</code>应该来说是一个更大的概念，所以<code>List&lt;?&gt; != List&lt;Object&gt;</code>，并且<code>List&lt;Object&gt;</code>不能指向<code>List&lt;?&gt;</code>的引用；而<code>List&lt;?&gt;</code>可以指向<code>List&lt;Object&gt;</code>的引用。</p>
<p>但是有一点需要注意若<code>List&lt;?&gt;</code>指向<code>List&lt;Object&gt;</code>之后，由于类型是未知的，所以<code>List</code>中使用泛型的方法都不能使用，也就是<code>add(E e)</code>不能使用，编译器报错；而<code>remove(Object o)</code>参数没有使用泛型，则可以使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objects = list;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;?&gt; list = objects;</span><br></pre></td></tr></table></figure>

<p><strong>2.4 小结</strong></p>
<p>​    不论使用哪种边界，对于存在<code>?</code>来说，表示的都是未知类型，所以在使用上下界处理时要精准的知道类型之间的继承关系，上下界对<strong>入参</strong>参数化类型和<strong>返回值</strong>参数类型行为上的区别，并且在合适的场景可以进行添加操作，合适的场景可以进行获取操作。根据<code>PECS(Producer Extends Consumer Super)</code>原则，频繁读取操作，适合使用上界<code>extends</code>，频繁插入操作，适合使用下界<code>Super</code>。</p>
<p><strong>2.5 不使用通过符<code>?</code>的上下界</strong></p>
<blockquote>
<p>形如<T extends Fruit>或者是<T Super Fruit>，这种方式在声明处就指定了参数化类型的值。</p>
</blockquote>
<p>修改<code>Plate</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T item;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在声明处指定参数化类型的值</span></span><br><span class="line">  Plate&lt;Fruit&gt; pf = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  pf.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 此处声明参数化类型的值为Apple</span></span><br><span class="line">  Plate&lt;Apple&gt; pa = <span class="keyword">new</span> Plate&lt;&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">  pa.set(<span class="keyword">new</span> Apple());</span><br><span class="line">  <span class="comment">// 编译报错，指定只能传入Apple对象</span></span><br><span class="line">  pa.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h4><h5 id="1-基本数据类型不能作为类型参数"><a href="#1-基本数据类型不能作为类型参数" class="headerlink" title="1. 基本数据类型不能作为类型参数"></a>1. 基本数据类型不能作为类型参数</h5><p>​    在泛型中不能使用基本数据类型作为类型的参数，也就是不允许<code>ArrayList&lt;int&gt;</code>的方式，只能通过<code>java</code>的自动装箱拆箱机制，使用<code>ArrayList&lt;Integer&gt;</code>来实现。</p>
<h5 id="2-重载问题"><a href="#2-重载问题" class="headerlink" title="2.重载问题"></a>2.重载问题</h5><p>​    当出现多个参数化类型时，由于类型擦除的原因，重载的方法实际产生的是一样类型签名，所以不能产生不同类型的参数列表，必须提供明显有区别的方法名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">    <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item = t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K k)</span></span>&#123;key = k;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-自限定的泛型"><a href="#3-自限定的泛型" class="headerlink" title="3. 自限定的泛型"></a>3. 自限定的泛型</h5><p>自限定泛型强调的是创建这个类所使用的参数与这个类具有相同的类型。感觉有点绕，下面看一下<code>java</code>编程思想中的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用自限定声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123; </span><br><span class="line">  T element;</span><br><span class="line">  <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> element; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自限定类型的使用就两种方式，就是以下两种方式。</span></span><br><span class="line"><span class="comment"> * 1. 这边为了引入概念来说明，标记class之后的A为A1，尖括号中的A为A2</span></span><br><span class="line"><span class="comment"> *    创建的这个类A1所使用的参数A2与这个类A1具有相同的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2. 由于A已经继承了SelfBounded&lt;A&gt;，所以B可以直接继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125; <span class="comment">// It&#x27;s OK.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123; set(arg); <span class="keyword">return</span> get(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// class E extends SelfBounded&lt;D&gt; &#123;&#125; // [Compile error]: Type parameter D is not within its bound</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.set(<span class="keyword">new</span> A());</span><br><span class="line">    a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">    a = a.get();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Enum</code>的设计正是采用泛型自限定的方式。<code>Enum</code>的泛型限定了<code>E</code>的上界为<code>Enum</code>自身，确保了<code>Enum</code>的子类才能作为泛型参数，而在枚举中<code>compareTo(E o)</code>，在比较时，希望的是传入的参数类型就是<code>Enum</code>类型。所以这种设计使得方法中传入参数和返回的方法是与创建的类型保持继承关系，也就是说<code>E extends Enum&lt;E&gt;</code>保证<code>Enum&lt;E&gt;</code>的子类，比如<code>StatusEnum</code>枚举类都能够接收或者返回其本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>webService初试</title>
    <url>/2022/03/02/java/webservice%E5%88%9D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="webService初试"><a href="#webService初试" class="headerlink" title="webService初试"></a>webService初试</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近工作上需要将一些业务数据推送到各个门户网站，而各个门户网站上接收数据的方式不一样，有<code>webservice</code>和<code>http</code>两种方式，初次使用<code>webservice</code>，记录一下踩得一些坑。<span id="more"></span></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>​    使用<code>hutool</code>中的<code>SoapClient</code>配合<code>SoapUi</code>工具进行使用。</p>
<ol>
<li><p>使用<code>SoapUi</code>工具解析<code>WSDL</code>地址，得到这个地址提供的方法，再进入相应的方法，得到请求这个方法的<code>xml</code>结构。</p>
<p><img src="https://s2.loli.net/2022/03/02/BTNvykhem238QDE.png" alt="Snipaste_2022-03-02_14-40-27.png"></p>
<p>例子中: 这个<code>WSDL</code>提供了四个调用方法，然后点击<code>Request1</code>弹出右边部分。右边部分为对这个方法发起请求的<code>xml</code>结构，这时只需要通过<code>hutool</code>工具类<code>SoapClient</code>创建一个一致的<code>xml</code>请求结构后发起请求即可。</p>
<ol start="2">
<li><p>直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SoapClient client = SoapClient.create(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    .setCharset(Charset.forName(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    .setMethod(<span class="string">&quot;调用的方法名&quot;</span>, <span class="string">&quot;命名空间&quot;</span>)</span><br><span class="line">    .setParam(<span class="string">&quot;参数名称&quot;</span>, <span class="string">&quot;参数值&quot;</span>);</span><br><span class="line">  <span class="comment">// 打印请求数据</span></span><br><span class="line">  log.info(<span class="string">&quot;webService请求: \n&#123;&#125;&quot;</span>, client.getMsgStr(<span class="keyword">false</span>));</span><br><span class="line">  client.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上就完成了<code>webService</code>的调用，使用上还是比较简单，主要是第一次使用<code>webService</code>，到处磕磕碰碰。</p>
</li>
</ol>
<p><strong>1.SoapUI解析错误</strong></p>
<p>部分门户使用<code>SoapUI</code>直接解析对应的<code>http://xxx/xxx.asmx?wsdl</code>地址，出现以下报错：</p>
<p><code>     Error loading [http://htgs.ccgp.gov.cn/GS8/services/Gs8WebService?wsdl]:     org.apache.xmlbeans.XmlException: org.apache.xmlbeans.XmlException: error:     The element type &quot;hr&quot; must be terminated by the matching end-tag </code>。</p>
<p>解决方案为通过浏览器进入这个地址，将这个页面中的内容保存为<code>xx.wsdl</code>文件，使用<code>SoapUI</code>加载这个文件。</p>
<p><strong>1. 使用postman调用</strong></p>
<p>在通过代码进行<code>webService</code>请求之前，实际上应该通过<code>SoapUI</code>发起请求，看是否能调用成功。(请求方式为上图右部分的绿色按钮)。但是有一个接口，由于使用<code>http://xx</code>地址解析失败后采用<code>xx.wsdl</code>文件的方式解析，这个接口一直不能发起请求。</p>
<p>解决方案为使用<code>postman</code>发起请求。设置头信息中<code>text/xml; charset=UTF-8</code>，然后<code>body</code>请求体中的参数修改为<code>raw</code>后选择<code>XML(text/xml)</code>后就可以发起对<code>webService</code>服务的请求。</p>
<p><strong>3.请求数据</strong></p>
<p>假设发起请求要携带的参数值为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user_name</span>&gt;</span>zanshang<span class="tag">&lt;/<span class="name">user_name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user_age</span>&gt;</span>15<span class="tag">&lt;/<span class="name">user_age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么实际上是需要将这个参数值填入到对应位置，实际发起的请求中是需要将<code>&lt;</code>和<code>&gt;</code>等字符进行编码化。<code>&amp;lt;</code>和<code>&amp;gt;</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>body<span class="symbol">&amp;gt;</span></span><br><span class="line">	<span class="symbol">&amp;lt;</span>user_name<span class="symbol">&amp;gt;</span>zanshang<span class="symbol">&amp;lt;</span>/user_name<span class="symbol">&amp;gt;</span></span><br><span class="line">	<span class="symbol">&amp;lt;</span>user_age<span class="symbol">&amp;gt;</span>15<span class="symbol">&amp;lt;</span>/user_age<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>/body<span class="symbol">&amp;gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.请求地址中?wsdl</strong></p>
<p>对<code>webService</code>的请求地址中是否需要<code>?wsdl</code>，就目前而言部分接口是需要，部分接口是不需要。这就使得调用是不知道需不需要带上，遇到过一个问题是这个接口实际上是不需要携带，但我在请求时携带了，然后请求返回的内容是这个访问地址的内容，还一直以为是请求的参数或者是姿势不对，排查了好久才找到问题。</p>
<p><strong>5.返回处理</strong></p>
<p>最让我觉得难受的是<code>webService</code>请求之后处理，因为对接了好几个门户网站，每个门户都返回一种不同的结构。情况非常多：</p>
<p><strong>异常情况：</strong>A门户的异常返回的是重定向页面的内容还包含了图片的<code>base64</code>串。B门户调用过于频繁也是返回一个重定向页面的内容。</p>
<p><strong>正常情况：</strong>A门户是在一种<code>xml</code>结构中的里层嵌入一个<code>json</code>串。B门户是在<code>xml</code>中用<code>![[DATA]]</code>的方式嵌入一个<code>xml</code>结构数据。然而AB门户的外层<code>xml</code>结构都不一致。</p>
<p>综上基本上每个门户的请求参数和返回都需要进行定制化，无法抽象出来达到通用。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用BigDecimal计算防止精度丢失</title>
    <url>/2022/08/11/java/%E4%BD%BF%E7%94%A8BigDecimal%E9%98%B2%E6%AD%A2%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<h1 id="使用BigDecimal计算防止精度丢失"><a href="#使用BigDecimal计算防止精度丢失" class="headerlink" title="使用BigDecimal计算防止精度丢失"></a>使用BigDecimal计算防止精度丢失</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近工作的业务上需要使用到计算相关的函数，虽然有过一点基本的理论知识，知道计算相关必须使用<code>BigDecimal</code>处理进行处理，若使用<code>float</code>、<code>double</code>会丢失一定的精度，但是在使用过程中还是踩了一些坑，所以对<code>BigDecimal</code>原理进行更深入的了解。</p>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>为什么<code>float</code>、<code>double</code>会存在精度丢失？</p>
<p>​    主要是由于二进制浮点表示方式的限制，在计算机中存储的是二进制数，而十进制和二进制之间的转换可能并不完美，某些十进制小数无法完美的转换为二进制表示，比如<code>0.1</code>无法使用二进制精确表示，所以就有了<code>IEEE 754</code>规范，用一个无限小数近似表示，对于<code>float</code>单精度和<code>double</code>双精度，简单理解就是保留的位数长度不同。</p>
<p>为什么<code>BigDecimal</code>能防止精度丢失？</p>
<p>​    <code>BigDecimal</code>是专门设计来解决浮点数精度问题，它是一个类，注意<code>float</code>和<code>double</code>是数据类型，而<code>BigDecimal</code>是一个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 省略部分字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">long</span> intCompact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单理解它使用两个数来表示一个浮点数，比如<code>0.03</code>，<code>scale</code>表示“负的多少次幂”，<code>intCompact</code>表示移除小数点之后的值，所以这时<code>intCompact=3, scale=2</code>。也就是<code>3*0.01=0.03</code>来表示这个数。</p>
<p><b>调试：</b></p>
<p>但是我在调试的时候发现一个问题，可能会造成一些误解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0.2</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">0.1F</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以先自己尝试理解，如果这段代码直接运行会得到什么样的结果。</p>
<p>上面提到，浮点数是无法精确的表达<code>0.1</code>、<code>0.2</code>的，但是实际上前两句的输出是会精确的输出<code>0.1</code>、<code>0.2</code>，但是第三句的求和运算后输出的值是一个近视值<code>0.30000000149011613</code>，到这里可能很多人会想不明白，甚至如果你通过<code>idea</code>的<code>debug</code>模式，会发现，<code>debug</code>中<code>a=0.2</code>、<code>b=0.1</code>，到这里可能就想不明白到底是为啥。</p>
<p>其实是<code>System.out.println()</code>是被特殊处理的，如果采用<code>System.out.printf(&quot;%.20f\n&quot;, b);</code>的方式打印，就会打印出一个近似值<code>0.10000000149011612000</code>。</p>
<p>至于<code>idea</code>的<code>debug</code>模式为什么也是显示<code>a=0.2</code>、<code>b=0.1</code>，是因为<code>idea</code>对<code>float</code>和<code>double</code>通常是经过格式化处理的，目的是更易于人类阅读和理解（<code>chatgpt</code>解答）</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p><b>1.使用浮点数创建BigDecimal对象</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">double</span>)</span><br><span class="line">BigDecimal(<span class="keyword">long</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里输出的结果是<code>0.1000000000000000055511151231257827021181583404541015625</code>。</p>
<p>这是因为<code>double</code>表示的小数是不精确的，只能表示对应的近似值，所以使用这个近似值来创建<code>BigDecimal</code>，最后得到的也只是一个近似值。<b>所以使用浮点数来创建<code>BigDecimal</code>对象的方式在实际中是不可取的。</b></p>
<p><b>2.BigDecimal比较大小</b></p>
<p>由于<code>BigDecimal</code>是一个类，在<code>BigDecimal.equals()</code>方法中是比较<code>scale</code>、<code>intCompact</code>等值是否相等来判定是否相等。比如</p>
<p><code>0.2</code>：<code>intCompact=2, scale=1</code></p>
<p><code>0.20</code>：<code>intCompact=2, scale=2</code></p>
<p>那么这时<code>equals()</code>方法会判定二者不相等，但是在实际的业务场景中应该<code>99.9%</code>是想让这两个值相等。</p>
<p>所以<code>BigDecimal</code>是否相等的判断最好是通过<code>compareTo()</code>方法，若两个值相等则返回0。</p>
<p><b>3.创建BigDecimal</b></p>
<p>如果需要创建一个精确表示浮点数的<code>BigDecimal</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal v1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">BigDecimal v2 = BigDecimal.valueOf(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure>

<p><b>第一种方式</b>是使用字符串进行<code>BigDecimal</code>的初始化，先使用字符串来表是<code>0.1</code>，再创建<code>BigDecimal</code>对象。</p>
<p><b>第二种方式</b>会调用到<code>Dable.toString()</code>方法，前面说到<code>double</code>可能无法表达精确的小数，那么这里为什么可以精确的创建出<code>0.1</code>的<code>BigDecimal</code>对象？其实<code>Double.toString()</code>，这个<code>toString()</code>方法是经过特殊设计，能够返回一个最简短的、没有信息损失的、可恢复的字符串表示，这意味着你可以从该字符串表示重新构建一个与原始<code>double</code>值完全相等的<code>double</code>值。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>maven插件整理</title>
    <url>/2023/07/26/maven/maven%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="maven插件整理"><a href="#maven插件整理" class="headerlink" title="maven插件整理"></a>maven插件整理</h1><p>​    常用<code>maven</code>插件整理，<code>maven</code>本质上是一个插件框架，它的核心并不具备执行任何构建任务的能力，所有的任务都是交由插件完成。</p>
<span id="more"></span>    

<p>​    <code>maven</code>插件<a href="https://maven.apache.org/plugins/index.html">官网</a>，里面有一个<code>Supported By The Maven Project</code>标题下的列表中的插件，是由<code>maven</code>官方支持的插件。还有一个<code>Outside The Maven Land</code>下的<code>At MojoHaus (formerly known as codehaus.org)</code>这个不是官网的插件列表，但其中的部分插件也是比较常用的。</p>
<h2 id="1-maven-antrun-plugin"><a href="#1-maven-antrun-plugin" class="headerlink" title="1.maven-antrun-plugin"></a>1.maven-antrun-plugin</h2><p>​    主要作用是能让用户在<code>maven</code>项目中运行<code>Ant</code>任务。</p>
<h2 id="2-maven-archetype-plugin"><a href="#2-maven-archetype-plugin" class="headerlink" title="2.maven-archetype-plugin"></a>2.maven-archetype-plugin</h2><p>​    <code>Archtype</code>指项目的骨架，主要作用是创建项目骨架原型。</p>
<ul>
<li><code>archetype:generate</code>：使用交互式的方式提示用户输入必要的信息以创建项目</li>
</ul>
<h2 id="3-maven-assembly-plugin"><a href="#3-maven-assembly-plugin" class="headerlink" title="3.maven-assembly-plugin"></a>3.maven-assembly-plugin</h2><p>​    这个插件就比较常用，用来对项目制作一些压缩包，定制压缩包中的内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/config/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="4-maven-dependency-plugin"><a href="#4-maven-dependency-plugin" class="headerlink" title="4.maven-dependency-plugin"></a>4.maven-dependency-plugin</h2><p>​    主要作用是分析项目中的依赖。</p>
<ul>
<li><code>dependency:list</code>：项目最终解析到的依赖列表</li>
<li><code>dependency:tree</code>：进一步的描绘项目依赖树</li>
<li><code>dependency:analyze</code>：项目依赖潜在的问题</li>
<li><code>dependency:copy-dependencies</code>：能将项目依赖从本地Maven仓库复制到某个特定的文件夹下面</li>
</ul>
<h2 id="5-maven-enforcer-plugin"><a href="#5-maven-enforcer-plugin" class="headerlink" title="5.maven-enforcer-plugin"></a>5.maven-enforcer-plugin</h2><p>​    设置约束项目的一系列规则并强制遵守，比如<code>maven</code>的版本，<code>java</code>的版本，禁止某些依赖，某些依赖的版本最低版本，在父<code>pom</code>中配置规则，当不符合规则时，会报错。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>display-info<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--规则检查不通过就构建失败;Default:false. --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;failFast&gt;true&lt;/failFast&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--maven的版本要大于3.0.4--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requireMavenVersion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">requireMavenVersion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--java的版本要大于1.6--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requireJavaVersion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">requireJavaVersion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--bannedDependencies表示禁止使用的依赖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bannedDependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否检查传递性依赖(间接依赖)--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">searchTransitive</span>&gt;</span>true<span class="tag">&lt;/<span class="name">searchTransitive</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--禁止的依赖列表--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>junit:junit<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">message</span>&gt;</span>must use TestNG<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bannedDependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>exclude</code>标签中，可以通过通配符的方式设置一些依赖规则，其他详见<a href="http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html">内置版本范围规则</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--groupId[:artifactId][:version][:type][:scope][:classifier]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:log4j<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:log4j:1.0<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:1.2<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span><span class="comment">&lt;!--排除1.2及其以上版本,等价于[1.2,)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:[1.2]<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span><span class="comment">&lt;!--明确排除1.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.log:*:*:jar:test<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*:*:*:jar:compile:tests<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-maven-help-plugin"><a href="#6-maven-help-plugin" class="headerlink" title="6.maven-help-plugin"></a>6.maven-help-plugin</h2><p>​    一个辅助工具，用来获取一些详细使用信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看`versions-maven-plugin`这个插件的详细描述，会输出这个插件的所有`goal`</span></span></span><br><span class="line">mvn help:describe -Dplugin=org.codehaus.mojo:versions-maven-plugin:2.7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看指定的某个goal</span></span></span><br><span class="line">mvn help:describe -Dplugin=org.codehaus.mojo:versions-maven-plugin:2.7 -Dgoal=set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看有效settings</span></span></span><br><span class="line">mvn help:effective-settings</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus特性</title>
    <url>/2022/10/14/mybatis/mybatis-plus%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="mybatis-plus特性"><a href="#mybatis-plus特性" class="headerlink" title="mybatis-plus特性"></a>mybatis-plus特性</h1><span id="more"></span>

<h2 id="1-字段类型转换器"><a href="#1-字段类型转换器" class="headerlink" title="1.字段类型转换器"></a>1.字段类型转换器</h2><p>如果出现实体字段类型与数据库类型不一致情况，比如实体是<code>String</code>但是数据库是<code>Date</code>，或者实体中是对象，而数据库中是<code>varchar</code>存储<code>json</code>；则可以通过字段类型转换器进行统一转换，无需业务层在每次存取时进行手段转换。</p>
<p><b>1.实体上设置转换器类型(设置之后，在通过基础接口的处理都会进行转换)</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里需要设置autoResultMap = true, 否则查询时不会将数据库中的json转换为对应实体</span></span><br><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">    <span class="comment">// 设置转换器的类型,这个是内置转换器,也可以自定义</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserExtraInfo userExtraInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>2.第一步骤中的设置仅导致通过内置接口的处理会进行转换，但是通过自定义XML的脚本语句不会进行转换。</b><br>法一：在<code>mapper</code>语句上通过<code>@Results</code>设置对应的映射关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Results(value = &#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;user_extra_info&quot;, property = &quot;userExtraInfo&quot;, typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二：需要在<code>xml</code>文件中配置<code>resultMap</code>结果集，并在结果集映射中设置对应的类型转换器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">testXmlSql</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;cn.com.xiaocainiaoya.springbootsimple.entity.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ID&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;NAME&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mobile&quot;</span> <span class="attr">column</span>=<span class="string">&quot;MOBILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;PASSWORD&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deleteStatus&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DELETE_STATUS&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userExtraInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;USER_EXTRA_INFO&quot;</span> <span class="attr">typeHandler</span> = <span class="string">&quot;com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testXmlSql&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;procurementTemplateMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-基础类扩展"><a href="#2-基础类扩展" class="headerlink" title="2.基础类扩展"></a>2.基础类扩展</h2><p>直接通过继承<code>mybatis-plus</code>提供的三层基础接口，可以直接具备一些数据操作能力，比如通过<code>deleteById</code>可以直接通过<code>id</code>删除记录，无需编写<code>SQL</code>语句。同时<code>mybatis-plus</code>还提供了对基础层的扩展，用户可自定义扩展点后，业务处理再继承于自定义的扩展点，使得系统应用具备自定义扩展底层接口的能力。<br><img src="https://s2.loli.net/2022/10/14/eropFI59y32lt4k.png" alt="mybatis-plus基础接口扩展.png"></p>
<p>上图中<code>userFacade</code>、<code>userService</code>、<code>userMapper</code>是业务层；<code>customerService&lt;User&gt;</code>、<code>CustomerServiceImpl</code>、<code>CustomerMapper</code>是自定义扩展层；<code>IService&lt;T&gt;</code>、<code>ServiceImpl</code>、<code>BaseMapper</code>是<code>mybatis-plus</code>的三次基础接口。</p>
<p><b>假设现在要扩展<code>Insert ignore</code>的插入语句</b></p>
<p><b>1.继承<code>AbstractMethod</code>编写具体<code>SQL</code>的拼写等处理：</b>可以参考原有的其他对<code>AbstractMethod</code>的实现，比如<code>com.baomidou.mybatisplus.core.injector.methods</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertIgnore</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        CustomerSqlMethod sqlMethod = CustomerSqlMethod.INSERT_IGNORE_ONE;</span><br><span class="line">        String columnScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlColumnMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertTrim(tableInfo.getAllInsertSqlPropertyMaybeIf(<span class="keyword">null</span>),</span><br><span class="line">                LEFT_BRACKET, RIGHT_BRACKET, <span class="keyword">null</span>, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(tableInfo.getKeyProperty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(sqlMethod.getMethod(), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, sqlMethod.getMethod(), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>2.设置自定义<code>SQL</code>注入器并注入到<code>Spring</code>容器：</b>将步骤一中创建的具体<code>SQL</code>执行器注入到<code>mybatis-plus</code>相应处理中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MybatisConfig</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">iSqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomerSqlInjector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>3.创建扩展的<code>mapper</code>层：</b>添加需要扩展的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>4.创建扩展<code>service</code>层</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> InsertIgnore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>4.创建扩展<code>serviceImpl</code>层</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">M</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomerService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertIgnore</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMapper.insertIgnore(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>5.到这里，业务层只要继承于扩展层，就具备了自定扩展的处理能力</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">CustomerMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> <span class="keyword">extends</span> <span class="title">CustomerService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">CustomerServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserExtraInfo userExtraInfo = UserExtraInfo.builder()</span><br><span class="line">                .address(<span class="string">&quot;北京市&quot;</span>)</span><br><span class="line">                .city(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                .id(<span class="string">&quot;12312311&quot;</span>)</span><br><span class="line">                .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                .mobile(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .deleteStatus(<span class="number">0</span>)</span><br><span class="line">                .userExtraInfo(userExtraInfo)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 这里就可以直接调用到扩展的接口</span></span><br><span class="line">        insertIgnore(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-逻辑删除"><a href="#3-逻辑删除" class="headerlink" title="3.逻辑删除"></a>3.逻辑删除</h2><p>只需要设置<code>@TableLogic</code>就具备了逻辑删除的能力，但是这仅限制与通过<code>mybatis-plus</code>的基础接口处理数据，如果是通过<code>xml</code>手写<code>SQL</code>是无法自动补充逻辑删除条件。</p>
<ul>
<li>插入语句不处理，也就是说默认值需要业务方插入或者通过数据库设置默认值来处理</li>
<li>查找、更新会追加查询条件</li>
<li>删除转为更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置逻辑删除字段</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleteStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-对第2点中的注入器分析"><a href="#4-对第2点中的注入器分析" class="headerlink" title="4.对第2点中的注入器分析"></a>4.对第2点中的注入器分析</h2><p>首先在<code>mybatis</code>对持久层进行解析时，需要对<code>xml</code>等进行解析，<code>mybatis-plus</code>对<code>mybatis</code>对<code>xml</code>解析进行了扩展，解析时会进入到<code>MybatisMapperAnnotationBuilder#parse</code>方法。每一个<code>XxxMapper</code>都会进入到这个解析方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个resource的值就是全限定路径，比如‘cn.com.xiaocainiaoya.user.UserMapper’</span></span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        String mapperName = type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.InterceptorIgnoreCache cache = InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="comment">// 因为UserMapper需要继承于或间接继承于mybatis-plus实现的通用BaseMapper接口</span></span><br><span class="line">        <span class="comment">// 所以这个methods得到的方法即UserMapper的所有方法(包含继承的上层接口的方法)</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这个地方主要是做缓存一类，默认情况下是不开启的</span></span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                SqlParserHelper.initSqlParserInfoCache(mapperName, method);</span><br><span class="line">                parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                <span class="comment">// TODO 使用 MybatisMethodResolver 而不是 MethodResolver</span></span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> MybatisMethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO 注入 CURD 动态 SQL , 放在在最后, because 可能会有人会用注解重写sql</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// https://github.com/baomidou/mybatis-plus/issues/3038</span></span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                <span class="comment">// 主要处理在这里</span></span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> InjectorResolver(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>parserInjector()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parserInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里在不扩展的情况下获取到的是DefaultSqlInjector，扩展之后就是扩展的实现类，比如在我的实现中是CustomerSqlInjector这个类</span></span><br><span class="line">    <span class="comment">// 注意在这个中：一定要获取super.getMethodList(mapperClass); 这是原本的通用方法的注入器，比如有selectById(id)、deleteById(id)</span></span><br><span class="line">    GlobalConfigUtils.getSqlInjector(configuration)</span><br><span class="line">    <span class="comment">// 进入注入器逻辑，这个方法的主要实现是在DefaultSqlInjector的父类AbstractSqlInjector中</span></span><br><span class="line">    .inspectInject(assistant, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>AbstractSqlInjector#inspectInject</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; modelClass = extractModelClass(mapperClass);</span><br><span class="line">    <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String className = mapperClass.toString();</span><br><span class="line">        Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">        <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">            <span class="comment">// 获取需要操作的方法列表，这个this.getMethodList()是模板方法，由子类实现，默认在DefaultSqlInjector中已经添加了17个通用方法，</span></span><br><span class="line">            <span class="comment">// 所以要求当需要自定义扩展时继承于DefaultSqlInjector类，并在getMethodList()实现中，先获取父类的getMethodList()，得到这17</span></span><br><span class="line">            <span class="comment">// 个通用方法之后，再添加自定义扩展的操作方法。</span></span><br><span class="line">            List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mapperRegistryCache.add(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的<code>CustomerSqlInjector</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意：这个很重要，这个是原本已经写好的数据处理能力</span></span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        <span class="comment">// 插入数据，如果中已经存在相同的记录，则忽略当前新数据</span></span><br><span class="line">        methodList.add(<span class="keyword">new</span> InsertIgnore());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlInjector</span> <span class="keyword">extends</span> <span class="title">AbstractSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DefaultSqlInjector中的通用17个方法sql注入器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Insert(),</span><br><span class="line">            <span class="keyword">new</span> Delete(),</span><br><span class="line">            <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">            <span class="keyword">new</span> DeleteById(),</span><br><span class="line">            <span class="keyword">new</span> DeleteBatchByIds(),</span><br><span class="line">            <span class="keyword">new</span> Update(),</span><br><span class="line">            <span class="keyword">new</span> UpdateById(),</span><br><span class="line">            <span class="keyword">new</span> SelectById(),</span><br><span class="line">            <span class="keyword">new</span> SelectBatchByIds(),</span><br><span class="line">            <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">            <span class="keyword">new</span> SelectOne(),</span><br><span class="line">            <span class="keyword">new</span> SelectCount(),</span><br><span class="line">            <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">            <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">            <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">            <span class="keyword">new</span> SelectList(),</span><br><span class="line">            <span class="keyword">new</span> SelectPage()</span><br><span class="line">        ).collect(toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进入到具体注入器中，这里以<code>mybatis-plus</code>内置的一个但未启用的一个注入器<code>InsertBatchSomeColumn</code>为例。它是在<code>com.baomidou.mybatisplus.extension.injector.methods</code>目录下，这里内置了好几个未启用的注入器。<code>InsertBatchSomeColumn</code>是对批量插入的<code>SQL</code>注入器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertBatchSomeColumn</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段筛选条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Accessors(chain = true)</span></span><br><span class="line">    <span class="keyword">private</span> Predicate&lt;TableFieldInfo&gt; predicate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法的主要逻辑就是拼接出 </span></span><br><span class="line"><span class="comment">     * &lt;script&gt; INSERT INTO tableName (field1,field2,field3....) VALUES </span></span><br><span class="line"><span class="comment">     *  &lt;foreach collection=&quot;list&quot; item=&quot;et&quot; separator=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="comment">     *      (#&#123;et.field1&#125;,#&#123;et.field2&#125;,#&#123;et.field3&#125;....)</span></span><br><span class="line"><span class="comment">     *  &lt;/foreach&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/script&gt;</span></span><br><span class="line"><span class="comment">     * 动态的批量插入脚本语句，这里需要注意的一点是，对于在mysql中设置字段默认值的情况，由于在这个sql中会对空值的字段赋值null</span></span><br><span class="line"><span class="comment">     * 所以使用这种情况的批量插入会导致mysql默认值失效。如果在mysql中设置字段not null，则这种情况会报错。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;Duplicates&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">        SqlMethod sqlMethod = SqlMethod.INSERT_ONE;</span><br><span class="line">        List&lt;TableFieldInfo&gt; fieldList = tableInfo.getFieldList();</span><br><span class="line">        String insertSqlColumn = tableInfo.getKeyInsertSqlColumn(<span class="keyword">false</span>) +</span><br><span class="line">            <span class="keyword">this</span>.filterTableFieldInfo(fieldList, predicate, TableFieldInfo::getInsertSqlColumn, EMPTY);</span><br><span class="line">        String columnScript = LEFT_BRACKET + insertSqlColumn.substring(<span class="number">0</span>, insertSqlColumn.length() - <span class="number">1</span>) + RIGHT_BRACKET;</span><br><span class="line">        String insertSqlProperty = tableInfo.getKeyInsertSqlProperty(ENTITY_DOT, <span class="keyword">false</span>) +</span><br><span class="line">            <span class="keyword">this</span>.filterTableFieldInfo(fieldList, predicate, i -&gt; i.getInsertSqlProperty(ENTITY_DOT), EMPTY);</span><br><span class="line">        insertSqlProperty = LEFT_BRACKET + insertSqlProperty.substring(<span class="number">0</span>, insertSqlProperty.length() - <span class="number">1</span>) + RIGHT_BRACKET;</span><br><span class="line">        String valuesScript = SqlScriptUtils.convertForeach(insertSqlProperty, <span class="string">&quot;list&quot;</span>, <span class="keyword">null</span>, ENTITY, COMMA);</span><br><span class="line">        String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">        String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 表包含主键处理逻辑,如果不包含主键当普通字段处理</span></span><br><span class="line">        <span class="keyword">if</span> (tableInfo.havePK()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tableInfo.getIdType() == IdType.AUTO) &#123;</span><br><span class="line">                <span class="comment">/* 自增主键 */</span></span><br><span class="line">                keyGenerator = <span class="keyword">new</span> Jdbc3KeyGenerator();</span><br><span class="line">                keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != tableInfo.getKeySequence()) &#123;</span><br><span class="line">                    keyGenerator = TableInfoHelper.genKeyGenerator(getMethod(sqlMethod), tableInfo, builderAssistant);</span><br><span class="line">                    keyProperty = tableInfo.getKeyProperty();</span><br><span class="line">                    keyColumn = tableInfo.getKeyColumn();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后生成的模板SQL</span></span><br><span class="line">        String sql = String.format(sqlMethod.getSql(), tableInfo.getTableName(), columnScript, valuesScript);</span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="comment">// 绑定到对应的mapperId上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.addInsertMappedStatement(mapperClass, modelClass, getMethod(sqlMethod), sqlSource, keyGenerator, keyProperty, keyColumn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在扩展的CustomBaseMapper中需要与这个method通用，才会与这个注入器进行绑定。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">(SqlMethod sqlMethod)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义 mapper 方法名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;insertBatchSomeColumn&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-批量操作"><a href="#5-批量操作" class="headerlink" title="5.批量操作"></a>5.批量操作</h2><p>​    在<code>mybatis-plus</code>中提供了一些批量操作，比如有<code>updateBatchById</code>、<code>saveBatch</code>、<code>saveOrUpdateBatch</code>等，这种批量方式与<b>第4点中注入器的方式底层处理上是有本质不同的</b>。<code>mybatis-plus</code>提供的这些批量操作，本质上是对<code>mybatis</code>的批量操作再次封装，而<code>mybatis</code>的批量操作是对<code>JDBC</code>批处理进行封装。</p>
<p>​    这种批量操作实际上是在一个<code>session</code>会话中，批量的执行一堆语句。而<b>第4点种的注入器的实现</b>是通过将批量插入的语句拼接成<code>insert into tableName(field1, field2..) values(...)(....)</code>，这里只有一条插入语句。</p>
<p>​    如果从执行的效率出发，使用将批量插入的语句拼接为一条长语句</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis执行器</title>
    <url>/2022/11/22/mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8/</url>
    <content><![CDATA[<h1 id="mybatis执行器"><a href="#mybatis执行器" class="headerlink" title="mybatis执行器"></a>mybatis执行器</h1><span id="more"></span>

<p>在<code>mybatis</code>中包含四大件是指<strong>：executor, statementHandler,parameterHandler，resultHandler对象</strong>。</p>
<p>它们都是sqlSession的底层类实现，本篇的重点是了解一下<code>executor</code>执行器的作用和一些原理。</p>
<p>在<code>mybatis</code>中有三类执行器：</p>
<ul>
<li>简单执行器：<code>SimpleExecutor</code>，是执行器的默认实现，继承了<code>BaseExecutor</code>抽象类，利用<code>StatementHandler</code>完成。每次调用执行方法都会构建一个<code>StatementHandler</code>，并预设参数，然后执行。</li>
<li>可重用执行器：<code>ReuseExecutor</code>，可重复使用<code>JDBC</code>中<code>Statement</code>，减少预编译次数。该执行器在执行<code>SQL</code>时会把<code>Statement</code>缓存起来，如果下次碰到相同的SQL，就会取出来使用。</li>
<li>批处理执行器：<code>BatchExecutor</code>，每次的执行操作 不会立即提交到数据库，而是把对应的<code>Statement</code>对象填充好参数之后暂存起来。调用<code>doFlushStatements</code>的时候一次性提交到数据库，可用于批处理插入的场景。</li>
</ul>
<p><img src="https://s2.loli.net/2022/11/22/meG7dva9NcRCg8U.png" alt="执行器.png"></p>
<p>执行器的顶层接口为<code>Executor</code>，它定义了数据修改、数据查询、缓存维护等基本功能，还有一些辅助的API接口，比如提交事务、回滚事务等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单列几个接口，还有一些没列出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象接口<code>BaseExecutor</code>实现<code>Executor</code>并提供一些通用能力，比如有一级缓存，获取连接等。比如针对查询来说，它实现了顶层接口的<code>query</code>方法，并实现一级缓存的相关逻辑，若缓存查询不同，通过<code>doQuery</code>方法，下放给具体实现子类，也就是说，子类只需要实现具体的<code>doQuery</code>方法。</p>
<p>在<code>mybatis</code>中有三种执行器，分别为简单执行器、可重用执行器、批处理执行器。在这种结构下，若希望添加一级缓存应该如何处理？可以在<code>BaseExecutor</code>上层抽象一层接口，这个抽象接口实现二级缓存的逻辑。但是<code>mybatis</code>不采用这种方式，它通过装饰者模式，构建<code>CachingExecutor</code>类实现于<code>Executor</code>接口，并将<code>Executor</code>作为他的一个属性，当自身的二级缓存获取不到值时，调用<code>delegate</code>的同名方法，进入具体的执行器中。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p><img src="https://s2.loli.net/2022/11/23/tVWrlBgjGM7L21F.png" alt="一级缓存.png"></p>
<p>​    一级缓存实际上就是一个<code>HashMap</code>，根据一些相关的参数信息生成一个<code>key</code>，结果集为值的<code>hashMap</code>。它的<code>CacheKey</code>的主要参数为<code>statementID</code>，<code>SQL</code>，执行参数等，所以有时候尽管是一模一样的<code>SQL</code>也不会命中<code>mybatis</code>的一级缓存。</p>
<p>​    <code>mybatis</code>的代码是极其精简的，这是仅是使用<code>HashMap</code>来存储一级缓存的内容，它甚至都不使用<code>concurrentHashMap</code>，这是因为<code>SqlSession</code>本身就不是线程安全的，对于<code>SqlSession</code>来说他需要创建一个执行器，执行器对应于一条<code>statementID</code>，如果出现并发，两个线程获取同一个<code>SqlSession</code>，那么就有可能导致执行器中绑定的<code>statementId</code>不一致，导致得到一级缓存的返回类型值不一样，从而报错。并且<code>SqlSession</code>获取对应的<code>JDBCConnection</code>连接同时得到事务，如果两个线程获取同一个线程，那么就表示两个线程拥有同一个事务，所以<code>SqlSession</code>不是线程安全了，在<code>Spring</code>中通过很多的手段去保证并发情况下<code>SqlSession</code>的线程安全。</p>
<p>​    所以一级缓存是与会话相关，如果会话被关闭，那么一级缓存就失效。</p>
<p><img src="https://s2.loli.net/2022/11/23/B5TGkf1XstumUOF.png" alt="一级缓存执行流程.png"></p>
<p>​    由<code>mybatis</code>生成对应的<code>mapper</code>的动态代理，在执行对应的<code>SQL</code>方法时，开启一个<code>SqlSession</code>会话，通过会话和相关信息开启一个执行器，在执行器中先调用<code>BaseExecutor#query()</code>，具体的一级缓存逻辑就是在<code>query()</code>方法中，如果一级缓存中获取不到，调用执行器实现子类的<code>doQuery()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">        UserMapper mapper = context.getBean(UserMapper.class);</span><br><span class="line">        User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看一段结合<code>Spring</code>之后的缓存问题，测试结果为<code>false</code>，说明一级缓存没有生效，这是由于<code>Spring</code>在每次执行具体的调用时都自动进行了事务的提交，也就是说每执行一次<code>selectById</code>就会开启一次会话。所以很多人会说在<code>Spring</code>集成了<code>mybatis</code>之后，<code>mybatis</code>的一级缓存失效了。</p>
<p>​    那么如果就是想在<code>Spring</code>中使用<code>mybatis</code>的一级缓存。可以通过手动开启事务的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpringTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    DataSourceTransactionManager transactionManager = (DataSourceTransactionManager)context.getBean(<span class="string">&quot;txManager&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动开启事务</span></span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line"></span><br><span class="line">    User user = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    User user1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user == user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Spring</code>中对<code>Mapper</code>做了一些动态代理的处理，通过<code>getBean()</code>获取到的<code>UserMapper</code>对象实际上已经是被<code>Spring</code>动态代理过的对象，</p>
<p><img src="https://s2.loli.net/2022/11/23/jzn7olaNiGMetWy.png" alt="spring结合mybatis会话.png"></p>
<ul>
<li><code>Mapper</code>：是被<code>spring</code>修改过的动态代理对象，做一些<code>statementID</code>相关预处理等操作。</li>
<li><code>SqlSessionTemplate</code>：它实现了<code>SqlSession</code>接口，并将数据库的相关操作，比如<code>query</code>、<code>update</code>、<code>insert</code>转发给具体的<code>sqlSession</code>。而它的能力为拦截之后获取对应的<code>sqlSession</code>会话对象。</li>
<li><code>SqlSessionFactory</code>：去创建对应的事务、执行器，然后返回<code>DefaultSqlSession</code>对象。</li>
</ul>
<p>那么现在来看一些<code>spring</code>使得<code>mybatis</code>一级缓存没有生效的具体源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略一些代码..</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个SqlSessionHolder，这个是存储在ThreadLocal对象中</span></span><br><span class="line"><span class="comment">// 也就是说它是跟线程绑定，与事务和线程绑定的原理对应上  </span></span><br><span class="line">SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里获取对应的session</span></span><br><span class="line">SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出在<code>sessionHolder</code>处如果获取到对应的<code>session</code>则直接返回，如果获取不到则创建一个新的<code>session</code>,所以这里实际上事务决定了会话，如果事务被提交，则事务被删除，也就导致<code> session</code>会话被删除，如果一个事务一直不提交，那么在这个事务内的所有数据库操作就会触发一级缓存的相关逻辑。  </p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>​    二级缓存也称作是应用级缓存，与一级缓存不同的是它的作用范围是整个应用，而且可以跨线程调用。所以二级缓存有更高的命中率，适合缓存一些修改较少的数据。由于二级缓存的作用范围是整个应用，所以需要为二级缓存考虑溢出淘汰的机制，而一级缓存的生命周期是一个会话，所以并没有特别为一级缓存考虑淘汰机制。</p>
<p>​    <img src="https://s2.loli.net/2022/11/24/w7NDM1HQ8ceiSYC.png" alt="二级缓存功能.png"></p>
<ul>
<li>过期清理：清理一些存放时间过久的数据，设置一个有效期，对超过有效期的缓存进行清理。</li>
<li>线程安全：二级缓存是跨线程使用的，所以需要考虑到线程安全的问题。</li>
<li>命中率统计：根据命中率统计来给用户提供反馈，告诉用户某次查询是否命中了缓存。</li>
</ul>
<p><img src="https://s2.loli.net/2022/11/24/ynvgEjMatCF6hHx.png" alt="二级缓存设计结构.png"></p>
<p>通过装饰者模式结合责任链的方式来实现二级缓存。每一种类型的缓存都是单一职责，当做完自己本身需要做的事情之后，就将需要缓存的相关参数等信息传递给责任链的下一个位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      这是缓存的顶层接口，非常简单，它通过接口屏蔽了复杂的底层调用，在使用的过程中，只需要通过这个接口<code>Cache</code>进行相关缓存的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cache cache = configuration.getCache(<span class="string">&quot;cn.com.xiaocainiaoya.mapper.UserMapper&quot;</span>);</span><br><span class="line">    User user = Mock.newUser();</span><br><span class="line">    cache.putObject(<span class="string">&quot;cacheTest&quot;</span>, user);<span class="comment">// 设置缓存</span></span><br><span class="line">    cache.getObject(<span class="string">&quot;cacheTest&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/24/96SgDRdh4eLoFVQ.png" alt="二级缓存.png"></p>
<p>1.<code>chcheEnabled</code>：全局缓存开关，只要这个参数配置了<code>false</code>，整个二级缓存就关闭。</p>
<p>2.<code>useCache</code>：表示当前的<code>statement</code>要不要使用缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(useCache = false)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<code>flushCache</code>：在查询时，将整个二级缓存清空。注意是整个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Options(flushCache = Options.FlushCachePolicy.TRUE)</span></span><br><span class="line">    <span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// selectByid2在没有配置flushCache的情况下，也是命中不了缓存的。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询1</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    UserMapper mapper1 = session1.getMapper(UserMapper.class);</span><br><span class="line">    mapper1.selectByid2(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// flush cache清空</span></span><br><span class="line">    User user = mapper1.selectByid(<span class="number">10</span>); <span class="comment">//清空了，提交</span></span><br><span class="line">    </span><br><span class="line">    session1.commit();</span><br><span class="line">    <span class="comment">// 查询2</span></span><br><span class="line">    SqlSession session2 = factory.openSession();</span><br><span class="line">    UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="line">    User use2 = mapper2.selectByid2(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.<code>&lt;cache/&gt;</code>或<code>@CacheNamespace</code>是标记在<code>xml</code>文件或者对应的<code>mapper</code>文件，默认都是使用全限定类名作为缓存的命名空间，如果两个文件同时标记时会报错。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">	&lt;cache/&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>5.在第四点中说到，对应的<code>mapper</code>文件和<code>xml</code>不能同时标记，那么如果就是想共用，那么就需要使用到缓存空间引用。<code>&lt;cache-ref/&gt;</code>或<code>CacheNamespaceRef</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.coderead.mybatis.UserMapper&quot;</span>&gt;</span><br><span class="line">	&lt;cache-ref namespace=<span class="string">&quot;cn.com.xiaocainiao.UserMapper&quot;</span> /&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>由于二级缓存是跨线程使用，所以需要在事务提交之后的数据库操作，才能命中缓存。</p>
<p><img src="https://s2.loli.net/2022/11/24/23OhkEWzlsTXw6j.png" alt="二级缓存脏读.png"></p>
<p>每一个会话都有一个事务缓存管理器，暂存区的个数取决于访问了多少个<code>mapper</code>。下方的缓存空间就是对应的<code>mapper</code>的缓存命名空间。会话一旦关闭，它所对应的事务缓存管理器就会被清理，从而导致暂存区数据被清理。在数据的操作过程，都是先操作暂存区，只有在事务提交或者事务回滚之后才会将暂存区数据提交到对应的缓存空间。</p>
<p>![image-20221127115857163](/Users/jiangjiamin/Library/Application Support/typora-user-images/image-20221127115857163.png)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以通过这个简单的代码，debug下暂存区的结构</span></span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">    session1.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二级缓存的执行流程：</p>
<p><img src="https://s2.loli.net/2022/11/24/I4Ysoi9WlELVMK8.png" alt="二级缓存执行流程.png"></p>
<p>根据上图可知：查询是直接查询缓存空间，其他操作是对暂存区数据进行操作，当进行<code>commit</code>操作时将暂存区的操作数据添加到缓存空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionalCache#commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出需要填充到二级缓存空间的数据，遍历进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis控制部分字段不打印</title>
    <url>/2022/11/13/mybatis/mybatis%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h1 id="mybatis控制部分字段不打印"><a href="#mybatis控制部分字段不打印" class="headerlink" title="mybatis控制部分字段不打印"></a>mybatis控制部分字段不打印</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近遇到生产环境的运维反馈，每天的生成的日志信息占用较大的磁盘空间，希望研发能减少部分无效日志信息，把日志文件拉回来看了一下，主要是在<code>MySQL</code>的一些执行打印了<code>text</code>等大字段的数据，当这些表频繁进行插入、修改动作时，导致一直打印这些大字段数据，从而导致占用较大的磁盘空间，但是我们又不能直接关闭<code>mybatis</code>的执行打印日志，在生产环境出现异常时，我们还是需要根据这写执行日志来定位问题，所以最后想是否能将打印的控制逻辑细化到字段上，也就是说对于类型为<code>text</code>等类型的大字段不输出，简单使用一个占位符替代，从而达到既不影响异常问题的定位，也减少了一些无用日志信息。</p>
<span id="more"></span>    



<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​    具体的<code>mybatis</code>的几个核心组件执行流程这里不过多介绍，这里仅简单说明一条<code>SQL</code>的执行，是要先经过参数解析器，将具体的参数和数据类型解析处理，而后通过执行器，通过<code>Statement</code>或者是<code>PrepareStatement</code>等进行执行之后，再由结果集处理器进行结果映射相关逻辑。</p>
<p>​    在跟踪了一下<code>mybatis</code>的执行代码之后发现，日志的打印逻辑是在执行器<code>Executor</code>中，而数据类型相关的处理是在参数解析器中，也就是说如果想做到部分字段不打印，就需要在执行器中修改打印的逻辑。</p>
<p>我这边测试的是通过<code>PreparedStatement</code>方式进行插入数据，处理打印的类是<code>PreparedStatementLogger</code>的<code>invoke</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 打印数据在这里</span></span><br><span class="line">        debug(<span class="string">&quot;Parameters: &quot;</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ... 省略很多无效代码</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用父类<code>BaseJdbcLogger</code>的<code>getParameterValueString</code>方法获取要打印的数据。可以看到这里就是直接将<code>columnValues</code>列表中的值进行拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">  <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      typeList.add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      typeList.add(objectValueString(value) + <span class="string">&quot;(&quot;</span> + value.getClass().getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">  <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，由于这个地方并没有提供扩展点，所以如果我想要打印的时候忽略某些类型的字段，我需要重写这个类，再有我需要在这里能获取到对应的数据类型，尝试之后发现，这个对象中主要是有一个<code>Map</code>对象，键是序号（填充最后执行<code>SQL</code>的序号），值就是对应要填充<code>SQL</code>的值。所以单纯的重写这个类型，获取不到对应的类型，也就无法进行类型的判断，所以需要外层这个类的地方，将执行<code>SQL</code>的类型信息传进来。</p>
<p><b>类型相关信息是解析到了<code>BoundSql</code>对象中。所以需要想方设法的将<code>BoundSql</code>对象传进来</b>，这个<code>PreparedStatementLogger</code>的创建和被调用并不是在同一个时间节点，也就是说将类型相关参数传进来有两种手段，一种是在<code>PreparedStatementLogger</code>创建的时候，跟着原本构造函数相关的参数带进来，另一种是在<code>invoke</code>方法在调用之前传进来。当然了根据尝试，否定了第一种方式，原因是创建这个对象的地方也没有类型相关信息。</p>
<p>后来发现在<code>PreparedStatementLogger#invoke</code>方法被调用之前是可以获取到<code>BoundSql</code>对象，调用的地方是<code>PreparedStatementHandler</code>的<code>update</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里是动态代理，通过这里进入到PreparedStatementLogger#invoke中</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只需要在这里做文章，将<code>BoundSql</code>对象传到<code>PreparedStatementLogger</code>中基本上就可以达到目的。</p>
<h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p>1.将<code>PreparedStatementLogger</code>拷贝到应用的类路径下，并创建同名类路径<code>org.apache.ibatis.logging.jdbc.PreparedStatementLogger</code>类，然后添加一个属性字段<code>BoundSql</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> BoundSql boundSql;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// ... 省略很多代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.同样，将<code>PreparedStatementHandler</code>拷贝到应用类路径下，并创建同名类路径<code>org.apache.ibatis.executor.statement.PreparedStatementHandler</code>，并在执行前设置<code>boundSql</code>的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 这里获取到的是PreparedStatementLogger的动态代理对象，所以需要获取到被代理对象target</span></span><br><span class="line">  <span class="comment">// 然后判断被代理对象是否为PreparedStatementLogger，是的话就赋值boundSql</span></span><br><span class="line">  <span class="keyword">if</span> (Proxy.isProxyClass(statement.getClass())) &#123;</span><br><span class="line">    MetaObject metaObject = SystemMetaObject.forObject(statement);</span><br><span class="line">    Object target = metaObject.getValue(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(target <span class="keyword">instanceof</span> PreparedStatementLogger)&#123;</span><br><span class="line">      PreparedStatementLogger preparedStatementLogger = (PreparedStatementLogger) target;</span><br><span class="line">      preparedStatementLogger.boundSql = boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">int</span> rows = ps.getUpdateCount();</span><br><span class="line">  Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">  KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();</span><br><span class="line">  keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);</span><br><span class="line">  <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.最后在需要忽略日志打印的实体字段上标记能识别到<code>jdbcType</code>的注解，我这里用的是<code>tk.mybatis</code>，所以标记注解是<code>tk.mybatis.mapper.annotation.ColumnType</code>。如果用的是<code>mybatis-plus</code>应该是<code>com.baomidou.mybatisplus.annotation.TableField</code>注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;GROUP_ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;PROJECT_ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="meta">@ColumnType(jdbcType = JdbcType.BLOB)</span></span><br><span class="line">    <span class="keyword">private</span> String extraInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的打印逻辑我这里就不去写了，附一张到这里的断点图，到这里已经能获取到字段的类型和字段的值。</p>
<p><img src="https://s2.loli.net/2022/11/14/Kp4nfxJ5MHWEekQ.png" alt="mybaits控制字段打印.png"></p>
<h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>​    这里通过自己定义了与<code>mybatis</code>中相关的包路径和同名类来达到替换第三方<code>jar</code>包中的同名对象。原理实际上就是<code>jdk</code>的类加载机制，采用的是双亲委派模型，如果一个类加载器收到了需要加载类的请求，它不会马上进行解析，而是把这个请求委派给父类去加载，每一个层级的类加载器都是入参，当最上层加载器无法解析之后，它才会一层一层往下委派。</p>
<p>​    比如<code>java.lang.Object</code>存放在<code>rt.jar</code>中，如果编写另一个<code>java.lang.Object</code>并放到<code>ClassPath</code>中，编译上是没有问题的，但是由于双亲委派模型，当获取<code>java.lang.Object</code>时会委派到最上级的启动类加载器，而类路径<code>ClassPath</code>是应用程序类加载器。</p>
<p>​    但是对于上面重写的两个类，使用到的都是应用程序类加载器，但是如果在在应用<code>ClassPath</code>下创建同名路径，那么编译之后，代码是在<code>classes</code>文件夹中，而第三方包是在<code>lib</code>文件夹中，这里加载类进行查找对应<code>.class</code>文件时也有一个优先级的关系，会优先获取<code>classes</code>中的<code>.class</code>文件。</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>坑</tag>
        <tag>问题和方案</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis的MetaObject反射工具类</title>
    <url>/2022/12/05/mybatis/mybatis%E7%9A%84MetaObject%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="mybatis的MetaObject反射工具类"><a href="#mybatis的MetaObject反射工具类" class="headerlink" title="mybatis的MetaObject反射工具类"></a>mybatis的MetaObject反射工具类</h1><p>​    <code>MetaObject</code>是<code>mybatis</code>中用于处理反射相关的工具类，通过<code>MetaObject</code>就可以进行获取和设置对象值。</p>
<span id="more"></span>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><b>简单类型：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Blog对象</span></span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">  	<span class="comment">// 使用默认配置创建一个MetaObject对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">  	<span class="comment">// 直接为Blog的id属性赋值</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>复杂类型：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    <span class="comment">// 为Bolg中的对象赋值，如果对象为空，会通过该对象的构造函数创建一个空对象</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;author.name&quot;</span>, <span class="string">&quot;tommy&quot;</span>);</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合类型：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMetaObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object blog = <span class="keyword">new</span> Blog();</span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(blog);</span><br><span class="line">    List&lt;Comment&gt; commentList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 尽管设置了数组长度为5，以下调用还是报错，原因是set(index, value)方法中有判断</span></span><br><span class="line">    <span class="comment">// 若 index &gt;= size 则报越界，而size只有add(value)方法会进行叠加</span></span><br><span class="line">    <span class="comment">//commentList.set(0,new Comment());</span></span><br><span class="line">    commentList.add(<span class="keyword">new</span> Comment());</span><br><span class="line">    <span class="comment">// 1.如果是Object对象，为空时会通过构造函数进行创建，但是集合不能自动创建</span></span><br><span class="line">    <span class="comment">// 2.setValue的底层是调用集合的List.set(index, value)方法，不是List.add方法，所以要注意数组越界</span></span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments&quot;</span>, commentList);</span><br><span class="line">    metaObject.setValue(<span class="string">&quot;comments[0]&quot;</span>, <span class="keyword">new</span> Comment());</span><br><span class="line">    System.out.println(metaObject.getValue(<span class="string">&quot;comments[0].user.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要由<code>MetaObject</code>、<code>ObjectWrapper</code>、<code>MetaClass</code>、<code>Reflector</code>构成。</p>
<p><img src="https://s2.loli.net/2022/12/05/MQDxLNbn4OgvKRw.png" alt="MetaObject.png"></p>
<h3 id="1-MetaObject"><a href="#1-MetaObject" class="headerlink" title="1.MetaObject"></a>1.MetaObject</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line">    <span class="comment">// 包装对象，根据不同对象的不同类型进行包装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同对象的不同对象进行包装</span></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完<code>MetaObject</code>之后，从<code>MetaObject</code>调用的<code>setValue</code>、<code>getValue</code>等属性操作方法实际上都委派给了<code>ObjectWrapper</code>进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="comment">// 如果存在下一层表达式，则创建下一层MetaObject</span></span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">        MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 通过创建的下一层的MetaObject对象，再次调用getValue，进入递归</span></span><br><span class="line">        	<span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在下一层表达式，通过wrapper对象进行反射获取值</span></span><br><span class="line">        <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-ObjectWrapper"><a href="#2-ObjectWrapper" class="headerlink" title="2.ObjectWrapper"></a>2.ObjectWrapper</h3><p><code>ObjectWrapper</code>是顶层接口，定义了<code>wrapper</code>包装原始对象的处理接口，如果原始对象是<code>Bean</code>对象那么具体的获取属性等操作在<code>BeanWrapper</code>，如果原始对象是<code>Map</code>则通过<code>MapWrapper</code>进行实现具体的属性操作，同理<code>List</code>则通过<code>CollectionWrapper</code>进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line">    </span><br><span class="line">    String[] getGetterNames();</span><br><span class="line">    </span><br><span class="line">    String[] getSetterNames();</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getSetterType(String name);</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; getGetterType(String name);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanWrapper</code>和<code>MapWrapper</code>是继承于抽象类<code>BaseWrapper</code>，由抽象类继承顶层接口<code>ObjectWrapper</code>。<code>CollectionWrapper</code>是直接继承于顶层接口。这是因为如果原始对象是集合，它仅有<code>add</code>和<code>addAll</code>操作，其他接口均抛异常。</p>
<p><b>在BeanWrapper中解析表达式为词法分析器后进行属性操作</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以set方法为例，通过PropertyTokenizer词法分析器，对比如“comment[0].user.id”进行解析</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object collection = resolveCollection(prop, object);</span><br><span class="line">    setCollectionValue(prop, collection, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setBeanProperty(prop, object, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取到对象的set方法</span></span><br><span class="line">        Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">        Object[] params = &#123;value&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射赋值</span></span><br><span class="line">        	method.invoke(object, params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>PropertyTokenizer：词法分析器</b>，实现迭代器接口，通过<code>next()</code>方法解析下一层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里以 comments[0].user.id为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前层的名字: comments</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 若是集合则为comments[0]，否则indexedName和name值一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">    <span class="comment">// 表示下标: 若不是集合或者Map，则为空</span></span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="comment">// 表示子表达式: user.id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-MetaClass"><a href="#3-MetaClass" class="headerlink" title="3.MetaClass"></a>3.MetaClass</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reflector reflector;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MetaClass</span><span class="params">(Class&lt;?&gt; type, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">      <span class="comment">// 通过这个反射工厂来创建一个反射器</span></span><br><span class="line">      <span class="keyword">this</span>.reflector = reflectorFactory.findForClass(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReflectorFactory</code>这个反射工厂的主要作用是对<code>Reflector</code>反射器进行缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultReflectorFactory</span> <span class="keyword">implements</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> classCacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">        <span class="comment">// 如果缓存中存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Reflector"><a href="#4-Reflector" class="headerlink" title="4.Reflector"></a>4.Reflector</h3><p>根据创建的<code>Class</code>对象，解析出这个类的所有<code>get</code>、<code>set</code>方法，构造函数，所有属性字段等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">      type = clazz;</span><br><span class="line">      addDefaultConstructor(clazz);</span><br><span class="line">      addGetMethods(clazz);</span><br><span class="line">      addSetMethods(clazz);</span><br><span class="line">      addFields(clazz);</span><br><span class="line">      readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">      writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">      <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">        caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis处理器</title>
    <url>/2022/11/22/mybatis/mybatis%E7%9A%84%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="mybatis处理器"><a href="#mybatis处理器" class="headerlink" title="mybatis处理器"></a>mybatis处理器</h1><span id="more"></span>



<h2 id="一、statementHandler"><a href="#一、statementHandler" class="headerlink" title="一、statementHandler"></a>一、statementHandler</h2><p>​    <code>JDBC</code>处理器，基于<code>JDBC</code>构建<code>Statement</code>并设置参数，然后去执行具体的<code>SQL</code>语句，每调用会话当中一次<code>SQL</code>，都会有与之相对应且唯一的<code>Statement</code>实例。</p>
<p><img src="https://s2.loli.net/2022/11/28/OsSeqNWphfcyRGt.png" alt="statementHandler.png"></p>
<p><code>StatementHandler</code>为顶层接口，为<code>Statement</code>处理器相关实现设置标准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  <span class="function">Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 设置参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 批处理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">batch</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 写操作</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 读操作</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读游标</span></span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(Statement statement)</span><span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 辅助接口：获取动态语句</span></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 辅助接口：获取参数解析器</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">getParameterHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BaseStatementHandler</code>抽取了具体子类的公共部分，比如有设置超时时间、设置获取行数等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseStatementHandler#prepare</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// BaseStatementHandler的抽象方法，由具体的子类来实现</span></span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      <span class="comment">// 根据子类返回的statement对象，来进行超时时间、获取行数的设置</span></span><br><span class="line">      setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 抽象方法，由具体的子类实现</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>

<p>本篇中没有特殊说明都是以<code>PreparedStatementHandler</code>为例。具体的子类需要实现这个方法，使用<code>Conection</code>对象生成对应的<code>statement</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PreparedStatementHandler#instantiateStatement</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">      <span class="comment">// 基于jdbc的connection#prepareStatement方法来创建PreparedStatement</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>StatementHandler执行流程：</strong></p>
<p><img src="https://s2.loli.net/2022/11/28/rmSGMb6WdnNoyu4.png" alt="statementHandler执行过程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleExecutor#doQuery</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 1.通过Configuration对象创建StatementHandler对象</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 2.预处理</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 3.最后执行，对于PreparedStatement来说就是调用它的execute()方法。</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.通过<code>Configuration</code>对象创建<code>StatementHandler</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过RoutingStatementHandler导航类来根据需要不同类型的statement进行创建</span></span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoutingStatementHandler#new()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.预处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的预处理接口来创建一个Statement对象</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 这里会调用参数解析器DefaultPrepareterHander来对statement对象的参数值(会经过类型转换等操作)</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.最后执行，对于<code>PreparedStatement</code>来说就是调用它的<code>execute()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// PreparedStatement的execute()方法。</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 执行完语句之后，使用结果集处理器对结果进行javabean的映射</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>BaseStatementHandler</code>将具体的<code>StatementHandler</code>中编写了具体子类的共性部分，实际上是由它来进行具体的<code>JDBC</code>抽象，创建它需要执行器、参数解析器、结果集处理器、动态语句等的参与。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BoundSql boundSql;</span><br></pre></td></tr></table></figure>

<h2 id="二、ParamenterHandler"><a href="#二、ParamenterHandler" class="headerlink" title="二、ParamenterHandler"></a>二、ParamenterHandler</h2><p>参数名称解析器<code>ParamNameResolver</code>。</p>
<p><b>单个参数：</b>默认不做任何处理，除非设置了<code>@Param</code></p>
<p><b>多个参数：</b></p>
<ol>
<li>根据参数声明的顺序将参数转换为<code>param1</code>、<code>param2</code>…</li>
<li>通过<code>@Param</code>指定变量名称</li>
<li>基于反射转换成变量名，如果不支持则根据声明的顺序转换成<code>arg0</code>、<code>arg1</code>…</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个参数情况下：</span></span><br><span class="line"><span class="comment"> *    args的值直接为这个参数的值 &#123;0, &quot;arg0&quot;&#125;</span></span><br><span class="line"><span class="comment"> * 多参数情况下：</span></span><br><span class="line"><span class="comment"> *    如果在mapper中对字段标记了<span class="doctag">@Param</span>注解并设置了对应的字段名称，则names的值为 &#123;&#123;0, &quot;field1&quot;&#125;, &#123;1, &quot;field2&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    如果没有标记<span class="doctag">@Param</span>注解，则names的值为&#123;&#123;0, &quot;arg0&quot;&#125;, &#123;1, &quot;arg1&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment"> *    所以这里仅仅是将字段名称和具体的参数值进行对应成param，实际的解析参数名的参数，在上层调用端。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// names 是一个SortMap</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果没有@Param注解，并且参数个数为1，直接返回原值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 直接将args参数中的值添加到param中</span></span><br><span class="line">        param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认还会为参数根据声明的顺序设置param1， param2 ...</span></span><br><span class="line">        <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 不存在同名的情况下，可能有人字段名直接命名成paramX。</span></span><br><span class="line">        <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">            param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所以如果不出现同名的情况，假设mapper接口设置了两个参数，那么这里返回有两份参数，</span></span><br><span class="line">        <span class="comment">// 一份要么是根据@Param解析规则，或者反射参数(启动参数) -parameters ,或者默认的arg0, arg1</span></span><br><span class="line">        <span class="comment">// 一份是param1， param2...</span></span><br><span class="line">        <span class="comment">// 要注意arg是从0下标开始，param是从1下标开始</span></span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以根据返回<code>param</code>不同的类型，使用的方式也有所不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是单个参数，那么这里的#&#123;userId&#125;,写什么都行，#&#123;param1&#125;, #&#123;arg0&#125;都可，实际上</span></span><br><span class="line"><span class="comment">// 根据就不校验名称，直接复制了</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where id=#&#123;userId&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByid</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的#&#123;name&#125;也可以写成#&#123;param1&#125;， 但是注意不能写#&#123;arg0&#125;， 因为#&#123;arg0&#125;已经变成@param</span></span><br><span class="line"><span class="comment">// 注解中的名称</span></span><br><span class="line"><span class="meta">@Select(&#123;&quot;select * from users where name=#&#123;name&#125; or age=#&#123;user.age&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function">User <span class="title">selectByNameOrAge</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;user&quot;)</span> User user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>结合前文提到的<code>StatementHandler</code>执行流程时序图中，在<b>预处理</b>阶段，会<font color="red">为PrearedStatement设置参数</font>，来具体看一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以SimpleExecutor为例, 在调用doUpdate或者是doQuery方法创建StatementHandler之后，都会进行设置参数。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 创建statement</span></span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    <span class="comment">// 为statement设置参数</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreparedStatementHandler#parameterize</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 进入参数解析器，为statement设置参数</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就进入到了<code>ParameterHandler</code>的<code>setParameters</code>中，为创建的<code>preparedStatement</code>设置具体的参数。先来看一下<code>ParameterHandler</code>的接口，<code>ParameterHandler</code>是<code>mybatis</code>中的参数处理器，负责为<code>PreparedStatement</code>的<code>SQL</code>语句参数动态赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 读取参数</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 用于对PreparedStatement的参数赋值</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只有一个实现类<code>DefaultParameterHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个parameterObject就是前面说到通过ParameterNameSolver解析之后的对象</span></span><br><span class="line"><span class="comment">// 如果是单个参数，就是具体的值</span></span><br><span class="line"><span class="comment">// 如果是多个参数就是一个map对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getParameterObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> parameterObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  <span class="comment">// parameterMappings是对具体执行语句的映射，将将要执行的语句映射成ParamterMapping对象，</span></span><br><span class="line">  <span class="comment">// 将具体需要填充的参数#&#123;&#125;解析出来，形成参数列表</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数化sql就需要进行参数设置，遍历这个参数列表，将参数设置到PreparedStatement中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="comment">// ParameterMode.OUT 存储过程的参数模式</span></span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        <span class="comment">// 声明value，最后就是将这个值设置到PreparedStatement中</span></span><br><span class="line">        Object value; </span><br><span class="line">        <span class="comment">// 获取执行语句声明的#&#123;&#125;中的参数变量名称</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; </span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 多个参数会走到这里，将map对象，转换成MetaObject对象，就可以直接通过字段名称来获取具体的值  </span></span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从parameterMapping获取TypeHandler类型转换器对象</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        <span class="comment">// 从TypeHandler类型转换器中获取对应的数据库类型</span></span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TypeHandler.setParameter实际上最后会调用到PreParedStatement.set*()方法，为要执行的语句绑定参数值</span></span><br><span class="line">          <span class="comment">// 比如说TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setBigDecimal(i, parameter);</span></span><br><span class="line">          <span class="comment">// TypeHandler是BigDecimalTypeHandler 则调用的就是ps.setByte(i, parameter);</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>debugger</code>了解一下<code>ParameterMapping</code>中的内容： 主要是将<code>mybatis</code>在<code>SQL</code>或者是在实体上设置的一些配置进行映射，包含有字段名称、<code>javaType</code>数据类型、<code>jdbcType</code>数据库类型，<code>typeHandler</code>类型处理器等。</p>
<p><img src="https://s2.loli.net/2022/12/05/VkmnT5IjZgsGvP9.png" alt="parameterMapping.png"></p>
<h2 id="三、ResultHandler"><a href="#三、ResultHandler" class="headerlink" title="三、ResultHandler"></a>三、ResultHandler</h2>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>tk.mybaits动态表名</title>
    <url>/2022/07/27/mybatis/tk.mybaits%E5%8A%A8%E6%80%81%E8%A1%A8%E5%90%8D/</url>
    <content><![CDATA[<h1 id="tk-mybaits动态表名"><a href="#tk-mybaits动态表名" class="headerlink" title="tk.mybaits动态表名"></a>tk.mybaits动态表名</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    由于目前项目中多采用模块化的方式进行组件的整合，在新服务的搭建时为了尽可能保证新服务指向的数据库中的表名统一于服务名，比如新服务是订单模块，希望这个模块指向的数据库中的表名都是以<code>ORDER_</code>开头。且一些二次开发的组件中也有使用<code>mysql</code>进行数据的相关处理，故希望可以通过统一处理的方式进行表名动态化。 <span id="more"></span>    </p>
<h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><p>​    <code>tk.mybatis</code>的大致处理逻辑：</p>
<p><img src="https://s2.loli.net/2022/07/27/XcaJ5jdZ2omVnP1.png" alt="tk相关处理过程.png"></p>
<ol>
<li>扫描器会将所有被<code>@Mapper</code>标记的类通过<code>SpringBean</code>的创建对象流程中，然后创建相应的对象后，添加到<code>SpringBean</code>容器中。</li>
<li>将这个标记的类对象包装为<code>MapperFactoryBean</code>对象</li>
<li>待到创建<code>bean</code>流程的最后，也就是经过了初始化、后置处理器列表等扩展点的相关处理之后，通过包装对象<code>MapperFactoryBean#afterPropertiesSet()</code>进行<code>tk.mybatis</code>对象的二次处理。</li>
<li>通过这个后置方法，解析出这个<code>@Mapper</code>对象所对应的表实体的表名和其他一些在创建<code>SQL</code>所需要的配置信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在这个map中 实体类 =&gt; 表对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, EntityTable&gt; entityTableMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EntityTable&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>根据这个标记对象所继承的上层接口，逐个解析出对应的<code>SQL</code>语句。以下方代码为例，这里的上层接口<code>CommonMapper</code>继承于<code>Mapper</code>，而<code>Mapper</code>又继承于很多的上层接口，其中就有<code>selectOne</code>接口，那么在这一步就会根据第四步骤中解析出来的表信息和字段信息等，构建一个基于变量的<code>SQL</code>语句，如果业务层调用该方法时，仅将相关参数填充后就形成一条完整的<code>SQL</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxxMapper</span> <span class="keyword">extends</span> <span class="title">CommonMapper</span>&lt;<span class="title">XxxAttachment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">ExampleMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">RowBoundsMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">Marker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectOneMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = &quot;dynamicSQL&quot;)</span></span><br><span class="line">    <span class="function">T <span class="title">selectOne</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>​    根据以上的步骤，可以得出一个结论，如果想要动态（这个动态是指创建时动态，并不是指运行时动态）的修改表名，那么需要在第四步之后，第五步之前将<code>entityTableMap</code>中对应的表名修改为想要的表名。</p>
<p>​    根据<code>Springbean</code>创建对象的逻辑，在初始化后置方法之前，会经过后置处理器列表，所以可以通过模拟一个后置处理器列表，提前对<code>entityTableMap</code>相关信息进行解析并缓存。</p>
<p><code>MapperFactoryBean</code> 进行处理的主要逻辑：</p>
<ol>
<li><p>根据<code>XxxMapper</code>类获取到对应的表实体</p>
</li>
<li><p>通过<code>EntityHelper.initEntityNameMap()</code>方法解析出这个表实体的相关信息，并缓存。</p>
</li>
<li><p>将<code>XxxMapper.selectExample() </code>等等内置的通用接口解析为动态SQL语句，缓存在某个地方(这个我没有去找在哪里)</p>
</li>
</ol>
<p>综上：只要能在 第3步之前将<code>EntityHelper</code>中的这个缓存中的<code>EntityTable</code>的表名称修改为相应的值，就能实现将表名动态化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TablePrefixBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * tk.mybatis 在 MapperFactoryBean 进行相关的逻辑处理，所以通过BeanPostProcessor，在执行MapperFactoryBean.afterPropertiesSet()方法之前，</span></span><br><span class="line"><span class="comment">    * 进行一次预处理，将表相关信息通过EntityHelper.initEntityNameMap()方法提前添加到对应的entityTableMap&lt;Class, EntityTable&gt;缓存之后，</span></span><br><span class="line"><span class="comment">    * 然后马上将这个实体所对应的EntityTable的表名进行需要的业务处理。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> xiaocainiaoya</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2022/7/27 16:04:01</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>: java.lang.Object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean.getClass() != <span class="keyword">null</span> &amp;&amp; bean.getClass().toString().contains(<span class="string">&quot;tk.mybatis.spring.mapper.MapperFactoryBean&quot;</span>))&#123;</span><br><span class="line">            Class&lt;?&gt; mapperClass = ((MapperFactoryBean)bean).getMapperInterface();</span><br><span class="line">            Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) types[<span class="number">0</span>];</span><br><span class="line">            Class&lt;?&gt; returnType = (Class&lt;?&gt;)  parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取mapperHelper</span></span><br><span class="line">            MapperHelper mapperHelper = (MapperHelper) ReflectUtil.getFieldValue(bean, <span class="string">&quot;mapperHelper&quot;</span>);</span><br><span class="line">            <span class="comment">// 提前解析这个bean所对应的表实体的相关信息</span></span><br><span class="line">            EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否需要修改表名</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                EntityTable entityTable = EntityHelper.getEntityTable(returnType);</span><br><span class="line">                entityTable.setName(<span class="string">&quot;prefix&quot;</span> + entityTable.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码中的最后的判断语句可以根据相应的规则，比如说自定义一个注解，并且在注解中指定一个前缀的参数，标记在实体上，这里可以通过获取这个注解进行是否需要添加前缀的逻辑处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    实际上以上这种场景应该在真是情况中少之又少，一般情况下并不会说想要统一某个服务中的所有表名前缀，但是在解决的问题的过程中，其实对<code>springBean</code>创建实体的流程，以及<code>tk.mybatis</code>对实体解析的相关逻辑都大致的过了一遍，加强了框架中一些细节处理的印象，对于后续如果出现一些<code>bug</code>可以尽快的定位到问题。</p>
<p>​    实际上我并不是一下子就想到这么做，在想到这么做之前，我也经过了其他的尝试，比方说我最先想到的是通过写<code>mybatis</code>插件的方式，拦截出<code>BoundSql</code>具体的<code>SQL</code>语句，通过修改这个<code>SQL</code>语句达到目的，但是发现不同类型的<code>SQL</code>判断方式略有不同，操作难度大，所以一直往上层追溯，发现<code>BoundSql</code>中的语句是在<code>Bean</code>初始化过程就已经生成，后面才一点一点整理出上述步骤流程，从而找到下手的地方。</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>问题和方案</tag>
      </tags>
  </entry>
  <entry>
    <title>tk.mybaits和mybatisPlus兼容性</title>
    <url>/2022/07/21/mybatis/tk.mybaits%E5%92%8CmybatisPlus%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="tk-mybaits和mybatisPlus兼容性"><a href="#tk-mybaits和mybatisPlus兼容性" class="headerlink" title="tk.mybaits和mybatisPlus兼容性"></a>tk.mybaits和mybatisPlus兼容性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    项目早期建设时底层采用了<code>tk.mybatis</code>方式来对数据访问层进行数据处理，而后再更新<code>Springboot</code>的同时因为一些不知原因（只能说我级别不够，不知领导的深意，但确实<code>tk.mybatis</code>官网已经没有维护了）又在底层引入了<code>mybatisPlus</code>，所以新代码采用<code>mybatisPlus</code>编写，旧模块任然使用<code>tk.mybatis</code>编写。<span id="more"></span>    </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    今天同事在移植项目中的一个功能模块时，报了一个错<code>No qualifying bean of type &#39;com.xxxx&#39;..</code>。乍一看猜测大概是因为对应的<code>xxxMapper</code>接口文件没有被扫描到<code>Spring</code>容器中，导致<code>tk.mybatis</code>的表集合中没有该实体。排查发现，启动类中并没有显示使用<code>@MapperScan</code>指定扫描路径，果然，使用的是启动类及以下的包结构，由于是搬迁的功能模块，不想调整原来包结构，故使用<code>@MapperScan</code>来指定扫描路径。</p>
<p>​    在启动类上通过<code>@MapperScan</code>指定了扫描路径之后可以正常启动，但是在调用接口发现又报错了<strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>，如果对<code>tk.mybatis</code>比较熟悉就知道，这里是因为<code>tk.mybatis</code>会将所有的表信息都缓存到一个集合中，仔细检查了指定的路径，也没有发现问题。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    经过一段时间的排查，终于找到了原因，在这里记录下，避免以后又遇到同样的问题，以下仅为个人观点，可能存在理解错误，请带着批判的视角阅读。</p>
<p>​    原来是在<code>tk.mybatis</code>中也有一个同名的<code>tk.mybatis.spring.annotation.MapperScan</code>，若使用<code>org.mybatis.spring.annotation.MapperScan</code>是不会对扫描到的对象进行一些<code>tk.mybatis</code>相关的处理，所以直接将注解更换为前者，再次启动，又报出了新的错误：</p>
<p>定位进去发现就是<code>tk.mybatis</code>处理对应接口缓存的时候报了类型转换异常：</p>
<blockquote>
<p>Caused by: java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getEntityClass(MappedStatement ms) &#123;</span><br><span class="line">    String msId = ms.getId();</span><br><span class="line">    <span class="keyword">if</span> (entityClassMap.containsKey(msId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> entityClassMap.get(msId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class&lt;?&gt; mapperClass = getMapperClass(msId);</span><br><span class="line">        Type[] types = mapperClass.getGenericInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType t = (ParameterizedType) type;</span><br><span class="line">                <span class="keyword">if</span> (t.getRawType() == <span class="keyword">this</span>.mapperClass || <span class="keyword">this</span>.mapperClass.isAssignableFrom((Class&lt;?&gt;) t.getRawType())) &#123;</span><br><span class="line">                    <span class="comment">// 报错报在这里</span></span><br><span class="line">                    Class&lt;?&gt; returnType = (Class&lt;?&gt;) t.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取该类型后，第一次对该类型进行初始化</span></span><br><span class="line">                    EntityHelper.initEntityNameMap(returnType, mapperHelper.getConfig());</span><br><span class="line">                    entityClassMap.put(msId, returnType);</span><br><span class="line">                    <span class="keyword">return</span> returnType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MapperException(<span class="string">&quot;无法获取 &quot;</span> + msId + <span class="string">&quot; 方法的泛型信息!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里直接下结论：</strong>报这个错的原因是因为指定扫描的路径范围太大了，导致扫描到了底层中的二次封装类<code>public interface CommonMapper&lt;T&gt; extends Mapper&lt;T&gt;</code>，结合以上代码不难发现，是取出了<code>T</code>泛型进行强转之后报错，所以只需要将扫描路径的范围缩小即可。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>​    在最后发现问题之后，解决起来就很轻松了，但是在排查的过程中，就非常的痛苦。因为报错的这个地方并没有显式的指明是某个类强转失败，而项目中又存在<code>mybatisPlus</code>和<code>tk.mybatis</code>共存的情况，乍一看代码以为是兼容性的问题，因为对于这两种方式来说，数据访问层接口采用的是不同的继承接口。</p>
<p>一个是<code>tk.mybatis.mapper.common.Mapper</code><T>，一个是<code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code>，所以一看到这个类型转换异常，就误以为是因为需要通过<code>tk.mybatis</code>来解析的<code>xxxMapper</code>被<code>mybatisPlus</code>接管导致。</p>
<p>​    在排查跟踪源码的过程中，对<code>tk.mybatis</code>和<code>mybatisPlus</code>相关的一些处理有了进一步的了解，在此做了记录。</p>
<p><code>tk.mybatis</code>通过<code>tk.mybatis.spring.mapper.ClassPathMapperScanner</code>扫描器将对应的表实体收集到一个集合中，注意<code>mybatis</code>也有自己的扫描器<code>org.mybatis.spring.mapper.ClassPathMapperScanner</code>，也就是说在项目启动过程中，实际上是经过了两次的扫描，并且<code>tk.mybatis</code>的扫描器在<code>mybatis</code>的扫描器之前，至于是怎么插到<code>mybatis</code>之前的，猜测是通过<code>spring</code>的某个后置接口，这个与本篇主题无关，不进一步详解。</p>
<p>​    其实<code>tk.mybatis</code>的扫描器主要是将指定路径(默认是启动类所在包及子包)中被<code>@Mapper</code>标记的类，解析成<code>BeanDefinition</code>，添加到<code>Spring</code>对应集合中，用于后续将其实例化为具体的<code>bean</code>对象到容器中。这些的主要逻辑在这两个扫描器的父类<code>ClassPathBeanDefinitionScanner#doScan</code>。经过<code>tk.mybatis</code>扫描器处理后的表实体，同样也会在<code>mybatis</code>扫描器被作为候选对象<code>candidate</code>被扫描到。但它会从<code>Spring</code>中查询一次，查看是否存在该<code>BeanDefinition</code>，若存在则打印<code>Skipping MapperFactoryBean with name &#39;xxxMapper&#39; and &#39;com.xx.xxx....mapper.XxxMapper&#39; mapperInterface. Bean already defined with the same name!</code>，大概意思就是这个类已经存在<code>BeanDefinition</code>，当前处理跳过该类的处理，也就是说在指定路径下的实体表只会被这两个扫描器中的其中一个扫描并进行相关处理。</p>
<p>​    <code>tk.mybatis</code>扫描器中在创建<code>BeanDefinition</code>时，将它的<code>resolvedTargetType</code>和<code>beanClass</code>字段都标记为了<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>，而<code>mybatis</code>扫描器扫描器中这两个字段标记的是<code>org.mybatis.spring.mapper.MapperFactoryBean</code>，这就导致在真正实例化<code>Spring bean</code>对象时调用了不同的后置接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 篇幅原因省略部分代码</span></span><br><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#invokeInitMethods</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最后会调用初始化的后置接口</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着跟踪下进入到不同的后置接口的调用方式，继承关系如下代码所示，从上面的代码中的最后调用<code>bean</code>对象的<code>afterPropertiesSet</code>方法，到下面代码中是由于二者的上层接口中<code>DaoSupport</code>实现了<code>InitializingBean</code>方法。且这个后置初始化方法中仅调用了<code>checkDaoConfig</code>和<code>initDao</code>方法，均由具体的子类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tk.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoSupport</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, BeanInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">// Let abstract subclasses check their configuration.</span></span><br><span class="line">        checkDaoConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let concrete implementations initialize themselves.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initDao();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Initialization of DAO failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tk.mybatis.spring.mapper.MapperFactoryBean</code>具体的实现：核心的处理在这里，刚刚上文说到，<code>tk.mybatis</code>会将指定路径下的所有<code>@Mapper</code>类的<code>BeanDefinition</code>中的<code>resolvedTargetType</code>和<code>beanClass</code>都标记为<code>tk.MapperFactoryBean</code>，那么也就是说指定路径下的所有<code>@Mapper</code>都会被识别为是<code>tk.mybatis</code>的<code>mapper</code>？其实不是，这里有一个判断<code>mapperHelper.isExtendCommonMapper()</code>，这个判断的主要逻辑是获取这个<code>XxxMapper</code>接口及所有上层父类接口是否有<code>tk.mybatis.mapper.annotation.RegisterMapper</code>注解，如果没有，则不采用<code>tk.mybatis</code>的方式进行解析。到这，应该就可以解答前面提出的问题，所以如果需要用<code>mybatisPlus</code>，那么它的<code>XxxMapper</code>接口的所有上传父类接口必然不会存在<code>tk.RegisterMapper</code>注解，也就不会进行<code>tk.mybatis</code>相关的处理(<code>tk.mybatis</code>这里的处理是将表实体和<code>xxxMapper</code>接口的一些方法等信息缓存起来)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasMapper(<span class="keyword">this</span>.mapperInterface) &amp;&amp; mapperHelper != <span class="keyword">null</span> &amp;&amp; mapperHelper.isExtendCommonMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">        mapperHelper.processConfiguration(getSqlSession().getConfiguration(), <span class="keyword">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>No qualifying bean of type &#39;com.xxxx&#39;..</code>的实际原因是移植的功能模块类路径不落在默认扫描路径范围内（启动类所在的包及子包）</li>
<li><strong>无法获取实体类<code>com.xx.xxx...xxx</code>对应的表名</strong>是因为通过<code>org.mybatis.spring.annotation.MapperScan</code>指定了<code>mybatis</code>的扫描路径，但没有指定<code>tk.MapperScan</code>，导致<code>tk</code>的扫描器使用默认值(默认值为启动类所在的包及子包)，恰好移植的功能模块不属于启动类的包及子包中，所以移植功能中的所有<code>xxxMapper</code>都被解析为了<code>mybatis</code>类型(也就是前面说的<code>beanDefinition</code>中的那两个属性被赋值为了<code>mybatis</code>对应的类)，最后导致在初始化<code>bean</code>对象时，没有进入到<code>tk.mybaits</code>对应类的后置处理器，也就没有将这些表实体相关信息缓存，从而导致以上报错。</li>
<li>类型转换异常的报错，是因为指定<code>tk.MapperScan</code>设置扫描范围太大，导致扫描到了底层二次封装的抽象父类，导致在获取接口层参数获取到了泛型参数<code>T</code>，泛型参数以<code>T</code>进行类型转换为<code>Class</code>从而导致了报错。</li>
<li>在都不指定<code>@MapperScan</code>的情况下，二者扫描器的默认扫描路径都是启动类所在的包以及子包，当指定了<code>tk.@MapperScan</code>之后那么<code>tk.mybatis</code>的扫描路径变成了这个具体的指定路径，<code>mybatis</code>的扫描路径还是默认的启动类所在的包极其子包，也就是说两个扫描器的扫描路径是互不影响的、各自维护，这个很重要，如果不明白这个，在排查的过程中，会影响对问题的判断。</li>
<li>引入<code>tk.mybatis</code>一定会经过两次扫描器，一次是<code>tk.mybatis</code>的扫描器，一次是<code>mybatis</code>原生的扫描器，如果某个<code>mapper</code>对象被<code>tk.mybatis</code>扫描生成了<code>BeanDefinition</code>，<code>mybatis</code>的扫描器会跳过该类，同样的，某个<code>xxxMapper</code>若想使用<code>mybatisPlus</code>的方式进行数据访问层的处理，虽然它在扫描阶段被认为是以<code>tk.mybatis</code>的方式解析，但是在具体创建<code>spring bean</code>对象的时候，<code>kt.mybatis</code>的后置接口中有相应的逻辑判断(所有上层接口是否有标记<code>RegisterMapper</code>)，来控制是否进行相应处理。</li>
</ol>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>坑</tag>
        <tag>问题和方案</tag>
      </tags>
  </entry>
  <entry>
    <title>德鲁伊简单使用</title>
    <url>/2023/05/11/mybatis/%E5%BE%B7%E9%B2%81%E4%BC%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="德鲁伊简单使用"><a href="#德鲁伊简单使用" class="headerlink" title="德鲁伊简单使用"></a>德鲁伊简单使用</h1><p>​    在翻阅项目底层代码时发现，在底层的<code>framework</code>模块中有引入<code>druid</code>监控端，但是好像在开发环境、测试环境甚至生产环境中并没有看到有具体的使用，所以想启用一下<code>druid</code>的监控模块。并没有什么实质性内容的介绍，仅仅是踩的一些坑的记录。</p>
<span id="more"></span>

<p><b>注：我使用的版本是<code>1.1.22</code>，如果不是这版本请绕道，避免引起不适，不同版本中修改了部分配置的前缀！！</b></p>
<h2 id="启用德鲁伊管理页"><a href="#启用德鲁伊管理页" class="headerlink" title="启用德鲁伊管理页"></a>启用德鲁伊管理页</h2><p>1.根据配置项加载这个管理页<code>bean</code>。前缀为<code>my.druid.monitor.enable</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建德鲁伊数据源</span></span><br><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="title">druidServlet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-password:admin&#125;&quot;)</span> String password,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.login-username:admin&#125;&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.reset-enable:true&#125;&quot;)</span> String reset,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.url-pattern:/druid/*&#125;&quot;)</span> String urlPattern,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.allow:&#125;&quot;)</span> String allow,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Value(&quot;$&#123;spring.datasource.druid.stat-view-servlet.deny:&#125;&quot;)</span> String deny</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    ServletRegistrationBean&lt;StatViewServlet&gt; reg = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">    reg.setServlet(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">    reg.addUrlMappings(urlPattern);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, reset);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, userName);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, password);</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;allow&quot;</span>,deny );</span><br><span class="line">    reg.addInitParameter(<span class="string">&quot;deny&quot;</span>,allow);</span><br><span class="line">    <span class="keyword">return</span> reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>yaml</code>或者<code>properties</code>配置文件中添加相关配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 忽略默认自动注入druid,避免走默认druid配置</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure</span></span><br><span class="line">  <span class="comment">#数据库连接池配置</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">reset-enable:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">        <span class="attr">allow:</span></span><br><span class="line">        <span class="attr">deny:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局druid参数，单独数据源配置为空取全局配置</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 声明默认的主数据源</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">druid:</span></span><br><span class="line">        <span class="comment"># 连接池的配置信息</span></span><br><span class="line">        <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">        <span class="attr">initial-size:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">        <span class="comment"># 配置一个连接在池中最小生存的时间，单位是毫秒</span></span><br><span class="line">        <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line">        <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">        <span class="attr">validation-query:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">        <span class="comment"># 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span></span><br><span class="line">        <span class="attr">connection-properties:</span> <span class="string">druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000</span></span><br></pre></td></tr></table></figure>

<p>到此在本地启动项目，访问<code>http://127.0.0.1:8064/xxxx/druid/login.html</code>进入管理页，登录之后，虽然进入了管理页，但是其实只是一个空壳，执行对应的<code>SQL</code>发现，并不会在监控页面上显示出来，后经过查询资料发现，这里的<code>filter</code>为空。</p>
<p><img src="https://s2.loli.net/2023/05/12/YQLoPJjbdrHqm3W.png" alt="druid中filter为空.png"></p>
<p>在配置文件中明明在<code>spring.datasource.druid.filters</code>设置了<code>stat,wall</code>等过滤器，但是实际上没有读到，排查发现，在<code>1.1.22</code>上，并不是这个配置，修改了配置前缀为<code>spring.datasource.druid.filter.stat.enabled</code></p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(FILTER_STAT_PREFIX)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = FILTER_STAT_PREFIX, name = &quot;enabled&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatFilter <span class="title">statFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 主要是为了创建这个filter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置后，在启动项目，在管理页上就显示出了执行的<code>SQL</code>语句。</p>
<h2 id="开发环境启用"><a href="#开发环境启用" class="headerlink" title="开发环境启用"></a>开发环境启用</h2><p>​    本以为到这里基本上已经万事大吉了，开发环境只需要复刻本地环境的配置即可。但是操作之后发现，在开发环境上访问<code>login.html</code>之后原本应该跳转到<code>druid/index.html</code>，但是<code>404</code>，看样子是<code>nginx</code>拦截处理了。</p>
<p>​    在<code>nginx</code>中，对于<code>/index.html</code>的路径直接转发到本地的某个文件夹中，所以修改<code>nginx.conf</code>相关配置信息，是的对<code>/druid/index.html</code>不进行这个拦截处理。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ (?!.*druid/index.html$).*/index.html</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span>  Cache-Control  <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>   /opt/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启<code>nginx</code>之后，发现还是有问题，观察发送的请求，在<code>login.html</code>提交表单之后，发起了一个<code>submitLogin</code>请求，如果用户名密码校验正确，会直接跳转到<code>druid/index.html</code>，但是这个<code>druid/index.html</code>的请求居然进行了<code>302</code>跳转，又跳回<code>druid/login.html</code>页面。通过和本地的工程发起的请求对比发现，在<code>submitLogin</code>登录之后会返回一个<code>JSESSIONID</code>的<code>cookies</code>，发起<code>druid/index.html</code>请求需要携带这个<code>cookies</code>值，但是在开发环境中不知道是<code>nginx</code>还是哪里给弄丢了，由于时间紧迫我没有细看在那个环节丢调了这个<code>cookies</code>值，我手动将这个<code>cookies</code>值打入浏览器的<code>cookies</code>中，正常访问。</p>
<h2 id="关闭广告"><a href="#关闭广告" class="headerlink" title="关闭广告"></a>关闭广告</h2><p>​    在开源项目若依中看到，感觉挺好玩的，便记录一下，用过<code>druid</code>管理页都知道，在面板的最下方有一个阿里的横幅广告，这个广告是请求服务器的<code>common.js</code>中会添加到页脚，请求公网的<code>banner</code>连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildFooter : function() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;&lt;a href=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner_click&quot; target=&quot;new&quot;&gt;&lt;img src=&quot;https://render.alipay.com/p/s/taobaonpm_click/druid_banner&quot;&gt;&lt;/a&gt;&lt;br/&gt;&#x27;</span> +</span><br><span class="line">              <span class="string">&#x27; powered by &lt;a href=&quot;https://github.com/alibaba/&quot; target=&quot;_blank&quot;&gt;Alibaba&lt;/a&gt; &amp; sandzhang &amp; &lt;a href=&quot;http://melin.iteye.com/&quot; target=&quot;_blank&quot;&gt;melin&lt;/a&gt; &amp; &lt;a href=&quot;https://github.com/shrekwang&quot; target=&quot;_blank&quot;&gt;shrek.wang&lt;/a&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">              <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br><span class="line">    $(document.body).append(html);</span><br></pre></td></tr></table></figure>

<p>​    所以思路上，通过对获取<code>common.js</code>进行拦截，并将这段页脚的<code>html</code>代码重写，即可达到关闭广告的目的。</p>
<p>1.设置一个过滤器，对<code>js/common.js</code>的请求进行拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DruidAdRemoveFilter 过滤器，过滤 common.js 的广告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;my.druid.monitor&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; <span class="title">druidAdRemoveFilterFilter</span><span class="params">(DruidStatProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 druid web 监控页面的参数</span></span><br><span class="line">        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();</span><br><span class="line">        <span class="comment">// 提取 common.js 的配置路径</span></span><br><span class="line">        String pattern = config.getUrlPattern() != <span class="keyword">null</span> ? config.getUrlPattern() : <span class="string">&quot;/druid/*&quot;</span>;</span><br><span class="line">        String commonJsPattern = pattern.replaceAll(<span class="string">&quot;\\*&quot;</span>, <span class="string">&quot;js/common.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 DruidAdRemoveFilter Bean</span></span><br><span class="line">        FilterRegistrationBean&lt;DruidAdRemoveFilter&gt; registrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> DruidAdRemoveFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.拦截过滤器中替换这段<code>html</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidAdRemoveFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * common.js 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_JS_ILE_PATH = <span class="string">&quot;support/http/resources/js/common.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        <span class="comment">// 重置缓冲区，响应头不会被重置</span></span><br><span class="line">        response.resetBuffer();</span><br><span class="line">        <span class="comment">// 获取 common.js</span></span><br><span class="line">        String text = Utils.readFromResource(COMMON_JS_ILE_PATH);</span><br><span class="line">        <span class="comment">// 正则替换 banner, 除去底部的广告信息</span></span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;&lt;a.*?banner\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        text = text.replaceAll(<span class="string">&quot;powered.*?shrek.wang&lt;/a&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        response.getWriter().write(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>替换之后的<code>html</code>变量值为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html =<span class="string">&#x27;&lt;footer class=&quot;footer&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;div class=&quot;container&quot;&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;&#x27;</span> +</span><br><span class="line">                      <span class="string">&#x27; &#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27;         &lt;/div&gt;&#x27;</span>+</span><br><span class="line">                      <span class="string">&#x27; &lt;/footer&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ消息投递确认</title>
    <url>/2023/08/16/mq/RabbitMQ%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E7%A1%AE%E8%AE%A4/</url>
    <content><![CDATA[<h1 id="RabbitMQ消息投递确认"><a href="#RabbitMQ消息投递确认" class="headerlink" title="RabbitMQ消息投递确认"></a>RabbitMQ消息投递确认</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    在项目中引入了<code>RabbitMQ</code>用于服务间一些解耦操作，在运行了一段时间之后，突然在某个环境中出现了一些异常情况。</p>
<span id="more"></span>    

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​    从投递者日志来看，确实投递者有将对应的数据投递出去；从消费者日志来看，一直未监听到对应的消息，并且从<code>RabbitMQ</code>后台来看，对应队列上是存在监听，并且通过<code>RabbitMQ</code>控制台通过<code>Publish message</code>发出的消息，在消费者服务的日志中可以看到对应的消费信息。</p>
<p>​    经过反复的查看，确定投递者服务投递的消息对应的交换机和路由器应该是没有问题的。排查到这里实际上我已经没有任何排查思路了，我猜测既然消费者的日志中并没有出现消费的相关日志，那么大概率问题应该是在投递端。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>​    在<code>RabbitMQ</code>中是有消息投递确认的回调处理，当投递失败时，可以通过回调接口在投递者服务中打印出对应的信息，这样至少排查问题时可以知道，是投递出现了问题。</p>
<p>这里先简单解释两个概念：</p>
<p>消息是由投递者投递到<b>交换机</b>，再由交换机根据指定路由键投递到对应的<b>队列</b>。</p>
<ul>
<li><p><code>publisher-confirm</code>：发送者确认，消息成功投递到交换机返回<code>ack</code>，消息未投递到交换机返回<code>nack</code>。<b>注意，这里的维度是交换机，也就是交换机接收了，就认为你投递成功。</b></p>
</li>
<li><p><code>publisher-return</code>：发送者回执，消息发送队列失败会回调这个方法。<b>注意，这里的维度是队列，就是交换机有没有将消息投递到具体的队列上，若投递不到具体的队列，则回调这个方法。</b></p>
</li>
</ul>
<p>1.在<code>spring</code>配置项中开启投递确认</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># simple 同步等待confirm结果，直到超时</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated </span></span><br><span class="line"><span class="comment"># 开始publish-return功能，同样基于callback机制，不过是定义ReturnCallback</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 定义消息路由失败时的策略，true则调用ReturnCallback; false则丢弃</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.mandatory</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>2.设置投递确认和投递回执监听</p>
<p>我这里为了快捷测试，就通过<code>@PostConstruct</code>设置对应的回调信息，实际项目中，应通过<code>@Configuration</code>或者<code>@Bean</code>抽取到对应的配置类中，因为<code>setReturnsCallback</code>等方法对应每一个<code>rabbitTemplate</code>实例只能设置一次，第二次赋值，将会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> RabbitTemplate.ReturnsCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由key&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">                    returnedMessage.getReplyCode(), returnedMessage.getReplyText(), returnedMessage.getExchange(),</span><br><span class="line">                    returnedMessage.getRoutingKey(), returnedMessage.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息投递异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/testMq&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;测试发送消息&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestResponse&lt;Boolean&gt; <span class="title">testMq</span><span class="params">(<span class="meta">@RequestParam(&quot;exchange&quot;)</span> String exchange, <span class="meta">@RequestParam(&quot;route&quot;)</span> String route)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchange, route, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.&lt;Boolean&gt;builder().data(<span class="keyword">null</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>测试结论：</b></p>
<p>1.若投递一个不存在的交换机，<code>setConfirmCallback()</code>中返回<code>false</code>。<b>不会进入<code>returnCallback</code>监听方法。</b>这里还是要老生常谈一下，一定要注意，若交换机投递失败，<code>returnCallback</code>是不会接受到监听回调。</p>
<p>2.若投递一个存在的交换机且存在的路由键，<code>setConfirmCallback()</code>中返回<code>true</code>，<b>不会进入<code>returnCallback</code>监听方法。</b>因为只有投递队列失败才会进入到这个方法中。</p>
<p>3.若投递一个存在的交换机且不存在的路由键，<code>setConfirmCallback()</code>中返回<code>true</code>，<b>会进入<code>returnCallback</code>监听方法。</b></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45讲学习总结（一）---初试</title>
    <url>/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89---%E5%88%9D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="mysql45讲学习总结（一）—初试"><a href="#mysql45讲学习总结（一）—初试" class="headerlink" title="mysql45讲学习总结（一）—初试"></a>mysql45讲学习总结（一）—初试</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    感觉自身对于<code>MYSQL</code>的知识点是零散的，没有形成网络，只用到了基本的增删改查功能，偶尔遇到一点性能的问题，还需要通过搜索引擎来查到解决方案，并且查找到的解决方案参差不齐，导致往往问题虽然解决，但是还是不知其所以然，从而重复出现问题时，也不能较快的解决问题。据说<code>MYSQL</code>45讲对<code>MYSQL</code>介绍比较细致，所以希望通过学习<code>MYSQL</code>45讲让自己的<code>MYSQL</code>形成知识网络。<span id="more"></span></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>​    下方为<code>MYSQL</code>的基本架构示意图，一个执行语句在不查询缓存的情况下，基本查询路径为：客户端&rarr;连接器 &rarr;分析器&rarr;优化器&rarr;执行器&rarr;存储引擎。对应过程：</p>
<ol>
<li>连接：连接管理模块，接收请求；连接进行和用户模块，验证通过；连接线程和客户端连接。</li>
<li>查询：（查询缓存）<ol>
<li>分析器：内建解析树，对其语法检查，<code>form</code>&rarr;<code>on</code>&rarr;<code>join</code>&rarr;<code>where</code>，检查权限，生成新的解析树，语义检查。</li>
<li>优化器：将解析树转换为执行计划，选择索引，并评估最优执行。</li>
<li>执行器：获取锁，打开表，通过<code>meta</code>数据，获取查询数据。</li>
</ol>
</li>
<li>返回结果：返回给连接进程，然后情况，等待新的请求。</li>
</ol>
<p><img src="https://s2.loli.net/2022/09/21/tsHEepgh6AIGyJZ.webp" alt="MySQL 的逻辑架构图.png"></p>
<p>总体来说<code>MYSQL</code>基本架构分为两个部分：</p>
<h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1.Server层"></a>1.Server层</h3><p><code>Server</code>层包含了很多执行组件，涵盖了<code>MYSQL</code>的大多数核心业务功能，以及所有的内置函数（聚合函数的处理），所有跨存储引擎的功能都是在这一层实现，比如存储过程、触发器、视图等。从图中可以看出所有存储引擎共用同一个<code>Server</code>层。</p>
<h4 id="1-1连接器"><a href="#1-1连接器" class="headerlink" title="1.1连接器"></a>1.1连接器</h4><p>当使用以下连接命令之后，连接器通过<code>TCP</code>与客户端建立连接、获取权限、维持和管理连接。</p>
<blockquote>
<p>mysql -h$ip -P$port -u$user -p</p>
</blockquote>
<p>通过以下命令可以查看每个连接的状态</p>
<blockquote>
<p>show processlist;</p>
</blockquote>
<table>
<thead>
<tr>
<th>Id</th>
<th>User</th>
<th>Host</th>
<th>db</th>
<th>Command</th>
<th>Time</th>
<th>State</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>root</td>
<td>172.17.0.1:40922</td>
<td>binlog_test</td>
<td>Query</td>
<td>0</td>
<td></td>
<td>show processlist</td>
</tr>
<tr>
<td>6</td>
<td>root</td>
<td>172.17.0.1:40926</td>
<td>binlog_test</td>
<td>Sleep</td>
<td>1237</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>Command</code>列中存在一个<code>Sleep</code>，表示有一个连接处于空闲状态。</p>
<h4 id="1-2分析器"><a href="#1-2分析器" class="headerlink" title="1.2分析器"></a>1.2分析器</h4><p>分析器的主要作用是对接收到的<code>SQL</code>语句进行解析。</p>
<p>首先进行”词法分析“：识别收到的<code>SQL</code>语句中代表的是什么、识别出列<code>ID</code>，查询条件等。</p>
<p>其次进行”语法分析“：进行语法规则的校验，判断输入<code>SQL</code>是否满足<code>MYSQL</code>语法，若语法错误则会抛出<code>You have an error in your SQL syntax</code>。</p>
<h4 id="1-3查询缓存"><a href="#1-3查询缓存" class="headerlink" title="1.3查询缓存"></a>1.3查询缓存</h4><p>​    接收到的<code>SQL</code>在进入到分析器之前，会先进入到查询缓存组件，判断之前是否执行过该语句，如果执行过直接返回结果，若没有执行过则进入分析器。但是大多数的情况下，由于缓存失效的非常频繁，只要对一个表存在更新操作，这个表所对应的所有缓存都失效，导致对缓存的命中率比较低。</p>
<blockquote>
<p>query_cache_type设置为DEMAND表示开启，NO表示关闭</p>
</blockquote>
<p>或者也可以通过<code>SQL</code>中关键字<code>SQL_CACHE</code>指定：</p>
<blockquote>
<p>select SQL_CACHE * from T where ID=10；</p>
</blockquote>
<p>同时在<code>MYSQL  8.0</code>版本中移除了缓存模块。</p>
<h4 id="1-4优化器"><a href="#1-4优化器" class="headerlink" title="1.4优化器"></a>1.4优化器</h4><p>​    优化器接收到了经过了分析器的<code>SQL</code>，优化器的主要作用是对<code>SQL</code>进行优化、多表连接顺序、多索引时选择使用哪个索引等。同一个<code>SQL</code>语句，不同的连接顺序、索引选择虽然查询结果一致，但是执行效率上存在差异。</p>
<p>​    优化器的作用便是在同样查询结果的情况下，对<code>SQL</code>语句进行优化，尽可能提升语句的查询效率，但是也有可能经过优化器处理之后，反而导致执行时长变长。</p>
<h4 id="1-5执行器"><a href="#1-5执行器" class="headerlink" title="1.5执行器"></a>1.5执行器</h4><p>​    优化器执行之后，<code>SQL</code>语句的执行方案就确定下来，然后进入执行器，在开始执行之前，需判断登录用户对操作表有没有执行查询的权限，若没有权限则报错：</p>
<blockquote>
<p>ERROR 1142 (42000): SELECT command denied to user ‘b’@’localhost’ for table ‘T’</p>
</blockquote>
<p>比如查询语句为：</p>
<blockquote>
<p>select * from T where ID=10;</p>
</blockquote>
<p>表 <code>T</code> 中，<code>ID</code> 字段没有索引，在执行器中的执行流程为：</p>
<ol>
<li>调用<code>InnoDB</code>引擎接口取这个表的第一行，判断<code>ID</code>值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>如果<code>ID</code>字段存在索引，只是在第1步骤中使用的调用存储引擎的接口不一致。</p>
<p>在慢查询日志中会有一个<code>rows_examined</code>的字段，表示这个语句在执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟<code>rows_examined</code>并不是完全相同的。</p>
<h3 id="2-存储引擎层"><a href="#2-存储引擎层" class="headerlink" title="2.存储引擎层"></a>2.存储引擎层</h3><p>存储引擎层负责数据的存储和提取。其架构模式是插件式，支持<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>。默认情况下使用<code>InnoDB</code>，也就是说通过<code>create Table</code>创建表时，若没有明确指定存储情况，默认就会使用<code>InnoDB</code>。</p>
<ul>
<li>InnoDB：事务型数据库的首选存储引擎，支持书屋安全表<code>ACID</code>，支持行锁和外键，<code>InnoDB</code>是<code>MYSQL</code>的默认存储引擎。</li>
<li>MyISAM：基于<code>ISAM</code>存储引擎，并对其进行扩展，它是在<code>Web</code>、数据仓储和其他应用环境下最常使用的存储引擎之一，拥有较高的插入和查询速度，但不支持事务。</li>
<li>Memory：内存数据库，将表中的数据存储到内存中。</li>
</ul>
<h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><p>​    更新语句和查询语句在执行器之前经过的<code>Server</code>层组件是一样的(唯一不同的是更新语句会移除所操作表的查询缓存)。与查询流程不一样的是，更新流程还涉及到两个重要的日志模块<code>redo log</code>(重做日志)，<code>binlog</code>(归档日志)。</p>
<h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><p>​    在<code>MYSQL</code>45讲中，使用《孔乙己》中酒店掌柜的例子，粉板和账本指代<code>redo log</code>和磁盘。当有一个更新操作时先将记录写入到<code>redo log</code>中，并不是执行写入磁盘(这么做的话<code>IO</code>成本、查找成本太高)。而是在适当的时机将<code>redo log</code>的内容写入到磁盘中。</p>
<p>​    通过<code>redo log</code>和磁盘结合的方式进行数据记录，这个整合的过程，就是<code>MYSQL</code>的<code>WAL(Write-Ahead Logging)</code>技术，它的关键点就是先写日志，再写磁盘。</p>
<h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><p>​    <code>redo log</code>是<code>InnoDB</code>引擎特有的日志，<code>bin log</code>是<code>Server</code>层日志。</p>
<p>这两种日志的不同点：</p>
<ul>
<li><code>redo log</code>是<code>InnoDB</code>引擎特有的；<code>bin log</code>是<code>Server</code>层实现，所有存储引擎都可以使用。</li>
<li><code>redo log</code>记录的是物理日志，记录的是”在某一个数据页上做了什么修改“，<code>bin log</code>是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c 字段加 1 “。</li>
<li><code>redo log</code>是循环写，空间是固定(粉板)，当写满之后会覆盖掉以前的日志；<code>bin log</code>是可以追加写，当文件写入到一定大小后会根据规则生成新的日志文件，不会覆盖旧日志。</li>
</ul>
<blockquote>
<p>create table T(ID int primary key, c int);</p>
<p>update T set c=c+1 where ID=2;</p>
</blockquote>
<p><strong>两阶段提交的简单流程</strong></p>
<ol>
<li>执行器先通过存储引擎接口获取到<code>ID=2</code>这一行记录，如果<code>ID=2</code>这行记录的数据页在内存中，则直接从内存中获取后返回给执行器。否则需要先将磁盘中这一页数据加载到内存中，再返回。</li>
<li>执行器得到这一行数据后，对<code>c</code>列执行<code>+1</code>操作，再调用存储引擎接口，将结果写入到这行新数据中。</li>
<li>存储引擎将这行数据更新到内存中，之后将这个更新操作写入到<code>redo log</code>中，并标记状态为<code>prepare</code>，然后告知执行器可以进行提交<code>commit</code>操作。</li>
<li>执行器生成这个操作的<code>bin log</code>，并将<code>bin log</code>刷盘。</li>
<li>执行器调用存储引擎的提交事务接口，存储引擎将刚刚的<code>redo log</code>由<code>perpare</code>修改为<code>commit</code>状态。</li>
</ol>
<p>先说这样做的好处：实际上引入<code>redo log</code>的作用是希望<code>MYSQL</code>具备<code>crash-safe</code>(指服务器宕机重启后，能够保证已提交的事务仍然存在)。</p>
<p>若服务器宕机出现在以上的某个流程中：</p>
<ul>
<li>在第3步骤写入<code>redo log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是不完整的，直接回滚事务。</li>
<li>在第4步骤写入<code>bin log</code>之后，由于<code>redo log</code>的状态为<code>prepare</code>，所以重启恢复是去判断<code>bin log</code>是不是完整，显然在这一步骤是完整的，直接提交事务。</li>
<li>在第5步骤修改<code>redo log</code>状态为<code>commit</code>状态，显然直接提交这个事务。</li>
</ul>
<p><strong>若不使用两阶段提交：</strong></p>
<p>假设两个前提：</p>
<ul>
<li>数据在一定周期内进行全量备份，可以是一天一备，也可以是一周一备。</li>
<li>开启<code>bin log</code>。</li>
</ul>
<p>在这种情况下数据恢复到某一时间点的操作为：</p>
<ol>
<li>找到最近一次的全量备份，将这个备份恢复到临时库中。</li>
<li>从备份的时间点开始，将备份时间点之后的的<code>bin log</code>依次取出，在临时库进行重放到需要恢复的这一时刻。</li>
<li>这时在临时库就有被误删的数据，简单处理可以手动将数据从临时表取出，按需恢复到线上库。</li>
</ol>
<p>由于存在两个日志文件，所以就需要保证两个日志文件在<code>MYSQL</code>发生异常时，数据能保持一致。</p>
<ol>
<li>**先写<code>binlog</code>后写<code>redo log</code>**：假设在<code>binlog</code>写完之后，<code>MYSQL</code>发生异常，由于<code>redo log</code>还没有写，导致<code>MYSQL</code>重启后<code>binlog</code>存在某一个操作，而<code>redo log</code>中没有这一操作，若从库使用<code>binlog</code>重放，则导致从库会有这一操作，从而导致主从数据不一致。</li>
<li>**先写<code>redo log</code>再写<code>binlog</code>**：假设在<code>redo log</code>写完之后，<code>MYSQL</code>发生异常，由于<code>binlog</code>还没写，导致重启之后，通过<code>redo log</code>进行数据恢复，所以主库中是存在这一操作，但是由于<code>binlog</code>中没有写入，所以导致使用<code>binlog</code>重放时，从库丢失一个操作。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    <code>redo log</code>的主要作用是利用”粉板”和”账本”的配合，提高<code>MYSQL</code>的吞吐性能，降低<code>IO</code>成本、查找成本。<code>bin log</code>是<code>Server</code>层日志，它存在于<code>redo log</code>之前，<code>redo log</code>是在<code>InnoDB</code>存储引擎诞生时，由<code>innoDB</code>引擎自身携带，其他存储引擎是没有的。还有<code>redo log</code>是对一个日志文件进行循环写，到一定数据量之后会覆盖旧值，不持久保存，<code>binlog</code>才具备”归档“的能力。</p>
<p>故障恢复是使用<code>redo log</code>日志进行恢复。主从同步是使用<code>binlog</code>进行数据同步。</p>
<ul>
<li><code>innodb_flush_log_at_trx_commit</code>：设置为1时表示，表示每次事务的<code>redo log</code>都直接持久化到磁盘。建议设置为1，保证<code>MySQL</code>异常重启之后数据不丢失。</li>
<li><code>sync_binlog</code>：设置成1的时候，表示每次事务的<code>binlog</code>都持久化到磁盘。建议设置成1，这样可以保证 <code>MySQL</code>异常重启之后<code>binlog</code>不丢失。</li>
</ul>
<p>​        </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45讲学习总结（三）---事务</title>
    <url>/2022/09/26/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89---%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="mysql45讲学习总结（三）—事务"><a href="#mysql45讲学习总结（三）—事务" class="headerlink" title="mysql45讲学习总结（三）—事务"></a>mysql45讲学习总结（三）—事务</h1><p>​    事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在<code>MySQL</code>中，事务支持是在引擎层实现的。<code>MySQL</code>是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如<code>MySQL</code>原生的<code>MyISAM</code>引擎就不支持事务，这也是<code>MyISAM</code>被<code>InnoDB</code>取代的重要原因之一。</p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p>
<p>当数据库上有多个事务同时执行的时候，就可能出现：</p>
<ul>
<li>脏读（dirty read）：无效数据的读出，假设事务T1将某一值修改，这是事务T2读取到这一新值，但是事务T1由于某种原因回滚了新值，这就导致事务T2所读到的新值是无效的。</li>
<li>不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，在这个数据还没有结束时，另一个事务也访问了同一数据，那么第一个事务在两次读取数据之间由于第二个事务的修改，导致前后读取到的数据不一样，因此称为不可重复读，即原始读取不可重复。</li>
<li>幻读（phantom read）：事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</li>
</ul>
<p>对应的<code>SQL</code>标准事务隔离级别包括：</p>
<ul>
<li>读未提交（read uncommitted）：一个事务还没有提交时，它做的变更可以被其他事务看到。</li>
<li>读提交（read committed）：一个事务提交之后，它做的变更才能被其他事务看到。</li>
<li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的；未提交的变更对其他事务也是不可见。</li>
<li>串行化（serializable ）：对同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写冲突时，后访问的事务需等待前访问事务释放锁，才可执行。</li>
</ul>
<p><b>例子</b></p>
<blockquote>
<p>create table T(c int) engine=InnoDB;</p>
<p>insert into T(c) values(1);</p>
</blockquote>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>启动事务查询得到值1</td>
<td>启动事务</td>
</tr>
<tr>
<td></td>
<td>查询得到值1</td>
</tr>
<tr>
<td></td>
<td>将1改成2</td>
</tr>
<tr>
<td>查询得到值V1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>提交事务B</td>
</tr>
<tr>
<td>查询得到值V2</td>
<td></td>
</tr>
<tr>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>查询得到值V3</td>
<td></td>
</tr>
</tbody></table>
<p>不同隔离级别下V1，V2，V3的返回值：</p>
<ul>
<li>读未提交：V1=V2=V3=2（V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2）</li>
<li>读提交：V1=1，V2=V3=2（V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2）</li>
<li>可重复读：V1=V2=1，V3=2（V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的）</li>
<li>序列化：V1=V2=1，V3=2（在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2）</li>
</ul>
<p>在实现上，<code>MYSQL</code>引入视图的概念，访问的时候以视图的逻辑结果为准。</p>
<ul>
<li>读未提交：可以直接看到未提交事务的变更，不存在视图。</li>
<li>读提交：在每个<code>SQL</code>语句开始执行的时候创建视图。</li>
<li>可重复读：在事务启动时创建，整个事务存在期间都使用这个视图。</li>
<li>序列化：直接使用锁来控制并行访问，不存在视图。</li>
</ul>
<p><b>不同的隔离级别，数据库的行为有所不同，<code>Oracle</code>数据库的默认隔离级别是”读提交“，<code>MySQL</code>默认的隔离级别是可重复读，如果是将<code>Oracle</code>迁移到<code>MySql</code>的引用，为保证数据库隔离级别一致，可以将<code>MySQL</code>的隔离级别设置为”度提交“</b></p>
<blockquote>
<p>show variables like ‘transaction_isolation’</p>
<p>将参数transaction-isolation 的值设置成 READ-COMMITTED</p>
</blockquote>
<p><b>使用”可重复读“的场景</b></p>
<p>​    假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。        </p>
<h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>​    在<code>MYSQL</code>中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值通过一个个回滚操作，可以回到之前的旧值。</p>
<p>假设一个值从1&rarr;2&rarr;3&rarr;4，最后新值为4，那么在回滚日志和视图如下：</p>
<p><img src="https://s2.loli.net/2022/09/26/tM79KoGIlz4OVhA.png" alt="事务隔离回滚.png"></p>
<p>最新值为4，但是不同时刻启动的事务会产生不同的视图，在在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。 对于视图A来说，要想等到值为1，只需要将最新值依次执行回滚动作。所以即使现在有新事务将4改成5，这个事务对视图A，B，C对应的事务不会存在冲突。当系统中没有比回滚日志更早的视图时，这些回滚日志就会被删除。</p>
<p>所以尽量不要使用长事务，长事务意味着系统里会存在很老的事务视图，导致在这个事务提交之前，这个事务可能用到的回滚记录都必须被保留，也就造成了占用了大量的存储空间。</p>
<h1 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h1><ol>
<li>显示启动事务语句，<code>begin</code>或者<code>start transaction</code>，结束事务使用<code>commit</code>，回滚使用<code>rollback</code>。</li>
<li><code>set autocommit=0</code>，关闭这个线程的自动提交，意味着只要执行一个<code>select</code>事务都会启动，并且不会自动提交，只有到显示<code>commit</code>或者<code>rollback</code>或者断开连接。</li>
</ol>
<p>查询持续时间超过60s的事务：</p>
<blockquote>
<p>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p>
</blockquote>
<h1 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h1><blockquote>
<p>CREATE TABLE <code>t</code> (</p>
<p>  <code>id</code> int(11) NOT NULL,</p>
<p>  <code>k</code> int(11) DEFAULT NULL,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE=InnoDB;</p>
<p>insert into t(id, k) values(1,1),(2,2);</p>
</blockquote>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>事务C</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set k=k+1 where id = 1;</td>
</tr>
<tr>
<td></td>
<td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td>
<td></td>
</tr>
<tr>
<td>select k from t where id =1;<br/>commit;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p><b>注意：</b><code>begin/start transaction</code>命令并不是一个事务的起点，在执行到他们之后的第一个操作<code>InnoDB</code>表的语句，事务才真正启动，若想马上启动则使用<code>start transaction with consistent snapshot</code>命令。</p>
<p>事务C没有显示的使用<code>begin/commit</code>，表示这个<code>update</code>语句本身是一个事务，语句在执行完成后会自动提交。</p>
<p>在上述三个事务中：事务A查到的k=1，事务B查到的k=3。</p>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>​    在可重复读隔离级别下，事务在启动的时候就对整个数据库“拍了个快照”。当然了，这个“快照”不是简单理解为拷贝数据，而是通过逻辑手段进行处理。</p>
<p>​    在<code>InnoDB</code>里面每个事务都有一个唯一的事务<code>ID(transaction id)</code>，在事务开始时向事务组件申请，是严格按照申请顺序递增。</p>
<p>​    每一行数据都是有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并把这个数据版本上的<code>row trx_id</code>标记为这个事务<code>ID</code>，同时旧数据版本，通过<code>undo log</code>来拿到具体旧数据版本。</p>
<p>综上：每一行数据，其实可能有多个版本<code>row</code>，每个版本有自己的<code>row_trx_id</code>。</p>
<p><img src="https://s2.loli.net/2022/09/27/mcCoSq971UtjWpR.png" alt="MVCC例子.png"></p>
<p>上图就是一个记录被多个事务更新后的状态，虚线框中是一行数据的4个版本，V4是最新的版本；图中的U1，U2，U3就是<code>undo log</code>，但需要获取到前置版本数据时，就是通过<code>undo log</code>计算出来，比如需要V2的时候，就是通过V4依次执行U3，U2计算得出。(上图中的数据版本所对应的事务都是提交状态，避免有人理解为还能对事务id=15的事务进行回滚。)</p>
<p>所以，某一个事务在启动的时候，会声明：“在我启动时刻为准，如果一个数据版本是在我启动之前生成，我可见；如果是在我启动之后才生成，我不可见，我必须找它之前的我可见的版本；如果是自身事务版本，我也是可见”。</p>
<p><code>InnoDB</code>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃中”(启动还未提交)的所有事务<code>ID</code>。当一个事务启动时，这个数组中的元素就是“活跃中”事务和自身事务(顺序排列)。当判断数据版本可见性时，就通过这个数组来进行判断，比如一个事务的数组为<code>[7,8, 10]</code>（自身事务id=9）：</p>
<ul>
<li>查询某个数据版本的<code>row trx_id=10</code>，这就表示这个数据版本是在当前事务之后生成，故向前获取版本。</li>
<li>查询某个数据版本的<code>row trx_id=6</code>，比数组中最小的还小，表示是在事务启动前生成的，可见。</li>
<li>查询某个数据版本的<code>row trx_id=7</code>，落在这个数组中，表示这个版本事务还未提交，不可见。</li>
<li>查询某个数据版本的<code>row trx_id=8</code>，比数组中最小的大，但是不落在这个数组中，表示这个版本事务已提交，可见。</li>
</ul>
<p>根据上述结论，分析之前事务A的查询情况：</p>
<ol>
<li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li>
<li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li>
<li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li>
</ol>
<p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p>
<p><img src="https://s2.loli.net/2022/09/27/iIohujG3qXvKedk.png" alt="MVCC事务A分析.png"></p>
<p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p>
<p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p>
<p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p>
<p>当事务 A 读事务时，由于它的视图数组是 [99,100]。读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p>
<ul>
<li>找到 (1,3) 的时候，判断出 row trx_id=101，比自身数组的最大值大，不可见</li>
<li>找到 (1,2) 的时候，判断出 row trx_id=102，比自身数组的最大值大，不可见</li>
<li>找到 (1,1) 的时候，它的 row trx_id=90，比自身数组的最小值小，可见</li>
</ul>
<p>综上：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<p><b>但是上述实际上只是查询数据时的逻辑，可以将上述分析结果代入事务B，会发现按这种规则代入，事务B中的k值应该为1，而不是2，问题出在事务B在查询之前执行了一次更新操作。</b></p>
<p>这是因为事务B要去更新数据时，就不能是历史版本上更新了，否则事务C的更新就丢失了，所以事务B此时的更新操作是在事务C的基础上操作的。</p>
<p><b>当前读：更新数据都是先读后写，这个读，只能读当前的值。</b></p>
<p>实际上除了<code>update</code>语句，<code>select</code>语句如果加锁，也是当前读。</p>
<blockquote>
<p>select k from t where id=1 lock in share mode;  // 读锁（S 锁，共享锁）</p>
<p>select k from t where id=1 for update; // 写锁（X 锁，排他锁）</p>
</blockquote>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>事务C</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>start transaction with consistent snapshot;<br>update t set k=k+1 where id = 1;</td>
</tr>
<tr>
<td></td>
<td>update t set k=k+1 where id = 1;<br/>select k from t where id =1;</td>
<td></td>
</tr>
<tr>
<td>select k from t where id =1;<br/>commit;</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td></td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>如果事务C并不是马上提交，而是在事务B执行更新动作之后提交，这时在事务C在执行更新操作时，是获取了这行数据的行锁，事务C在更新之后，事务B的更新操作需要去获取行锁，但是被事务C锁住，故事务B进入等待，直到事务C提交事务后，事务B获取到锁继续往下执行。</p>
<p>综上：可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45讲学习总结（二）---索引</title>
    <url>/2022/09/21/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89---%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="mysql45讲学习总结（二）—索引"><a href="#mysql45讲学习总结（二）—索引" class="headerlink" title="mysql45讲学习总结（二）—索引"></a>mysql45讲学习总结（二）—索引</h1><p>​    一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
<span id="more"></span>

<h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>​    索引实际上就像是字典的目录，当需要查询某个字时，通过目录可以快速定位到某一页，从而快速查找到所需要的数据，不必进行全局遍历，达到提高查询效率的目的，实现上一般都是通过设计某种的数据结构，简单介绍几个常用的数据结构。</p>
<ol>
<li>哈希表：一种以键值对存储数据的数据结构，类似于<code>Java</code>中的<code>HashMap</code>的实现（当然了<code>jdk8</code>之后是采用数组加红黑树的方式），数据结构为一个数组加链表（有的地方称拉链法），当添加某个值时计算出这个值的<code>HASH</code>值，然后插入到数组对应的链表尾部，这种数据结构对于添加和删除的效率是比较高的，只需要移动一个节点的引用。</li>
<li>有序数组（规则数组）：通过某种规则将数据存入到数组中，在查询时同样可以根据这种规则直接通过下标获取到数据，如果是有序数组，对于范围查询的效率也是比较高的。这种数据结构瓶颈在于扩容以及空间的使用率上，比如现在是有序数组，数组长度为10，假设现在仅有两个值1和50，那么50的这个值存放在哪个位置？如果将数组长度扩大50，空间利用率就极低。</li>
<li>二叉树：二叉树是课本中经典的数据结构了，同样在添加、删除节点时，需要进行平衡。</li>
</ol>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>​    <code>InnoDB</code>引擎中采用<code>B+</code>数索引模型，每一个索引都对应着一颗<code>B+</code>树。分为主键索引和非主键索引。</p>
<p>​    主键索引又称为聚簇索引，主键索引的叶子节点是整行数据。</p>
<p><img src="https://s2.loli.net/2022/07/29/Cdn3PoHR5vbi8Iy.png" alt="主键索引示意图.png"></p>
<p>​        非主键索引又称为二级索引，非主键索引的叶子节点的内容是主键的值。由下图可知，非主键索引的查询逻辑是通过非主键索引获取到要查询数据的主键，再通过主键索引获取到对应行数据，这个过程称为回表。</p>
<p><img src="https://s2.loli.net/2022/07/29/nI3Ay1ZM4bpQRs8.png" alt="非主键索引示意图.png"></p>
<h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><p>​    在<code>InnoDB</code>存储引擎中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表。<code>InnoDB</code>使用的索引模型为<code>B+</code>树形索引模型，所以数据都是存储在<code>B+</code>树中。</p>
<p>每一个索引在<code>InnoDB</code>里面都对应着一颗<code>B+</code>树。</p>
<p>假设有一个表，<code>ID</code>为主键，且还有字段<code>k,name</code>，同时<code>k</code>字段上有索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中有5条记录：(ID,K)&rarr; (100,1)、(200,2)、(300,3)、(500,5) 、 (600,6)</p>
<p>主键索引树和<code>k</code>字段索引树如下：(图中主键索引显示为[100, 200]在一页，[300, 500, 600]在一页)</p>
<p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p>
<p>由上图可知：</p>
<p>索引类型分为主键索引(聚簇索引)和非主键(二级索引)索引。</p>
<ul>
<li>主键索引的叶子节点存储的是一整行的记录。</li>
<li>非主键索引的叶子节点存储的是主键ID。</li>
</ul>
<p>某个查询语句使用主键索引和非主键索引的差别在于，非主键索引查询到树节点之后得到叶子节点上的主键<code>ID</code>之后，需要再通过主键索引树再查找一轮，得到主键<code>ID</code>对应的行数据，这个过程称为回表。</p>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>​    根据第一小节中的常见的索引模型可知，索引之所以查询速度高，实际上是依赖于索引模型，也就是说在插入数据时，就需要根据索引模型相应的规则进行数据的存储。所以虽然添加索引的查询效率高，但索引的数量并不是越多越好，过多的索引会增加插入数据带来的成本。</p>
<p>以上方索引树的图为例：</p>
<ul>
<li>如果插入的新行<code>ID</code>值为700，则只需要在R5的记录后面插入一条新记录。</li>
<li>如果插入的新行<code>ID</code>值为400，则需要将500和600往后挪，空出位置。如果R5所在的数据页满了，则需要申请一个新的数据页，然后将部分数据挪过去，这个过程称为页分裂。</li>
<li>如果相邻两页数据由于删除了数据，导致利用率比较低，那么就会出现合并页，这个过程是页分裂的逆过程。</li>
</ul>
<h1 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h1><p>还是这个表为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"># 同时插入6条记录</span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/09/22/5VS38hx476lnUrK.png" alt="ID和k索引树.png"></p>
<p>执行查询语句：</p>
<blockquote>
<p>select * from T where k between 3 and 5</p>
</blockquote>
<p>执行流程：</p>
<ol>
<li>到非主键索引<code>k</code>上搜索<code>k=3</code>的树节点，得到主键<code>ID=100</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R3</code>。</li>
<li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=5</code>这个树节点，得到主键<code>ID=500</code>。根据这个<code>ID</code>值，到主键索引树查询到对应行<code>R4</code>。</li>
<li>到非主键索引<code>k</code>上取<code>k=3</code>的下一个值，得到<code>k=6</code>这个树节点，不满足<code>where</code>条件，循环结束。</li>
</ol>
<p>在步骤1和步骤2都有回表的动作，这是因为需要查询的字段在非主键索引<code>k</code>上没有，那么有没有办法避免回表？</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果将执行语句修改为：</p>
<blockquote>
<p>select ID from T where k between 3 and 5</p>
</blockquote>
<p>由于这时需要查询的字段<code>ID</code>，就是非主键索引<code>k</code>的叶子节点上能获取到的数据，所以就不需要进行回表的操作，也就达到了减少一次回表查询的动作，从而提升查询效率。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>所以为了不进行回表，就需要在数节点上存储的数据做文章，就需要通过联合索引。这里的<code>name_age</code>就是联合索引。</p>
<p>假设一个市民信息表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>如果这时需要用市民的名称查询他的年龄：</p>
<blockquote>
<p>select age from tuser where name = “xxx”</p>
</blockquote>
<p>如果使用<code>name_age</code>索引，就不需要进行一次回表就可以查出想要的某个名称对应的年龄，当然了这里会出现多条记录的情况。</p>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>如果将这条查询语句换个查询条件，能否使用这个联合索引呢？</p>
<blockquote>
<p>select name from tuser where age = xx</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/09/22/uneZG4Os8JbfMRS.jpg" alt="联合索引.jpeg"></p>
<p>由上图可以看出，联合索引是根据联合索引定义时字段的先后顺序进行排序，也就是这里先根据<code>name</code>排序，再根据<code>age</code>排序。</p>
<ul>
<li>当需求为查询所有名字为”张三“的人，可以快速定位到ID4，然后逐个遍历节点与<code>where</code>条件进行比对。</li>
<li>当需求为查询所有名字第一个字为”张”，查询语句为<code>where name like &#39;张%&#39;</code>，也会命中这个索引，查询到第一个符合条件的节点为ID3，然后逐个遍历节点与<code>where</code>条件进行比对。</li>
<li>当需求为查询年龄为20的人，就无法使用这个索引。对这个索引来说，是先对<code>name</code>进行排序，在<code>name</code>一致的情况下，对<code>age</code>排序。</li>
</ul>
<p>综上：查询条件中不一定要全部定义，只要满足最左前缀，就可以利用这个索引来加速检索。这个最左前缀可以是联合索引的最左<code>N</code>个字段，也可以是字符串索引的最左<code>M</code>个字符。</p>
<p><b>在建立联合索引的时候，如何安排索引内的字段顺序。</b></p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<b>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</b></p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>如果查询语句的查询条件部分满足最左前缀原则呢？</p>
<p>以市民表的联合索引<code>(name, age)</code>为例</p>
<blockquote>
<p>select * from tuser where name like ‘张 %’ and age=10 and ismale=1;</p>
</blockquote>
<p>根据最左前缀的规则，这个语句在搜索树时，只能用到”张”，找到第一个满足条件的记录X，然后根据其他判断条件进行判断，就算只有这样，也是要比全表扫描效率高。</p>
<p>在<code>MYSQL5.6</code>之前，只能从记录X开始一个个回表，到主键索引上找出记录行，在对比字段值。</p>
<p>在<code>MYSQL5.6</code>之后，引入索引下推优化，可以在所有遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>无索引下推执行过程如下图所示：不会获取联合索引中<code>age</code>的值，在匹配”张“之后，逐个往后遍历，并进行回表取出对应行数据进行查询条件的判断。</p>
<p><img src="https://s2.loli.net/2022/09/22/Ik84FoZC3MHlWPV.jpg" alt="无索引下推.jpeg"></p>
<p>采用索引下推的执行过程如下图所示：在匹配”张“之后，会获取<code>age</code>的值与查询条件进行匹配，如果不匹配直接获取下一个节点。所以这里的年龄等于30和20的数据，获取到之后不会进行回表操作。</p>
<p><img src="https://s2.loli.net/2022/09/22/OzSdyGrlAkwEhUC.jpg" alt="有索引下推.jpeg"></p>
<h1 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h1><p>重建非主键索引：</p>
<blockquote>
<p>alter table T drop index k;</p>
<p>alter table T add index(k);</p>
</blockquote>
<p>重建主键索引：</p>
<blockquote>
<p>alter table T drop primary key;</p>
<p>alter table T add primary key(id);</p>
</blockquote>
<p>重建非主键索引的做法是合理的，可以达到省空间的目的；但是重建主键索引的过程是不合理的，不论是删除主键还是创建主键，都会将整个表重建，所以第一个语句其实可有可无，单纯执行第二个语句就会对表进行重建。再者可以使用<code>alter table T engine=InnoDB</code>对表进行重建。</p>
<p><b>表数据删除一半，表文件大小不变？</b></p>
<p>​    <code>InnoDB</code>表包含两个部分，表结构定义和数据。在<code>MYSQL8.0</code>之前，表结构是存储在以<code>.frm</code>为后缀的文件里。而<code>MYSQL8.0</code>则已经允许将把表结构定义放在系统数据表，实际上表结构定义占用的空间很小，所以占用空间的主要部分就是表数据。</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的：</p>
<ol>
<li>这个参数设置为<code>OFF</code>表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>
<li>这个参数设置为<code>ON</code>表示的是，每个<code>InnoDB</code>表数据存储在一个以<code>.ibd</code>为后缀的文件中。</li>
</ol>
<p>从<code>MySQL 5.6.6</code>版本开始，它的默认值就是<code>ON</code>。一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<p>在<code>InnoDB</code>中，数据都是以<code>B+</code>树模型且按页存储，前面也有说到，在进行查询数据时，<code>MYSQL</code>是将数据的某一页或者某几页加载到内存中。假设要删除<code>A</code>页的<code>R4</code>这条记录，这里只会将这个空间标记为复用，但是占用的空间并没有减少，如果之后又在300~600间插入一条数据，那么会复用这个空间，所以有时候删除记录并不会减少表占用空间。</p>
<p><img src="https://s2.loli.net/2022/09/23/ARtpzfZ5Dg7G1O6.png" alt="索引数据页结构.png"></p>
<p>​    当然了，如果将300-600的数据行都删除，那么这整个<code>A</code>数据页就被标记复用，对应数据页的复用，比行的复用稍微灵活，比如上述中将500对应行删除之后，只能在插入300-600之间的数据可以复用这个空间，但是如果整个数据页被标记复用，这个时候如果需要使用新页，这个标记删除的数据页就可以被复用。如果相邻两个数据页的利用率比较低，<code>MYSQL</code>也会将这两个页的数据合并到一个页，将另一个页标记为复用。</p>
<p>​    所以如果使用<code>delete</code>删除整个表，结果就是这个表的所有数据页被标记为复用，但是占用的磁盘空间并不会减少；但是若使用<code>truncate</code>命令，相当于使用了<code>drop</code>和<code>create</code>命令的结合，单纯从这一方面看，<code>truncate</code>在删除整个表数据时会减少空间。(但是<code>truncate</code>不能加<code>where</code>条件，动作上是先删除表<code>drop</code>再<code>create</code>表，所以它是<code>DDL</code>命令)。</p>
<p>​    这里将这些标记为复用的空间称为”空洞“。新增、删除、修改(比如将300修改为800，则操作上是将300对应行标记复用，在插入800对应行)数据都会存在生成新的空洞的情况，比如新增一条数据，导致某个页进行了页分裂，但是由于页空间没有填满，造成了较大的空洞，如果空洞比较多，产生的现象就是删除部分数据，并不会导致磁盘空间的减少。所以如果在删除数据之后能将这些空洞去掉，就可以减少占用磁盘空间。</p>
<h2 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h2><p>​    假设已经存在了一个较多空洞的表<code>A</code>，可以通过创建一个同样的表<code>B</code>，按照主键递增的顺序将数据从<code>A</code>表中读出，再写入到表<code>B</code>中，由于表<code>B</code>是新建表，所以表<code>A</code>主键索引上的空洞在表<code>B</code>是不存在的。这时用表<code>B</code>替换表<code>A</code>，从结果上来看，起到了收缩表<code>A</code>的目的。</p>
<p>​    在<code>MYSQL</code>中已经存在这个命令，通过使用<code>alter table A engine=InnoDB</code>来重建表。实际上流程就是上述流程，只不过<code>MYSQL</code>将这些操作内置，你只需要通过这一个命令即可。</p>
<p>​    当然了，这个过程中最消耗资源的过程，就是将表<code>A</code>数据拷贝到表<code>B</code>的过程。但是在这个过程中，如果出现新数据需要写入到表<code>A</code>中，就有可能造成数据丢失，所以在这个过程中表<code>A</code>不能有更新。</p>
<p>在<code>MYSQL5.6</code>版本开始引入<code>Online DDL</code>，对这个操作流程进行优化。也就是在拷贝的过程中，通过记录一个<code>row log</code>，拷贝完成之后，将<code>row log</code>的操作应用到表<code>B</code>。由于这个优化之后，在表重建过程中，允许对表<code>A</code>做写操作，所以称为<code>Online DDL</code>。</p>
<p>​    这个<code>DDL</code>在<code>alter</code>启动的时候就获取了<code>DML</code>写锁，但是在真正拷贝数据时，就退化为读锁，这样是为了实现<code>Online</code>，<code>MDL</code>读锁不会阻塞写操作，至于为什么不直接释放锁，是因为要禁止其他线程同时做<code>DDL</code>。</p>
<p>上述的这些重建方法都会扫描原表数据和构建临时文件，对于大表来说，这个操作是很消耗<code>IO</code>和<code>CPU</code>资源，所以可以通过一些比较稳定的开源组件操作，比如<code>GitHub</code>开源的<code>gh-ost</code>。</p>
<p>据说100万行数据以下，可以使用<code>online ddl</code>超过百万可以使用<code>gh-ost</code></p>
<p>关于重建表的三个命令：</p>
<ul>
<li><code>alter table t engine = InnoDB</code>：在5.6版本之后，默认就是<code>Online DDL</code>的方式。</li>
<li><code>analyze table t</code>：这个命令实际上不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程加了<code>MDL</code>读锁。</li>
<li><code>optimize table t</code>：这个命令等于<code>recreate</code>+<code>analyze</code></li>
</ul>
<h1 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h1><p>使用唯一索引还是普通索引？这是分为查询过程和更新过程来分析两种索引之间的性能差别</p>
<h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><blockquote>
<p>select id from T where k=5</p>
</blockquote>
<p>这个查询语句在索引树上查找的过程：先从<code>B+</code>树根开始按层搜索叶子节点。</p>
<ul>
<li>普通索引：查找到满足条件的第一个记录(5, 500)后，需要查找下一个记录，知道碰到第一个不满足的<code>k=5</code>条件的记录。</li>
<li>唯一索引：查找到满足条件的第一个记录(5, 500)后，由于唯一索引的特性，直接停止检索。</li>
</ul>
<p>所以对于查询语句来说，两种索引的性能差别几乎没有差别，由于<code>MYSQL</code>是按页读写数据，所以当找到<code>k=5</code>的记录时，它所在的数据页都在内存里，那么对于普通索引来说仅比唯一索引多做了一个判断而已，所以几乎忽略不计。</p>
<h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><blockquote>
<p>change buffer：当需要更新一个数据页时，如果这个数据页在内存中，则直接更新这个数据页；如果这个数据页不在内存中，在不影响数据一致性的情况下，InnoDB会将这些更新动作缓存在 change buffer 中，这样就不需要从磁盘中读出这个数据页，当下次查询出这个数据页时，将数据页读入到内存中，然后先执行 change buffer 中与这个页相关的动作之后，再返回。(虽然这块缓存的名称叫 change buffer 实际上它是可以持久化数据，也就是说 change buffer 的数据也会被写入磁盘中。)</p>
<p>将 change buffer 的动作应用到操作页，得到最新的数据结果的过程称为 merge。除了访问数据页之外，后台会用定时线程会触发 merge、数据库正常关闭也会触发 merge。</p>
</blockquote>
<p>实际上唯一索引并不会用到 change buffer。这是因为唯一索引在更新时，需进行唯一性约束。而这个判断就使得必须将数据页读入内存才能判断，所以如果都已经将数据读入到内存中，那么直接更新内存中的值即可。</p>
<p>如果要插入一个新记录（4, 400）：</p>
<p>第一种情况，这个记录要更新的数据行在内存中。</p>
<ul>
<li>唯一索引：找到3到5之间的位置，判断到没有冲突，插入新记录。</li>
<li>普通索引：找到3到5之间的位置，插入新记录。</li>
</ul>
<p>普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p>
<p>第二种情况，这个记录要更新的数据行不在内存中。</p>
<ul>
<li>唯一索引：需要将数据页读到内存中，判断没有冲突，插入新记录</li>
<li>普通索引：将动作插入到 change buffer。</li>
</ul>
<p>将数据从磁盘读入到内存中涉及随机IO的访问，是数据库里成本最高的操作之一。change buffer 减少了随机磁盘访问，所以对更新性能是很明显。</p>
<h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><p>​    在<code>MySQL</code>中一张表是可以创建多个索引，但是具体的<code>SQL</code>语句使用哪个索引来进行查询，是由<code>MySQL</code>来确定，有没有可能<code>MySQL</code>选到的索引不是最优解。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 创建<span class="number">10</span>w条数据: 从(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)，(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)，(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)直到(<span class="number">100000</span>,<span class="number">100000</span>,<span class="number">100000</span>)</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>现在来看一条<code>SQL</code>查询语句：</p>
<blockquote>
<p>select * from t where a between 10000 and 20000;</p>
</blockquote>
<p>这样查询语句会使用索引<code>a</code>来提高查询效率，用<code>explain</code>命令结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t</td>
<td>range</td>
<td>a</td>
<td>a</td>
<td>5</td>
<td></td>
<td>10000</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>果然<code>key=a</code>表示使用了所以<code>a</code>，扫描了10000行数据。</p>
<p>再来：</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>Start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t;<br>call idata();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>explain select * from t where a between 10000 and 20000;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>这里表示<code>sessionA</code>开启一个事务后，<code>sessionB</code>把数据删了之后，再次调用写10w行数据的存储过程，再通过<code>explain</code>命令查询这条<code>SQL</code>语句的执行。</p>
<p>这时<code>sessionB</code>的查询语句就不会再选择索引<code>a</code>，但是如果这里使用<code>select * from t force index(a) where a between 10000 and 20000;</code>就会使用索引。</p>
<p>这个例子对应的就是我们平常不断的删除数据和新增数据的场景，在这种情况下<code>MySQL</code>可能会选错索引。</p>
<p>在<code>sessionB</code>中删除了所有数据，然后通过<code>call idata()</code>插入10w行数据，看上去这里重新插入了10w行数据，但是<code>sessionA</code>在<code>sessionB</code>删除之前就开启了事务且还没有提交，所以之前的10w行数据还不能删除，这就导致之前的每一行数据都有两个版本，旧版本是数据，新版本被标记<code>delete</code>。所以再重新插入10w行数据之后，索引<code>a</code>上就有两份10w行数据。</p>
<p>至于为什么会选错索引，实际上优化器在选择索引的时候，有很多判断维度：扫描行、是否使用临时表、是否排序等。这里主要是因为旧的10w行数据的存在，优化器认为需要扫描的行数比较多，索引没有命中索引。其实优化器在对扫描行的判断，是通过采样分析，也是一个预估的值。可以通过<code>analyze table t</code>来重新进行统计。</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;geek&#96; (</span><br><span class="line">  &#96;a&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;d&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;a&#96;,&#96;b&#96;),</span><br><span class="line">  KEY &#96;c&#96; (&#96;c&#96;),</span><br><span class="line">  KEY &#96;ca&#96; (&#96;c&#96;,&#96;a&#96;),</span><br><span class="line">  KEY &#96;cb&#96; (&#96;c&#96;,&#96;b&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<p>表<code>geek</code>已经存在联合主键<code>(a, b)</code>，是不是只需要创建<code>(c)</code>索引包含了<code>(ca)</code>和<code>(cb)</code>的场景，为什么需要再创建<code>(ca)</code>和<code>(cb)</code>?</p>
<p>假设存在以下两条语句：</p>
<blockquote>
<p>select * from geek where c=N order by a limit 1;</p>
<p>select * from geek where c=N order by b limit 1;</p>
</blockquote>
<p>那么这时所有<code>ca</code>和索引<code>cb</code>有存在的必要吗？</p>
<p>假设表中记录为：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>d</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td>d</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
<td>d</td>
</tr>
</tbody></table>
<p>主键<code>a</code>和<code>b</code>的联合主键相当于对数据进行<code>order by a, b</code>。也就是先按<code>a</code>排序，再按<code>b</code>排序，<code>c</code>无序，这里没有使用到<code>d</code>。</p>
<p>索引<code>ca</code>的组织结果：逻辑上最后一列是<code>ab</code>的值，但是由于联合索引中已经存在了<code>a</code>，索引最后一列中只有<code>b</code>。<b>与索引<code>(c)</code>一致。</b></p>
<table>
<thead>
<tr>
<th>c</th>
<th>a</th>
<th>b(主键的b部分)</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>索引<code>cb</code>的组织结果：同理，最后一列也只有<code>b</code>。</p>
<table>
<thead>
<tr>
<th>c</th>
<th>a</th>
<th>a(主键的a部分)</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p>综上：<code>ca</code>索引和<code>c</code>的数据组织结果一致，但<code>cb</code>不一致，若上述两条查询语句为高频语句，则<code>cb</code>可以保留。</p>
<h2 id="字符串添加索引"><a href="#字符串添加索引" class="headerlink" title="字符串添加索引"></a>字符串添加索引</h2><p>​    字符串字段存在一个问题，如果是热点字段使用比较频繁，在不加字段的情况下，就会出现一直全表扫描，那么如果为字符串字段添加索引？</p>
<p>如果你仅仅只想到直接为该字符串字段添加一个索引，那么只能说你只看到了问题的表面，因为为字符串字段添加索引需要考虑到这个字符串字段的长度问题，如果这个字符串长度比较长，那么这个索引需要占用的空间就会比较大。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是只取字段的部分长度作为索引：</p>
<blockquote>
<p>alter table SUser add index index2(email(6));</p>
</blockquote>
<p>设置<code>SUser</code>表的<code>email</code>字段的前6位作为索引。<br>假设表中有数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>email</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>xiaocainiaoya@foxmail</td>
</tr>
<tr>
<td>2</td>
<td>cainiao@foxmail</td>
</tr>
<tr>
<td>3</td>
<td>niao@foxmail</td>
</tr>
</tbody></table>
<p>那么如果根据<code>email</code>前六位来做为前缀索引就只需要匹配一次，回表一次后，将字段值与查询值再次匹配若匹配成功，则获取数据。<br>所以这种方式需要这个字段存储的值具备一定的规则，然后根据规则设置索引的长度，长度越长，区分度就越高，查询效率就越高，伴随着占用空间就越大。</p>
<p><b>注：前缀索引会破坏覆盖索引，如果仅查询索引上的字段，但是由于需要回表进行一次匹配（系统不知道这个字段值到底有没有被截断）。所以覆盖索引相关的优化可能就失效了。</b></p>
<h3 id="倒叙存储"><a href="#倒叙存储" class="headerlink" title="倒叙存储"></a>倒叙存储</h3><p>一些字段的规则比如身份证，身份证的前面6位表示地域位置，在查询时需要遍历的列就比较多，可以将身份证倒叙存储，也就是通过<code>reverse(idCard)</code>进行存储，再通过<code>index(idCard(6))</code>设置索引，减少遍历的行数。</p>
<h3 id="哈希字段"><a href="#哈希字段" class="headerlink" title="哈希字段"></a>哈希字段</h3><p>再设置一个哈希字段，比如创建身份证字段之后，再创建一个身份证的哈希字段，插入的时候计算身份证的哈希值填入，那么就可以为这个哈希字段添加索引，从而减少索引字段的长度，但是由于不同值经过哈希算法后可能会得到同一个值，所以存在一定的误差，在查询时还是要将身份证的原值加上。</p>
<blockquote>
<p>select field_list from t where id_card_crc=crc32(‘input_id_card_string’) and id_card=’input_id_card_string’</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>直接创建完整索引，这样可能比较占用空间；</p>
</li>
<li><p>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</p>
</li>
<li><p>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</p>
</li>
<li><p>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</p>
</li>
</ol>
<h2 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h2><p>如果在查询条件上添加聚合函数会导致索引失效，这是因为对索引字段进行聚合函数会破坏索引的有序性，导致优化器放弃走索引树的搜索功能，但是并不是说放弃了这个索引，因为如果遍历这个索引比遍历主键索引来的快，还是会使用这个索引，但是结果是使用了这个索引扫描的行也是全表的行数。</p>
<p>但是尽管有些聚合操作不破坏索引有序性，但是<code>MySQL</code>也不予支持，比如<code>where age + 1 = 1001</code>，不会改变索引的有序性，但是这时候也是扫描全表，要修改为<code>where age = 1001 - 1</code></p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>如果表中有一个<code>varchar</code>字段，但是查询语句是<code>where age = 10</code>，那么就涉及到类型的转换，<code>MySQL</code>采用的是字符串转换成数字的转换。也就是说<code>where age = 10</code>，需要将全表的数据都进行字符串转数字的转换，所以导致了索引失效。<br>如果换过来，表中有一个<code>int</code>字段，但是查询语句是<code>where age = &#39;10&#39;</code>,这个时候实际上是将这个<code>&#39;10&#39;</code>转为数字，在去表中匹配，这时就会命中索引。</p>
<h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>假设有两个表有关联操作，但是关联字段的编码不一样，一个是<code>utf8mb4</code>，一个是<code>utf8</code>，因为<code>utf8mb4</code>是<code>utf8</code>的超集，在做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，是按“数据长度增加的方向”进行转换。</p>
<p>也就是说，实际上这个语句等同于下面这个写法: </p>
<blockquote>
<p>select * from trade_detail  where traideid USING utf8mb4 = $L2.tradeid.value;<br>select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value;</p>
</blockquote>
<p>在这种情况下实际上就是需要判断谁是驱动表，谁是被驱动表，</p>
<blockquote>
<p>select * from trade_detail  where traideid = CONVERT($L2.tradeid.value USING utf8mb4);</p>
</blockquote>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45讲学习总结（五）---排序</title>
    <url>/2022/10/09/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89---%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="mysql45讲学习总结（五）—排序"><a href="#mysql45讲学习总结（五）—排序" class="headerlink" title="mysql45讲学习总结（五）—排序"></a>mysql45讲学习总结（五）—排序</h1><p>​<br>本篇记录<code>MySQL</code>在执行<code>order by</code>语句时系统的具体执行流程，以及在具备索引的情况下，索引的选择情况。</p>
<span id="more"></span>

<h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><blockquote>
<p>select name, age, address from t where name = ‘xxx’ order by age limit 1000  ;</p>
</blockquote>
<p>使用<code>explain</code>分析该语句：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>bid_confirm_project</td>
<td></td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4033</td>
<td>10</td>
<td>Using where; Using filesort</td>
</tr>
</tbody></table>
<p><code>Using filesort</code>：表示需要排序。<code>MySQL</code>会给每个线程分配一块<code>sort_buffer</code>内存空间用于排序。</p>
<p>假设在<code>name</code>上有索引排序流程：</p>
<ol>
<li>初始化<code>sort_buffer</code>空间，确定将用于存入字段<code>name</code>、<code>age</code>、<code>address</code>的值。</li>
<li>从索引<code>name</code>上找到第一个满足<code>xxx</code>条件的<code>id</code>。</li>
<li>根据这个<code>id</code>通过主键索引获取整行数据，将<code>name</code>、<code>age</code>、<code>address</code>的值存入到<code>sort_buffer</code>中。</li>
<li>从索引<code>name</code>取下一个记录的主键。</li>
<li>重复3,4步骤，直到从索引<code>name</code>取到的值不满足查询条件为止。</li>
<li>对<code>sort_buffer</code>空间的数据按照<code>age</code>进行排序。</li>
<li>返回结果集数据。</li>
</ol>
<p>​    <b>步骤6中按照<code>age</code>进行排序：这个可能在内存中完成，也有可能需要使用到外部排序。</b>这取决于排序所需要的内存空间大小和参数<code>sort_buffer_size</code>。如果需要排序的数据量小于<code>sort_buffer_size</code>则使用内存空间进行排序，如果需要排序的数量大于<code>sort_buffer_size</code>则需要使用磁盘临时文件辅助排序。</p>
<p>仅仅使用<code>explain</code>只能分析改语句是否需要排序，至于排序是在内存中排序还是在磁盘中排序就无法得知，需要使用其他手段。<b><code>MySQL</code>版本需要到5.6以上。</b></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 打开 optimizer_trace，只对本线程有效</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行语句</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 OPTIMIZER_TRACE 输出 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`</span><br></pre></td></tr></table></figure>

<p>查询的结果是一个<code>json</code>结果：(<code>json</code>结果比较大，截取一段)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;filesort_summary&quot;: &#123;</span><br><span class="line">  &quot;rows&quot;: 4250,  </span><br><span class="line">  &quot;examined_rows&quot;: 4291, // 排序的行数</span><br><span class="line">  &quot;number_of_tmp_files&quot;: 11,   // 排序过程中使用的临时文件数，如果在内存中排序，则这个值为0</span><br><span class="line">  &quot;sort_buffer_size&quot;: 261696,  // 就是上面说的排序的空间大小，这个是可以通过命令调整</span><br><span class="line">  &quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>假设查询语句变为：</p>
<blockquote>
<p>select * from t where name = ‘xxx’ order by age limit 1000  ;</p>
</blockquote>
<p>对比可知，仅仅是将查询结果的字段修改为了<code>*</code>，这时在步骤1中就需要为很多无需排序的字段开辟空间，那么就会造成<code>sort_buffer_size</code>空间中单行的数据比较长，那么<code>MySQL</code>会怎么做？</p>
<p>实际上当<code>MySQL</code>判断单行数据过长时，它会修改<code>sort_buffer_size</code>存放值的策略，之前全字段排序时<code>sort_buffer</code>存放的字段为<code>name</code>、<code>age</code>、<code>address</code>，而如果单行数据过长时，<code>sort_buffer</code>存储的字段就变成<code>id</code>、<code>age</code>，排序完成之后，通过主键<code>id</code>索引进行一次回表，也就是说比全字段排序多了一个步骤，在排序完成之后需要进行一次回表。</p>
<p>同时在刚刚的<code>optimizer_trace</code>的<code>json</code>中的<code>sort_mode</code>项中会标识出是否采用了<code>rowid</code>算法。通过参数<code>max_length_for_sort_data</code>控制单行数据长度。</p>
<p><b>全字段排序对比rowid排序</b></p>
<p>如果<code>MySQL</code>认为内存足够大，会优先选择<b>全字段排序</b>，如果认为排序内存太小，影响排序效率，则会采用<code>rowid</code>排序算法，这样排序过程中一次可以排多行，但是需要再回表取相关字段数据。</p>
<p>排序对于<code>MySQL</code>来说是一个成本比较高的操作，并不是所有的<code>order by</code>都需要排序操作，之所以需要排序操作，是因为查到的数据是无序的，所有才需要进行排序操作，但是在<code>MySQL</code>中有一种方式是天然排序的，那就是索引，可以通过创建对应索引，使得查询到的数据已经是有序，那么就无需在经过排序操作。这种情况下<code>explain</code>得到的结果中就没有<code>filesort</code>。</p>
<h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h2><blockquote>
<p>CREATE TABLE <code>words</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>word</code> varchar(64) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>) ENGINE=InnoDB;</p>
<p>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=0;<br>  while i&lt;10000 do<br>    insert into words(word) values(concat(char(97+(i div 1000)), char(97+(i % 1000 div 100)), char(97+(i % 100 div 10)), char(97+(i % 10))));<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;</p>
<p>call idata();</p>
</blockquote>
<p>然后执行以下语句用于获取随机的前三个数据，这里的<code>order by rand()</code>，会对每一行的数据都生成一个随机值，然后根据这个随机值进行排序，最后取得前三行数据。</p>
<blockquote>
<p>select word from words order by rand() limit 3;</p>
</blockquote>
<p>使用<code>explain</code>命令执行结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>words</td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>10304</td>
<td>Using temporary; Using filesort</td>
</tr>
</tbody></table>
<p><code>Using temporary</code>表示需要使用到临时表，这里是因为需要为每一行生成一个随机值进行排序，所以需要一个临时表存储生成的这个随机值。</p>
<p>对于内存临时表来说，会选用那种算法存放数据？是全字段索引的算法？还是<code>rowid</code>算法？。<br>答案是使用<code>rowid</code>算法，因为对内存临时表来说，回表只是简单的根据数据行的位置直接访问到数据，不会导致访问磁盘，所以这时采用的是<code>rowid</code>排序。</p>
<ol>
<li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li>
<li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li>
<li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li>
<li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li>
<li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li>
<li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li>
<li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li>
</ol>
<p><b>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</b></p>
<h2 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h2><p>当需要到临时表的空间比较大时，超过了<code>tmp_table_size</code>的值，那么内存临时表会转换为磁盘临时表。<br>在磁盘临时表中还有一种优化算法：优先队列排序算法。对于这个查询语句，实际上只需要取值最小的3个值，但是如果使用归并排序的话，是将所有数据都排序了，所以实际上浪费了很大的计算量。所以这里<code>MySQL</code>提供了优先队列排序算法：<br>  先取3行数据构建一个堆，再取下一行数据，与这个堆的最大值进行比较，如果大则丢弃，如果小则替换，依次执行，知道扫描完整个表。</p>
<p>如果需要的空间大于<code>sort_buffer_size</code>则采用磁盘临时表，通过磁盘临时表进行排序。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45讲学习总结（六）---锁（第二弹）</title>
    <url>/2023/03/02/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89---%E9%94%81%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%EF%BC%89/</url>
    <content><![CDATA[<h1 id="mysql45讲学习总结（六）—锁（第二弹）"><a href="#mysql45讲学习总结（六）—锁（第二弹）" class="headerlink" title="mysql45讲学习总结（六）—锁（第二弹）"></a>mysql45讲学习总结（六）—锁（第二弹）</h1><p>​    本篇主要为了记录间隙锁和<code>next-key lock</code>相关概念以及加锁规则，在根据一些例子来理解这些加锁规则。</p>
<span id="more"></span>

<p>这里简单回顾一下：</p>
<p>表锁：如果查询条件中不包含索引字段，则是表锁。</p>
<p>行锁：行锁只能锁住行，跟行锁有冲突的是“另外一个行锁”</p>
<p>间隙锁：间隙锁是锁住两个值之间的空隙，跟间隙锁有冲突的是“往这个间隙插入一个记录”这个动作，所以某一个间隙可以被多个线程上间隙锁。</p>
<p><code>Next-Key Lock</code>是行锁和间隙锁的结合体。</p>
<p><b>无论任何锁的释放，都不是在执行完事务内的某条语句之后，是整个事务提交之后才会释放锁。</b></p>
<h2 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `USER_INFO` (</span><br><span class="line">  `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `USER_NAME` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`ID`),</span><br><span class="line">  KEY `IDX_USER_ID` (`USER_ID`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br></pre></td></tr></table></figure>

<p>可以看到上面示例中有一张<code>USER_INFO</code>表，在<code>ID</code>上有主键索引，在<code>USER_ID</code>上有非唯一索引。这时有两个事务并发，事务1是删除，事务2是插入。</p>
<p><strong>分析一下上锁过程：</strong></p>
<p>因为<code>USER_ID</code>是有非唯一索引，那么对<code>USER_ID</code>索引上<code>Next-Key Lock</code>。(假设事务1比事务2快一点点到达)</p>
<ol>
<li>上锁的基本单位是<code>Next-Key Lock</code>，上<code>Next-Key Lock</code>为(前一个<code>USER_ID</code>, 10]，前开后闭。</li>
<li>由于<code>USER_ID</code>是非唯一索引，这时还需要向后扫描到第一个不等值才返回(不等于10)，但是由于目前这张表中的最大<code>USER_ID=10</code>，所以这时会变成<code>mysql</code>预设的最大值(+suprenum)。</li>
<li>所以最后锁的范围为(前一个formId， +suprenum)</li>
</ol>
<p><font color="red">在步骤2中，由于间隙锁需要锁住一个空间，但是在<code>USER_ID=10</code>之后没有其他数据，才会导致锁住了<code>USER_ID=10</code>之后的所有空间，这也不能理解，由于是非唯一索引，所以无法保证不会在<code>USER=10</code>之后再插入一条<code>USER_ID=10</code>的数据。</font></p>
<p>所以这个时候的事务2进来是就需要等待事务1提交事务之后才能进行数据插入。</p>
<p>可以自己通过脚本测试一下，验证结论是否正确。开两个<code>SQL</code>窗口，进行两个线程测试。</p>
<p>线程1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> USER_INFO <span class="keyword">where</span> USER_ID <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="comment">-- 延迟 提交事务</span></span><br><span class="line"><span class="keyword">SELECT</span> sleep(<span class="number">10</span>) <span class="keyword">FROM</span> USER_INFO limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>线程2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> USER_INFO <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">20</span>, &quot;marry&quot;);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h2 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h2><ol>
<li>原则1：加锁的基本单位就是<code>Next-Key Lock</code>，<code>Next-Key Lock</code>是前开后闭区间。</li>
<li>原则2：在加锁过程中访问到的对象(记录)才会被锁。</li>
<li>优化1：对唯一索引的等值查询，<code>Next-Key Lock</code>退化为行锁。</li>
<li>优化2：索引上的等值查询，从第一个满足等值条件的索引记录开始向右遍历到第一个不满足等值条件记录，并将第一个不满足等值条件记录上的<code>Next-Key Lock</code>退化为间隙锁</li>
</ol>
<p>下文通过这个脚本中的表和数据为例，进行加锁规则的一些解释。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>这时对于主键索引来说，具有的值为<code>0、5、10、15、20、25</code>，以及7个间隙。</p>
<p><img src="https://s2.loli.net/2023/03/02/IqU9dRAu2c6VCYz.png" alt="间隙锁2.png"></p>
<h3 id="1-等值查询间隙锁"><a href="#1-等值查询间隙锁" class="headerlink" title="1.等值查询间隙锁"></a>1.等值查询间隙锁</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>update t set d=d+1 where id=7</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>Insert into t values(8, 8, 8)<br>(<font color='red'>blocked</font>)</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>update set d=d+1 where id=10;<br/>(<font color='green'>Query OK</font>)</td>
<td>T3</td>
</tr>
</tbody></table>
<ol>
<li>在<code>T1</code>时刻，由于没有<code>id=7</code>这条记录，根据加锁规则，锁住<code>B</code>这个间隙，由于<code>Next-Key Lock</code>是前开后闭，所以锁住空间为<code>(5,10]</code></li>
<li><font color="red">若表中存在<code>id=7</code>这条记录，则根据优化1，锁住的仅仅为<code>id=7</code>这条记录。但是由于没有这条记录，故进入优化2的加锁规则。</font>根据优化2，等值查询<code>where id=7</code>向右遍历时，遇到的最后一个不满足等值条件的记录时，<code>Next-Key Lock</code>退化为间隙锁，所以<code>T1</code>时刻后最终加锁的范围为<code>(5,10)</code></li>
</ol>
<p>所以<code>T2</code>时刻的<code>SessionB</code>操作被阻塞，<code>T3</code>时刻的<code>SessionC</code>操作没有被阻塞。</p>
<h3 id="2-非唯一索引等值锁"><a href="#2-非唯一索引等值锁" class="headerlink" title="2.非唯一索引等值锁"></a>2.非唯一索引等值锁</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select id form t where c=5 lock in share mode;</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where id=5;<br>(<font color='green'>Query OK</font>)</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(7, 7,7)<br/>(<font color='red'>blocked</font>)</td>
<td>T3</td>
</tr>
</tbody></table>
<ol>
<li>根据原则1，加锁单位是<code>Next-Key Lock</code>,所以会给<code>(0,5]</code>上<code>Next-Key Lock</code>锁。</li>
<li>由于<code>c</code>是非唯一索引，当访问到<code>c=5</code>这条记录后不会停下来，会继续向后遍历，当遍历到<code>c=10</code>这条记录后停止，所以这时要对<code>(5,10]</code>上<code>Next-Key Lock</code>，但根据优化2，这时<code>Next-Key Lock</code>退化为间隙锁<code>(5,10)</code></li>
</ol>
<p>所以最终，在<code>T1</code>时刻，上锁的范围是<code>(0, 5]</code>的<code>Next-Key Lock</code>和<code>(5,10)</code>的间隙锁，故<code>T3</code>时刻，<code>SessionC</code>插入<code>c=7</code>的数据被阻塞。</p>
<p><font color="red">这里为什么<code>T2</code>时刻的<code>SessionB</code>执行成功？</font>这是因为加锁规则中的原则2，只有访问到的对象才会加锁，因为这条<code>SQL</code>采用的是索引覆盖，所以并不需要访问主键索引，所以也就没有对主键索引上锁，所以<code>sessionB</code>才会执行成功。</p>
<p><b>注意:<code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>不一样，<code>Mysql</code>这时认为接下来要更新数据，会顺便为主键索引上锁。</b>所以如果你要用<code>lock in share mode</code>来给行添加读锁避免数据被更新，就必须绕过覆盖索引的优化，在查询字段中添加索引中不存在的字段，让它必须进行一次回表。</p>
<h3 id="3-主键范围索引锁"><a href="#3-主键范围索引锁" class="headerlink" title="3.主键范围索引锁"></a>3.主键范围索引锁</h3><p>这两条<code>SQL</code>虽然在查询结果是一致的，但是它们的加锁规则不太一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> update;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select * from t where id&gt;=10 and id&lt;11 for update;</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>insert into t values(8, 8,8);<br>(<font color='green'>Query OK</font>)<br>insert into t values(13, 13,13);<br/>(<font color='red'>blocked</font>)</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where id=15;<br/>(<font color='red'>blocked</font>)</td>
<td>T3</td>
</tr>
</tbody></table>
<ol>
<li>开始执行时，从<code>id=10</code>开始查询，这里本来应该是<code>(5,10]</code>的<code>Next-Key Lock</code>，由于<code>id</code>是唯一索引，退化为行锁，这时只加了<code>id=10</code>这一行的行锁。</li>
<li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code>，这里要扫到<code>id=15</code>是正常的，只有扫到了这条记录，才会知道需不需要继续往后找。</li>
</ol>
<p><b>注意：</b><code>sessionA</code>的步骤一首次定位<code>id=10</code>是用等值查询来判断的，步骤二继续向右遍历用的是范围查询判断(范围查询并没有在两个优化中，所以这里的<code>(10, 15]</code>不会退化为间隙锁！！！这个要注意，优化只有在等值查询的时候才会发生，我在第一次看的时候当时也突然卡住，没有想明白为什么没有退化为间隙锁！)</p>
<h3 id="4-非唯一索引范围锁"><a href="#4-非唯一索引范围锁" class="headerlink" title="4.非唯一索引范围锁"></a>4.非唯一索引范围锁</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select * from t where c&gt;=10 and c&lt;11 for update;</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>insert into t values(8, 8,8);<br>(<font color='red'>blocked</font>)</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>update t set d=d+1 where c=15;<br/>(<font color='red'>blocked</font>)</td>
<td>T3</td>
</tr>
</tbody></table>
<p>这个与案例3的区别在于通过字段<code>c</code>来进行查询，字段<code>c</code>是非唯一索引。</p>
<ol>
<li>根据<code>c=10</code>找到了<code>c=10</code>这条记录，所以添加对<code>(5,10]</code>添加<code>Next-Key Lock</code>，由于是非唯一索引，所以不会退化为间隙锁。</li>
<li>继续向右遍历，找到<code>id=15</code>这条记录后停止，所以这里加<code>(10, 15]</code></li>
</ol>
<p>综上：这里对索引<code>c</code>上了<code>(5,10]</code>和<code>(10, 15]</code>两个<code>Next-Key Lock</code>。</p>
<h3 id="5-唯一索引范围锁bug"><a href="#5-唯一索引范围锁bug" class="headerlink" title="5.唯一索引范围锁bug"></a>5.唯一索引范围锁bug</h3><p>在开头叙述的两个原则，两个优化的加锁原则之外，还有一个加锁<code>bug</code>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select * from t where id&gt;10 and id&lt;=15 for update;</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where id=20;<br/>(<font color='red'>blocked</font>)</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(16, 16,16);<br/>(<font color='red'>blocked</font>)</td>
<td>T3</td>
</tr>
</tbody></table>
<p><code>sessionA</code>是一个范围查询，根据原则1，这时为<code>(10,15]</code>上<code>Next-Key Lock</code>，并且<code>id</code>是唯一键，所以判断到<code>id=15</code>这一行就应该停止了，但实际上<code>InnoDB</code>会继续向后遍历到第一个不满足条件的行为止，也就是<code>id=20</code>这条记录，所以<code>(15,20]</code>也会上<code>Next-Key Lock</code>。所以这时<code>SessionB</code>和<code>SessionC</code>也会被锁住。</p>
<p>照理来说，扫描到<code>id=15</code>这行后，就可以不用继续往后查询了，但实际上<code>InnoDB</code>实际上还是这么做了。所以在<code>mysql 45讲</code>的作者认为这是一个<code>bug</code>。</p>
<h3 id="6-非唯一索引上存在等值的情况"><a href="#6-非唯一索引上存在等值的情况" class="headerlink" title="6.非唯一索引上存在等值的情况"></a>6.非唯一索引上存在等值的情况</h3><p>开头创建的表结构和数据中，没有存在索引<code>c</code>上有等值的数据，所以这里插入一条等值数据。</p>
<blockquote>
<p>insert into t values(30,10,30);</p>
</blockquote>
<p>执行之后，表中有两条<code>c=10</code>的数据。下图为索引<code>c</code>的间隙状态如下(上方是<code>c</code>，下方是主键)</p>
<p><img src="https://s2.loli.net/2023/03/02/FpGekvjcSrM7zCt.png" alt="非唯一索引间隙锁.png"></p>
<p>这时有两个<code>c=10</code>的记录，他们的主键<code>id</code>值不同（分别是<code>10</code>和<code>30</code>），但是这两个记录之间也是有间隙的。</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>delete from t where c=10</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where c=15;<br/>(<font color='green'>Query OK</font>)</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(12, 12,12);<br/>(<font color='red'>blocked</font>)</td>
<td>T3</td>
</tr>
</tbody></table>
<ol>
<li><code>sessionA</code>在遍历时先访问第一个<code>c=10</code>的记录，这时先对<code>(c=5,id=5)</code>到<code>(c=10,id=10)</code>这个<code>Next-Key Lock</code></li>
<li>继续向后遍历，直到碰到<code>(c=15,id=15)</code>这一行，遍历停止，根据优化2，这时一个等值查询，向右遍历第一个不满足条件的的行会退化为<code>(c=10,id=10) </code>到<code> (c=15,id=15)</code>的间隙锁。</li>
</ol>
<p>也就是说这个<code>delete</code>语句在索引<code>c</code>上的加锁范围就是下图中标记的区域，这里不包含两边的两条记录，是开区间，即<code> (c=5,id=5)</code> 和<code>(c=15,id=15)</code>这两行上都没有锁。<b>同时主键索引上锁(10,10,10) 和 (30,10,30) 两行,是行锁。</b></p>
<p><img src="https://s2.loli.net/2023/03/02/E5r6kSWTJDxpNQu.png" alt="非唯一索引间隙锁2.png"></p>
<h3 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h3><p>这个是对案例6的一个对照案例。</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>delete from t where c=10 limit 2;</td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>insert into t values(12, 12, 12);<br/>(<font color='green'>Query OK</font>)</td>
<td>T2</td>
</tr>
</tbody></table>
<p>这个例子对比案例6的<code>sessionA</code>，仅在<code>delete</code>语句上加了<code>limit 2</code>，可能你会觉得数据库中<code>c=10</code>的记录只有两条，加不加<code>limit 2</code>删除的效果都是一样的，但是实际上加锁的访问有所不同。</p>
<p>这是因为，案例7的<code>delete</code>语句明确了<code>limit 2</code>的限制，因此在遍历到<code>(c=10, id=30)</code>这一行之后，就已经满足语句了，遍历就结束了。所以索引<code>c</code>的加锁范围就变成了<code>（c=5,id=5)</code>到<code>（c=10,id=30)</code>这个前开后闭区间。所以这时<code>T2</code>时刻的<code>sessionB</code>插入<code>c=12</code>是可以执行成功的。</p>
<p>所以这个例子对我们的实践是有指导意义的，<b>在删除数据的时候尽量加<code>limit</code>，</b>这样不仅可以控制删除的条数，也可以减少加锁的范围。</p>
<h3 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select from t where c=10 lock in share mode;</td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where c=10;<br/>(<font color='green'>Query OK</font>)</td>
<td>T2</td>
</tr>
<tr>
<td>insert into t values(8, 8, 8)</td>
<td></td>
<td>T3</td>
</tr>
<tr>
<td></td>
<td>ERROR 1213:Deadlock found when trying to get lock; try restarting transaction</td>
<td>T4</td>
</tr>
</tbody></table>
<ol>
<li><code>session A </code>启动事务后执行查询语句加<code> lock in share mode</code>，在索引 <code>c </code>上加了<code> next-key lock(5,10]</code> 和间隙锁<code> (10,15)</code>；</li>
<li><code>session B </code>的<code> update</code> 语句也要在索引 <code>c </code>上加<code> next-key lock(5,10]</code> ，进入锁等待；</li>
<li>然后 <code>session A</code> 要再插入<code> (8,8,8)</code> 这一行，被<code>session B</code>的间隙锁锁住。由于出现了死锁，<code>InnoDB</code> 让 <code>session B </code>回滚。</li>
</ol>
<p>实际上步骤2中加<code>Next-Key Lock</code>是两步操作，分成间隙锁和行锁，在步骤2中加间隙锁是不会冲突，但是在加行锁的时候进入了等待，而T3时刻，<code>sessionA</code>插入数据需要等待<code>sessionB</code>释放间隙锁，所以出现了相互等待的情况，从而导致死锁。</p>
<p>虽然在分析<code>Next-Key Lock</code>表示间隙锁和行锁的结合，但是具体执行的时候要分为两段来执行。</p>
<h3 id="9-非唯一索引排序"><a href="#9-非唯一索引排序" class="headerlink" title="9.非唯一索引排序"></a>9.非唯一索引排序</h3><table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select * from t where c&gt;=15 and c&lt;=20 order by c desc lock in share mode;</td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>insert into t values(6,6,6);<br/>(<font color='red'>blocked</font>)</td>
<td>T2</td>
</tr>
</tbody></table>
<ol>
<li>由于这里有<code>order by c desc</code>所以首先从<code>c=20</code>开始定位，所以首先加上间隙锁<code>(20, 25)</code>和<code>Next-Key Lock</code>锁<code>(15, 20]</code>。</li>
<li>在索引<code>c</code>向左遍历，需要扫描到<code>c=10</code>这条记录才会停止，所以<code>(5, 10]</code>。所以<code>sessionB</code>会阻塞。</li>
<li>在扫描的过程中，会对<code>c=10</code>，<code>c=15</code>，<code>c=20</code>这三行有数据，且查询字段是<code>select * </code>，需要进行回表，所以会在主键索引上上三个行锁。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql45讲学习总结（四）---锁</title>
    <url>/2022/09/29/mysql/mysql45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89---%E9%94%81/</url>
    <content><![CDATA[<h1 id="mysql45讲学习总结（四）—锁"><a href="#mysql45讲学习总结（四）—锁" class="headerlink" title="mysql45讲学习总结（四）—锁"></a>mysql45讲学习总结（四）—锁</h1><p>​    数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
<span id="more"></span>

<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p>
<ul>
<li><code>DML</code>：数据操纵语言(Data Manipulation Language)</li>
<li><code>DDL</code>：数据定义语言(Data Definition Language)</li>
<li><code>MDL</code>：元数据锁(meta data lock)</li>
</ul>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>​    全局锁顾名思义就是对整个数据库实例上锁，让整个数据库处于只读状态，<code>MySQL</code>提供了一个加全局读锁的方法，命令是<code>Flush tables with read lock(FTWRL)</code>。使用这个命令之后，其他线程的数据更新语句<code>DML</code>(增删改)、数据定义语句<code>DDL</code>(建表、修改字段信息)和更新类事务的提交语句。</p>
<p>一般来说全局锁的使用场景就是全库的备份，使用<code>FTWRL</code>命令之后，使得整个库处于只读状态之后，进行数据备份。那么有两种情况，如果在主库进行备份，备份期间，主库处于业务停摆；如果在从库备份，从库无法执行主库过来的<code>binlog</code>，导致主从延迟。</p>
<p>那么有没有什么方式可以不影响业务？</p>
<p>先简单还原全库备份如果不上全局锁产生的问题：假设有两张表，一张账户余额表，一张用户课程表；事务内的操作顺序为余额表扣款，课程表添加一条课程记录。假设这个动作是在备份过程中执行，在余额表扣款之前，备份了余额表，在课程表添加记录之后，备份了课程表，导致在备份库中，余额表的金额是原值，课程表却新增了一条记录。从语义上简单说就是钱没有花，但是买到了课。</p>
<p>产生这个问题的原因主要是备份库得到的不是一个逻辑时间点，视图的逻辑是不一致的，所以备份的时候应该要拿到一个时间点的一致性视图。也就是在可重复读隔离级别看开启一个事务，那么在这个事务中的操作，对于每个表来说已经形成了”快照“，对这个”快照“进行备份，从而保证备份库数据逻辑正确。</p>
<p>官方自带的逻辑备份工具<code>mysqldump</code>，使用参数<code>--single-transaction</code>后备份数据会启动一个事务，来确保拿到的是一致性视图，但是要注意，这个参数需要存储引擎支持可重复读这个隔离级别。比如<code>MyISAM</code>不支持，那么只能使用<code>FTWRL</code>进行备份。</p>
<p>当然了还有人说可以使用<code>set global readonly = true</code>的方式让整个库处于只读的状态，但是这种做法存在两个致命的问题：</p>
<ul>
<li>使用<code>FTWRL</code>命令，当这个线程因为发生异常断开之后，会释放这个全局锁。</li>
<li>假设其他应用层框架通过这个<code>readonly</code>全局参数判断是否是主库，导致一些应用层逻辑出现问题。</li>
</ul>
<p>业务的更新不只是<b>增删改数据（<code>DML</code>)</b>，还有可能是加字段等<b>修改表结构的操作（<code>DDL</code>）</b>。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</p>
<h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p><code>MySQL</code>里面的表级别锁有两种：表锁和元数据锁<code>MDL</code>。</p>
<h2 id="表锁-1"><a href="#表锁-1" class="headerlink" title="表锁"></a>表锁</h2><blockquote>
<p>表锁的语法是 lock tables … read/write</p>
</blockquote>
<p>与<code>FTWRL</code>类似，可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。</p>
<p><code>lock tables</code>命令除了会限制别的线程的读写之外，也会限制自身线程的数据访问权限：假设线程A中执行<code>lock tables t1 read, t2 write</code>那么其他线程的写<code>t1</code>、读写<code>t2</code>都会被阻塞。同时当线程A在执行<code>unlock tables</code>之前，自身线程只能执行读<code>t1</code>、读写<code>t2</code>，这时连写<code>t1</code>都不允许，自然不能访问其他表。</p>
<p>一般不使用<code>lock tables</code>来控制并发，这个锁的面积太大。</p>
<h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p>​    <code>MDL</code>不需要显示使用，在访问一个表的时候会自动加上，它的作用是保证读写的正确性，这是因为假设一个查询正在遍历表数据，突然另一个线程变更了表结构，那么查询线程获取到的数据结构跟原本对不上。</p>
<p>​    所以当对一个表做增删改操作时，加<code>DML</code>读锁，当要对表结构做变更时，加<code>DML</code>写锁。</p>
<ul>
<li>读锁之间不互斥，因此你可以多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，一个线程获取了读锁，另一个线程如果要获取写锁就需要进入等待。</li>
</ul>
<p>尽管这样还是可能会出现一些问题：</p>
<p>​    在给一个表添加字段、修改字段或者索引的处理，这些操作是需要全表扫描的。假设线程A获取了<code>DML</code>读锁，在对表进行查询操作，线程B想要获取<code>DML</code>写锁，进行修改表字段操作，这时由于线程A持有<code>DML</code>读锁，线程B阻塞进入等待，同时其他线程若想再查这个表数据，需要获取<code>DML</code>读锁，都会因为线程B而进入等待，如果这个表查询比较频繁，且很多客户端是有重试机制，也就是等待超时之后会重启一个<code>session</code>再次请求，那么这个库的线程很快就会满。<b>事务中的<code>DML</code>锁，在语句执行开始时申请，并不是在语句执行完成后就释放，而是在事务提交之后才释放。</b></p>
<p>所以一般情况下，首先要解决长事务，事务不提交会一直持有<code>DML</code>锁，或者将这个线程<code>kill</code>掉，但是对于热点表来说，可能<code>kill</code>不是那么有效果，可能刚<code>kill</code>掉，请求马上就又来了，所以只能通过为这个变更语句设置等待时间，如果在这个时间之内能获取到<code>DML</code>锁，就执行变更，如果获取不到，也不要阻塞业务，先放弃，之后在重复执行这个命令。</p>
<blockquote>
<p>ALTER TABLE tbl_name NOWAIT add column …</p>
<p>ALTER TABLE tbl_name WAIT N add column …</p>
</blockquote>
<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>​    <code>MySQL</code>的行锁是各个引擎层自己实现，并不是所有存储引擎都支持行锁，比如<code>MyISAM</code>就不支持行锁，也就是锁它的并发控制只能使用表锁，这种颗粒度严重影响了业务并发度。</p>
<p>​    行锁就是针对于数据表中行记录的锁，锁的是主键索引，比如事务A更新了一行，这时候事务B也要更新同一行，那么事务B进入等待，如果事务B更新的不是同一行，那么事务B无需等待。</p>
<p><b>两阶段锁</b></p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>update t set k=k+1 where id=1;<br>update t set k= k+1 where id=2;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Begin;<br>update t set k=k+2 wehre id=1;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>这种情况下，事务A在执行两条更新语句之后，持有了这两条记录的行锁，但是事务A是在提交之后才会释放行锁，所以事务B的更新语句，要在事务A提交之后才能执行。</p>
<p><b>在<code>InnoDB</code>事务中，行锁是在执行语句的时候获取的，但并不是语句执行之后就释放，而是在这个事务提交之后才释放，这就是两阶段协议。</b></p>
<h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>间隙锁是用来解决幻读带来的问题，幻读是指事务T1对表中的数据进行了条件判断修改，比如<code>set k=1 where k=2</code>，同时事务T2向表中插入一条<code>k=1</code>的数据，那么事务T1再次查询时会发现，存在未修改行。</p>
<p>创建一个表，这个表除了主键 id 外，还有一个索引 c，初始化语句在表中插入了 6 行数据。</p>
<blockquote>
<p>CREATE TABLE <code>t</code> (<br><code>id</code> int(11) NOT NULL,<br><code>c</code> int(11) DEFAULT NULL,<br><code>d</code> int(11) DEFAULT NULL,<br>PRIMARY KEY (<code>id</code>),<br>KEY <code>c</code> (<code>c</code>)<br>) ENGINE=InnoDB;</p>
<p>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);</p>
</blockquote>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>select * from where d=5 for update</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t value(1, 1, 5)</td>
</tr>
<tr>
<td>select * from where d=5 for update</td>
<td></td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p><code>sessionA</code>第一次查询的时候只返回一条记录，第二次查询的时候由于<code>sessionB</code>已经提交了，所以可以查到两条记录。</p>
<p>也就是说幻读指一个事务内的两次查询，后一次的查询看到了前一次查询没有看到的行。</p>
<p>仔细观察<code>sessionA</code>的查询语句，可以发现，<code>for update</code>命令加上之后，是当前读，当前读就是要读到已经提交的最新值，所以<code>sessionA</code>看到<code>sessionB</code>提交的结果看起来并没有什么问题。</p>
<p>但是，实际上这是有问题的，因为<code>sessionA</code>的第一个查询语句的语义是要锁住所有<code>d=5</code>的行，不允许其他事务进行写操作，如果将<code>sessionB</code>的语句修改为<code>update c=1 where d=5</code>，这时<code>sessionB</code>就会进入等待，等待<code>sessionA</code>提交之后释放锁。</p>
<p><b>锁的设计是为了在并发时保持数据的一致性，包括数据库内部数据状态的一致性，也包括了日志的一致性。</b></p>
<p>看下面的例子：</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>select * from where d=5 for update;<br>update t set d=100 where d=5;</td>
<td></td>
<td></td>
<td>T1</td>
</tr>
<tr>
<td></td>
<td>update t set d=5 where id=0;<br>update t set c=5 where id = 0;</td>
<td></td>
<td>T2</td>
</tr>
<tr>
<td>select * from where d=5 for update;</td>
<td></td>
<td></td>
<td>T3</td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(1,1,5);<br>update set c=5 where id=1;</td>
<td>T4</td>
</tr>
<tr>
<td>select * from where d=5 for update;</td>
<td></td>
<td></td>
<td>T5</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
<td></td>
<td>T6</td>
</tr>
</tbody></table>
<p>当执行完成之后数据库数据结果：</p>
<ol>
<li>经过T1之后，id=5这一行变成(5, 5, 100)，但是这个要在T6之后才正式提交。</li>
<li>经过T2之后，id=0这一行变成(0, 5, 5)</li>
<li>经过T4之后，表里对了一行(1, 5, 5)</li>
</ol>
<p>所以<code>binlog</code>中的语句大概是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure>

<p>如果使用这个<code>binlog</code>来备份或者是从库同步数据都会出现数据不一致的情况。</p>
<p>那么是什么导致了这个数据不一致？可以简单的认为是<code>sessionA</code>在T1时未锁住数据导致的，那么如果它在T1时刻锁住了所有扫描到的行又会怎么样？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br><span class="line"> </span><br><span class="line">update t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line">update t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，就算锁住了所有扫描行，阻塞了<code>sessionB</code>的执行，但是也无法锁住<code>sessionC</code>语句的执行，<b>换句话说就是即使是所有数据都上锁，也还是无法阻止新记录的插入。</b>这也就是为什么幻读需要单独拿出来说的原因。</p>
<p>所以产生幻读的原因是行锁只能锁住数据行，而新插入的数据是插入到数据行之间的间隙，因此为了解决幻读，<code>InnoDB</code>引入了间隙锁(<code>Gap Lock</code>)。</p>
<p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，在主键索引上这就产生了 7 个间隙。</p>
<p><img src="https://s2.loli.net/2022/10/12/DqFhULJ4MSvCWje.png" alt="间隙锁.png"></p>
<p>所以当执行<code>select * from t where d=5 for update</code>时，不止是给数据库中已有的6个记录上锁，同时也加上了7个间隙锁。这样就可以确保数据无法插入。也就是说在扫描行时不仅给行上锁，也给行两边的间隙上锁。</p>
<p>间隙锁的性质与之前碰到的锁性质有所不同。</p>
<p>比如行锁分为读写锁，读锁之间不冲突，读写、写写之间是冲突。而间隙锁，两个<code>session</code>可以同时对一个间隙上间隙锁，只要不插入数据就不会产生冲突。</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin<br>select * from t where c=7 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin<br>select * from t where c=7 lock in share mode;</td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>这里的<code>sessionB</code>并不会阻塞，因为表中没有<code>c=7</code>这条记录，对于<code>sessionB</code>来说也是对(5,10)这个范围加间隙锁，它也<code>sessionA</code>锁住的范围是一致的，目标也是一致的，都是为了保护(5,10)这个范围不能插入数据。</p>
<p>间隙锁和行锁合称<code>next-key lock</code>，每个<code>next-key lock</code>是前开后闭区间。</p>
<p>当然了间隙锁的引入也会带来一些问题。</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>select * from where id=5 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from where id=5 for update;<br>insert into t values(5,1,5);</td>
</tr>
<tr>
<td>insert into t values(5,1,5);</td>
<td></td>
</tr>
</tbody></table>
<p>这个会带来死锁，原因是<code>sessionA</code>为(5,10)加上了间隙锁，<code>sessionB</code>也为(5, 10)加上了间隙锁，但是<code>sessionB</code>的插入语句需要等待<code>sessionA</code>释放间隙锁，<code>sessionA</code>的插入语句也在等待<code>sessionB</code>释放间隙锁，从而造成死锁。</p>
<p>间隙锁实际上是可重复读的隔离级别才会出现，如果隔离级别设置为读提交就不会产生幻读，也就不需要引入间隙锁。在读提交下，一般将日志格式设置为<code>row</code>来解决数据不一致的问题。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>行锁：对索引记录加锁。</li>
<li>间隙锁：锁住某个区间。(可以是两个索引记录之间，也可以是第一个索引之前或者最后一个索引之后的空间)</li>
<li>next-key锁：行锁和间隙锁的组合。</li>
</ul>
<p><b>如果检索条件不是索引的话会全表扫描，这时是表级锁。</b></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>如果需要删除一个表里前10000行数据，有一下三种方法可以做到：</p>
<ol>
<li>直接执行 <code>delete from T limit 10000</code>：单个语句占用时间过长，锁的时间比较长，而且大事务还会导致主从延迟。</li>
<li>在一个连接中循环执行20次<code>delete from T limit 500</code>：一般推荐这种方式。</li>
<li>在20个连接中同时执行<code>delete from T limit 500</code>：人为造成锁冲突。但是如果可以加上特定的条件，将这10000天然的分开，或者可以获取到主键<code>ID</code>，那么这种方式也不错。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql日志文件</title>
    <url>/2022/07/14/mysql/mysql%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="mysql日志文件"><a href="#mysql日志文件" class="headerlink" title="mysql日志文件"></a>mysql日志文件</h1><p>​    <code>mysql</code>在进行数据的存储过程中，为了处理数据、预防数据丢失、查询数据优化等的场景的需要，约定了一些日志文件系统。<span id="more"></span></p>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>​    错误日志<code>error_log</code>文件对<code>MYSQL</code>的启动、允许、关闭过程进行记录，在遇到问题时可以查看该文件进行问题的定位。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>​    慢查询日志<code>slow log</code>文件，可以在<code>MYSQL</code>启动时设置一个阈值，将执行时间超过该值的<code>SQL</code>语句都记录到慢查询文件中，通过查看该文件中的<code>SQL</code>语句来对系统中的慢查询进行优化处理。</p>
<p>默认情况下，<code>MYSQL</code>不开启慢查询日志：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启慢查询日志</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span></span><br><span class="line"><span class="comment">-- 查看慢查询的时间，多久认为是慢SQL 大于long_query_time才会认为是慢查询</span></span><br><span class="line"><span class="comment">-- 5.1版本之后long_query_time的单位改为微秒，5.1之前是秒</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_slow_queries&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果与语句没有使用到索引，都认为是慢查询</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.6.5 版本之后才有的参数，用来表示每分钟允许记录的未使用索引的SQL次数</span></span><br><span class="line"><span class="comment">-- 默认值为0，表示没有限制；在生产环境下，若过多的SQL语句没有使用索引，会导致</span></span><br><span class="line"><span class="comment">-- 频繁的将SQL记录到slow log表中，消耗性能和占用资源</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_throttle_queries_not_using_indexes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5.1 之后允许将慢查询SQL记录到TABLE中，便于开发者查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看记录的方式，默认是FILE</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_output&#x27;</span></span><br><span class="line"><span class="comment">-- 修改为TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;TABLE&#x27;</span></span><br><span class="line"><span class="comment">-- 通过MYSQL.slow_log 查看</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MYSQL.SLOW_LOG</span><br></pre></td></tr></table></figure>

<p>默认情况下<code>slow_log</code>表使用的是<code>CSV</code>引擎，如果数据量的情况下，查询效率可能不高，可以将<code>slow_log</code>表的引擎修改为<code>MyISAM</code>,并且对列<code>start_time</code>上添加索引来提交查询的效率。</p>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志文件<code>bin log</code>记录对数据执行的所有操作，但不包含<code>select</code>等查询操作，因为本质上查询并不会对数据本身进行修改。</p>
<p>但非查询语句又对数据没有产生变化，这类还是会被记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 比如：数据库中并没有名为marry的数据</span></span><br><span class="line">update user_info <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;marry&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>bin log</code>的主要作用为：</p>
<ul>
<li>恢复：比如对某些数据进行<code>DELETE</code>操作，可以通过使用<code>mysqlbinlog</code>工具对<code>bin log</code>文件中的的某些事件的起止节点或者时间的起止进行数据的恢复。</li>
<li>复制：常用的场景为主从模式下，主节点通过将<code>bin log</code>文件传递给从节点，然后从节点通过读取<code>bin log</code>文件的数据保证主从数据一致性。</li>
<li>审计：通过<code>bin log</code>文件中的信息进行审计，判断是否有对数据库注入的攻击。</li>
</ul>
<p>默认情况下二进制文件<code>binlog</code>是关闭的，需要手动开启，逻辑上是存在一定的性能消耗，但是根据官方测试结果数据来看，开启仅消耗使得性能下降1%左右。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看binlog存放位置</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;datadir&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示缓存区大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_cache_size&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用了临时文件写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_disk_use&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示使用缓存区写二进制日志的次数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Binlog_cache_use&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置文件中相应的配置参数</strong></p>
<ul>
<li><code>max_binlog_size</code>： 指定单个二进制文件的最大值。如果操作该值则产生新的二进制文件，<code>MYSQL5.0</code>之前默认值为<code>1.1G</code>，之后版本为<code>1G</code></li>
<li><code>binlog_cache_size</code>：在事务未提交的二进制日志会被记录到一个缓存区中，等到事务提交之后再写入到<code>binlog</code>中，缓存区默认大小为<code>32K</code>。且该参数是基于会话，也就是说当一个线程开启一个事务时，就会分配一个<code>binlog_cache_size</code>大小的缓存区。当事务中的记录容量超过该值时，<code>MySql</code>会将缓冲区中的日志写入到一个临时文件中。</li>
<li><code>sync_binlog</code>：默认情况下，并不是每次写的时候都将日志内容写入到磁盘中，所以当数据库发生宕机时，可能有部分缓存区的数据还未写入到磁盘中。<code>sync_binlog</code>这个参数就是用来控制写入到缓存多少次后将缓存中的日志数据同步到磁盘中。默认值为0</li>
<li><code> binlog_do-db</code>：表示需要写入那些库的日志</li>
<li> <code>binlog-ignore-db</code>：表示需要忽略那些库的日志</li>
</ul>
<p><strong>binlog_format</strong>：这个参数比较重要，单独罗列出来，表示记录到<code>binlog</code>日志的数据格式，在<code>MySql5.1</code>版本之后才有该参数。可选参数有：</p>
<ul>
<li><p><code>STATEMENT</code>：基于<code>SQL</code>语句记录。存在两个问题：</p>
<ul>
<li><p>如果主服务器使用了一些生成函数，比如<code>uuid</code>等，这时从服务器得到主服务器的<code>binlog</code>进行回放后会导致主从数据不一致。</p>
</li>
<li><p>由于<code>MySql</code>的<code>INnoDB</code>存储引擎的默认事务隔离级别是<code>RR(REPEATABLE READ)可重复读</code>。如果事务隔离级别不是<code>RR</code>,会出现一种情况是：</p>
<p>假设事务隔离级别为<code>RC</code>且有一个<code>user_info（id， name）</code>表和两个字段，且有两条数据<code>(1, &#39;tom&#39;), (2, &#39;marry&#39;)</code>，下表的两个事务执行之后的数据为<code>(3, &#39;tom&#39;), (2, &#39;tom&#39;)</code>，但是从服务器获取到的<code>binlog</code>中，由于事务B先提交，那么会先回放事务B的<code>SQL</code>语句，结果就变成了<code>(3, &#39;tom&#39;), (3, &#39;marry&#39;)</code>,从而导致主从数据不一致。所以有些人说<code>MySQL</code>为了避免这种情况，将事务的隔离级别默认设置为<code>RR</code>，但<code>Oracle</code>的默认事务隔离级别为<code>RC</code></p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>update T set id=3 where name=’tom’</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>Update T set name=’tom’ where name=’marry’</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>4</td>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>ROW</code>：不是简单的<code>SQL</code>语句，而是记录表所对应行数据的变化，也就是从某某修改为某某。假设<code>name=tom</code>的数据有1w条，那么采用<code>STATEMENT</code>仅记录一条<code>DELETE</code>语句，采用<code>ROW</code>则记录1w条日志记录，显然后者需要更大的磁盘空间。</p>
</li>
<li><p><code>MIXED</code>：混合模式，默认采用<code>STATEMENT</code>格式，指定一些情况使用<code>ROW</code>格式，比如使用了<code>uuid()</code>等生成函数，在<code>innodb</code>对表的数据进行增删改操作等等。</p>
</li>
</ul>
<p><strong>binlog的写入机制</strong></p>
<ol>
<li><code>binlog</code>的写入是利用事件触发执行机制，根据<code>binlog_format</code>格式和操作的类型触发<code>Log Event</code>事件。</li>
<li>将事务在执行过程中产生的所有<code>Log Event</code>写入到缓存区中，一个执行语句不一定都只对应一个<code>Log Event</code>，每个事务线程都有独立的缓存区。</li>
<li>事务提交后会将缓存区中的<code>Log Event</code>写入到<code>bin log</code>文件中。事务的写入是串行的方式，也就是说一个事务在写入的中间不会穿插其他事务的<code>Log Event</code>。</li>
</ol>
<h3 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h3><blockquote>
<p>重做日志redo log</p>
</blockquote>
<h3 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h3><p>​        </p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引优化</title>
    <url>/2022/07/29/mysql/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="mysql索引优化"><a href="#mysql索引优化" class="headerlink" title="mysql索引优化"></a>mysql索引优化</h1><p>​    描述使用<code>explain</code>命令中的每列所代表的含义，以及出现某些慢查询时的一些优化。</p>
<span id="more"></span>

<p>通过<code>explain</code>命令可以知道<code>MySQL</code>是怎么执行语句，包括有关如何连接表以及连接表的顺序、扫描的行数、是否使用索引、排序使用的是内存排序还是磁盘排序等等。所以一般的语句优化手段都是通过<code>explain</code>来查询语句的处理过程，修改全表扫描的语句，优化查询效率。</p>
<p><img src="https://s2.loli.net/2022/10/17/mPcMZU9QsSJ5z7K.png" alt="简单expain示例.png"></p>
<p><b>上图是一个最简单的<code>explain select * from xxx</code>的执行结果，以下依次解释每一项的含义</b></p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>假设执行语句为<code>explain select * from words where id in (select id from words where word like &#39;aa%&#39;)</code><br>输出结果为:<br><img src="https://s2.loli.net/2022/10/17/5LAeJ2RofKDiMVS.png" alt="expain查询id示例.png"></p>
<p>这里的<code>id</code>值有两个1和2，实际上对于这条查询语句来说，是先执行了括号内的查询，在将括号内的结果赋予外层查询语句进行第二次查询，所以在<code>expian</code>结果有两条记录，id值越高越先执行，id值相同时从上往下执行。</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>表示查询的类型：</p>
<ol>
<li><code>SIMPLE</code>: 简单语句，比如<code>select * from xxx </code>。</li>
<li><code>SUBQUERY</code>: 子查询</li>
<li><code>PRIMARY</code>: 主查询，最外层查询，表示最后一个到它</li>
<li><code>DERIVED</code>: 衍生表，查询语句中会生成新的表，比如<code>select * from words as t1, (select false) as t2</code></li>
<li><code>UNION</code>: 连接表</li>
<li><code>UNION RESULT</code>: 连接结果，一般与<code>UNION</code>配套出现</li>
</ol>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示某一个子查询使用到的表是什么，一般的查询语句直接就是某一个表，但是一些特殊处理，比如<code>select * from words as t1, (select false) as t2</code>这里的<code>table</code>就是空，因为它是临时生成的不是数据库中存在的表结构，再或者是使用<code>union</code>联合的时候，<code>select_type=UNION RESULT</code>的子查询是将两个查询结果联合，所以会标识是那两个id值所对应的查询进行联合<code>&lt;union id1, id2&gt;</code></p>
<p><img src="https://s2.loli.net/2022/10/17/7yjJrwtMZKVvqGh.png" alt="explain衍生表示例.png"></p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type表示连接类型，查看索引执行情况的一个重要指标。以下性能从好到坏依次：<br><code>system  &gt; const &gt; eq_ref &gt; ref  &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p>
<ol>
<li><code>system</code>：这种类型要求数据库表中只有一条数据，是const类型的一个特例，一般情况下是不会出现的。</li>
<li><code>const</code>：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，速度非常快。</li>
<li><code>eq_ref</code>：常用于主键或唯一索引扫描，一般指使用主键的关联查询</li>
<li><code>ref</code>：常用于非主键和唯一索引扫描。</li>
<li><code>ref_or_null</code>：这种连接类型类似于ref，区别在于MySQL会额外搜索包含NULL值的行</li>
<li><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</li>
<li><code>unique_subquery</code>：类似于eq_ref，条件用了in子查询</li>
<li><code>index_subquery</code>：区别于unique_subquery，用于非唯一索引，可以返回重复值。</li>
<li><code>range</code>：常用于范围查询，比如：between … and 或 In 等操作，如果是这个类型需要注意，可能会因为数据量的原因导致索引失效</li>
<li><code>index</code>：全索引扫描</li>
<li><code>ALL</code>：全表扫描</li>
</ol>
<h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p><code>possible_key</code>这个一般来说用不上，意思就是理论上可能会使用到的索引，但是实际执行时可能会用不上，说了等于没说。<br><code>key</code>表示使用到的索引。</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>使用的到的索引长度，<code>key_len</code>可以衡量索引的好坏，<code>key_len</code>越小，索引的效果越好，但是要注意如果索引是建立在一个字符串字段上，且字符串字段长度比较长，进行索引时可能会将字符串截断，也就是这一列的前n个字符参与索引。<br><code>MySQL innodb</code>引擎对于索引的长度是有限制的，最大为767字节，不同字符编码方式对应的字节数不一样，比如最常用的<code>utf8mb4</code>字符集是4字节字符集，767/4=191，所以在字符串上创建索引的前191字符才会参与索引。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>显示索引的哪一列被使用了，如果是<code>where word = &#39;name&#39;</code>，那么显示的就是<code>const</code></p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于<code>InnoDB</code>表，此数字是估计值，并非一定是个准确值，<code>InnoDB</code>的优化器也会通过需要扫描的行数来判断选择哪个索引。可以通过<code>analyze table t</code>命令，来重新统计索引信息。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>Using filesort</code>：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现。一般见于order by语句<br><code>Using index</code> ：表示是否用了覆盖索引。<br><code>Using temporary</code>： 表示是否使用了临时表,性能特别差，需要重点优化。一般多见于group by语句，或者union语句。<br><code>Using where</code> ： 表示使用了where条件过滤.<br><code>Using index condition</code>：MySQL5.6之后新增的索引下推。在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</p>
<h1 id="常用优化手段"><a href="#常用优化手段" class="headerlink" title="常用优化手段"></a>常用优化手段</h1><h3 id="1-in内容过多"><a href="#1-in内容过多" class="headerlink" title="1. in内容过多"></a>1. in内容过多</h3><p>使用<code>in</code>查询最好内容不要超过200个，因为<code>in</code>查询底层是通过<code>n*m</code>的方式去搜索，也就是每一个条件逐条遍历，默认临界值<code>eq_range_index_dive_limit=200</code>，如果超过这个值，可能会导致代价计算存在问题，从而导致<code>mySQL</code>选择的索引不准确。</p>
<h3 id="2-磁盘排序"><a href="#2-磁盘排序" class="headerlink" title="2. 磁盘排序"></a>2. 磁盘排序</h3><p>如果查询语句中存在<code>order by</code>但是<code>Extra</code>中没有<code>Using filesort</code>那么恭喜你，你的排序命中了索引，沿用了索引已然有序的特性直接查询出数据。但是实际情况并不是这么刚好，不命中索引的情况下，排序下的<code>Extra</code>的结果为<code>Using filesort</code>。排序分为全字段排序和<code>rowid</code>排序。至于是使用全字段排序和<code>rowid</code>排序主要影响因素是<code>max_length_for_sort_data</code>参数，当单行长度超过这个参数值时使用的就是<code>rowid</code>排序。<code>rowid</code>需要回表，查询性能比全字段查询差。</p>
<h3 id="3-不等号"><a href="#3-不等号" class="headerlink" title="3.不等号"></a>3.不等号</h3><p>查询使用不等号或者是<code>not in</code>这些时，索引形同虚设，这其实是被优化器处理了，因为优化器认为即便是走索引，还是需要扫描很多行，所以它觉得不划算，所以直接不走索引。还有<code>NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE</code>都会导致索引失效。</p>
<h3 id="4-group-by"><a href="#4-group-by" class="headerlink" title="4.group by"></a>4.group by</h3><blockquote>
<p>explain select wrod, num from words group by word</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/10/17/2aLHIpAiF6oYWuN.png" alt="排序explain.png"><br>可以看到在<code>Extra</code>中有<code>Using filesort</code>和<code>Using temporary</code>，表示使用到了排序和临时表。<br><code>group by</code>的执行流程：</p>
<ol>
<li>创建内存临时表，表里设置字段<code>(word, num)</code></li>
<li>全表扫描<code>words</code>，依次取出<code>word</code>的值，判断临时表中是否有这个值，如果没有就插入<code>（word, 1）</code>，如果有就对这一行的<code>num</code>加一。</li>
<li>遍历完成后，再对<code>word</code>排序后返回结果。</li>
</ol>
<p><b>优化方式：</b>可以对<code>group by</code>后面的字段添加索引，提高步骤1的执行效率；使用<code>order by null</code>，既然默认是要排序，那么手动设置为不要排序，提高步骤3的执行效率。</p>
<h3 id="5-delete-in"><a href="#5-delete-in" class="headerlink" title="5. delete + in"></a>5. delete + in</h3><p><code>delete form xx where xx in (xx)</code>这个删除语句不会命中索引，但是<code>select * form xx where xx in (xx) </code>这个是会命中索引的，原因是对于这个查询语句实际上将<code>SQL</code>优化为可以命中索引的方式。</p>
<h3 id="6-asc和desc"><a href="#6-asc和desc" class="headerlink" title="6. asc和desc"></a>6. asc和desc</h3><p>如果出现<code>asc</code>和<code>desc</code>混用，也会导致索引失效。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql问题汇总</title>
    <url>/2022/10/11/mysql/mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="MySQL单表数据数据最大两千万？"><a href="#MySQL单表数据数据最大两千万？" class="headerlink" title="MySQL单表数据数据最大两千万？"></a>MySQL单表数据数据最大两千万？</h2><p>相比大家也有听说过<code>MySQL</code>单表数据数据最大两千万，如果超过两千万数据库性能就会下降的说法。<span id="more"></span></p>
<p>其实这种说法的背后是索引高度的问题，<code>MySQL</code>索引内部使用的是<code>B+</code>树，叶子节点存具体的数据，非叶子节点是为了去叶子节点寻址。<code>MySQL</code>的数据是按页存储，每一页的大小是16k，读取的时候也是按页读取，也就是说就算你的语句里有<code>limit 1</code>，但是实际上也是将整页都加载到内存中。</p>
<p>这个16k大小的页包含有页头（页号，寻址指针等内容）、页尾（检验码等）、页目录（这一页内的数据目录，用于快速找到页内数据），剩下的空间就是存放具体的数据记录<code>record</code>。结合<code>B+</code>树的特性，非叶子节点内具体的数据记录<code>record</code>实际上存储的某一页的页号以及这一页的最小记录的<code>id</code>值。叶子节点内具体的数据记录<code>record</code>实际上存储的是行信息(再具体到存储的是行记录的多少内容，要看是什么索引)。</p>
<p>所以想查询某一行数据的主要过程：从索引的根往下找，先根据非叶子节点的<code>id</code>值匹配，匹配到对应的<code>id</code>值之后根据页号，找到对应的叶子节点，从而获取到整行数据。</p>
<p>当数据庞大时，树的叶子节点如果想要容纳所有数据就需要增加高度，高度越高，能容纳的数据量也就越大。同时也伴随着更多的磁盘io，一般3层索引树，会有3次磁盘io，并且是随机io。<br>这里有一个计算公式：<code>(x ^ (z-1)) * y</code></p>
<ul>
<li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li>
<li>叶子节点内能容纳的<code>record</code>数量为<code>y</code></li>
<li><code>B+</code>树的层数为<code>z</code></li>
</ul>
<p><b>x的值：</b>主键假设是bigint（8Byte），而页号在源码里叫FIL_PAGE_OFFSET（4Byte），那么非叶子节点里的一条数据是12Byte左右，整个数据页16k， 页头页尾那部分数据全加起来大概128Byte，加上页目录毛估占1k吧。那剩下的15k除以12Byte，等于1280，也就是可以指向x=1280页。<br><b>y的值：</b>叶子节点和非叶子节点结构是一致的，这里也假设记录可用空间为15k，假设一行数据需要占用1k空间，那么叶子节点可用容纳15行的数据。</p>
<p>根据公式：<br>若z=2，则(1280 ^ (2-1)) * 15 ≈ 2w<br>若z=3，则(1280 ^ (3-1)) * 15 ≈ 2.5kw<br>这里的<code>2.5kw</code>也就是通常说的单表数据不要超过2kw的估值，如果高度再加一层，那么所能容纳的数据量就更加庞大。但是你有没有发现，我假设了单行数据的空间是1k，如果表字段不多，单行数据仅0.25k呢，那么这个计算结果就是1亿，也就是在三层高度的情况下，数据量也有可能达到1亿。</p>
<h2 id="随机IO-顺序IO"><a href="#随机IO-顺序IO" class="headerlink" title="随机IO/顺序IO"></a>随机IO/顺序IO</h2><p>顺序IO是指读写操作的访问地址连续。随机IO是指读写操作的时间连续，但访问的地址不连续。</p>
<h2 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h2><p>深度分页涉及到的问题通常是使用<code>limit offset, size</code>，对于<code>limit 10, 10</code>和<code>limit 10000, 10</code>，性能上前者是快于后者的，这是因为后者也是需要查出10000条数据，然后丢弃掉，再往后获取10条数据，也就是说前者总共获取了20条数据，后者获取了10010条数据。</p>
<p>这种情况其实是无解的，因为这是<code>MySQL</code>的内部逻辑，我们根本就触及不到，但是在一定条件下，可以通过一定的手段进行优化。假设有语句：</p>
<blockquote>
<p>select * from page order by id limit 10000, 10;</p>
</blockquote>
<p>这条查询语句还是有优化空间的，由于这里需要查询整行数据，也就导致了丢弃的10000行数据也去查询了整行数据，实际上这是没有必要的。<br>优化如下，虽然它也是会获取那丢弃的10000条数据，但是这10000条数据仅获取了id值，并没有获取整行数据，当行数据比较长时，还是会有一定的性能提升。</p>
<blockquote>
<p>select * from page  where id &gt;=(select id from page  order by id limit 10000, 1) order by id limit 10; </p>
</blockquote>
<p>再看在非主键索引上的操作：</p>
<blockquote>
<p>select * from page order by user_name  limit 10000, 10;</p>
</blockquote>
<p>这里由于是非主键索引，所以会对这丢弃的10000条数据都进行一次回表操作，影响性能。可以通过连接来优化，减少回表次数：</p>
<blockquote>
<p>select * from page t1, (select id from page order by user_name limit 10000, 10) t2  WHERE t1.id = t2.id;</p>
</blockquote>
<p>前面的优化实际上也都会查询丢弃的10000条数据，所以这里再怎么优化都是治标不治本的优化手段。所以只能通过一些特殊手段控制，比如百度、淘宝的搜索页只会固定页码，到一定页码之后就不允许往后页码查。再比如抖音这种这种滚动下只有翻页没有跳页，可以将当前页设置一个最小值，下一页在这个最小值的基础上查询。这也是同步大表时的一个手段。</p>
<p>如果同步一个大表，你使用的是<code>select * from tableName</code>，同步到异构系统，比如es等，因为数据量比较大，数据库无法一次性获取到所有数据而报错，如果仅仅通过<code>limit offset, size</code>就有可能出现深度分页的情况，所以一般来说可以通过<code>id</code>排序，将<code>id</code>对应的记录分块，当前块的最大<code>id</code>值，作为下一块<code>id</code>的查询条件。</p>
<blockquote>
<p>select * from tableName where id &gt; 上一块id的最大值 order by id limit 100</p>
</blockquote>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos简单入门</title>
    <url>/2022/10/27/nacos/nacos%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="nacos入门"><a href="#nacos入门" class="headerlink" title="nacos入门"></a>nacos入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近闲来无事看到一篇关于<code>DynamicTp</code>动态可监控线程池框架，也去<code>DynamicTp</code>官网看了一下，发现原来跟<code>Hutool</code>出自同一个社区，想着上手试试，看了下官网的『使用步骤』发现需要引入配置中心，在工作中<code>apollo</code>已经使用比较多，所以这次想尝试一下使用<code>nacos</code>。<span id="more"></span></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>​    因为我使用的是<code>mac</code>，且安装了<code>docker</code>和<code>kitematic</code>，本以为只需要从容器仓库中拉一个<code>nacos</code>的镜像就大工告成，没想到，事情没有我想象的那么顺利，还是一波三折。</p>
<p>​    通过<code>kitematic</code>直接搜索<code>nacos</code>镜像，并下载启动。</p>
<p><img src="https://s2.loli.net/2022/10/27/DqZVrThs5FeLSip.png" alt="nacos部署.png"></p>
<p>启动后直接报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No DataSource set</span><br><span class="line">	at com.alibaba.nacos.config.server.service.dump.DumpService.dumpOperate(DumpService.java:236)</span><br><span class="line">	at com.alibaba.nacos.config.server.service.dump.ExternalDumpService.init(ExternalDumpService.java:52)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)</span><br><span class="line">	... 53 common frames omitted</span><br></pre></td></tr></table></figure>

<p>看报错信息，大概率是数据连接的问题，到目前为止，容器是镜像下载之后直接启动的，我并没有配置数据库连接相关信息，到这里，我第一反应是将<code>nacos</code>的部分文件/文件夹挂载到宿主机，修改是也方便，但是对于容器的修改挂载点有点复杂，有的说去修改底层的那个<code>config.v2.json</code>文件，有的说通过<code>export</code>修改，不知道是我操作有问题还是怎么样，我尝试了之后是没有成功。后面我是将这个运行容器删掉，利用镜像重新启动一个容器，这时就可以指定对应的挂载卷，本来想把整个<code>/nacos</code>文件夹都挂载出来，但是指定之后，死活报错，某个文件找不到，启动失败，无奈只能走最下策，进入容器操作。</p>
<p>所以进入容器中，查看相关配置信息。</p>
<p>进入容器中定位到<code>/home/nacos/conf/application.properties</code>，不同容器应该会不太一样，但是大概率是在<code>~/nacos/conf</code>文件夹。</p>
<p>想将<code>conf</code>文件夹下的数据库脚本文件<code>shcema.sql</code>脚本，拿到数据库中执行之后，在修改<code>application.properties</code>文件。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">$&#123;SERVER_SERVLET_CONTEXTPATH:/nacos&#125;</span></span><br><span class="line"><span class="meta">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">$&#123;NACOS_APPLICATION_PORT:8848&#125;</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">$&#123;SPRING_DATASOURCE_PLATFORM:mysql&#125;</span></span><br><span class="line"><span class="meta">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="meta">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="meta">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">$&#123;MYSQL_DATABASE_NUM:1&#125;</span></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://$&#123;MYSQL_SERVICE_HOST:docker.for.mac.host.internal&#125;:$&#123;MYSQL_SERVICE_PORT:32786&#125;/$&#123;MYSQL_SERVICE_DB_NAME:nacos&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=10000&amp;socketTimeout=30000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&#125;</span></span><br><span class="line"><span class="comment"># db.url.1=jdbc:mysql://$&#123;MYSQL_SERVICE_HOST&#125;:$&#123;MYSQL_SERVICE_PORT:3306&#125;/$&#123;MYSQL_SERVICE_DB_NAME&#125;?$&#123;MYSQL_SERVICE_DB_PARAM:characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&#125;</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">$&#123;MYSQL_SERVICE_USER:root&#125;</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">$&#123;MYSQL_SERVICE_PASSWORD:root&#125;</span></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">$&#123;NACOS_AUTH_SYSTEM_TYPE:nacos&#125;</span></span><br></pre></td></tr></table></figure>

<p>填写上数据库相关信息之后，重启还是报错，在这个地方磨了好久，一直想不明白为什么数据库连接不上。</p>
<p>这里主要原因是因为我的<code>mysql</code>数据库不是直接安装在本机上，也是通过<code>docker</code>容器部署，所以我最开始的时候通过<code>nacos</code>容器去<code>ping</code>连接<code>mysql</code>的容器，在<code>ping</code>通的情况下，我以为<code>nascos</code>容器通过<code>mysql</code>容器的<code>ip</code>可以直接访问到数据库。一直报错之后，使用<code>telnet</code>命令查看端口是否可访问时，报错了，才发现了问题。</p>
<p>按我理解，访问不到的原因可能是如果<code>ip</code>写的是<code>mysql</code>容器的<code>ip</code>，那么端口应该写哪个合适?是写容器对应开放的端口，还是写宿主机绑定的端口？我两种都尝试了一次，结果都是访问不到。所以将访问<code>ip</code>修改为访问宿主机<code>ip</code>+宿主机绑定<code>mysql</code>容器的端口，这种方式是可以访问到的。</p>
<p>这里必须安利一波<code>mac</code>上的<code>docker</code>和<code>kitematic</code>，基本上所有的类似组件，比如<code>rabbitmq</code>，<code>mysql</code>，<code>redis</code>，<code>jenkins</code>，<code>nexus3</code>等我都是通过容器化部署，只需要把对应的数据卷挂载到宿主机，保证重启是数据不丢失即可，好处当然多多，一是干净，二是简单。</p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><blockquote>
<p>127.0.0.1:4567/nacos/index.html</p>
</blockquote>
<p><code>nacos</code>的默认账号和密码都是<code>nacos</code></p>
<p><img src="https://s2.loli.net/2022/10/27/IM5EVBWFh98iYw4.png" alt="nacos登录页.png"></p>
<p>在<code>nacos</code>中有命名空间和分组的概念，每一个命名空间中可以划分多个组，在<code>spring</code>配置文件中，可以指定需要拉取哪个命名空间下的那个组的配置。</p>
<p>通过『命名空间』创建<code>dev</code>、<code>test</code>命名空间之后，在『配置列表』会显示出对应的命名空间。</p>
<p><img src="https://s2.loli.net/2022/10/27/ymrj5ZHOnDb7cpo.png" alt="nacos配置列表.png"></p>
<h2 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h2><p>引入<code>nacos</code>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动类启用<code>nacos</code>配置注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@NacosPropertySource(dataId = &quot;simple-dev-yaml&quot;, groupId = &quot;DEV_GROUP&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootSimpleApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootSimpleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件添加<code>nacos</code>服务器访问地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">nacos.config.server-addr</span>=<span class="string">127.0.0.1:4567</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NacosValue(value = &quot;$&#123;useLocalCache:false&#125;&quot;, autoRefreshed = true)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useLocalCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useLocalCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是想使用一下<code>nacos</code>，所以采用的都是最简单的写法，写死的方式指定了<code>dataId</code>和<code>groupId</code>，在实际的使用中一般都是使用配置文件来进行管理。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>nacos</category>
      </categories>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2020/04/13/nginx/nginx/</url>
    <content><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p><code>nginx.conf</code>是<code>nginx</code>的主要配置文件。</p>
<ol>
<li>顶层下可以有<code>events</code>、<code>http</code>层。</li>
<li><code>http</code>层下允许有多个<code>server</code>层，用于对不同的网址做不同的配置。</li>
<li><code>server</code>层下允许有多个<code>location</code>层，用于对不同的(路由)地址进行不同的转发操作。</li>
</ol>
<p>修改完<code>nginx.conf</code>配置文件后，可以使用如下命令对进行语法检查。</p>
<blockquote>
<p>nginx -t -c /etc/nginx/nginx.conf</p>
</blockquote>
<span id="more"></span>

<h2 id="nginx模块"><a href="#nginx模块" class="headerlink" title="nginx模块"></a>nginx模块</h2><table>
<thead>
<tr>
<th>nginx编译选项</th>
<th>模块作用</th>
</tr>
</thead>
<tbody><tr>
<td>ngx_http_core_module</td>
<td>包含一些核心的http的参数配置，对应nginx的配置区块部分</td>
</tr>
<tr>
<td>ngx_http_access_module</td>
<td>访问控制模块，用来控制网站用户对nginx的访问</td>
</tr>
<tr>
<td>ngx_http_gzip_module</td>
<td>压缩模块，对nginx返回的数据压缩，数据性能优化模块</td>
</tr>
<tr>
<td>ngx_http_fastcgi_module</td>
<td>fastcgi模块，和动态应用相关的模块</td>
</tr>
<tr>
<td>ngx_http_upstream_module</td>
<td>负载均衡模块，可以实现网址的负载均衡功能以及节点节点健康检查</td>
</tr>
<tr>
<td>ngx_http_rewrite_module</td>
<td>URL地址重写模块</td>
</tr>
<tr>
<td>ngx_http_proxy_module</td>
<td>proxy代理模块</td>
</tr>
<tr>
<td>ngx_http_limit_conn_module</td>
<td>限制用户并发连接数以及请求数模块</td>
</tr>
<tr>
<td>ngx_http_limit_req_module</td>
<td>限制nginx request processing rate根据定义的key(限制请求，一个连接可以有多个请求)</td>
</tr>
<tr>
<td>ngx_http_log_module</td>
<td>访问日志模块，指定的格式记录nginx客户访问日志等信息</td>
</tr>
<tr>
<td>ngx_http_auth_basic_module</td>
<td>web认证模块，这只web用户通过账号密码访问nginx</td>
</tr>
<tr>
<td>ngx_http_ssl_module</td>
<td>ssl模块，用户加密的http连接，比如https</td>
</tr>
</tbody></table>
<p>在<code>nginx.conf</code>中有三种常见变量：<code>http</code>请求变量、<code>nginx</code>内置变量、自定义变量。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$uri: 当前请求的uri，不带参数</span><br><span class="line">$request_uri: 请求的uri，带完整参数</span><br><span class="line">$host: http请求报文中host首部，如果没有则以处理此请求的虚拟主机名代替</span><br><span class="line">$hostname: nginx服务运行在主机的主机名</span><br><span class="line">$remote_addr: 客户端ip</span><br><span class="line">$remote_port: 客户端端口</span><br><span class="line">$remote_user: 使用用户认证时客户端用户输入的用户名</span><br><span class="line">$request_filename: 用户请求中的URI经过本地root或alias转换后映射的本地文件路径</span><br><span class="line">$request_method: 请求方法，GET、POST、PUT、DELETE</span><br><span class="line">$server_addr: 服务器地址</span><br><span class="line">$server_name: 服务器名称</span><br><span class="line">$server_port: 服务器端口</span><br><span class="line">$server_protocol: 服务器向客户端发送响应时的协议</span><br><span class="line">$scheme: 在请求中使用scheme</span><br><span class="line">$http_HEADER: 匹配请求报文中指定的HEADER</span><br><span class="line">$http_host: 匹配请求报文中的host首部</span><br><span class="line">$document_root: 当前请求映射到root的配置</span><br></pre></td></tr></table></figure>

<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>通过内置变量，对访问的请求进行日志输出。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="comment"># 日志输出格式</span></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line">$remote_addr: 客户端地址</span><br><span class="line">$remote_user: http客户端请求nginx认证用户名</span><br><span class="line">$time_local: nginx的时间</span><br><span class="line">$request: request请求行，GET等方法，http协议等</span><br><span class="line">$status: response 返回状态码</span><br><span class="line">$body_bytes_sent: 服务端响应给客户端body信息大小</span><br><span class="line">$http_referer: http上一级页面</span><br><span class="line">$http_user_agent: http头部,客户端访问设备</span><br><span class="line">$http_x_forwarded_for: http请求携带的http信息</span><br></pre></td></tr></table></figure>

<h3 id="监控模块"><a href="#监控模块" class="headerlink" title="监控模块"></a>监控模块</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 监控</span></span><br><span class="line">        <span class="attribute">location</span> /mystatus &#123;</span><br><span class="line">      			<span class="comment"># 启用监控</span></span><br><span class="line">            <span class="attribute">stub_status</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置<code>stub_sattus on</code>之后，就可以通过<code>localhost:80/mystatus</code>访问监控内容。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前活跃连接数</span></span><br><span class="line"><span class="attribute">Active</span> connections: <span class="number">2</span></span><br><span class="line">server accepts handled requests</span><br><span class="line"><span class="number">16</span> <span class="number">16</span> <span class="number">19</span></span><br><span class="line"><span class="comment"># server表示nginx启动到现在共处理了多少次连接</span></span><br><span class="line"><span class="comment"># accepts nginx启动到现在共成功创建了16次握手，请求的丢失数=握手数-连接数</span></span><br><span class="line"><span class="comment"># handled requests 总共处理了19次请求</span></span><br><span class="line">Reading <span class="comment"># nginx读取到客户端的header信息数</span></span><br><span class="line">Writing <span class="comment"># nginx返回给客户端的header信息数</span></span><br><span class="line">Waiting <span class="comment"># nginx开启keep-alive长连接情况下，既没有读也没有写</span></span><br></pre></td></tr></table></figure>

<p>一般可以通过在<code>shell</code>脚本中通过<code>curl</code>获取到这些监控信息后，再通过<code>python</code>将这些信息上报到监控平台组件(<code>openfalcon</code>)，达到可视化监控<code>nginx</code>连接情况的目的。</p>
<h3 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h3><p>将<code>nginx</code>作为资源服务器，提供文件下载功能。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 下载站点</span></span><br><span class="line">        <span class="attribute">location</span> /down &#123;</span><br><span class="line">      		  <span class="comment"># 指向服务器的资源目录</span></span><br><span class="line">            <span class="attribute">root</span> /soft/package/src;</span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="comment"># 显示文件时间</span></span><br><span class="line">            <span class="attribute">autoindex_localtime</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="comment"># 默认是on 显示的是byte off:文件大概大小单位是kb、mb、gb</span></span><br><span class="line">            <span class="attribute">autoindex_exact_size</span> <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限流模块"><a href="#限流模块" class="headerlink" title="限流模块"></a>限流模块</h3><ul>
<li>连接频率限制<code>ngx_limit_conn_module</code>，通过<code>limit_req_zone</code>用来限制单位时间内的请求数目，以及速度限制。</li>
<li>请求频率限制<code>ngx_limit_req_module</code>，通过<code>limit_req_conn</code>用来限制同一时间连接数，即并发限制。</li>
</ul>
<p>对于<code>http</code>协议的连接和请求：<code>Http</code>是建立在<code>TCP</code>，通过<code>TCP</code>三次握手，在连接的基础上进行<code>Http</code>请求，也就是说可能存在一个连接多次请求。</p>
<table>
<thead>
<tr>
<th>HTTP协议版本</th>
<th>连接关系</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP1.0</td>
<td>TCP不能复用</td>
</tr>
<tr>
<td>HTTP1.1</td>
<td>顺序性TCP复用</td>
</tr>
<tr>
<td>HTTP2.0</td>
<td>多路复用TCP</td>
</tr>
</tbody></table>
<h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nobody;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 第一个参数: $binary_remote_addr,表示通过它来做标识,也就是说多次连接时如何判定是同一个机器发起</span></span><br><span class="line">    <span class="comment"># 第二个参数: 表示生成一个大小为1M, 名字为req_zone的内存区域, 用来存储访问的频次</span></span><br><span class="line">    <span class="comment"># 第三个参数: 表示连接频率, 1r/s表示每秒1次</span></span><br><span class="line">    <span class="comment"># 第四个参数: 表示缓存区大小, 这里表示当有大量请求时, 超过了访问频次rate的限制, 先将请求放入缓存区</span></span><br><span class="line">    <span class="comment"># 第四个参数: nodelay表示当burst占满时的策略, 如果配置了nodelay, 会立即执行burst中的请求, 若没有配置nodelay, 则表示会按照rate的速率进行请求处理。</span></span><br><span class="line">    <span class="attribute">limit_req_zone</span> $binary_remote_addr zone=req_zone:<span class="number">1m</span> rate=1r/s burst=<span class="number">3</span> nodelay;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            <span class="comment"># location中引用全局定义的请求限制</span></span><br><span class="line">            <span class="attribute">limit_req</span> zone=req_zone;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单实例</strong></p>
<p>1.每个<code>IP</code>在每秒内只能访问2次。(<code>nginx</code>的时间处理单位是毫秒，也就是说会将每秒2次转换为每500毫秒1次)</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> $binary_remote_addr zone=limitTest:<span class="number">10m</span> rate=2r/s;</span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">location</span> / &#123; </span><br><span class="line">        <span class="attribute">limit_req</span> zone=limitTest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.添加请求缓存区，这时表示每个<code>IP</code>最多允许4个突发请求。假设某个<code>IP</code>在10ms内发送了6个请求，这时第一个请求被立即执行，第2~5个放入缓存区，第6个直接拒绝。这时由于没有配置<code>nodelay</code>，所以缓存区中的4个请求会按照<code>rate</code>的速率慢慢执行。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> $binary_remote_addr zone=limitTest:<span class="number">10m</span> rate=2r/s;</span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">location</span> / &#123; </span><br><span class="line">        <span class="attribute">limit_req</span> zone=limitTest burst=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.添加<code>nodelay</code>参数，通过设置<code>burst</code>可以允许<code>nginx</code>进行一定程度的并发，多余的请求会进入缓存区，慢慢处理，起到了对抗一些突发流量的目的，但是如果队列设置比较大，那么根据<code>rate</code>速率执行的时间比较长，就会导致用户等待时间加大。这里可以通过配置<code>nodelay</code>参数，表示缓存区中的请求立即执行，无需等待<code>rate</code>速率。</p>
<p>​    借用示例2中的例子，假设某个<code>IP</code>在10ms内发送了6个请求，这时第一个请求被立即执行，第2<del>5个放入缓存区，第6个直接拒绝。这时由于配置了<code>nodelay</code>，第1</del>5基本上可以说是同时执行。所以这种情况下，系统的瞬时<code>QPS</code>会超过<code>rate</code>设置的阈值。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> $binary_remote_addr zone=limitTest:<span class="number">10m</span> rate=2r/s;</span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">location</span> / &#123; </span><br><span class="line">        <span class="attribute">limit_req</span> zone=limitTest burst=<span class="number">4</span> nodelay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>对比2和3：</b>从例子的结果来看，示例2和示例3的请求处理的个数是一致的，只不过示例3的花费时间减少了。但是虽然<code>burst</code>和<code>nodelay</code>能够降低突发请求的处理事件，但是长期来看并不会提高吞吐量的上限。长期吞吐率是由<code>rate</code>决定，因为<code>nodelay</code>只能保证<code>burst</code>缓存中的请求被立即执行，但是<code>nginx</code>会限制队列元素的释放速度。</p>
<h4 id="连接限制"><a href="#连接限制" class="headerlink" title="连接限制"></a>连接限制</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nobody;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 全局定义连接限制</span></span><br><span class="line">    <span class="attribute">limit_conn_zone</span> $binary_remote_addr zone=conn_zone:<span class="number">10m</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            <span class="comment"># 同一时刻只允许一个客户端ip连接</span></span><br><span class="line">            <span class="attribute">limit_conn</span> zone=conn_zone <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问ip的配置语法</span></span><br><span class="line"><span class="attribute">allow</span> ipaddress | CIDR | unix: | all;</span><br><span class="line"><span class="comment"># 拒绝访问ip的配置语法</span></span><br><span class="line"><span class="attribute">deny</span> ipaddress | CIDR | unix: | all;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝某个ip的访问 其他的全部允许</span></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">root</span>   html;</span><br><span class="line">          <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">          <span class="attribute">deny</span> <span class="number">192.168.1.1</span>;</span><br><span class="line">          <span class="attribute">allow</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许某个网段       </span></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">root</span>   html;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">      <span class="attribute">allow</span> <span class="number">192.168.1.0</span>/<span class="number">24</span>;</span><br><span class="line">      <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h4><p><code>nginx</code>也提供了简单的基于<code>http</code>基本身份认证</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">root</span>   html;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">      <span class="attribute">auth_basic</span> <span class="string">&quot;please!&quot;</span>;</span><br><span class="line">      <span class="attribute">auth_basic_user_file</span> /etc/nginx/auth_conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用参数解析"><a href="#常用参数解析" class="headerlink" title="常用参数解析"></a>常用参数解析</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> 代理地址(域名)   <span class="comment"># 当前服务器能访问地址</span></span><br><span class="line">proxy_buffering <span class="literal">on</span> | <span class="literal">off</span>  <span class="comment"># 缓冲区</span></span><br><span class="line"><span class="comment"># 缓冲区大小配置</span></span><br><span class="line">proxy_buffer_size</span><br><span class="line">proxy_buffers</span><br><span class="line">proxy_busy_buffer_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳转重定向</span></span><br><span class="line">proxy_redirect default | <span class="literal">off</span> | <span class="literal">redirect</span> replacement</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置头信息</span></span><br><span class="line">proxy_set_header Host $proxy_host</span><br><span class="line">proxy_set_header Connection close</span><br><span class="line"><span class="comment"># 添加请求头</span></span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span> always;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置代理到后端的TCP超时时间</span></span><br><span class="line"><span class="attribute">proxy_connection_timeout</span> time</span><br><span class="line"><span class="comment"># 建立连接时间</span></span><br><span class="line">proxy_read_timeout time</span><br><span class="line"><span class="comment"># 服务端请求完 发送给客户端的时间</span></span><br><span class="line">proxy_send_timeout</span><br></pre></td></tr></table></figure>

<p>部分参数配置参考</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxy_redirect</span> default;</span><br><span class="line"><span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">30</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span> <span class="number">60</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">128k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line"><span class="attribute">proxy_max_temp_file_size</span> <span class="number">256k</span>;</span><br></pre></td></tr></table></figure>

<h4 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a>location匹配规则</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">location [ = | ^~ | ~ | ~* ] /uri/ &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>=</code>：表示精确匹配</li>
<li><code>^~</code>：表示uri以一个常规字符串开头</li>
<li><code>~</code>：表示区分大小写的匹配规则</li>
<li><code>~*</code>：表示不区分大小写</li>
<li><code>!~</code>和<code>!~*</code>：表示区分大小写不匹配或者不区分大小写不匹配规则</li>
<li><code>/</code>：通用匹配，任何请求都可以匹配到</li>
</ul>
<p>匹配优先级顺序：首先匹配<code>=</code>,其次匹配<code>^~</code>,接着按顺序匹配正则表达式，最后最后匹配<code>/</code>,当有匹配成功则停止匹配。</p>
<p>假设<code>nginx.conf</code>中配置的顺序如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">    <span class="comment"># A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> = /login &#123;</span><br><span class="line">    <span class="comment"># B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /static/ &#123;</span><br><span class="line">    <span class="comment"># C</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png|js|css)$</span> &#123;</span><br><span class="line">    <span class="comment"># D</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.png$</span> &#123;</span><br><span class="line">    <span class="comment"># E</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> !<span class="regexp">~ \.xhtml$</span> &#123;</span><br><span class="line">    <span class="comment"># F</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> !<span class="regexp">~* \.xhtml$</span> &#123;</span><br><span class="line">    <span class="comment"># G</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="comment"># H</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>http://localhost/</code>→ 匹配A</li>
<li><code>http://localhost/login/</code> → 匹配B</li>
<li><code>http://localhost/register</code> → 匹配H</li>
<li><code>http://localhost/static/a.html</code> → 匹配C</li>
<li><code>http://localhost/a.png</code> → 匹配规则D</li>
<li><code>http://localhost/a.PNG</code> → 匹配规则E</li>
<li><code>http://localhost/a.xhtml</code> → 匹配规则H</li>
<li><code>http://localhost/category/id/1111</code> → 匹配规则H</li>
</ol>
<p>也可以通过内置变量获取一些特定值进行路由控制。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lcaiton</span> /&#123;</span><br><span class="line">    if($http_user_agent ~* &quot;android&quot;)&#123;</span><br><span class="line">        <span class="comment"># 访问安卓站点</span></span><br><span class="line">    &#125;</span><br><span class="line">    if($http_user_agent ~* &quot;iphone&quot;)&#123;</span><br><span class="line">        <span class="comment"># 访问苹果站点</span></span><br><span class="line">    &#125;</span><br><span class="line">    if($http_user_agent ~* &quot;Safari&quot;)&#123;</span><br><span class="line">        <span class="comment"># safari站点</span></span><br><span class="line">    &#125;</span><br><span class="line">    if($http_user_agent ~* &quot;firefox&quot;)&#123;</span><br><span class="line">        <span class="comment"># 访问火狐站点</span></span><br><span class="line">    &#125;</span><br><span class="line">    if($http_user_agent ~* &quot;chrome&quot;)&#123;</span><br><span class="line">        <span class="comment"># 访问谷歌站点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>root、alias和proxy_pass的区别：</b></p>
<ul>
<li><code>root</code>直接将<code>location</code>后匹配规则拼接到<code>root</code>后面进行访问。</li>
<li><code>alias</code>别名，将<code>location</code>后匹配规则与<code>alias</code>替换。</li>
<li><code>proxy_pass</code>转发到其他服务器上</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /proxy_file&#123;</span><br><span class="line">        <span class="attribute">root</span> /soft/code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 访问http://127.0.0.1/proxy_file 实际访问-&gt;http://127.0.0.1/soft/code/proxy_file</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /proxy_file&#123;</span><br><span class="line">        <span class="attribute">ailas</span> /soft/code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 访问http://127.0.0.1/proxy_file 实际访问-&gt;http://127.0.0.1/soft/code </span></span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /proxy_file&#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http:<span class="number">192.168.1.1:8080</span>/proxy_file;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 访问http://127.0.0.1/proxy_file/xxx 实际访问-&gt;http:192.168.1.1:8080/proxy_file</span></span><br></pre></td></tr></table></figure>

<h2 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h2><p>​    在<code>nginx</code>中使用<code>upstream</code>模块设置负载均衡器。通过<code>upstream</code>设置两台服务器地址，在<code>server</code>中配置反向代理。默认情况下<code>upstream</code>采用轮询的方式。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># testName这个名字可以随便起，但是要尽量符合服务器的用途和域名</span></span><br><span class="line"><span class="attribute">upstream</span> testName &#123; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.1:8090</span>; </span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.1.2:8090</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://testName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>nginx</code>也能进行四层转发，使用的是<code>stream</code>，区别于<code>upstream</code>。可以实现端口到端口的转发。</p>
<h2 id="静态资源配置"><a href="#静态资源配置" class="headerlink" title="静态资源配置"></a>静态资源配置</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片格式采用压缩方式</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jgp|gif|png)$</span> &#123;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 压缩参数值范围1~9, 很多资料都建议4~5</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment"># 对那些请求方式生效</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/json application/x-javascript image/gif</span><br><span class="line">    root /soft/code/images;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># cache js css</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jgp|gif|png)$</span> &#123;</span><br><span class="line">    <span class="comment"># 缓存30天</span></span><br><span class="line">    <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 缓存文件夹</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ ^/(images/js/css/static)/</span> &#123;</span><br><span class="line">    <span class="comment"># 缓存30天</span></span><br><span class="line">    <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 解决跨域</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(html|htm)$</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Access_Control_Allow_Orgin 地址</span><br><span class="line">    add_header Access_Control_Allow_Methods GET,POST,DELETE,OPTIONS</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 防盗链</span></span><br><span class="line"><span class="comment"># valid_referers 会根据请求头部的内容分配一个值为0或1给变量$invalid_referer,如果</span></span><br><span class="line"><span class="comment"># 请求头部中的referer不符合valid_referers,则变量$invalid_referer会被设置为1</span></span><br><span class="line"><span class="comment"># none 表示头部没有referer</span></span><br><span class="line"><span class="comment"># bolcked 表示被防火墙或者代理去除了</span></span><br><span class="line"><span class="comment"># servername 匹配规则</span></span><br><span class="line">location <span class="regexp">~ .*\.(jgp|gif|png)$</span> &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> 域名/ip</span><br><span class="line">    if($invalid_referer)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /soft/code/images;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 视频</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(mp4|avi|flv)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /soft/code/mp4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><p>通常简单压测可以使用<code>ab</code>工具进行压测。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n 总的请求次数</span></span><br><span class="line"><span class="comment"># -c 并发请求数</span></span><br><span class="line"><span class="comment"># -k 是否开启长链接</span></span><br><span class="line">ab -n 200 -c 2 http://localhost/</span><br></pre></td></tr></table></figure>

<p>如果服务器被别人使用<code>ab</code>压测工具也可以使用<code>nginx</code>进行简单预防。在没有模拟<code>agent</code>的情况下，可以使用这种方式阻止请求访问。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /&#123;</span><br><span class="line">    if($http_user_agent ~&quot;Wget|ApacheBench&quot;)&#123;</span><br><span class="line">        <span class="attribute">set</span> $block_user_agent <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    if($block_user_agent = 1)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下配置文件为<code>nginx</code>初始配置文件<code>nginx.conf</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用的用户和组</span></span><br><span class="line"><span class="attribute">user</span>  nobody;</span><br><span class="line"><span class="comment"># 指定工作衍生进程数(一般为CPU总核心数或者总核数的两倍)</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定错误日志存放路径 日志级别为[info | debug | warn | notice | error | crit]</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx主进程pid存放路径</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 允许连接数(每个worker进程支持的连接数)</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">    <span class="comment"># 内核模型 select poll epoll</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="comment"># 日志输出格式</span></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx之proxy_pass</title>
    <url>/2023/09/13/nginx/nginx%E4%B9%8Bproxy_pass/</url>
    <content><![CDATA[<h1 id="nginx之proxy-pass"><a href="#nginx之proxy-pass" class="headerlink" title="nginx之proxy_pass"></a>nginx之proxy_pass</h1><ul>
<li>往期回顾：<a href="https://xiaocainiaoya.github.io/2020/04/13/nginx/nginx/">nginx</a></li>
</ul>
<p><code>proxy_pass</code>是<code>nginx</code>中常见的反向代理指令。</p>
<blockquote>
<p>格式：proxy_pass {传输协议}{主机名}{URI}</p>
</blockquote>
<ul>
<li>传输协议：<code>http://</code>或者<code>https://</code></li>
<li>主机名：<code>IP:PORT</code></li>
<li><code>URI</code>：具体的访问地址</li>
</ul>
<span id="more"></span>

<p>先下结论：</p>
<p>当<code>URI</code>是<code>\</code>时，表示是绝对路径，则不会将<code>location</code>后的匹配规则路径携带到转发目标路径中。</p>
<p>当<code>URI</code>为空时，表示是相对路径，则会将<code>location</code>后的匹配规则路径携带到转发目标路径中。</p>
<p>假设访问地址是：<code>http:test.nginx.com/proxy/getUserName</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.URI=/,表示是绝对路径。所以最终的访问地址是: http://127.0.0.1:81/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">	<span class="attribute">proxy_pass</span> http://127.0.0.1:81/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.URI=空,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/proxy/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">	<span class="attribute">proxy_pass</span> http://127.0.0.1:81;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.URI=/v1,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/v1getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">	<span class="attribute">proxy_pass</span> http://127.0.0.1:81/v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.URI=/v1/,表示是相对路径。所以最终的访问地址是: http://127.0.0.1:81/v1/getUserName</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">	<span class="attribute">proxy_pass</span> http://127.0.0.1:81/v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上所述：只有当<code>URI</code>为空时，才会将<code>location</code>后的匹配字符串带到最终的转发目标路径上。</p>
<h2 id="proxy-set-header-排坑"><a href="#proxy-set-header-排坑" class="headerlink" title="proxy_set_header 排坑"></a>proxy_set_header 排坑</h2><p>​    这里简单描述一下我遇到的场景，在排查过程中耗费了较多的精力。这里我们需要对接外部服务，但是外部服务有一些安全策略，互联网无法直接访问，需要通过跳板机进行访问，同样”外部服务“也只能通过跳板机访问”服务集群“，这里在跳板机上部署了<code>nginx2</code>。<code>nginx1</code>是原本环境中的反向代理。</p>
<p><img src="https://s2.loli.net/2023/09/18/GubszUkKHY8TRMW.png" alt="pass_header.png"></p>
<p>​    在<code>nginx</code>中配置了这样一段，用于”外部服务“请求”服务集群“。用于</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> https://test.service.cn/;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> Host $host:$server_port;</span><br><span class="line">  <span class="attribute">proxy_hide_header</span> <span class="string">&quot;X-Frame-Options&quot;</span>;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Real-Ip $remote_addr;</span><br><span class="line">  <span class="attribute">proxy_set_header</span> X-Forwarded-For $remote_addr;</span><br><span class="line">  <span class="attribute">client_max_body_size</span>  <span class="number">100m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在测试中发现，”外部服务“始终无法调用到”服务集群“的接口，而在<code>nginx2</code>的访问日志中显示<code>404</code>，一直以为是”服务集群“中部署有问题，但是通过<code>curl</code>又能正常访问。</p>
<p>​    在折腾一段时间之后，发现是<code>proxy_set_header</code>这个变量设置的有问题导致请求到达<code>nginx1</code>时出现问题。在了解这个具体问题之前，先来简单解释一下<code>nginx</code>的工作方式。</p>
<p><code>nginx</code>作为反向代理时，它是需要监听<code>service_name</code>和端口的。</p>
<ul>
<li><p>第一步根据请求中的<code>IP</code>和端口先匹配到具体的代理<code>server</code>。</p>
</li>
<li><p>第二步才是进行路径的匹配，根据<code>location</code>的路径规则，进行具体的代理逻辑。</p>
</li>
</ul>
<p>​    然而第一步中的匹配不是根据<b>请求的地址中的IP和端口</b>，而是通过请求头中的<code>Host</code>属性进行匹配。再回到最开始出现问题的地方，由于我设置了<code>proxy_set_header Host $host:$server_port;</code>，导致到达<code>nginx1</code>的请求的请求头中的<code>Host</code>是<code>nginx2</code>本机地址，从而导致<code>nginx1</code>代理规则匹配失败，所以这里出现的<code>404</code>是由于<code>nginx1</code>无法匹配到具体的代理<code>server</code>导致。</p>
<p>​    若没有配置则默认是：<code>proxy_set_header Host $proxy_host;</code>，表示代理的地址。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>端口</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>$host</td>
<td>没有端口</td>
<td>本机地址</td>
</tr>
<tr>
<td>$pass_host</td>
<td>80不显示，其他显示</td>
<td>被代理服务的ip和端口</td>
</tr>
<tr>
<td>$http_host</td>
<td>端口存在则显示</td>
<td>请求时的ip和端口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Spock实践（一）</title>
    <url>/2022/08/05/spock/Spock%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Spock实践（一）"><a href="#Spock实践（一）" class="headerlink" title="Spock实践（一）"></a>Spock实践（一）</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>​    单元测试算是一个老生常谈的问题了，在实际的情况中，总是需要在单元测试与进度之间进行一个权衡，而往往实际上权衡时都是偏向进度一方，甚至很多自信的开发者都不推崇进行单元测试的编写，觉得单元测试费时费力，并且在需求调整又需要重新进行单元测试的编写，其实还有很大一部分原因是因为目前在<code>Spring</code>体系中，常用的单元测试框架就是基于<code>PowerMock</code>或者<code>MockTo</code>等，由于这些框架依赖<code>Spring</code>容器，所以在编写过程需要频繁的启动<code>Spring</code>容器进行单元测试的测试，导致过程比较繁琐。<span id="more"></span></p>
<p>​    最近看到一篇美团的2021博客点击率<code>TOP10</code>中的一篇<a href="https://tech.meituan.com/2021/08/06/spock-practice-in-meituan.html">Spock单元测试框架介绍以及在美团优选的实践</a>，使用全新的<code>Spock</code>框架来进行单元测试，这个框架的好处，无需依赖<code>Spring</code>容器来进行单元测试，并且结合<code>groovy</code>动态语言的特点，提供了一些标签，并采用简单、通用、结构化的描述语言，让编写测试代码更加简洁、高效。具体细节参考美团的那篇技术博客。</p>
<h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><h4 id="对于dao层抽象"><a href="#对于dao层抽象" class="headerlink" title="对于dao层抽象"></a>对于dao层抽象</h4><p>​    在将这篇博客中的一些例子简单跑过之后，<code>Spock</code>确实在单元测试的编写上比较简单且直观，但是由于它不依赖于<code>Spring</code>容器，导致了原来<code>Spring</code>框架为我们封装的一些特性无法使用，比如在我们应用中，到处都是通过<code>tk.mybatis</code>或者<code>mybatis plus</code>的一些通过接口<code>api</code>来动态化<code>SQL</code>，而无需进行手动编写<code>SQL</code>。这些特性实际上是通过<code>Spring</code>容器中在创建特定<code>bean</code>对象时通过<code>spring</code>的扩展点进行处理的。在美团的那篇博客中也提到了如果想测试<code>dao</code>层，可以通过<code>MyBatis的SqlSession</code>启动<code>mapper</code>实例，但是这种方式仅仅获取到的是最基础的<code>ibatis</code>的代理对象，没有了<code>tk</code>或者是<code>mp</code>相关的增强。</p>
<p>​    由于目前只是想简单的引入<code>Spock</code>到某一个服务中，在实际的业务逻辑中，并不确定引入<code>Spock</code>对单元测试的编写是否会有提高，所以这里仅仅研究了如何在不依赖<code>spring</code>容器的情况下，伪造<code>tk.mybatis</code>查询时的<code>mapper</code>对象。</p>
<p>​    跟踪<code>Springbean</code>对象的创建过程，发现<code>tk.mybatis</code>主要是靠<code>tk.mybatis.spring.mapper.MapperFactoryBean</code>(注意包路径，<code>ibatis</code>包下有一个同名类)来进行一些增强处理。所以创建一个工具类，专门用来获取对应的<code>mapper</code>代理对象。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用mapper工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * @date 2022/7/30 16:11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapperUtil</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MapperHelper mapperHelper = <span class="keyword">new</span> MapperHelper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Config config = <span class="keyword">new</span> Config()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapperHelper.setConfig(config)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">def</span> getMapper(Class clazz)&#123;</span><br><span class="line">        ClassLoader classLoader = MapperUtil.<span class="keyword">class</span>.getClassLoader()</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(classLoader.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟tk.mybatis相关创建过程</span></span><br><span class="line">        MapperFactoryBean mapperFactoryBean = <span class="keyword">new</span> MapperFactoryBean(clazz)</span><br><span class="line">        mapperFactoryBean.setSqlSessionFactory(sqlSessionFactory)</span><br><span class="line">        mapperFactoryBean.setMapperHelper(mapperHelper)</span><br><span class="line">        mapperFactoryBean.afterPropertiesSet()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperFactoryBean.getObject()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="H2内存数据库"><a href="#H2内存数据库" class="headerlink" title="H2内存数据库"></a>H2内存数据库</h4><p>​    在美团的这篇博客中，推荐使用<code>H2</code>数据库进行数据的隔离，在对<code>H2</code>进行一些了解后发现<code>H2</code>对<code>mysql</code>的一些语句并不支持，比如建表时的索引之类，所以需要修改原本的建表脚本，在进行一些字段迭代时，可能会比较繁琐。</p>
<p>通过直接使用<code>java.sql.Connection</code>对象来创建数据库连接，并执行建表语句。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AUTO_SERVER=TRUE 默认情况下只能单个连接，这个配置用来开启多个连接</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:h2:~/test;MODE=MySQL;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;AUTO_SERVER=TRUE</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>执行处理代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> executeSql(String sqlPath) &#123;</span><br><span class="line">    <span class="comment">// 执行sql文件</span></span><br><span class="line">    File sqlFile = <span class="keyword">new</span> File(sqlPath)</span><br><span class="line">    <span class="keyword">if</span>(!sqlFile.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;sql文件不存在&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Statement statement = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        statement = CONNECTION.createStatement();</span><br><span class="line">        <span class="keyword">boolean</span> success = statement.execute(sqlFile.text)</span><br><span class="line">        <span class="comment">// 这里有点不解，无论是脚本执行成功还是执行失败，这里好像返回的都是false</span></span><br><span class="line">        <span class="comment">// 目前不影响使用，没有进行深究</span></span><br><span class="line">        success ? println(<span class="string">&quot;执行sql文件成功&quot;</span>) : println(<span class="string">&quot;执行sql文件失败&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(statement != <span class="literal">null</span>)&#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="DbUnit的使用"><a href="#DbUnit的使用" class="headerlink" title="DbUnit的使用"></a>DbUnit的使用</h4><p>​    根据美团的这篇博客中，使用<code>DbUnit</code>来进行数据层数据的访问控制，也就是在初始化某个单元测试接口时进行的一些准备数据脚本的执行，</p>
<h5 id="基于xml脚本文件"><a href="#基于xml脚本文件" class="headerlink" title="基于xml脚本文件"></a>基于xml脚本文件</h5><p>​    在经过测试发现，<code>DbUnit</code>是通过<code>xml</code>文件来编写插入数据的脚本，这就导致写<code>xml</code>插入数据脚本文件也会花费一些工作量。以下为一个示例，假设要为某个接口准备几十条数据，估计准备数据的过程要疯，后期可以看看<code>DbUnit</code>有没有接口可以通过<code>SQL</code>转换为这个<code>xml</code>文件，或者自己实现一个接口，将<code>SQL</code>转换为<code>xml</code>文件来减少工作流。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataset</span>&gt;</span></span><br><span class="line">    &lt;gpfa_process_business</span><br><span class="line">            id=&quot;10007&quot;</span><br><span class="line">            test_id=&quot;1&quot;</span><br><span class="line">            name=&quot;2&quot;</span><br><span class="line">            value = &quot;1&quot;</span><br><span class="line">            mark = &quot;测试&quot;</span><br><span class="line">            create_time = &quot;2018-01-01&quot;</span><br><span class="line">            /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">dataset</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="基于csv脚本文件"><a href="#基于csv脚本文件" class="headerlink" title="基于csv脚本文件"></a>基于csv脚本文件</h5><p>​    <code>DbUnit</code>还支持通过<code>.csv</code>文件进行数据准备，但是比较繁琐的是它好像不能执行具体的文件，需要执行一个目录，并且目录下需要创建一个<code>table-ordering.txt</code>文件，内容为此目录下要执行的<code>csv</code>文件名称，同时<code>csv</code>文件的名称需与表名保持一致。</p>
<h4 id="自定义查询SQL语句"><a href="#自定义查询SQL语句" class="headerlink" title="自定义查询SQL语句"></a>自定义查询SQL语句</h4><p>​    对于在<code>xxxMapper.xml</code>文件中的查询语句，目前不知道因为什么原因，字段值无法赋值到实体上，需要通过<code>as</code>关键字将下划线字段别名为驼峰形式才可在实体中获取到，这个问题无疑是致命的，导致基本上所有的<code>mapper.xml</code>文件都无法进行单元测试。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>Spock</category>
      </categories>
  </entry>
  <entry>
    <title>备忘</title>
    <url>/2021/04/16/%E5%A4%87%E5%BF%98/%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h1><span id="more"></span>

<h2 id="mac快捷键"><a href="#mac快捷键" class="headerlink" title="mac快捷键"></a>mac快捷键</h2><ul>
<li><code>command</code> + <code>shift</code> + <code>.</code>  ： 查看隐藏文件夹</li>
<li><code>command</code> + <code>shift</code> + <code>g</code>  ：到指定路径</li>
<li><code>command</code> + <code>option</code> + <code>c</code>  ：复制文件路径</li>
<li><code>command</code> + <code>t</code>  ：访达内多标签</li>
</ul>
<h2 id="mac杂项"><a href="#mac杂项" class="headerlink" title="mac杂项"></a>mac杂项</h2><p><code>mac</code>应用授权：</p>
<blockquote>
<p>sudo xattr -d com.apple.quarantine /Applications/xxxx.app</p>
</blockquote>
<p><code>docker</code>访问主机地址：</p>
<blockquote>
<p>docker.for.mac.host.internal</p>
</blockquote>
<p>测试能否连接github</p>
<blockquote>
<p>ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#x63;&#x6f;&#109;</a></p>
</blockquote>
<p>打开虚拟机：</p>
<blockquote>
<p>export SYSTEM_VERSION_COMPAT=1<br>open -a Parallels\ Desktop.app</p>
</blockquote>
<p><b><code>mac</code>调度中心快捷键失效解决方案：</b></p>
<blockquote>
<p>系统设置-&gt;键盘-&gt;键盘快捷键-&gt;调度中心中的向左移动一个空间/向右移动一个空间失效</p>
</blockquote>
<ol>
<li>删除<code>~/Library/Preferences/com.apple.symbolichotkeys.plist</code>文件后，通过左上角“退出登录xxx”进行账号登出。</li>
<li>重新登录账号后，进入<code>调度中心</code>重新进行配置快捷键，配置完成后进行保存。</li>
<li>打开终端，执行<code>mv ~/Library/Preferences/com.apple.symbolichotkeys.plist ~/Desktop/</code>后即可。</li>
</ol>
<h4 id="macos中应用与原生快捷键冲突解决"><a href="#macos中应用与原生快捷键冲突解决" class="headerlink" title="macos中应用与原生快捷键冲突解决"></a>macos中应用与原生快捷键冲突解决</h4><p>在我本机的<code>idea</code>中，全局搜索的快捷键是<code>command + H</code>，原来这个快捷键一直与<code>macOS</code>中的隐藏应用冲突，导致我再<code>idea</code>中通过快捷键唤出全局搜索的弹窗之后，这个弹窗没有被聚焦。</p>
<p>进入[设置]&rarr;[键盘]&rarr;[App快捷键]&rarr;[+(添加)]：</p>
<p><img src="https://s2.loli.net/2023/12/11/P4fqKFigVvL36pQ.png" alt="键盘快捷键冲突.png"></p>
<p>这里以<code>idea</code>中<code>command + H</code>的冲突为例：</p>
<p>应用程序：选择冲突的应用程序。选择<code>IntelliJ IDEA.app</code></p>
<p>菜单标题：[命令+应用名]，填入<code>Hide IntelliJ IDEA</code>，注意这里的应用名需与【应用程序】那一栏中保持一致。</p>
<p>键盘快捷键：希望将原始的这个快捷键转换为哪一个快捷键，填入<code>command + alt + H</code>，则表示，在<code>idea</code>中，需要键入<code>command + alt + H</code>会使得应用隐藏。</p>
<p><strong>应用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>快捷键</th>
<th>英文缩写</th>
</tr>
</thead>
<tbody><tr>
<td>隐藏当前应用程序</td>
<td>Command + H</td>
<td>Hide</td>
</tr>
<tr>
<td>退出当前应用程序</td>
<td>Command + Q</td>
<td>Quit</td>
</tr>
<tr>
<td>新建一个文件或文档</td>
<td>Command +N</td>
<td>New</td>
</tr>
<tr>
<td>打开一个已有的文件或文档</td>
<td>Command + O</td>
<td>Open</td>
</tr>
<tr>
<td>保存当前文件或文档</td>
<td>Command + S</td>
<td>Save</td>
</tr>
<tr>
<td>另存为当前文件或文档</td>
<td>Command + Shift + S</td>
<td>Save As</td>
</tr>
<tr>
<td>撤销上一步操作</td>
<td>Command + Z</td>
<td>Undo</td>
</tr>
<tr>
<td>重做上一步操作</td>
<td>Command + Shift + Z</td>
<td>Redo</td>
</tr>
<tr>
<td>剪切选中的文本或图像</td>
<td>Command + X</td>
<td>Cut</td>
</tr>
<tr>
<td>复制选中的文本或图像</td>
<td>Command + C</td>
<td>Copy</td>
</tr>
<tr>
<td>粘贴剪贴板中的文本或图像</td>
<td>Command +V</td>
<td>Paste</td>
</tr>
<tr>
<td>查找文本或图像</td>
<td>Command + F</td>
<td>Find</td>
</tr>
<tr>
<td>替换文本或图像</td>
<td>Command + Option + F</td>
<td>Replace</td>
</tr>
<tr>
<td>全选当前文本或图像</td>
<td>Command + A</td>
<td>Select All</td>
</tr>
<tr>
<td>在应用程序中查看帮助</td>
<td>Command + Shift +/</td>
<td>Help</td>
</tr>
<tr>
<td>缩小当前窗口</td>
<td>Command + M</td>
<td>Minimize</td>
</tr>
<tr>
<td>放大当前窗口</td>
<td>Command + Option + M</td>
<td>Zoom</td>
</tr>
<tr>
<td>切换全屏模式</td>
<td>Command + Control + F Enter Full</td>
<td>Screen</td>
</tr>
<tr>
<td>切换应用程序</td>
<td>Command + Tab</td>
<td>Switch</td>
</tr>
<tr>
<td>在当前应用程序中打开新窗口</td>
<td>Command + N</td>
<td>New Window</td>
</tr>
<tr>
<td>在当前应用程序中打开新标签页</td>
<td>Command + T</td>
<td>New Tab</td>
</tr>
<tr>
<td>在当前应用程序中关闭当前窗口或标签页</td>
<td>Command +W</td>
<td>Close Window/Tab</td>
</tr>
<tr>
<td>在当前应用程序中打印当前文档或页面</td>
<td>Command + P</td>
<td>Print</td>
</tr>
<tr>
<td>在当前应用程序中查看页面源代码</td>
<td>Command + Option + U</td>
<td>View Source</td>
</tr>
<tr>
<td>更改字体和字号</td>
<td>Command +T</td>
<td>Font/Font Size</td>
</tr>
<tr>
<td>更改文本和图像的对齐方式</td>
<td>Command + Shift + L/C/R/J</td>
<td>Alignment</td>
</tr>
<tr>
<td>插入链接或超链接</td>
<td>Command +K</td>
<td>Insert Link/Hyperlink</td>
</tr>
<tr>
<td>插入图片</td>
<td>Command + Shift + D</td>
<td>Insert Image</td>
</tr>
<tr>
<td>更改文本或图像的颜色</td>
<td>Command + Shift + C</td>
<td>Color</td>
</tr>
</tbody></table>
<h2 id="idea快捷键"><a href="#idea快捷键" class="headerlink" title="idea快捷键"></a>idea快捷键</h2><p>快捷键(<code>keymap</code>)：</p>
<ul>
<li><p><code>Toggle Case</code>：大小写转换</p>
</li>
<li><p><code>Find in Files...</code>：全局查找</p>
</li>
<li><p><code>Replace... </code>: 文件内替换</p>
</li>
<li><p><code>Replace in Files...</code>：全局替换</p>
</li>
<li><p><code>Change Signature</code>：重构方法（command + F6）</p>
</li>
</ul>
<p><code>idea</code>的最近打开文件路径：<code>/Users/xxx/Library/Application Support/JetBrains/IntelliJIdea2021.3/options/recentProjects.xml</code></p>
<h2 id="DataGrip设置"><a href="#DataGrip设置" class="headerlink" title="DataGrip设置"></a>DataGrip设置</h2><p>1.鼠标选中配色修改：<code>setting#编辑器#配色方案#常规#文本光标下的标识符</code></p>
<h2 id="本机工具路径"><a href="#本机工具路径" class="headerlink" title="本机工具路径"></a>本机工具路径</h2><ul>
<li><code>jdk</code>：<code>/Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/lib</code></li>
</ul>
<h2 id="备忘杂项"><a href="#备忘杂项" class="headerlink" title="备忘杂项"></a>备忘杂项</h2><p><code>springboot/springcloud</code>对应版本：<a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a></p>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>边角料记录</title>
    <url>/2021/04/16/%E5%A4%87%E5%BF%98/%E8%BE%B9%E8%A7%92%E6%96%99%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="边角料记录"><a href="#边角料记录" class="headerlink" title="边角料记录"></a>边角料记录</h1><span id="more"></span>

<h2 id="1-maven中的bom"><a href="#1-maven中的bom" class="headerlink" title="1.maven中的bom"></a>1.maven中的bom</h2><p>​    <code>BOM</code>全称是<code>Bill Of Materials</code>，译作材料清单。它实际上就是一个普通的<code>pom</code>文件，只是这个<code>pom</code>中罗列了工程的依赖以及对应的版本，当其他主工程引用这个<code>pom</code>时，可以直接使用其中定义的版本，<code>springboot</code>就是通过这种方式，使得用户无需主动考虑<code>spring framework</code>对应的版本。</p>
<p>​    一般可以通过两种方式引入<code>BOM</code>，一种是使用<code>&lt;parent&gt;</code>标签继承于父类<code>BOM</code>，但是继承仅支持继承一个父类；另一种方式是通过<code>&lt;dependencyManagement&gt;&lt;dependencies&gt;</code>引入<code>BOM</code>。</p>
<p>引入<code>BOM</code>之后，再引入其他依赖，在<code>&lt;dependencies&gt;&lt;dependency&gt;</code>中只需要编写依赖的<code>&lt;groupId&gt;&lt;artifactId&gt;</code>不需要指定版本。</p>
<p><code>&lt;packaging&gt;pom&lt;packaging&gt;</code>设置之后则这个就是<code>BOM</code>，<code>BOM</code>的引入在<code>External Libries</code>库中是获取不到。</p>
<p><b>冲突处理：优先顺序</b></p>
<ul>
<li>当前工程显示指定版本</li>
<li><code>parent</code>中指定版本</li>
<li>在当前工程中通过<code>dependencyManagement</code>引入的<code>BOM</code>清单中的版本，当引入的多个<code>BOM</code>时，先引入的<code>BOM</code>生效</li>
<li>依赖调解：最短路径生效。比如存在两条对<code>D</code>的依赖<code>A-&gt;B-&gt;C-D1.0</code>和<code>A-&gt;E-&gt;D1.1</code>，这里最终会引用到<code>D1.1</code>。</li>
</ul>
<h2 id="2-maven常用命令"><a href="#2-maven常用命令" class="headerlink" title="2.maven常用命令"></a>2.maven常用命令</h2><ul>
<li><code>mvn clean</code>： 清除目标目录中的生成结果</li>
<li><code>mvn package</code>： 依据项目生成 jar 文件（打包）</li>
<li><code>mvn install</code>： 在本地 Repository 中安装 jar</li>
<li><code>mvn -Dmaven.test.skip=true</code>： 忽略测试文档编译</li>
<li><code>mvn clean compile</code> ：清理编译</li>
<li><code>mvn clean test</code> ：清理测试</li>
<li><code>mvn clean package</code> ：清理打包</li>
<li><code>mvn clean package -Dmaven.test.skip=true</code> ：清理打包生成jar包</li>
<li><code>mvn clean install</code> ：清理将打包好的jar存入 本地仓库 注意是本地仓库</li>
<li><code>mvn -e</code>：显示详细错误</li>
<li><code>mvn -U</code>：强制更新snapshot类型的插件或依赖库</li>
<li><code>mvn -pl</code>： module_name在指定模块上执行命令</li>
<li><code>mvn -ff</code>： 在递归执行命令过程中，一旦发生错误就直接退出</li>
<li><code>mvn -Dxxx=yyy</code>： 指定java全局属性</li>
<li><code>mvn -Pxxx</code>：引用profile xxx</li>
<li><code>mvn -f pom.xml</code>：指定<code>pom</code>文件，一般在多模块工程中，指定启动类对应模块的<code>pom.xml</code></li>
</ul>
<p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">maven插件整理</a></p>
<h2 id="3-指定类路径"><a href="#3-指定类路径" class="headerlink" title="3.指定类路径"></a>3.指定类路径</h2><p><code>classpath</code>和<code>classpath*</code>的区别：</p>
<p><code>classpath</code>：只会在当前工程/应用的类路径下匹配这个指定的类路径。</p>
<p><code>classpath*</code>：不仅会在当前的工程/应用的类路径下匹配，也会到引用的<code>jar</code>包的类路径下匹配。</p>
<p>比如：</p>
<p>现在有一个应用，在当前应用中<code>resources</code>路径下有个<code>mapper/UserMapper.xml</code>文件，在引入的<code>xiaocainiao-common</code>包中的<code>resources</code>中也有一个<code>mapper/PersonMapper.xml</code>文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   └── main</span><br><span class="line">│       └── cn.com.xiaocainiaoya</span><br><span class="line">│       │   ├── Application.java</span><br><span class="line">│       ├── resources</span><br><span class="line">│               ├── mapper</span><br><span class="line">│                     ├── UserMapper.xml</span><br><span class="line">├── lib</span><br><span class="line">│    ├── xiaocainiao-common</span><br><span class="line">│                       ├── resources</span><br><span class="line">│                               ├── mapper</span><br><span class="line">│                                     ├── PersonMapper.xml</span><br></pre></td></tr></table></figure>

<p>这时如果使用<code>classpath:mapper/*.xml</code>，那么只会加载到<code>UserMapper.xml</code>。</p>
<p>如果使用<code>classpath*:mapper/*.xml</code>那么<code>UserMapper.xml</code>和<code>PersonMapper.xml</code>都会被加载到。</p>
<h2 id="4-推送本地jar包到远程仓库"><a href="#4-推送本地jar包到远程仓库" class="headerlink" title="4.推送本地jar包到远程仓库"></a>4.推送本地jar包到远程仓库</h2><p>推送指定的<code>jar</code>包到本地仓库或者远程仓库。</p>
<p>通过<code>mvn install:install-file</code>将指定<code>jar</code>打入本地仓库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=/path/to/jar/file -DgroupId=com.example -DartifactId=my-jar -Dversion=1.0 -Dpackaging=jar</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-Dfile</code>：选项指定<code>JAR</code>文件的路径，</li>
<li><code>-DgroupId</code>、<code>-DartifactId</code>和<code>-Dversion</code>选项指定<code>JAR</code>文件的<code>Maven</code>坐标</li>
<li><code>-Dpackaging</code>：选项指定<code>JAR</code>文件的类型。</li>
</ul>
<p>通过<code>mvn deploy:deploy-file</code>将指定<code>jar</code>推送远程仓库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn deploy:deploy-file -Dfile=/path/to/jar/file -DgroupId=com.example -DartifactId=my-jar -Dversion=1.0 -Dpackaging=jar -Durl=http://myrepo.com/nexus/content/repositories/releases/ -DrepositoryId=my-repo</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-Durl</code>：选项指定远程仓库的地址，</li>
<li><code>-DrepositoryId</code>：选项指定远程仓库的<code>ID</code>，这些信息需要和<code>pom.xml</code>文件中的配置相匹配。</li>
<li><code>-Dusername</code>：远程仓库账号</li>
<li><code>-Dpassword</code>：远程仓库密码</li>
</ul>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ IDEA插件开发</title>
    <url>/2022/09/19/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/IntelliJ%20IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>​    公司中提交<code>MYSQL</code>脚本有相应的规范，需要编写为<code>groovy</code>文件，同时里面包含了一些其他信息项，有对应版本、编写人、模块编码、日期等等，每次写脚本时都通过拷贝旧文件，再修修改改之后提交，所以错误率比较高，想着通过配置信息项以及通过代码来直接生成对应脚本。完成之后发现，虽然达到了生成脚本的预期，但是交互是在<code>console</code>控制台上交互，使用上有点繁琐，偶然看到关于<code>IDEA</code>插件开发的博客，想着是否可以通过<code>IDEA</code>插件来写一个<code>UI</code>，生成逻辑直接使用原有代码移植过来。同时记录在开发<code>IntelliJ IDEA</code>插件过程中遇到的一些问题和踩到的一些坑。</p>
<span id="more"></span>

<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>​    <code>IntelliJ IDEA</code>插件开发有两种方式，一种是直接引入<code>Plugin DevKit</code>，然后配置<code>IntelliJ Platform Plugin SDK</code>进行开发，另一种是使用<code>gradle</code>构建项目并引入<code>IDEA</code>插件开发包。使用<code>gradle</code>的好处是同时也可以引入一些其他的库进行使用。</p>
<p>​    在<code>IDEA 2021.3</code>以及之后的版本，开发需要使用<code>JDK 11</code>进行开发，在我开发的时候我本地也没有<code>JDK 11</code>(一台电脑可以支持多个版本的<code>JDK</code>，问题在于环境变量配置的是哪个版本而已。因为目前只有这里插件开发我才会用到<code>JDK 11</code>，所以没有将它添加到环境变量中，仅通过<code>IDEA</code>工具添加了<code>JDK</code>路径)。</p>
<p>​    我使用的是<code>gradle</code>的方式进行插件的开发。<code>gradle</code>导入之后，在<code>Libraries</code>下会有一个<code>com.jetbrains:ideaIC:2021.3</code>，这就是<code>IDEA</code>插件的开发包。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="comment">// IDEA的插件开发包</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;1.8.1&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// 设置阿里云maven仓库 </span></span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;cn.hutool:hutool-all:5.6.7&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.alibaba:fastjson:1.2.28&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-core:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-jul:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.logging.log4j:log4j-slf4j-impl:2.14.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;mysql:mysql-connector-java:8.0.25&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.9.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.9.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.8&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idea的使用版本</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    version = <span class="string">&#x27;2021.3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">patchPluginXml &#123;</span><br><span class="line">    changeNotes = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Add change notes here.&lt;br&gt;</span></span><br><span class="line"><span class="string">      &lt;em&gt;most HTML tags may be used&lt;/em&gt;&quot;&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gradle</code>中一些常用项：</p>
<p><code>intellij -&gt; runIde</code>：这时会新启动一个<code>IDEA</code>工具，可以进行调试插件。</p>
<p><code>intellij -&gt; buildPlugin</code>：构建插件，用来完成之后将代码打包成<code>.zip</code>。(路径为<code>build/distributions</code>)。</p>
<h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><p>点击<code>Help -&gt; Edit Custom Properties...</code>，添加以下配置后重启<code>IDEA</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">idea.is.internal</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>在<code>Tool</code>下会出现<code>Interal Actions</code>和<code>View PSI Structure...</code>按钮。</p>
<p><img src="https://s2.loli.net/2022/09/20/xouELJspl16qTnj.png" alt="ideaInternal.png"></p>
<p>参考面板：<code>Internal Actions -&gt; UI -&gt; Show Standard Panels</code>：会弹出一个<code>UI</code>面板，结合<code>UI Debug</code>就可以参考到对应的源码。</p>
<p><img src="https://s2.loli.net/2022/09/20/p46q5sldBj7Q3cn.png" alt="standPanel.png"></p>
<p>通过<code>Internal Actions -&gt;UI Debugger</code>可以监控在<code>IDEA</code>中鼠标操作对应的<code>Action</code>。比如创建一个类，在<code>UI Debugger</code>面板上可以看到一个<code>CreateClassAction</code>的类，就可以看到这个创建一个类的源码，如果功能类似甚至可以直接复用。</p>
<p>与<code>PSI</code>相关<code>API</code>目前占时没有使用，具体如果需要插件能实现在代码里根据某种规则生成内容，则就需要通过<code>PSI</code>相关内容进行处理。</p>
<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">idea-plugin</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">    └── main</span><br><span class="line">          └── resources</span><br><span class="line">          │     └── META-INF</span><br><span class="line">          │          └── plugin.xml</span><br><span class="line">          └── java</span><br><span class="line">              └── cn<span class="selector-class">.com</span>.xiaocainiao</span><br><span class="line">                       └── MyWindowFactory<span class="selector-class">.java</span>  </span><br></pre></td></tr></table></figure>

<h2 id="plugin-xml配置"><a href="#plugin-xml配置" class="headerlink" title="plugin.xml配置"></a>plugin.xml配置</h2><p>我使用的是<code>ToolWindowFactory</code>创建右侧窗体。若是创建<code>Action</code>，可以直接通过<code>New -&gt; Plugin DevKit -&gt; Action</code>进行创建，通过这种方式创建，会自动在<code>plugin.xml</code>文件中添加<code>&lt;action&gt;</code>的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>org.example.SecondIdeaPlugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SecondIdeaPlugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;xiaocainiaoya@foxmail.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://xxx.com&quot;</span>&gt;</span>bosssoft<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">        For simple and quick generation of SQL script files&lt;br&gt;</span><br><span class="line">        &lt;em&gt;Tools that are easy to use&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- please see https://plugins.jetbrains.com/docs/intellij/plugin-compatibility.html</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.platform<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">toolWindow</span> <span class="attr">id</span>=<span class="string">&quot;generatorSQL&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">secondary</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">anchor</span>=<span class="string">&quot;right&quot;</span> <span class="attr">factoryClass</span>=<span class="string">&quot;cn.com.xiaocainiaoya.MyWindowFactory&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">toolWindow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><p>​    由于<code>IDEA</code>插件的<code>UI</code>采用的是<code>Swing</code>、<code>Awt</code>来进行窗体开发，当知道使用的是<code>Swing</code>一度想要放弃掉，确实是使用<code>Swing</code>是一件比较痛苦的事情。后借助于<code>IDEA</code>的<code>Swing UI Designer</code>功能通过拖拽简单组件的方式，硬着头皮画出了<code>UI</code>界面。</p>
<p><img src="https://s2.loli.net/2022/09/19/sTRPS3cQYnVABFD.png" alt="ideaSwing.png"></p>
<h1 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h1><h2 id="1-路径"><a href="#1-路径" class="headerlink" title="1.路径"></a>1.路径</h2><p>​    可能由于项目有别于常用的<code>java</code>项目、<code>spring</code>项目，所以在获取资源文件(<code>/resources/**</code>)时，总是感觉摸不着头脑。参考了一些其他博主写的<code>IDEA</code>插件项目，获取资源文件的方式，与<code>java</code>项目、<code>Spring</code>项目并无差别，但是我在获取资源文件时，一直提交获取不到资源文件，也有可能是<code>velocity</code>组件的问题。</p>
<p>​    原本使用<code>velocity</code>模板引擎来加载对应模板文件，但是一直报错获取不到对应资源文件之后，将这种动作修改为代码层获取到资源文件内容，在将模板内容提交给<code>velocity</code>模板引擎。</p>
<p>注：<code>velocity</code>组件和<code>groovy</code>库相关包在<code>com.jetbrains:ideaIC:20201.3</code>中已经存在，所以不能由自身再引入。</p>
<p>在调试开发过程中，<code>velocity</code>正常使用，但是打包成插件之后，通过插件的方式运行，一直报一个日志相关的异常。</p>
<p>添加<code>velocity.proerties</code>配置文件相关配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">runtime.log.logsystem.class</span>=<span class="string">org.apache.velocity.runtime.log.SimpleLog4JLogSystem</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.category</span>=<span class="string">velocity</span></span><br><span class="line"><span class="meta">runtime.log.logsystem.log4j.logger</span>=<span class="string">velocity</span></span><br></pre></td></tr></table></figure>

<p>因为在调试过程的运行和实际插件方式运行是对应的相对路径是不一致的，所以在使用系统级有关的相对路径是需通过使用<code>com.intellij.openapi.application.PathManager</code>类来获取对应的路径：</p>
<p>比如使用<code>PathManager.getBinPath()</code>：</p>
<p>在调试运行获取到的路劲为：<code>/usr/local/Cellar/gradle/7.3.1/caches/modules-2/files-2.1/com.jetbrains.intellij.idea/ideaIC/2021.3/75777e10a0e2880bc02945066dda2480a696c3d9/ideaIC-2021.3/bin</code></p>
<p>在实际插件方式允许获取的路径为：<code>/Applications/IntelliJ IDEA.app/Contents/bin</code></p>
<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://zhuanlan.zhihu.com/p/400059601" target="_blank">IntelliJ IDEA 插件开发指南</a></p>
<p><a href="https://plugins.jetbrains.com/docs/intellij/welcome.html" target="_blank">插件入门官网</a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown记录</title>
    <url>/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/markdown%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><span id="more"></span>

<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
<th>编码(使用时移除’+’号)</th>
</tr>
</thead>
<tbody><tr>
<td>←</td>
<td>左箭头</td>
<td>&amp;+larr;</td>
</tr>
<tr>
<td>→</td>
<td>右箭头</td>
<td>&amp;+rarr;</td>
</tr>
<tr>
<td>↑</td>
<td>上箭头</td>
<td>&amp;+uarr;</td>
</tr>
<tr>
<td>↓</td>
<td>下箭头</td>
<td>&amp;+darr;</td>
</tr>
<tr>
<td>↔</td>
<td>水平箭头</td>
<td>&amp;+harr;</td>
</tr>
<tr>
<td>↕</td>
<td>竖直箭头</td>
<td>&amp;+varr;</td>
</tr>
<tr>
<td>⇐</td>
<td>双线左箭头</td>
<td>&amp;+lArr;</td>
</tr>
<tr>
<td>⇒</td>
<td>双线右箭头</td>
<td>&amp;+rArr;</td>
</tr>
<tr>
<td>⇑</td>
<td>双线上箭头</td>
<td>&amp;+uArr;</td>
</tr>
<tr>
<td>⇓</td>
<td>双线上箭头</td>
<td>&amp;+dArr;</td>
</tr>
<tr>
<td>⇔</td>
<td>双线水平双箭头</td>
<td>&amp;+hArr;</td>
</tr>
<tr>
<td>⇕</td>
<td>双线竖直箭头</td>
<td>&amp;+vArr;</td>
</tr>
</tbody></table>
<h1 id="跳转方式"><a href="#跳转方式" class="headerlink" title="跳转方式"></a>跳转方式</h1><p><strong>1.页内定位：</strong></p>
<ol>
<li>定义一个锚(id)：<code>&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</code></li>
<li>使用markdown语法：<code>[点击跳转](#jump)</code></li>
</ol>
<p><strong>2.重定向</strong></p>
<blockquote>
<p>[描述] (地址)</p>
</blockquote>
<p><strong>3.新标签页打开：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>显示字眼<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="表格内换行"><a href="#表格内换行" class="headerlink" title="表格内换行"></a>表格内换行</h1><p>使用<code>&lt;br&gt;</code></p>
<h1 id="黑体"><a href="#黑体" class="headerlink" title="黑体"></a>黑体</h1><p>部分<code>markdown</code>渲染器无法识别<code>****</code>，可以使用<code>&lt;b&gt;&lt;/b&gt;</code>的<code>html</code>标签来实现。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本基础</title>
    <url>/2022/09/13/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>shell脚本中的一些常规语法笔记，由于日常中使用比较少，每次想写一点简单脚本的时候都忘记了相应的语法，所以这里记录一些常规的语法。</p>
</blockquote>
<span id="more"></span>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>最精简的<code>if</code>语句：<code>condition</code>是判断条件，<code>statement</code>判断条件为真时的执行语句。在<code>shell</code>脚本中不是通过大括号<code>&#123;&#125;</code>开标识代码的开始与结束。而是通过<code>fi</code>来闭合。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>也可以写成：当<code>condition</code>和<code>then</code>在同一行时，需要使用分号隔开，否则报语法错误。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition; <span class="keyword">then</span></span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>结合<code>else</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statement2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>再结合<code>else if</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    statement2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statementn</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>判断表达式：</p>
<blockquote>
<p>-e filename 如果 filename存在，则为真<br>-d filename 如果 filename为目录，则为真<br>-f filename 如果 filename为常规文件，则为真<br>-L filename 如果 filename为符号链接，则为真<br>-r filename 如果 filename可读，则为真<br>-w filename 如果 filename可写，则为真<br>-x filename 如果 filename可执行，则为真<br>-s filename 如果文件长度不为0，则为真<br>-h filename 如果文件是软链接，则为真<br>filename1 -nt filename2 如果 filename1比 filename2新，则为真。<br>filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</p>
</blockquote>
<p>整数变量表达式：</p>
<blockquote>
<p>-eq 等于<br>-ne 不等于<br>-gt 大于<br>-ge 大于等于<br>-lt 小于<br>-le 小于等于</p>
</blockquote>
<p>字符串变量表达式：</p>
<blockquote>
<p>If  [ $a = $b ]         如果string1等于string2，则为真<br>if  [ $string1 !=  $string2 ]  如果string1不等于string2，则为真<br>if  [ -n $string  ]       如果string 非空(非0），返回0(true)<br>if  [ -z $string  ]       如果string 为空，则为真<br>if  [ $sting ]          如果string 非空，返回0 (和-n类似) </p>
</blockquote>
<p>逻辑符号：</p>
<blockquote>
<p>逻辑非 !     if [ ! 表达式 ]<br>if [ ! -d $num ]         如果不存在目录$num</p>
<p>逻辑与 –a          条件表达式的并列(类似其他语言的<code>&amp;&amp;</code>)<br>if [ 表达式1  –a  表达式2 ]</p>
<p>  逻辑或 -o          条件表达式的或(类似其他语言的<code>||</code> )<br>if [ 表达式1  –o 表达式2 ]</p>
</blockquote>
<h4 id="2-循环"><a href="#2-循环" class="headerlink" title="2.循环"></a>2.循环</h4><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zip4j打包文件</title>
    <url>/2023/03/24/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E4%BD%BF%E7%94%A8zip4j%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>​    最近接到需求需要为打包后的<code>zip</code>文件设置压缩密码，而我们之前使用的<code>ZipOutputStream</code>结合<code>hutool</code>的<code>NoiUtil</code>进行打包生成<code>zip</code>文件，但是<code>ZipOutputStream</code>没有设置解压密码的功能，故尝试寻找其他三方库(这里是直接问<code>chatGPT</code>)，它的回答是<code>Zip4j</code>。</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Zip4j</code>是一个用于处理<code>ZIP</code>文件格式的<code>Java</code>库，它提供了一个易于使用的<code>API</code>，可以方便地创建、提取和修改<code>ZIP</code>文件，以及支持密码保护的ZIP文件。</p>
<p><code>Zip4j</code>的主要特点包括：</p>
<ol>
<li>支持标准<code>ZIP</code>文件格式以及<code>ZIP64</code>扩展格式，可以处理包含数百万文件的<code>ZIP</code>文件。</li>
<li>支持密码保护的<code>ZIP</code>文件，包括标准密码和<code>AES</code>加密密码。</li>
<li>支持<code>ZIP</code>文件的分卷（spanned）和自解压缩（self-extracting）功能。</li>
<li>支持<code>ZIP</code>文件的压缩级别、注释和<code>UTF-8</code>编码文件名等属性的设置。</li>
<li>提供了方便的<code>API</code>，可以方便地添加、提取和修改<code>ZIP</code>文件中的文件和文件夹，以及获取<code>ZIP</code>文件中的文件列表和属性信息。</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我使用的是<code>2.1.6</code>版本，新版本对旧版本中的一些常量和接口有调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstDemo</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    List&lt;File&gt; fileToAdds = Arrays.asList(file1, file2);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    zipFile.addFiles(fileToAdds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    String filePath1 = <span class="string">&quot;/xxx/demo1.txt&quot;</span>;</span><br><span class="line">    String filePath2 = <span class="string">&quot;/xxx/demo2.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(filePath1);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(filePath2);</span><br><span class="line"></span><br><span class="line">    ZipDemo zipDemo = <span class="keyword">new</span> ZipDemo();</span><br><span class="line">    zipDemo.firstDemo(file1, file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>fileToAdds</code>列表打包为目标地址为<code>/xxx/result.zip</code>的压缩文件。这种写法是最简单的打包方式，将需要打包的源文件都打包在目标<code>zip</code>文件的顶层目录下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├─────── demo1.txt</span><br><span class="line">  └─────── demo2.txt</span><br></pre></td></tr></table></figure>

<p>但是有时候，甚至大部分时候都是需要将打包源文件进行分级(压缩包内文件夹)的方式进行打包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result.zip</span><br><span class="line">  ├───── dir1</span><br><span class="line">  │       └─ demo1.txt</span><br><span class="line">  └───── demo2.txt</span><br></pre></td></tr></table></figure>

<p><b>1.设置目标<code>zip</code>文件内文件夹结构示例代码：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customInnerFilePath</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化压缩参数</span></span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 将设置的压缩参数作用在某个文件上</span></span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>2.设置文件夹加密：</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptZip</span><span class="params">(File file1, File file2)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipParameters zipParameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    <span class="comment">// 指定zip文件内部对于根目录的绝对路径</span></span><br><span class="line">    zipParameters.setFileNameInZip(<span class="string">&quot;dir1/demo1.txt&quot;</span>);</span><br><span class="line">    zipParameters.setEncryptFiles(<span class="keyword">true</span>);</span><br><span class="line">    zipParameters.setEncryptionMethod(EncryptionMethod.AES);</span><br><span class="line">    zipParameters.setAesKeyStrength(AesKeyStrength.KEY_STRENGTH_256);</span><br><span class="line"></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">    zipFile.addFile(file1, zipParameters);</span><br><span class="line">    zipFile.addFile(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>注意：</b>上述代码中仅仅是对<code>file1</code>设置了<code>zipParameters</code>参数，也就是说现在有两个被打包文件，但是压缩参数只设置到了其中的一个文件上，打开压缩后的文件会发现，是需要解压密码才能解压，但是如果你有一些不需要解压可以查看<code>zip</code>包内部情况的工具可以发现，可以<code>file2</code>所对应的文件是无需密码就可以查看，也就是说，如果要对压缩包内所有文件在没有解压密码之前都不能访问，需要每个文件添加时设置<code>zipParameters</code>参数，设置为加密开启。</p>
<p><img src="https://s2.loli.net/2023/03/27/qbauo5fZCevzDUS.png" alt="zip文件内部分文件加密.png"></p>
<p>还有一点：踩过一个坑，由于我在打包文件的时候，可能出现某一个压缩包已经打包过了，但是业务上并不知道已经打包过了，所以会出现重复打包的情况，而我在针对重复打包的情况，会先将目标<code>zip</code>设置为一个空文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过java标准库中的方法，这时这个目标文件存在，但是内容被清除，结果是0B</span></span><br><span class="line">Files.newByteChannel(result, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE).close();</span><br></pre></td></tr></table></figure>

<p>但是这种情况下运行会报错：</p>
<blockquote>
<p>Zip file size less than minimum expected zip file size. Probably not a zip file or a corrupted zip file</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (zip4jRaf.length() &lt; ENDHDR) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ZipException(<span class="string">&quot;Zip file size less than minimum expected zip file size. &quot;</span> +</span><br><span class="line">                         <span class="string">&quot;Probably not a zip file or a corrupted zip file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概意思是目标文件是一个空文件，校验了目标文件头部的一个什么长度。没有细究这个问题，我的做法是改成直接删除旧文件，然后再生成文件。</p>
<p><b>3.打包分卷</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">zip</span><span class="params">(List&lt;String&gt; srcFiles, String destFile, <span class="keyword">long</span> fileSize)</span> <span class="keyword">throws</span> ZipException </span>&#123;</span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(destFile);</span><br><span class="line">    List&lt;File&gt; filesToAdd = srcFiles.stream().map(File::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    ZipParameters parameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">    parameters.setCompressionMethod(CompressionMethod.DEFLATE);</span><br><span class="line">    parameters.setCompressionLevel(CompressionLevel.NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未指定则设置为512KB</span></span><br><span class="line">    <span class="keyword">if</span>(fileSize==<span class="number">0</span>)&#123;</span><br><span class="line">        fileSize = <span class="number">65536</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置压缩分卷</span></span><br><span class="line">    zipFile.createSplitZipFile(filesToAdd, parameters, <span class="keyword">true</span>, fileSize);</span><br><span class="line">    <span class="keyword">return</span> zipFile.getSplitZipFiles();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分卷生成的文件结构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目标文件目录</span><br><span class="line">  ├─────── result.z01</span><br><span class="line">  └─────── result.z02</span><br></pre></td></tr></table></figure>

<p>这里会生成<code>.z</code>+<code>数字排列</code>的压缩包，要提取或打开这样的分卷<code>ZIP</code>文件，必须将所有的<code>ZIP</code>文件都放在同一个目录下。这种场景就可以用于大文件分卷为多个小文件后，传输小文件到目标地址。</p>
<p><b>4.提取</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> ZipException</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个ZipFile对象，用于打开要提取的ZIP文件</span></span><br><span class="line">    ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="string">&quot;/xxx/result.zip&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置解压缩密码（如果需要）</span></span><br><span class="line">    <span class="keyword">if</span> (zipFile.isEncrypted()) &#123;</span><br><span class="line">        zipFile.setPassword(<span class="string">&quot;password&quot;</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.将所有文件都提取到当前目录下</span></span><br><span class="line">    zipFile.extractAll(<span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.仅提取一个文件</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;demo1.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.提取的这个文件不是在顶层目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/demo3.txt&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.提取整个内部目录</span></span><br><span class="line">    zipFile.extractFile(<span class="string">&quot;dir3/&quot;</span>, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，<code>Zip4j</code>是一个非常实用的<code>Java</code>库，可以帮助程序员方便地处理<code>ZIP</code>文件格式，节省大量的开发时间和工作量。还包含其他的一些，比如添加某个文件到<code>zip</code>文件中，修改<code>zip</code>中的某个文件等等。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记(一)</title>
    <url>/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="redis学习笔记-一"><a href="#redis学习笔记-一" class="headerlink" title="redis学习笔记(一)"></a>redis学习笔记(一)</h3><h4 id="一、非关系数据库"><a href="#一、非关系数据库" class="headerlink" title="一、非关系数据库"></a>一、非关系数据库</h4><blockquote>
<p><code>not only Sql</code>是非关系型数据库</p>
</blockquote>
<span id="more"></span>

<h5 id="1-NoSQL的特点"><a href="#1-NoSQL的特点" class="headerlink" title="1.NoSQL的特点"></a>1.NoSQL的特点</h5><ul>
<li><p>方便扩展（数据之间没有关系，很好扩展）</p>
</li>
<li><p>大数据高性能（8w写，11w读）</p>
</li>
<li><p>数据类型多样性（无需事先设计数据库，随取随用）</p>
</li>
</ul>
<h5 id="2-传统RDBMS和NoSQL"><a href="#2-传统RDBMS和NoSQL" class="headerlink" title="2.传统RDBMS和NoSQL"></a>2.传统RDBMS和NoSQL</h5><p>​    传统的<code>RDBMS</code>是结构化组织、建立在<code>SQL</code>语句之上，数据和数据间的关系存储在表中，严格的一致性，事务等。</p>
<p>​    非关系型数据库<code>NoSQL</code>是没有固定的查询语言，有列存储、键值对存储、图像数据库、文件存储，强调最终一致性，建立在<code>CAP</code>定理和<code>BASE</code>理论，具有高性能、高可用、高可扩。</p>
<blockquote>
<p>大数据时代的3V(海量Volume，多样Variety，实时Velocity)+3高(高并发、高可用、高性能)</p>
</blockquote>
<h5 id="3-四大分类"><a href="#3-四大分类" class="headerlink" title="3.四大分类"></a>3.四大分类</h5><ol>
<li><p><strong>KV键值对</strong></p>
<p>代表性的有<code>redis</code>、<code>memecache</code></p>
</li>
<li><p><strong>文档型数据库</strong></p>
<p><code>MongoDB</code>一个基于分布式文件存储的数据库，<code>C++</code>编写，主要用来处理大量的文档，是一个介于关系型数据库和非关系型数据库的中间产品，<code>MongoDB</code>是非关系型数据库中功能最丰富，最像关系型数据库的。</p>
</li>
<li><p><strong>列存储数据库</strong></p>
<ul>
<li><code>Hbase</code></li>
<li>分布式文件系统</li>
</ul>
</li>
<li><p><strong>图关系数据库</strong></p>
<ul>
<li>存储拓扑图关系，比如朋友圈社交网络、广告推荐！(<code>Neo4j、infoGrid</code>)</li>
</ul>
</li>
</ol>
<h4 id="二、redis简介"><a href="#二、redis简介" class="headerlink" title="二、redis简介"></a>二、redis简介</h4><p>​    <code>Redis</code>是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串<code>String</code>， 散列<code>hashes</code>， 列表<code>lists</code>， 集合<code>sets</code>， 有序集合<code>sorted sets</code>与范围查询， <code>bitmaps</code>， <code>hyperloglogs</code>和地理空间<code>geospatial</code>索引半径查询。<code>Redis</code> 内置了复制，<code>LUA</code>脚本，<code>LRU</code>驱动事件，事务<code>transactions</code>和不同级别的磁盘持久化<code>persistence</code>， 并通过<code>Redis</code>哨兵<code>Sentinel</code>和自动分区<code>Cluster</code>提供高可用性<code>high availability</code>。</p>
<blockquote>
<p><code>Redis</code> 官方发布效率8w写，11万读 （mysql在300w数据之后需要加索引）</p>
</blockquote>
<h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h5><ol>
<li>内存存储、持久化，内存是断电即失，所以持久化很重要(<code>AOP</code>、<code>RDB</code>)</li>
<li>效率高可用用于高速缓存。</li>
<li>发布订阅系统。</li>
<li>地图信息分析。</li>
<li>计时器、计数器(浏览量、点赞数、发布数)</li>
</ol>
<h5 id="2-单线程"><a href="#2-单线程" class="headerlink" title="2. 单线程"></a>2. 单线程</h5><p><code>redis</code>是单线程，官方表示<code>redis</code>是基于内存操作，<code>CPU</code>不是<code>redis</code>性能瓶颈，<code>redis</code>的性能瓶颈是根据机器的内存和网络带宽。</p>
<p><strong>redis是单线程为什么还这么快?</strong></p>
<p>两个误区：高性能服务器一定是多线程？多线程一定比单线程效率高？</p>
<p>核心是：<code>redis</code>是将所有数据全部存放在内存中，所以使用单线程去操作效率就是最高的，减少了<code>CPU</code>上下文切换的时间，多线程会引发上下文切换，对于内存系统来说，如果没有上下文切换效率就是最高的。而且<code>redis</code>是基于<code>reactor</code>模型，使用的是<code>I/O</code>多路复用的<code>IO</code>模型。</p>
<p><strong><code>I/O</code>多路复用：</strong>在<code>I/O</code>多路复用模型中，最重要的函数调用就是<code>select</code>，该方法能同时监控多个文件描述符的可读可写情况，当其中某个文件描述符可读或可写时，<code>select</code>方法就会返回可读以及可写的文件描述符个数，<code>netty</code>的底层采用的也是<code>I/O</code>多路复用的模型。</p>
<h4 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h4><p>​    <code>redis</code>是内存数据库，如果不将内存中的数据保存在硬盘中，若出现断电或者宕机等情况，内存中保存的数据也会丢失。</p>
<h5 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h5><p>​    <code>RDB</code>全称是<code>Redis DataBase</code>，在指定的时间间隔内将内存中的数据集快照<code>Shapshot</code>写入磁盘，恢复时只需要将快照加载入内存即可，默认保存的文件名为<code>dump.rdb</code>。</p>
<p>​    <code>redis</code>会通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有内存数据写入到一个临时文件中，待持久化结束后，会替换掉上一次持久化好的文件。整个过程，主进程不进行任何<code>I/O</code>操作，确保了极高的性能。并且<code>.rdb</code>是二进制文件，比较轻量，灾难之后的恢复会快一些。</p>
<p><strong>两种方式</strong></p>
<ul>
<li><code>save</code>：阻塞主线程，使得主线程不能继续对外提供请求，若数据量小，将数据写入备份文件快，则没有多大影响，若数据量大，写入备份文件时间长，则写多长时间就会停机多长时间。</li>
<li><code>bgsave</code>：主线程<code>fork</code>子进程，子进程进行数据的备份，主进程在<code>fork</code>子进程时阻塞，之后不会阻塞，相比于<code>save</code>方式，阻塞时间可以忽略不计。</li>
</ul>
<p><strong><code>bgsave</code>的原理</strong></p>
<p>​    主进程在<code>fork()</code>子进程之后，内核把主进程所有的内存页的权限都设置为<code>read-only</code>，然后将子进程的地址空间指向主进程。所以这里两个进程共享了同一块内存空间，最极端的情况当子进程在备份数据时，主进程接收到写请求，这时由于内存页的权限是<code>read-only</code>，会触发页异常中断后，会将这个数据的内存页复制一份，并且主进程指向该内存页。所以可以得出，在某一个时间节点触发了<code>bgsave</code>，则它只会备份那个时间节点的数据，那个时间节点只有的写操作，它都无法处理到。从一般设计来说，缓存中都是使用频繁且读多写少的数据，所以这一机制并不会使得在备份时频繁带来内存页数据异常导致的性能问题。</p>
<h5 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h5><p>​    <code>AOF</code>全称是<code>Append only file</code>，以日志的形式来记录每个写操作(默认情况是关闭)，将<code>redis</code>执行过的所有写操作命令备份下来，会把写操作命令一直追加到文件中。恢复时，默认会读取<code>appendonly.aof</code>文件中的命令，逐个执行命令，使得数据恢复。</p>
<p>​    <code>redis</code>通过创建子线程的方式单独创建一个线程来进行持久化，这个线程会将所有<code>AOF</code>缓冲区的命令同步到<code>appendonly.aof</code>文件中。</p>
<p><strong><code>AOF</code>的配置项</strong></p>
<ul>
<li><code>appendonly on</code>：默认是关闭状态</li>
<li><code>appendfilename &quot;appendonly.aof&quot;</code>：默认的持久化文件名称</li>
<li><code>appendfsync always</code>：同步策略，有三种<code>always</code>(每次修改都会同步)，<code>everysec</code>(每秒同步一次)，<code>no</code>由操作系统控制同步，默认是<code>everysec</code></li>
</ul>
<p><strong><code>AOF</code>重写</strong></p>
<p>​    <code>AOF</code>重写会在保持最终数据一致的前提下，将一些多条命令，整合成一条命令来代替多条命令。<code>AOF</code>重写是通过子进程的方式进行，使用子进程不会阻塞父进程，使得父进程还是可以处理客户端请求，并且子进程可以继承父进程资源，并且这种继承采取<code>copy-on-write</code>的策略，所以<code>AOF</code>重写无需关心由于客户端写请求导致数据不一致问题。</p>
<p>​    <code>AOF</code>重写的写命令不仅要写入到<code>AOF</code>缓冲区，还会写入<code>AOF</code>重写缓冲区，写入原<code>AOF</code>缓冲区是为了避免若重写失败导致数据丢失；写入<code>AOF</code>重写缓冲区是为了子进程在进行<code>AOF</code>重写期间还是在继续处理命令请求。</p>
<p>​    子进程在重写完毕后会发送一个信号给父进程，父进程收到信号后，会将<code>AOF</code>重写缓冲区的所有内容写入到新的<code>AOF</code>文件中，并且采用原子操作覆盖现有<code>AOF</code>文件，完成新旧文件的替换。</p>
<p><strong>小结</strong></p>
<p>​    如果需要大规模恢复数据，且对数据恢复的完整性不是非常敏感，那么<code>RDB</code>比<code>AOF</code>方式更加有效，<code>RDB</code>的缺点是最后一次持久化可能会丢失一部分数据。若从安全性来说，<code>AOF</code>会比较高一点，<code>AOF</code>最多丢失1秒的数据(采用默认配置的话)，而<code>RDB</code>丢失上一次备份与宕机时间差之间的数据。在<code>redis</code>服务器开启<code>AOF</code>持久化功能时，会采用<code>AOF</code>文件来恢复数据，若没有开启<code>AOF</code>功能时，才会使用<code>RDB</code>来恢复数据。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习笔记(二)</title>
    <url>/2022/07/12/%E7%BC%93%E5%AD%98/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="redis学习笔记-二"><a href="#redis学习笔记-二" class="headerlink" title="redis学习笔记(二)"></a>redis学习笔记(二)</h1><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>​    主从复制是将一台<code>redis</code>服务器设置为主服务器<code>master</code>，复制到其他多台从服务<code>slave</code>上，主服务器负责读写操作，从服务器只能读。<strong>数据的复制只能是主服务器到从服务器。</strong>当主服务器宕机时，可以让从服务器接管主服务器接管，保证系统不至于停机，否则在主服务器重启到恢复数据的这个过程中，服务一直处于停机状态。<strong>主从服务器之间通过心跳的机制检查服务器间的连接状态</strong><span id="more"></span></p>
<p><strong>主从服务之间的数据复制通过全量复制和部分复制。</strong></p>
<ol>
<li><p><strong>全量复制</strong> </p>
<p>​    分为两步操作：①主节点接收到从节点的全量复制命令，执行<code>gbsave</code>，在后台生成<code>RDB</code>文件，同时将此刻之后的写操作命令添加到复制缓冲区中。②将<code>RDB</code>文件发送给从节点，从节点先清除本身数据后加载<code>RDB</code>文件，然后在将主节点的复制缓冲区写命令依次执行。从而保证了从节点和主节点的数据一致。</p>
</li>
<li><p><strong>部分复制</strong></p>
<ul>
<li>复制偏移量：主从节点分别维护一个<code>offset</code>偏移量，主节点每次向从节点发送多少数据，修改<code>offset</code>偏移量值；同理，从节点每次从主节点接收多少数据，也会修改<code>offset</code>偏移量值。</li>
<li>复制积压缓冲区：主节点内部维护一个长度固定的<code>FIFO</code>队列作为复制积压缓冲区，默认大小是<code>1M</code>，在进行命令同步时，不仅会将写命令同步到从节点，同时会将写命令写入复制积压缓冲区，由于长度固定，写入比较早的命令会被挤出缓冲区，所以当主从的<code>offset</code>差距大于缓冲区长度时，无法进行部分复制，只能执行全量复制。</li>
<li>服务器运行<code>ID</code>(<code>runId</code>)：每个节点都有运行<code>ID</code>，运行<code>ID</code>在节点启动时自动生成，主节点会将自己的<code>runId</code>发送给从节点，从节点保存起来，出现从节点断线重连：①若若从节点中保存的主<code>runId</code>=主<code>runId</code>则之前同步过该主节点数据，会首先尝试部分复制。②若从节点中保存的主<code>runId</code>!=现主<code>runId</code>，则只能全量复制。</li>
</ul>
</li>
</ol>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>​    在主从复制模式下，若出现主服务器宕机，则需要运维人员手动修改从服务器为主服务器，不能良好的支持高可用。哨兵模式从出现就是为了解决这个问题，所以哨兵模式其实就是高可用的主从复制模式。可以由至少一个哨兵(哨兵可以集群)，监听任意多个主从服务器，当主服务器出现异常，导致宕机的时候，由哨兵投票将某个从服务器选举为主服务器，这样就可以保证主从服务之间的高可用。</p>
<blockquote>
<p>启动哨兵：redis-sentinel /path/to/sentinel.conf</p>
</blockquote>
<ul>
<li><code>Subjectively Down(SDOWN)</code>：主观下线，单个哨兵做出下线的判断。</li>
<li><code>Objectively Down(ODOWN)</code>：客观下线，多个哨兵实例对同一客户端做出下线判断。</li>
</ul>
<p><strong>客观下线只适用于主服务器，其他从服务器或者哨兵只会主观下线。哨兵在判定它们为下线前不需要进行协商，所以从服务器或者哨兵永远不会达到客观下线的条件。</strong>理论上，主观下线的作用就是当主服务器出现客观下线时，哨兵进行选举的从服务器不会从主观下线的从服务器中选举。</p>
<p><strong><code>redis</code>集群</strong></p>
<p>​    集群是为了解决单机<code>redis</code>容量有限的问题，将数据按一定的规则分配到多台机器中，也叫数据分片，集群不需要哨兵。</p>
<p>使用<code>redis</code>分片会遇到一个问题是如果将所有数据都均匀的分布到每一台服务器上，如果仅仅只通过<code>key</code>的哈希值取服务器数量的模有可能出现两个问题：</p>
<ul>
<li><p>大量的哈希碰撞导致大量数据存储在了某一台或者某几台服务器上。</p>
</li>
<li><p>当出现服务器增加一台或者减少一台时，需要迁移大量的数据。</p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<p>采用一致性哈希算法进行处理。</p>
<p>如下图设置一个从0~2^32-1头尾相连的环。将目前集群中的服务器的<code>ip</code>进行哈希运算后对<code>2^23</code>进行取模后，得到结果一定落在这个环上的某个位置。</p>
<p><img src="https://s2.loli.net/2022/07/12/fb96c7TK3knjGdv.png" alt="一致性哈希图1.png"></p>
<p>假设现在集群中有三台服务器，分别进行<code>hash(ip)%2^23</code>运算之后，落在环上的位置，同时对一些需要存储在服务器中的数据进行<code>hash(key)%2^23</code>运算之后的值也会落在这个环上。根据顺时针，将对应的键归于某台服务器上，比如下图中<code>key1</code>落在<code>S1</code>服务器上，<code>key4</code>落在<code>S2</code>服务器上，<code>key2</code>和<code>key3</code>落在<code>S3</code>服务器上。</p>
<p><img src="https://s2.loli.net/2022/07/12/BujMksDNmw5Hx9z.png" alt="一致性哈希2.png"></p>
<p>假设这时需要添加一台服务器<code>S4</code>，那么只需要将<code>S4</code>在这个环上左侧部分的数据迁移到<code>S4</code>服务器上，其他服务器不需要进行迁移操作，删除服务器类似，所以不论是添加或者删除服务器，仅需要集群中的两台服务器进行迁移处理。</p>
<p><img src="https://s2.loli.net/2022/07/12/n8CoMD6u7KBAp2O.png" alt="一致性哈希3.png"></p>
<p>到这实际上已经解决了使用缓存集群进行分片在扩展和收缩时牵一发而动全身的数据迁移情况，但是在上面的例子中，服务的分布过于理想化，有可能出现一种场景是集群中就两台服务器，且两台服务器在这个环上距离非常靠近。业界称为<strong>数据倾斜</strong>：在存储集群中意思为大部分数据存储在少来服务器上，在计算集群中意思为大部分数据由少量服务器进行计算。</p>
<p>这里可以通过为服务器创建虚拟的节点，来扩大服务器在环上的分布，比如由每台服务器仅经过一次<code>hash(ip)%2^23</code>运算修改为<code>ip#1</code>、<code>ip#2</code>进行编号后在进行运算，使得一台服务器在环上存在多个节点，达到尽可能将数据均匀分布到各个服务器上的目的。</p>
<h4 id="缓冲穿透、击穿、雪崩"><a href="#缓冲穿透、击穿、雪崩" class="headerlink" title="缓冲穿透、击穿、雪崩"></a>缓冲穿透、击穿、雪崩</h4><p><strong>缓存穿透</strong>：当某一个<code>key</code>对应数据在缓存中不存在同时在持久层也不存在时，如果大量的请求涌入，会造成数据库的压力，这种现象称为缓存穿透。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>布隆过滤器：将所有数据都打入布隆过滤器中，当通过布隆过滤器查询某个值时，若返回<code>false</code>则一定不存在该数据，若返回<code>true</code>则可能存在数据(有一定误判率)，进入<code>redis</code>查询，若没有命中，在进入持久层查询。</li>
<li>缓存空对象：这种做法比较粗暴，当出现数据查询不到时，将空对象缓存，一般会设置一个较短的缓存时间。</li>
</ul>
<p><strong>缓存击穿</strong>：当某一时刻，某一个<code>key</code>对应的缓存时间过期导致失效，如果大量的请求涌入，导致所有的请求都到持久层，会造成数据库压力，这种现象称为缓存击穿。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>使用互斥锁：使用<code>mutex</code>，当缓存失效时，获取锁，在进入持久层，查询到数据后再添加到缓存中，也就是说若缓存中查询不到值，需要获取锁之后，才能进入持久层。</li>
</ul>
<p><strong>缓存雪崩</strong>：在某一个时刻，多个<code>key</code>对应的缓存时间过期，导致这些<code>key</code>全部失效，如果大量的请求涌入，导致所有的请求都到达持久层，会造成数据库压力，这种现象称为缓存雪崩。</p>
<p><strong>解决方案</strong></p>
<ul>
<li>缓存失效随机值，尽量避免多个<code>key</code>扎堆在同一时刻失效。</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis序列化配置</title>
    <url>/2023/05/05/%E7%BC%93%E5%AD%98/redis%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="redis序列化配置"><a href="#redis序列化配置" class="headerlink" title="redis序列化配置"></a>redis序列化配置</h1><blockquote>
<p>使用spring操作redis，一般会使用到Spring提供的RedisTemplate模板类，在使用时需要配置存入的key和value的序列化方式。</p>
</blockquote>
<span id="more"></span>

<h2 id="模板类RedisTemplate"><a href="#模板类RedisTemplate" class="headerlink" title="模板类RedisTemplate"></a>模板类RedisTemplate</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplate</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">RedisAccessor</span> <span class="keyword">implements</span> <span class="title">RedisOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enableTransactionSupport = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> exposeConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enableDefaultSerializer = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> ClassLoader classLoader;</span><br><span class="line">    <span class="comment">//序列化器</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> <span class="keyword">private</span> <span class="meta">@Nullable</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> RedisSerializer&lt;String&gt; stringSerializer = RedisSerializer.string();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> ScriptExecutor&lt;K&gt; scriptExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常用数据结构操作类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValueOperations&lt;K, V&gt; valueOps = <span class="keyword">new</span> DefaultValueOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListOperations&lt;K, V&gt; listOps = <span class="keyword">new</span> DefaultListOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SetOperations&lt;K, V&gt; setOps = <span class="keyword">new</span> DefaultSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamOperations&lt;K, ?, ?&gt; streamOps = <span class="keyword">new</span> DefaultStreamOperations&lt;&gt;(<span class="keyword">this</span>,</span><br><span class="line">            ObjectHashMapper.getSharedInstance());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZSetOperations&lt;K, V&gt; zSetOps = <span class="keyword">new</span> DefaultZSetOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GeoOperations&lt;K, V&gt; geoOps = <span class="keyword">new</span> DefaultGeoOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HyperLogLogOperations&lt;K, V&gt; hllOps = <span class="keyword">new</span> DefaultHyperLogLogOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterOperations&lt;K, V&gt; clusterOps = <span class="keyword">new</span> DefaultClusterOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有5个序列化器：</p>
<ul>
<li><code>keySerializer</code>：对存入<code>redis</code>中的<code>key</code>的序列化器</li>
<li><code>valueSerializer</code>：对存入<code>redis</code>中的<code>value</code>的序列化器</li>
<li><code>hashKeySerializer</code>：对以<code>hash</code>结构数据存入的<code>hashkey</code>序列化器</li>
<li><code>hashValueSerializer</code>：对以<code>hash</code>结构数据存入的<code>hashvalue</code>序列化器</li>
<li><code>stringSerializer</code>：字符串方式序列化器</li>
</ul>
<p>序列化器具体的实现：</p>
<ol>
<li><code>FastJsonRedisSerializer</code>由阿里巴巴的<code>fastjson</code>提供的转为<code>JSON</code>格式进行序列化。</li>
<li><code>Jackson2JsonRedisSerializer</code>在<code>spring</code>中已经集成，采用<code>Jackson</code>的方式转换为<code>JSON</code>格式进行序列化。</li>
<li><code>JdkSerializationRedisSerializer</code>jdk默认提供的序列化方式，如果是<code>POJO</code>需要实现<code>Serializable</code>接口。</li>
<li><code>StringRedisSerializer</code>字符方式序列化，如果是<code>POJO</code>，相当于调用了<code>toString</code>进行序列化。</li>
</ol>
<p><b>默认情况下使用的是<code>jdk</code>方式进行键和值的序列化，如果需要修改默认方式，在接入<code>spring</code>的情况下需要设置这些序列化器之后添加到<code>spring</code>容器中。你可以仅仅修改你想要修改的序列化器，其他的保持默认，模板类提供了一个后置接口。</b></p>
<p>它会逐个进行判断处理，如果某个序列化器为空，则设置对应的默认序列化器。所以一般在设置完成之后会调用一次这个后置接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(</span><br><span class="line">                classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableDefaultSerializer) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            keySerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            valueSerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hashKeySerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            hashValueSerializer = defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h2><p>对<code>RedisTemplate</code>进行配置，设置<code>value</code>的序列化器为<code>jdk</code>提供的序列化器，<b><code>POJO</code>需要实现<code>Serializable</code>接口。</b></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用jdk序列化方式进行序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式进行序列化之后，在<code>redis-cli</code>上查看时，默认获取的值会被转换为<b>十六进制</b>，导致在排查问题时可读性较差。</p>
<blockquote>
<p>\xAC\xED\x00\x05sr\x00\x1Ecn.com.xiaocainiaoya.vo.Person\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x04L\x00\x03aget\x00\x13Ljava/lang/Integer;L\x00\x06housest\x00\x10Ljava/util/List;L\x00\x08passwordt\x00\x12Ljava/lang/String;L\x00\x08userNameq\x00<del>\x00\x03xpsr\x00\x11java.lang.Integer\x12\xE2\xA0\xA4\xF7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xAC\x95\x1D\x0B\x94\xE0\x8B\x02\x00\x00xp\x00\x00\x00\x0Csr\x00\x13java.util.ArrayListx\x81\xD2\x1D\x99\xC7a\x9D\x03\x00\x01I\x00\x04sizexp\x00\x00\x00\x01w\x04\x00\x00\x00\x01sr\x00\x1Dcn.com.xiaocainiaoya.vo.House\x00\x00\x00\x00\x00\x00\x00\x01\x02\x00\x02L\x00\x07addressq\x00</del>\x00\x03L\x00\x04areat\x00\x16Ljava/math/BigDecimal;xpt\x00\x06\xE5\x8C\x97\xE4\xBA\xACsr\x00\x14java.math.BigDecimalT\xC7\x15W\xF9\x81(O\x03\x00\x02I\x00\x05scaleL\x00\x06intValt\x00\x16Ljava/math/BigInteger;xq\x00<del>\x00\x06\x00\x00\x00\x01sr\x00\x14java.math.BigInteger\x8C\xFC\x9F\x1F\xA9;\xFB\x1D\x03\x00\x06I\x00\x08bitCountI\x00\x09bitLengthI\x00\x13firstNonzeroByteNumI\x00\x0ClowestSetBitI\x00\x06signum[\x00\x09magnitudet\x00\x02[Bxq\x00</del>\x00\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFF\xFF\xFE\x00\x00\x00\x01ur\x00\x02[B\xAC\xF3\x17\xF8\x06\x08T\xE0\x02\x00\x00xp\x00\x00\x00\x02\x03\xE9xxxt\x00\x03123t\x00\x03tom</p>
</blockquote>
<p>根据比对调用反序列化时的二进制流，发现这一串乱码中“\xAC”表示的十六进制，“\x05sr”中的“\x05”表示一个十六进制，“sr”需要按位解析为二进制，按这个逻辑进行解析之后，得到的结果就是反序列化字节流，所以根据这个逻辑就可以简单通过一段代码将这串乱码反序列化为原始对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String value = <span class="string">&quot;\\xAC\\xED\\x00\\x05t\\x00\\x18Pj/1x/ZLXkvm0q6bNZiOYw==&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] hexValues = value.split(<span class="string">&quot;\\\\x&quot;</span>);</span><br><span class="line">    <span class="comment">// 结果字节流长度，适当调整长度，如果类过大，可能长度不够会报数组长度越界</span></span><br><span class="line">    <span class="keyword">byte</span>[] resultValue = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> resultIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hexValues.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 切割之后可能出现首个或者末个是空串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isEmpty(hexValues[i]))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// AC/ED/00等表示为单个十六进制</span></span><br><span class="line">        <span class="keyword">if</span>(hexValues[i].length() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(hexValues[i], <span class="number">16</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 05t等认为前两位为十六进制，后面按字符逐个转换为字节</span></span><br><span class="line">            String str = hexValues[i];</span><br><span class="line">            resultValue[resultIndex++] = (<span class="keyword">byte</span>) Integer.parseInt(str.substring(<span class="number">0</span>, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 后面的按字符转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; str.length(); j++)&#123;</span><br><span class="line">                resultValue[resultIndex++] = (<span class="keyword">byte</span>) str.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对转换的字节流进行反序列化解析为对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> JdkSerializationRedisSerializer().deserialize(resultValue);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在排查问题时，可以尝试使用这种方式对乱码串进行解析，得到原始对象。(<b>前提是你的工程存在这个类！！</b>)</p>
<h2 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h2><p>字符序列化器，一般对于存入的<code>key</code>和非<code>POJO</code>都会采用这种方式进行序列化，在<code>redis-cli</code>上也能直观的看到对应的键和值是什么。</p>
<p>在<code>Spring</code>中已经提供了对键和值都采用字符序列化器的方式进行操作的模板类<code>StringRedisTemplate</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setKeySerializer(RedisSerializer.string());</span><br><span class="line">        setValueSerializer(RedisSerializer.string());</span><br><span class="line">        setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RedisSerializer&lt;String&gt; <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringRedisSerializer.UTF_8;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置为编码为UTF-8的字符序列化器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer UTF_8 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Jackson2JsonRedisSerializer"><a href="#Jackson2JsonRedisSerializer" class="headerlink" title="Jackson2JsonRedisSerializer"></a>Jackson2JsonRedisSerializer</h2><p><code>jackson</code>机制进行序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line"></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>jackson</code>方式进行序列化之后的值，如下所示，对于复杂对象会表示它的类型，这种存储方式会导致占用的序列化串长度过长，占用一定的存储空间。</p>
<blockquote>
<p>[“cn.com.xiaocainiaoya.vo.Person”,{“userName”:”tom”,”password”:”123”,”age”:12,”houses”:[“java.util.ArrayList”,[[“cn.com.xiaocainiaoya.vo.House”,{“address”:”北京”,”area”:[“java.math.BigDecimal”,100.1]}]]]}]</p>
</blockquote>
<h2 id="FastJsonRedisSerializer"><a href="#FastJsonRedisSerializer" class="headerlink" title="FastJsonRedisSerializer"></a>FastJsonRedisSerializer</h2><p>阿里巴巴提供的<code>fastjson</code>序列化器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下两种redisTemplate自由根据场景选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer = <span class="keyword">new</span> FastJsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        <span class="comment">// 全局开启AutoType，不建议使用</span></span><br><span class="line">        <span class="comment">// ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span></span><br><span class="line">        <span class="comment">// 建议使用这种方式，小范围指定白名单</span></span><br><span class="line">        <span class="comment">//ParserConfig.getGlobalInstance().addAccept(&quot;cn.com.xiaocainiao&quot;);</span></span><br><span class="line">        template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"><span class="comment">//        template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式生成的<code>JSON</code>串结果如下所示，对比<code>jackson</code>序列化器生成的结果串，发现复杂对象的所在类不会生成，减少一定的空间占用。</p>
<blockquote>
<p>{“age”:12,”houses”:[{“address”:”北京”,”area”:100.1}],”password”:”123”,”userName”:”tom”}</p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库和缓存双写一致性</title>
    <url>/2022/07/20/%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1 id="数据库和缓存双写一致性"><a href="#数据库和缓存双写一致性" class="headerlink" title="数据库和缓存双写一致性"></a>数据库和缓存双写一致性</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    使用缓存在存储热点数据是常用的提交系统响应速度的一种解决方案，但是在更新数据时如何确保数据库和缓存中的数据一致性，特别是在高并发的场景下，应如何保证双写数据的一致性。<span id="more"></span></p>
<p><img src="https://s2.loli.net/2022/07/20/m6zT1AH2oZvSwa8.png" alt="双写一致性.png"></p>
<p>通常来说，常见的应用场景为：</p>
<ol>
<li>用户请求查询某些数据，先进入缓存查看是否存在</li>
<li>存在则直接返回数据</li>
<li>不存在则查数据库，查到则将数据添加一份到缓存中，再返回，使得下次查询可以直接从缓存中获取，从而提高系统的响应速度。</li>
</ol>
<h2 id="双写的四种场景"><a href="#双写的四种场景" class="headerlink" title="双写的四种场景"></a>双写的四种场景</h2><ol>
<li>先更新缓存，再更新数据库</li>
</ol>
<p>​    如果采用这种方式，极易产生数据不一致的情况。因为先更新缓存，如果因为某些原因出现数据写入失败，比如主键冲突、非空字段未填值、数据库宕机等等情况导致数据库写入失败，这时就出现了缓存中是新值，数据库中是旧值，造成了数据库和缓存数据不一致。</p>
<ol start="2">
<li>先更新数据库，再更新缓存</li>
</ol>
<p>​    假设更新数据库的操作和更新缓存的操作在同一个事务中，那么更新数据库之后，再更新缓存，如果出现缓存更新失败，那么事务回滚，保证了数据的一致性。但由于数据库和缓存实际上都是采用远程链接的方式读写数据，所以一般来说只有在低并发的场景下，才会将二者放在同一个事务中，否则若写缓存过慢，直接导致数据库事务时间被拉长，而形成长事务。如果二者不在同一个事务中，若数据库更新数据成功，缓存中更新数据失败，就会导致数据的不一致。</p>
<p>​    假设在高并发场景下，且更新缓存和更新数据库不在同一个事务中执行。假设有两个写操作，当写操作A更新数据库之后，在将数据写入缓存的过程中出现网络拥堵等情况，这时写操作B，也更新了数据库，拿着更新之后的值，写入到缓存中，同时写操作A的网络不拥堵了，写操作A又更新了缓存，这时数据库中是写操作B的值，缓存中是写操作A的值，从而造成了数据不一致。</p>
<p><img src="https://s2.loli.net/2022/07/20/rq9LGBjQ4EfCvRh.png" alt="先更新数据库再更新缓存.png"></p>
<ol start="3">
<li>先删除缓存，再更新数据库</li>
</ol>
<p>​    同样在高并发下，如果请求A在删除缓存之后，写入数据库之前的这段时间内，如果有请求B进行获取数据，这是它从缓存中获取不到，则从数据库中获取，由于这时A还未将数据写入到数据库中，请求B读到的是旧值，而请求B又将读到的旧值写入到缓存中，之后请求A又将新值写入到数据库中，造成了数据库和缓存数据不一致。</p>
<p><img src="https://s2.loli.net/2022/07/20/lZQImSBoycYAO5b.png" alt="先删缓存再写库.png"></p>
<p>可以通过<strong>缓存双删</strong>的方式解决这个问题，写操作A在写入数据库之后，再删除一次缓存，这时又有一个新的问题，如果写操作A在一更新数据库之后，就去删缓存，可能存在某些线程中已经获取了旧值，只不过还没写入到缓存中，也就是上图的步骤7和步骤8。所以一般是在更新数据库之后一段时间之后进行缓存删除，比如500ms。</p>
<ol start="4">
<li>先更新数据库，再删除缓存</li>
</ol>
<p>​    同样假设有两个请求，一个读请求A，一个写请求B。</p>
<ul>
<li>当写请求B先到，在更新数据库的过程中或者更新数据库后还未删除缓存时，读请求到达，读取了缓存中的数据，然后写请求B再删除缓存，对于这种场景仅读请求A读取了一次旧值。</li>
<li>当读请求A先到，读取到了缓存中的数据，直接返回了，这时写请求B在更新数据库，再删除缓存，同样对于这种场景，仅读请求A读取了一次旧值。</li>
</ul>
<p>但是还是有一种场景下，会导致数据不一致，也就是缓存过期了。</p>
<p>也就是当写操作A到达，在更新数据时出现拥堵，这时读操作B来读取缓存，刚好缓存过期，则从数据库中获取到了旧值，同时写操作A更新了数据库，且删除了缓存，然后读操作B再将旧值写入到缓存中，造成数据不一致。</p>
<p><img src="https://s2.loli.net/2022/07/20/jD6v2BzV7gylqRE.png" alt="写库再删缓存.png"></p>
<p>但是一般来说认为要造成上述场景需要满足两个条件：</p>
<ol>
<li>缓存刚好过期了</li>
<li>读操作B从数据库读到数据之后，更新缓存的耗时比写操作A更新数据库+删除缓存的耗时长。(一般来说对缓存的操作耗时要远小于对数据的操作耗时)</li>
</ol>
<p><strong>综上，一般来说还是需要采用先更新数据库再删除缓存的策略。</strong></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    实际上不论是方案3中的缓存双删还是方案4都存在一个问题，在二者操作不在同一个事务的前提下，如果删除缓存操作失败了，那么就会导致缓存和数据库数据不一致。</p>
<p>​    这时就需要引入重试机制，缓存删除失败之后进行重试。关于重试就可简单可复杂了，简单就是直接捕获异常进行重试操作，但这可能影响接口时效，也可以将设置专门线程池，将重试操作推给线程池，又或者引入一些任务调度或者是<code>MQ</code>的中间件来处理。在查资料的过程中，有看到有人说也可以通过订阅<code>mysql</code>的<code>binlog</code>，如果发现了更新数据请求，则删除对应的缓存，但是据我所知很多项目在生产环境甚至连<code>binlog</code>功能都没有开启[旺柴]。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的过滤器和拦截器</title>
    <url>/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/spring%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h3 id="SpringMVC中的过滤器和拦截器"><a href="#SpringMVC中的过滤器和拦截器" class="headerlink" title="SpringMVC中的过滤器和拦截器"></a>SpringMVC中的过滤器和拦截器</h3><p>[TOC]</p>
<h4 id="一、过滤器"><a href="#一、过滤器" class="headerlink" title="一、过滤器"></a>一、过滤器</h4><blockquote>
<p>​    过滤器<code>Filter</code>是通过实现<code>java.servlet.filter</code>接口实现过滤器功能，作用是用于对传入的<code>request</code>和响应的<code>response</code>进行一些处理，比如对请求参数进行校验，或者设置、检验头部信息，再或者对一些非法行为进行校验。由实现的接口可知，过滤器是依赖于<code>servlet</code>容器。<strong>所以由于过滤器不依赖于<code>spring</code>容器，它也就无法获取到容器中的对象。</strong></p>
</blockquote>
<span id="more"></span>

<p>创建一个过滤器类继承<code>java.servlet.filter</code>接口，实现<code>filter</code>中的拦截方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="comment">// 过滤器的具体执行方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把创建的过滤器类加入过滤器链中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建两个过滤器myFilter和myFilter2，并且分别添加到FilterRegistrationBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">		FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> </span><br><span class="line">            											FilterRegistrationBean();</span><br><span class="line">		filterRegistrationBean.setFilter(myFilter());</span><br><span class="line">		filterRegistrationBean.setName(<span class="string">&quot;myFilter&quot;</span>);</span><br><span class="line">		filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">		filterRegistrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//filterRegistrationBean.setInitParameters();</span></span><br><span class="line">		<span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filter2RegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">		FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span></span><br><span class="line">            										FilterRegistrationBean();</span><br><span class="line">		filterRegistrationBean.setFilter(myFilter2());</span><br><span class="line">		filterRegistrationBean.setName(<span class="string">&quot;myFilter2&quot;</span>);</span><br><span class="line">		filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">		filterRegistrationBean.setOrder(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">//filterRegistrationBean.setInitParameters();</span></span><br><span class="line">		<span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Filter <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Filter <span class="title">myFilter2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyFilter();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、拦截器"><a href="#二、拦截器" class="headerlink" title="二、拦截器"></a>二、拦截器</h4><blockquote>
<p>拦截器<code>Interceptor</code>是通过实现<code>org.springframework.web.servlet</code>包的<code>HandlerInterceptor</code>接口实现，这个接口是<code>spring</code>容器的接口，所以它是依赖于<code>spring</code>容器的。主要作用是<code>AOP</code>的思想，可以对某一个方法进行横切，做一些业务逻辑。</p>
</blockquote>
<p><strong>1.编写自定义拦截器类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;请求调用之前&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;请求调用之后&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;afterCompletion:请求调用完成后回调方法，即在视图渲染完成后回调&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.注册自定义拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.modules.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在spring2.0中WebMvcConfigurerAdapter已经过时，这里只是为了演示效果，</span></span><br><span class="line"><span class="comment"> * 有兴趣可以看下spring2.0中的WebMvcConfigurer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2020/6/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurer</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">		registry.addInterceptor(getHandlerInterceptor()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HandlerInterceptor <span class="title">getHandlerInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CustomHandlerInterceptor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>过滤器和拦截器执行过程图</strong></p>
<p>​    在请求到达容器前，进入<code>Filter</code>过滤器链，执行完过滤器链上每个<code>Filter#doFilter()</code>方法后，进入<code>Servlet#service()</code>方法，然后由<code>dispatcher</code>分发器将请求方法给对应映射成功的处理器<code>controller</code>，在进入<code>controller</code>具体方法之前，会被先进入<code>Interceptor#preHandler()</code>方法，然后再进入<code>controller</code>的具体返回，执行之后进入<code>Interceptor#postHandler()</code>这里主要是拦截了<code>controller</code>方法执行之后到返回的数据模型到达视图解析器之前，接着进入<code>Interceptor#afterCompletion()</code>方法，主要可以操作返回客户端之前的逻辑，最后返回到过滤链中各个<code>Filter</code>的调用点，可以处理返回到客户端的跳转等逻辑。</p>
<p><img src="https://gitee.com/jiangjiamin/image-bed/raw/master/upic/2020-11/GvwS1P.png"></p>
<h4 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h4><p>​    过滤器是<code>servlet</code>中的接口，主要可以用于在请求进入到<code>servlet</code>之前拦截请求<code>HttpServletRequest</code>并根据需要进行一些检查等逻辑操作，也可以在<code>HttpServletResponse</code>返回到客户端之前进行一些逻辑操作。</p>
<p>​    拦截器是<code>spring</code>中的接口，所以它可以获取到<code>spring</code>中的一些<code>bean</code>和其他的一些资源，在面向切面编程中应用比较广，拦截其实就是一种<code>AOP</code>策略。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>从myBatis Plugin看责任链模式</title>
    <url>/2021/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8EmyBatis%20Plugin%E7%9C%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="从myBatis-Plugin看责任链模式"><a href="#从myBatis-Plugin看责任链模式" class="headerlink" title="从myBatis Plugin看责任链模式"></a>从myBatis Plugin看责任链模式</h3><p>[TOC]</p>
<h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>​    在<code>mybatis</code>中从<code>sql</code>的解析到最后结果集的返回，经过了一系列的内部组件，比如参数处理器<code>parameterHandler</code>，语句处理器<code>StatementHandler</code>，结果集处理器<code>ResultSetHandler</code>等。若开发者需要对<code>SQL</code>执行的某一环节进行一些特定的处理，比如参数类型的转换，数据分页功能，打印执行的<code>SQL</code>语句等都可以通过<code>mybatis</code>的插件机制实现。</p>
<span id="more"></span>

<h4 id="二、mybatis的责任链"><a href="#二、mybatis的责任链" class="headerlink" title="二、mybatis的责任链"></a>二、mybatis的责任链</h4><p>​    <code>mybatis</code>中就是对内部的一个<code>List</code>数组做拦截，业务方通过实现<code>Interceptor</code>接口后，将具体的实现类通过<code>InterceptorChain#addInterceptor</code>添加到责任链中，当<code>mybatis</code>初始化资源时，会调用<code>InterceptorChain#pluginAll</code>通过代理的方式，将所有的插件通过逐层代理的方式将内部核心组件(比如<code>ParameterHandler</code>)包裹返回一个代理对象。</p>
<p>​    真正执行的地方是由于将内部核心组件都包装成了代理类，所以在调用执行方法时，会被代理对象拦截进入<code>invoke</code>方法，根据执行方法所属类以及注解等判断是否执行拦截器或者是执行原方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截执行该方法</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部就是一个拦截器的List</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环调用每个Interceptor.plugin方法</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、过滤器相关责任链"><a href="#三、过滤器相关责任链" class="headerlink" title="三、过滤器相关责任链"></a>三、过滤器相关责任链</h4><p>​    在权限校验等一些拦截器中，通常的做法是有多层拦截，比如简单的登录过程，先校验用户名密码是否正确，在校验是否拥有某项操作的操作权限之后才会使得用户获取到资源，但是如果用户名密码校验失败，就没有必要进入第二部的操作权限校验，所以这种场景下使用<code>mybatis</code>那种方式的责任链有所不妥。以下是基于在多层拦截下，若某层校验失败，直接拒绝继续往下校验的责任链模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截执行方法</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function">Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现A拦截</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterA</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="comment">// 在这里选择是否继续往下走，这种方式会往下走</span></span><br><span class="line">    <span class="keyword">return</span> filterChain.doFilter(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现B拦截</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterB</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target, FilterChain filterChain)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="comment">// 这种方式会直接返回，不会继续执行其他拦截器(当然了在我的例子中也没有其他拦截器了)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部维护一个数组，存储各个拦截器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Iterator iterator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doFilter</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iterator == <span class="keyword">null</span>)&#123;</span><br><span class="line">      iterator = filters.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iterator.hasNext())&#123;</span><br><span class="line">      Filter filter = (Filter) iterator.next();</span><br><span class="line">      filter.doFilter(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">    filters.add(filter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">  FilterA filterA = <span class="keyword">new</span> FilterA();</span><br><span class="line">  FilterB filterB = <span class="keyword">new</span> FilterB();</span><br><span class="line">  filterChain.addFilter(filterA);</span><br><span class="line">  filterChain.addFilter(filterB);</span><br><span class="line">  filterChain.doFilter(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    以上两种责任链的不同形式，其实是应对于不同的业务场景，当需要所有的拦截都走一轮，则采用第一种；当在某个拦截器失败后不继续进行，则采用第二种。在实际的场景中需要综合考虑，采取最符合业务场景的形式进行编码。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>从德鲁伊词法分析器看访问者模式</title>
    <url>/2021/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%8E%E5%BE%B7%E9%B2%81%E4%BC%8A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9C%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="从德鲁伊词法分析器看访问者模式"><a href="#从德鲁伊词法分析器看访问者模式" class="headerlink" title="从德鲁伊词法分析器看访问者模式"></a>从德鲁伊词法分析器看访问者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    公司内部为了<code>SQL</code>脚本可管理、可重复执行，每个版本提交的每个脚本都需要填写对应的版本、负责人、版本号、具体脚本等信息并确保脚本可重复执行，但是基础具体的<code>SQL</code>之外，其他需要填写的信息都属于重复操作，所以想着写一个工具来代替重复操作，只需要编写具体的<code>SQL</code>，其他信息根据配置自动生成，由于脚本需要允许可重复执行，故需要对编写的执行<code>SQL</code>进行词法分析，提取其中的数据库实例名称、数据表名、字段名、索引名等信息，在引入德鲁伊的词法分析器之后，感觉使用起来非常简单，需要什么类型的脚本，打入什么类型的实体即可，看了一下源码，词法分析器是采用访问者模式设计的。</p>
<span id="more"></span>

<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas的基本使用</title>
    <url>/2021/11/18/Springboot/arthas/Arthas%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    最近正式环境出现一起事故，业务端经过一些列的业务逻辑之后，使用<code>wkhtmltopdf</code>工具进行<code>html</code>转换为<code>pdf</code>，但出现生成完成之后(正常结束，并未发生异常)业务端再次获取这个<code>pdf</code>文件时，出现文件不存在问题。<span id="more"></span></p>
<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>​    经过一系列的排查，最终锁定在<code>wkhtmltopdf</code>工具是否正常生成<code>pdf</code>文件，请看如下代码，这里通过<code>wkhtmltopdf</code>提供的工具类<code>pdf.saveAsDirect(ftpDir + &quot;/&quot; + path);</code>进行<code>pdf</code>的生成，但并未对返回的结果进行判断，所以猜测这里根本没有生成<code>pdf</code>文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadToPdfDirect</span><span class="params">(WrapperConfig config, String sourceString, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pdf pdf = <span class="keyword">new</span> Pdf(config);</span><br><span class="line">        pdf.setAllowMissingAssets();</span><br><span class="line">        pdf.addPageFromString(sourceString);</span><br><span class="line">        pdf.addParam(pageInfo);</span><br><span class="line">        pdf.saveAsDirect(ftpDir + <span class="string">&quot;/&quot;</span> + path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;wkHtmlToPdf发生异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 捕获到InterruptedException异常后恢复中断状态</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wkHtmlToPdf发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据猜测希望将代码修改为：(本想借助<code>Arthas</code>将代码修改以下代码，但由于线上一直产生数据，事故面积越来越大，来不及研究<code>Arthas</code>的使用，只能走繁琐的流程，进行发包替换正式环境的包)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadToPdfDirect</span><span class="params">(WrapperConfig config, String sourceString, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pdf pdf = <span class="keyword">new</span> Pdf(config);</span><br><span class="line">        pdf.setAllowMissingAssets();</span><br><span class="line">        pdf.addPageFromString(sourceString);</span><br><span class="line">        pdf.addParam(pageInfo);</span><br><span class="line">        <span class="comment">// 对生成的结果进行判断, 到底有没有生成对应文件</span></span><br><span class="line">        File file = pdf.saveAsDirect(ftpDir + <span class="string">&quot;/&quot;</span> + path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">&quot;文件生成失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;wkHtmlToPdf发生异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 捕获到InterruptedException异常后恢复中断状态</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wkHtmlToPdf发生异常：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>​    经过漫长的发版流程等待，等到正式环境替换包已经是大半夜。经过测试，确实是<code>pdf</code>文件未生成(如果会使用<code>Arthas</code>，这个时候应该就已经解决问题)。这里要说明下，到目前为止只知道这种方式会生成失败，至于在什么情况下生成失败就不得而知了，因为开发环境、测试环境、预发布环境都是正常生成。痛定思痛，决定学习一下<code>Arthas</code>的使用。</p>
<h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><p>简单的使用流程：</p>
<ol>
<li><p>找到需要进行添加代码的类全路径后进行反编译到某个文件夹中。</p>
<blockquote>
<p>jad –source-only com.xxx.service.v3.xxxService &gt; /tmp/xxxService.java</p>
</blockquote>
<p>这里是由<code>.class</code>反编译为<code>.java</code>文件，所以阅读上没有那么友好，其实刚出现问题的时候就想到使用<code>Arthas</code>，但是被这个反编译出来的代码劝退了，反编译出来的代码甚至有指令重排，不太敢修改这个反编译文件。</p>
</li>
<li><p>修改这个反编译文件</p>
<blockquote>
<p>vim /tmp/UserController.java</p>
</blockquote>
<p>这里实际上是要先退出<code>arthas</code>，第一次使用的时候还以为<code>arthas</code>命令行可以直接操作文件，实际上应该退出<code>arthas</code>使用<code>linux</code>命令的方式进行文件修改。</p>
</li>
<li><p>查找这个类对应的类加载器</p>
<blockquote>
<p>sc -d *xxxService | grep classLoadHash</p>
<p>classLoadHash 6bc26251</p>
</blockquote>
<p>这里得到这个类的加载器的哈希值为<code>6bc26251</code></p>
</li>
<li><p>使用这个类加载器将修改后的文件编译为<code>.class</code>文件</p>
<blockquote>
<p>mc -c 6bc26251 /tmp/xxxService.java -d /tmp</p>
</blockquote>
<p>这时会在<code>/tmp</code>文件夹下生成一个以包结构为文件路径的<code>.class</code>文件。</p>
</li>
<li><p>进行热更新</p>
<blockquote>
<p>redefine /tmp/com/xxx/service/v3/xxxService.class</p>
</blockquote>
<p>当看到提示<code>redefine success, size: 1</code>说明替换成功，就可以进行具体的测试。</p>
</li>
</ol>
<p>以上这种方式，出现问题的概率极大，因为要修改反编译文件，且反编译文件好像进行了一些指令重排，导致阅读上比较困难，实际上以上的前四步骤就是为了得到修改之后的<code>.class</code>文件，那么实际上我们可以借助于<code>idea</code>进行处理。</p>
<ol>
<li>找到线上代码的标签，拉取修改文件分支。</li>
<li>检出这个分支，进行特定文件的修改后，直接使用<code>idea</code>工具进行文件的编译。这时就可以通过<code>target</code>文件夹获取到对应修改文件的<code>.class</code>文件。</li>
<li>将这个<code>.class</code>文件上传到对应服务器。</li>
<li>直接热更新这个文件。(也就是上述的第5步)</li>
</ol>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><ol>
<li>在某个接口的服务层添加一个日志打印信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequireFileVo <span class="title">getFiles</span><span class="params">(ParamVo ParamVo, Integer pageNum, Integer pageSize)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;pageSize:&#123;&#125;&quot;</span>, pageSize);</span><br><span class="line">        <span class="comment">// 以下为很复杂的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>通过<code>idea</code>对整个服务进行编译后，获取到该文件的<code>.class</code>文件。</p>
</li>
<li><p>上传到服务器中，由于服务是运行在<code>docker</code>中，所以上传到服务器后移动文件到<code>docker</code>与宿主机的挂载目录中。</p>
</li>
<li><p>从挂载目录移动到简单目录。(测试的时候使用的挂载目录路径比较长，就移动到简单一点的目录比如<code>/tmp</code>)</p>
</li>
<li><p>使用<code>redefine</code>命令后看到<code>redefine success, size: 1</code>表示成功</p>
</li>
<li><p>测试，通过<code>postman</code>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">11</span>-<span class="number">18</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">30.491</span> [TraceId=92aeb19c3e8ce62b,SpanId=92aeb19c3e8ce62b,ParentSpanId=] [http-nio-<span class="number">20065</span>-exec-<span class="number">5</span>] INFO  c.b.g.b.s.v.s.xxxService-pageSize:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其他基础功能"><a href="#其他基础功能" class="headerlink" title="其他基础功能"></a>其他基础功能</h2><ul>
<li><strong>reset</strong>：重置增强类，此命令会将<code>arthas</code>增强过的类都重置为增强之前的情况。</li>
<li><strong>quit</strong>：退出，<code>quit</code>只是退出<code>archas</code>的<code>session</code>，实际上目标进程<code>arthas server</code>还在运行中。</li>
<li><strong>stop</strong>：彻底退出<code>arthas</code>，使用此命令后，实际上会执行一次<code>reset</code>命令。</li>
</ul>
<p><strong>注意：</strong>要区别于<code>quit</code>和<code>stop</code>两个退出之间的区别。</p>
<blockquote>
<p> 通过线程<code>id</code>查看线程的具体信息，比如查看线程<code>id</code>为1的线程的具体信息：<code>thread 1</code></p>
</blockquote>
<p><strong>1.watch</strong>：查看类里面的某个方法的返回值和入参(实际上只能看参数类型, 是否有值, 并不能看值是多少)</p>
<blockquote>
<p>命令 + 类完全限定名 + 需要检测的方法 + 表达式 + (额外参数)</p>
<p>watch com.xxx.xxx.service.v3.xxxService  getFiles “{params, returnObj}” -x 2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">额外参数：</span><br><span class="line">-x 指定输出结果(默认为<span class="number">1</span>) 这里为<span class="number">2</span>层</span><br><span class="line">-b 表示在方法调用之前</span><br><span class="line">-e 表示在方法出异常时</span><br><span class="line">-s 表示在方法返回之后</span><br><span class="line">-f 表示在方法结束之后(正常返回和异常返回)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">表达式核心变量列表：</span><br><span class="line">loader      本次调用类所在的 ClassLoader</span><br><span class="line">clazz       本次调用类的 Class 引用</span><br><span class="line">method      本次调用方法反射引用</span><br><span class="line">target      本次调用类的实例</span><br><span class="line">params      本次调用参数列表，这是一个数组，如果方法是无参方法则为空数组</span><br><span class="line">returnObj   本次调用返回的对象。当且仅当 isReturn==<span class="keyword">true</span> 成立时候有效，表明方法调用是以正常返回的方式结束。如果当前方法无返回值 <span class="keyword">void</span>，则值为 <span class="keyword">null</span></span><br><span class="line">throwExp    本次调用抛出的异常。当且仅当 isThrow==<span class="keyword">true</span> 成立时有效，表明方法调用是以抛出异常的方式结束。</span><br><span class="line">isBefore    辅助判断标记，当前的通知节点有可能是在方法一开始就通知，此时 isBefore==<span class="keyword">true</span> 成立，同时 isThrow==<span class="keyword">false</span> 和 isReturn==<span class="keyword">false</span>，因为在方法刚开始时，还无法确定方法调用将会如何结束。</span><br><span class="line">isThrow     辅助判断标记，当前的方法调用以抛异常的形式结束。</span><br><span class="line">isReturn    辅助判断标记，当前的方法调用以正常返回的形式结束。</span><br></pre></td></tr></table></figure>

<p><strong>2.trace</strong>：方法内部的调用路径，并输出方法路径上的每个节点耗时</p>
<blockquote>
<p>命令 + 类完全限定名 + 需要检测的方法</p>
<p>trace com.xxx.xxx.service.v3.xxxService  getFiles</p>
</blockquote>
<p><strong>3.heapdump</strong>：生成快照信息</p>
<blockquote>
<p>heapdump (–live) 生成文件路径/xxx.hprof</p>
</blockquote>
<p><strong>–live</strong>：只<code>dump</code>活着的对象</p>
<p>我是使用<code>jdk</code>自带的<code>jvisualvm</code>来打开<code>xx.hprof</code>文件进行分析。<code>jdk</code>自带的<code>jvisualvm</code>在<code>~/home/bin</code>目录下。顺便记录下<code>mac</code>系统查看<code>jdk home</code>所在位置的方式：执行<code>/usr/libexec/java_home -V</code></p>
<p><strong>4.sysprop</strong>：查看<code>Sysetm properties</code>信息</p>
<p>可以指定单个 </p>
<blockquote>
<p>sysprop @appId</p>
</blockquote>
<p>或者使用<code>grep</code>进行过滤</p>
<blockquote>
<p>sysprop | grep @appId </p>
</blockquote>
<p>再或者直接添加一个新的键值对</p>
<blockquote>
<p>sysprop timeout 50</p>
</blockquote>
<p><strong>5.sysenv</strong>：查看环境变量(使用上和<code>sysprop</code>一致)</p>
<p>注意：系统变量通过<code>System.getProperty()</code>，环境变量通过<code>System.getEnv()</code>。系统变量可以通过<code>-D</code>的方式在启动时添加，环境变量</p>
<p><strong>6.jvm</strong>：可以查看<code>jvm</code>虚拟机的一些信息</p>
<p><strong>7.sc</strong>：可以查看已经加载的类，如果类是接口，可以获取到已加载的所有实现类，通过<code>-d</code>参数可以打印类加载的具体信息。并且支持通配符查找类。</p>
<blockquote>
<p>sc -d xxx</p>
</blockquote>
<p><strong>8.sm</strong>：查找具体的函数</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>文档地址[<a href="https://arthas.aliyun.com/doc/]">https://arthas.aliyun.com/doc/]</a></p>
<p>git地址(<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a>)</p>
<p>使用教程地址(<a href="https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&amp;id=arthas-advanced">https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&amp;id=arthas-advanced</a>)</p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>FastThreadLocal</title>
    <url>/2021/04/13/java/ThreadLocal/FastThreadLocal/</url>
    <content><![CDATA[<h3 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h3><p>[TOC]</p>
<h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    因为需要，研究了可以通过<code>InheritableThreadLocal</code>进行父子线程中如何传递本地线程变量，通过阿里开源项目<code>TransmitableThreadLocal</code>进行进行线程池传递本地线程变量(详解可查看以往博客)。在查找资料的过程中无意发现了<code>Dobbo</code>的<code>InternalThreadLocal</code>，其实<code>Dobbo</code>的<code>InternalThreadLocal</code>和<code>netty</code>的<code>FastThreadLocal</code>有异曲同工之妙。之前学<code>netty</code>的时候有了解一点，为了加深一下<code>ThreadLocal</code>种群的了解，使用本博客记录一下。</p>
<span id="more"></span>

<h4 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 原生线程调用方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      username.set(<span class="string">&quot;zhangSang&quot;</span>);</span><br><span class="line">      password.set(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      password.remove();</span><br><span class="line"></span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   * FastThreadLocalThread线程调用方式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> FastThreadLocalThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      username.set(<span class="string">&quot;zhangSang&quot;</span>);</span><br><span class="line">      password.set(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单从运行结果看，都能获取到对应设置的值，二者没有任何输出区别，但是跟踪一下，可以看到调用的逻辑是有所区别的。</p>
<h4 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h4><p>​    熟悉<code>ThreadLocal</code>的应该知道，<code>Threadlocal</code>其实内部逻辑是一个以<code>ThreadLocal</code>对象为<code>key</code>，需要存储的值为<code>value</code>的<code>map</code>结构。而<code>FastThreadLocal</code>的内部实现是一个数组，实现上是直接通过下标定位元素，所以单纯从取、存的角度看，<code>FastThreadLocal</code>是比<code>ThreadLocal</code>高效。</p>
<p>​    对于使用原生线程<code>Thread</code>来说，其实最后是将数据存<code>Thread.threadLocals(ThreadLocal.ThreadLocalMap)</code>中,也就是说在这个线程所使用的所有<code>FastThreadLocal</code>最后都以 <code>key=ThreadLocal&lt;InternalThreadLocalMap&gt;</code><br>对象,<code>value=InternalThreadLocalMap</code>的方式存在线程<code>ThreadLocal</code>的一个节点中。而若使用的是<code>netty</code>封装的<code>FastThreadLocalThread</code>,则<code>FastThreadLocalThread</code>对象的属性<code>threadLocalMap</code>中。</p>
<p>​    <code>FastThreadLocalThread</code>是直接继承于线程类<code>Thread</code>，并且内部维护一个<code>InternalThreadLocalMap</code>，用于存储变量。虽然这个类命名为<code>Map</code>，结构上其实是一个数组。并且下标为0的元素是一个<code>Set&lt;FastThreadLocal&lt;?&gt;&gt;</code>的结构，存储着当前有效的<code>FastThreadLocal</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>InternalThreadLocalMap</code>中提供了一些静态方法，通过当前线程的不同类型，以不同的方式获取对应所需要的<code>InternalThreadlocalMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread thread = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 根据不同的线程类型，以不同的方式获取对应的InternalThreadLocalMap</span></span><br><span class="line">  <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">    <span class="keyword">return</span> fastGet((FastThreadLocalThread) thread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> slowGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FastThreadLocalThred获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">fastGet</span><span class="params">(FastThreadLocalThread thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 直接从FastThreadLocalThread对象中获取InternalThreadLocalMap</span></span><br><span class="line">  InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</span><br><span class="line">  <span class="comment">// 若为空,初始化一个InternalThreadLocalMap</span></span><br><span class="line">  <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    thread.setThreadLocalMap(threadLocalMap = <span class="keyword">new</span> InternalThreadLocalMap());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原生线程的获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从UnpaddedInternalThreadLocalMap中获取到ThreadLocal&lt;InternalThreadLocalMap&gt;</span></span><br><span class="line"><span class="comment">  * 在从ThreadLocal中获取InternalThreadLocalMap,若为空初始化一个。所以由此可知，原生线程</span></span><br><span class="line"><span class="comment">  * 的FasstThreadLocal具体值，是以InternalThreadLocalMap为值，存储在ThreadLocal中。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = </span><br><span class="line">    UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">  InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">    slowThreadLocalMap.set(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-set值"><a href="#1-set值" class="headerlink" title="1.set值"></a>1.set值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="comment">// 根据不同的线程类型，获取到的InternalThreadLocalMap进行设置值。</span></span><br><span class="line">    set(InternalThreadLocalMap.get(), value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="comment">// 将需要存储的值添加到InternalThreadLocalMap对应的下标位置。</span></span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line">      addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove(threadLocalMap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据下标获取对应的元素</span></span><br><span class="line">  Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">  Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line">  <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若为空，创建set结构并将值添加到对应的下标位置</span></span><br><span class="line">    variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">    threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接应用取出的值</span></span><br><span class="line">    variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 添加元素到set集合中</span></span><br><span class="line">  variablesToRemove.add(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-get值"><a href="#2-get值" class="headerlink" title="2.get值"></a>2.get值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(InternalThreadLocalMap.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * get操作比较简单，直接从threadLocalMap获取对应的下标元素返回。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  Object v = threadLocalMap.indexedVariable(index);</span><br><span class="line">  <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="keyword">return</span> (V) v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> initialize(threadLocalMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是一个默认值操作，可以通过最后的initValue()会调用FastThreadLocal#initialValue</span></span><br><span class="line"><span class="comment">  * 做一个初始化的操作。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">initialize</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  V v = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = initialValue();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    PlatformDependent.throwException(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadLocalMap.setIndexedVariable(index, v);</span><br><span class="line">  addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-remove"><a href="#3-remove" class="headerlink" title="3.remove"></a>3.remove</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  remove(InternalThreadLocalMap.getIfSet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 删除对应下标值，赋值为UNSET占位符</span></span><br><span class="line">  Object v = threadLocalMap.removeIndexedVariable(index);</span><br><span class="line">  <span class="comment">//删除InternalThreadLocalMap[0]的Set&lt;FastThreadLocal&lt;?&gt;&gt;中的当前FastThreadLocal对象</span></span><br><span class="line">  removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 是一个增强，删除之后的业务逻辑，由子类实现，默认是空实现</span></span><br><span class="line">      onRemoval((V) v);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​    <code>FastThreadLocal</code>实际上采用的是数组的方式进行存储数据，在数据的获取、赋值都是通过下标的方式进行，而<code>ThreadLocal</code>是通过<code>map</code>结构，先计算哈希值，在进行线性探测的方式进行定位。所以在高并发下，<code>FastThreadLocal</code>应该相对高效，但是<code>FastThread</code>有一个弊端就是<code>index</code>是一直累加，也就是说如果移除了某个变量是通过将对应下标的元素标记为<code>UNSET</code>占位，而不进行回收，会无限制增大，会触发扩容等一些问题。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>InheritableThreadLocal</title>
    <url>/2021/04/13/java/ThreadLocal/InheritableThreadLocal/</url>
    <content><![CDATA[<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>[TOC]</p>
<h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>​    在<code>Thread</code>中除了有属性<code>threadLocals</code>引用<code>ThreadLocal.ThreadLocalMap</code>，其实还有一个属性，也就是<code>inheritableThreadLocals</code>，<code>threadLocals</code>的作用是保存本地线程变量，而<code>inneritableThreadLocals</code>的作用是传递当前线程本地变量<code>InheritableThreadLocal</code>到子线程的本地变量<code>InheritableThreadLocal</code>中。</p>
<span id="more"></span>

<h5 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  InheritableThreadLocal&lt;String&gt; username = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">  ThreadLocal&lt;String&gt; password = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">  username.set(<span class="string">&quot;zhangShang&quot;</span>);</span><br><span class="line">  password.set(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">      System.out.println(password.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zhangShang</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>所以基本上可以得出结论：<code>InheritableThreadLocal</code>是具有父子线程传递的，而<code>ThreadLocal</code>不具有父子线程传递的功能。</p>
<h5 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h5><h6 id="1-InheritableThreadLocal的实现"><a href="#1-InheritableThreadLocal的实现" class="headerlink" title="1. InheritableThreadLocal的实现"></a>1. <code>InheritableThreadLocal</code>的实现</h6><p><code>InheritableThreadLocal</code>继承于<code>ThreadLocal</code>，并重写了<code>ThreadLocal</code>中的三个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个接口是ThreadLocal的开放接口，默认实现是抛出UnsupportedOperationException异常。</span></span><br><span class="line"><span class="comment">     * 实现上仅返回入参，调用上是在创建子线程时使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写getMap,操作InheritableThreadLocal时，将只会影响到线程对象Thread的</span></span><br><span class="line"><span class="comment">     * inheritableThread属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与上面的获取方法getMap情况一致，创建时同理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-线程的创建过程"><a href="#2-线程的创建过程" class="headerlink" title="2.线程的创建过程"></a>2.线程的创建过程</h6><p>跟踪<code>new Thread()</code>方法。</p>
<blockquote>
<p>1.进入初始化方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.调用<code>init</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">  init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后实际调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">// parent线程为创建子线程的当前线程，也就是父线程。</span></span><br><span class="line">  Thread parent = currentThread();</span><br><span class="line">  </span><br><span class="line">		... 省略一些与本章无关代码</span><br><span class="line">  <span class="comment">// inheritThreadLocals=true,默认值是true,且父线程的inheritableThreadLocal对象不为空</span></span><br><span class="line">  <span class="comment">// 创建当前线程的inheritableThreadLocals对象。    </span></span><br><span class="line">  <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">  <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">  <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set thread ID */</span></span><br><span class="line">  tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.进入创建方法<code>createInheritedMap</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 以父线程的inheritableThreadLocals为实例创建一个ThreadLocalMap对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以父线程的inheritableThreadLocals为实例创建子线程的inheritableThreadLocals对象</span></span><br><span class="line"><span class="comment"> * 实现上比较简单，将父线程的inheritableThreadLocals循环拷贝给子线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  Entry[] parentTable = parentMap.table;</span><br><span class="line">  <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">  setThreshold(len);</span><br><span class="line">  table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    Entry e = parentTable[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">      <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 至于这个地方为什么采用key.childValue(),内层的逻辑也仅仅是返回入参。</span></span><br><span class="line">        <span class="comment">// 网上有些人说是为了减轻代码的阅读难度，笔者觉得有点牵强。感觉是为了在获取</span></span><br><span class="line">        <span class="comment">// 过程中做一些小转换之类的？</span></span><br><span class="line">        Object value = key.childValue(e.value);</span><br><span class="line">        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        table[h] = c;</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h5><p>​    上面说父子进程通过<code>inheritableThreadLocals</code>属性来传递本地变量，在实际的应用场景中，一般不会出现父进程直接创建子进程的情况，一般都是采用线程池的方式，如果采用线程池那么<code>inheritableThreadLocal</code>还会有效吗？读者可以考虑一下，写个<code>demo</code>跑一下，看看具体的情况，下一篇文章将进行解答。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal初探</title>
    <url>/2021/04/13/java/ThreadLocal/ThreadLocal/</url>
    <content><![CDATA[<h3 id="ThreadLocal初探"><a href="#ThreadLocal初探" class="headerlink" title="ThreadLocal初探"></a>ThreadLocal初探</h3><p>[TOC]</p>
<h4 id="一、ThreadLocal的实现原理"><a href="#一、ThreadLocal的实现原理" class="headerlink" title="一、ThreadLocal的实现原理"></a>一、ThreadLocal的实现原理</h4><p>​    <code>Thread</code>有一个内部变量<code>ThreadLocal.ThreadLocalMap</code>,这个类是<code>ThreadLocal</code>的静态内部类，它的实现与<code>HashMap</code>类似，当线程第一次调用<code>ThreadLocal</code>的<code>get/set</code>方法时会初始化它。它的键是这个<code>ThreadLocal</code>对象本身，值是需要存储的变量。也就是说<code>ThreadLocal</code>类型的本地变量是存放在具体的线程空间里。当不断的使用<code>get</code>方法获取时，是到线程独有线程空间中获取变量，使得其他线程无法访问到，也就达到了线程安全的目的。在使用完成之后，可以通过<code>remove</code>方法，移除不使用的本地变量。</p>
<span id="more"></span>

<p><strong>ThreadLocal和同步机制的比较</strong></p>
<p>​    如果说同步机制是一种以时间换空间的做法，那么<code>ThreadLocal</code>就是一种以空间换时间的做法，在同步机制下，当访问共享变量时，同步机制保证了同一个时刻只能有一个线程访问到，其他线程进入阻塞。<code>ThreadLocal</code>下，为每个线程都复制了共享变量的副本，也就不存在共享变量的说法。</p>
<h4 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h4><h5 id="1-set"><a href="#1-set" class="headerlink" title="1.set()"></a>1.set()</h5><blockquote>
<p>通过<code>ThreadLocal</code>的set方法调用到<code>ThreadLocal.ThreadLocalMap</code>静态内部类的set方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">          Thread t = Thread.currentThread();</span><br><span class="line">          ThreadLocalMap map = getMap(t);</span><br><span class="line">          <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">              map.set(<span class="keyword">this</span>, value);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若对象为空，则初始化threadLocalMap对象</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">						<span class="comment">// 先通过hashcode作为下标取数组对应位置的值，若为空，设置值。</span></span><br><span class="line">      			<span class="comment">// 若不为空，往后移动一个位置，如果获取到的长度等于数组长度，从0位置查找。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     				<span class="comment">// 清除Entry对象还在，但是Entry的值为空的位置 &amp;&amp; 当前数量是否大于容量</span></span><br><span class="line">      			<span class="comment">// 扩容</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这边的扩容有两个步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1. 重新排列table数组里的值，根据hashcode获取下标，若对应下标为空，则移动到该位置</span></span><br><span class="line">      <span class="comment">// 若下标位置不为空，往后移动位置，直到找到空位置。</span></span><br><span class="line">      expungeStaleEntries();</span><br><span class="line">      <span class="comment">// 2.排列的同时如果是空位置，会相应减少size，若排列之后的size仍然大于容量的3/4则扩容</span></span><br><span class="line">      <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 两倍原长度扩容</span></span><br><span class="line">      resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-get"><a href="#2-get" class="headerlink" title="2.get()"></a>2.get()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        T result = (T)e.value;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">      Entry e = table[i];</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取不到值有两种情况，e=null, e.get() == null,如果e=null直接返回null,</span></span><br><span class="line">    <span class="comment">// 如果e.get()=null，清除这个位置的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">          expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、继承性"><a href="#三、继承性" class="headerlink" title="三、继承性"></a>三、继承性</h4><blockquote>
<p><code>ThreadLocal</code>对父子线程也是一样，同样是不可相互访问。但是，在特殊情况下或许还是存在父子线程需要相互访问<code>ThreadLocal</code>中的值的业务需求。可以使用<code>ThreadLocal</code>的子类<code>InheritableThreadLocal</code>,它可以实现父子进程之间的变量获取。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	InheritableThreadLocal继承ThreadLocal方法，并重写了三个方法，getMap、createMap方法</span></span><br><span class="line"><span class="comment">	是为了让创建map和获取map的时候使用thread中的inheritableThreadLoca变量。而childValue</span></span><br><span class="line"><span class="comment">	是为了在thread父进程调用init创建子进程时，创建子进程的inheritableThreadLocal的时候，逐</span></span><br><span class="line"><span class="comment">	个拷贝父进程的nheritableThreadLocal值。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="comment">// 在这里拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// threalLocal中根据threadLocalMap创建threadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">  Entry[] parentTable = parentMap.table;</span><br><span class="line">  <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">  setThreshold(len);</span><br><span class="line">  table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    Entry e = parentTable[j];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">      <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重写childChild方法</span></span><br><span class="line">        Object value = key.childValue(e.value);</span><br><span class="line">        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        table[h] = c;</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、内存泄漏"><a href="#四、内存泄漏" class="headerlink" title="四、内存泄漏"></a>四、内存泄漏</h4><p><img src="https://gitee.com/jiangjiamin/image-bed/raw/master/upic/2020-10/xCD8sO.png"></p>
<p>​    <code>ThreadLcal</code>的引用关系如上如所示，虚线是使用软引用的地方。如果这个地方使用的是强引用，在业务代码中使用<code>threadlocalInstance==null</code>将<code>ThreadLocalRef</code>和<code>ThreadLocal</code>之间的强引用置空，<code>value</code>还是会通过另一条引用链<code>currentThread-&gt;currentThread-&gt;map-&gt;entry-&gt;value</code>到达，也是不会被GC掉。而若采用软引用，在系统将要发生内存溢出时会回收掉，也就是会断掉<code>key</code>与<code>ThreadLocal</code>之间的引用，使得<code>key=null</code>。</p>
<p>​    在<code>ThreadLocal</code>的实现中，为了避免内存泄漏已经做了很多安全性的控制，在<code>get()</code>和<code>set()</code>方法中都有相应的处理，通过特定的方式对存在<code>key=null</code>的脏<code>Entry</code>进行<code>value=null</code>的处理，使得<code>value</code>的引用链不可达。</p>
<p> <strong>为什么使用弱引用？</strong></p>
<p>一是尽管使用强引用也会出现内存泄漏，二是在<code>ThreadLocal</code>的生命周期中<code>set、getEntry、remove</code>里，都针对键为空的脏<code>Entry</code>进行处理。但是尽管如此，在编程过程中，形成一种良好的规范，在使用完<code>ThreadLocal</code>后都应该手动调用<code>remove</code>方法进行清理。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>TransmittableThreadLocal</title>
    <url>/2021/04/13/java/ThreadLocal/TransmittableThreadLocal/</url>
    <content><![CDATA[<h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><p>[TOC]</p>
<h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>​    上文说到父子线程传递本地变量可以通过<code>InheritableThreadlocoal</code>进行传递，但是如果采用线程池，不一定能传递，因为在线程在线程池中的存在不是每次使用都会进行创建，<code>InheritableThreadlocal</code>是在线程初始化时<code>intertableThreadLocals=true</code>才会进行拷贝传递。所以若本次使用的子线程是已经被池化的线程，从线程池中取出线下进行使用，是没有经过初始化的过程，也就不会进行父子线程的本地变量拷贝。</p>
<p>​    由于在日常应用场景中，绝大多数都是会采用线程池的方式进行资源的有效管理。目前知道的阿里有一个开源项目就是为了解决这个问题<code>ThansmittableThreadLocal</code>。</p>
<span id="more"></span>

<h4 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h4><p>​    在使用线程池等会池化复用线程的执行组件情况下，提供<code>ThreadLocal</code>值的传递功能，解决异步执行时上下文传递的问题。</p>
<p>​    <code>JDK</code>的<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html"><code>InheritableThreadLocal</code></a>类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的<code>ThreadLocal</code>值传递已经没有意义，应用需要的实际上是把 <strong>任务提交给线程池时</strong>的<code>ThreadLocal</code>值传递到 <strong>任务执行时</strong>。</p>
<p>​    本章主要介绍使用线程池场景下的问题，<code>TransmittableThreadLocal</code>还有很多其他的应用场景。<a href="https://github.com/alibaba/transmittable-thread-local">传送门</a></p>
<h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><blockquote>
<p>1.引入<code>TransimittableThreadLocal</code>依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.简单使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="comment">// 创建线程池</span></span><br><span class="line">  ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="comment">// 线程池经过TtlExecutors工具类包装，返回包装类ExecutorServiceTtlWrapper</span></span><br><span class="line">  executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line">	<span class="comment">// 创建需要传递给线程池本地变量</span></span><br><span class="line">  TransmittableThreadLocal&lt;String&gt; username = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 首次调用,这时候线程池中还未有线程，就算不使用TTL也可以通过InheritableThreadLocal获取到</span></span><br><span class="line">  <span class="comment">// 父线程的本地变量。</span></span><br><span class="line">  username.set(<span class="string">&quot;zhangShang&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 第二次调用，由于使用的是单一线程的线程池，这时候是复用了上面创建的线程，所以这时通过</span></span><br><span class="line">  <span class="comment">// inheritableThreadLocal是获取不到本地变量的。</span></span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">  username.set(<span class="string">&quot;liSi&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">  username.set(<span class="string">&quot;wangWu&quot;</span>);</span><br><span class="line">  executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(username.get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zhangShang</span><br><span class="line">liSi</span><br><span class="line">wangWu</span><br></pre></td></tr></table></figure>

<h4 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h4><blockquote>
<p>从定义来看，<code>TransimittableThreadLocal</code>继承于<code>InheritableThreadLocal</code>，并实现<code>TtlCopier</code>接口，它里面只有一个<code>copy</code>方法。所以主要是对<code>InheritableThreadLocal</code>的扩展。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">TtlCopier</span>&lt;<span class="title">T</span>&gt; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>TransimittableThreadLocal</code>中添加<code>holder</code>属性。这个属性的作用就是被标记为具备线程传递资格的对象都会被添加到这个对象中。<strong>要标记一个类，比较容易想到的方式，就是给这个类新增一个<code>Type</code>字段，还有一个方法就是将具备这种类型的的对象都添加到一个静态全局集合中。之后使用时，这个集合里的所有值都具备这个标记。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. holder本身是一个InheritableThreadLocal对象</span></span><br><span class="line"><span class="comment">// 2. 这个holder对象的value是WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;</span></span><br><span class="line"><span class="comment">// 		2.1 WeekHashMap的value总是null,且不可能被使用。</span></span><br><span class="line"><span class="comment">//    2.2 WeekHasshMap支持value=null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt; holder = <span class="keyword">new</span> InheritableThreadLocal&lt;WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重写了childValue方法，实现上直接将父线程的属性作为子线程的本地变量对象。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; childValue(WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;(parentValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应用代码是通过<code>TtlExecutors</code>工具类对线程池对象进行包装。工具类只是简单的判断，输入的线程池是否已经被包装过、非空校验等，然后返回包装类<code>ExecutorServiceTtlWrapper</code>。根据不同的线程池类型，有不同和的包装类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">getTtlExecutorService</span><span class="params">(<span class="meta">@Nullable</span> ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (TtlAgent.isTtlAgentLoaded() || executorService == <span class="keyword">null</span> || executorService <span class="keyword">instanceof</span> TtlEnhanced) &#123;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceTtlWrapper(executorService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入包装类<code>ExecutorServiceTtlWrapper</code>。可以注意到不论是通过<code>ExecutorServiceTtlWrapper#submit</code>方法或者是<code>ExecutorTtlWrapper#execute</code>方法，都会将线程对象包装成<code>TtlCallable</code>或者<code>TtlRunnable</code>，用于在真正执行<code>run</code>方法前做一些业务逻辑。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在ExecutorServiceTtlWrapper实现submit方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(<span class="meta">@NonNull</span> Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> executorService.submit(TtlCallable.get(task));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在ExecutorTtlWrapper实现execute方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">  executor.execute(TtlRunnable.get(command));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以，重点的核心逻辑应该是在<code>TtlCallable#call()</code>或者<code>TtlRunnable#run()</code>中。以下以<code>TtlCallable</code>为例，<code>TtlRunnable</code>同理类似。在分析<code>call()</code>方法之前，先看一个类<code>Transmitter</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获当前线程中的是所有TransimittableThreadLocal和注册ThreadLocal的值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(captureTtlValues(), captureThreadLocalValues());</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获TransimittableThreadLocal的值,将holder中的所有值都添加到HashMap后返回。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captureTtlValues() &#123;</span><br><span class="line">    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;Object&gt; threadLocal : holder.get().keySet()) &#123;</span><br><span class="line">      ttl2Value.put(threadLocal, threadLocal.copyValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ttl2Value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获注册的ThreadLocal的值,也就是原本线程中的ThreadLocal,可以注册到TTL中，在</span></span><br><span class="line"><span class="comment">    * 进行线程池本地变量传递时也会被传递。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; captureThreadLocalValues() &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;ThreadLocal&lt;Object&gt;,TtlCopier&lt;Object&gt;&gt;entry:threadLocalHolder.entrySet())&#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      <span class="keyword">final</span> TtlCopier&lt;Object&gt; copier = entry.getValue();</span><br><span class="line">      threadLocal2Value.put(threadLocal, copier.copy(threadLocal.get()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threadLocal2Value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将捕获到的本地变量进行替换子线程的本地变量，并且返回子线程现有的本地变量副本backup。</span></span><br><span class="line"><span class="comment">    * 用于在执行run/call方法之后，将本地变量副本恢复。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(<span class="meta">@NonNull</span> Object captured)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Snapshot capturedSnapshot = (Snapshot) captured;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(replayTtlValues(capturedSnapshot.ttl2Value), </span><br><span class="line">                        replayThreadLocalValues(capturedSnapshot.threadLocal2Value));</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换TransmittableThreadLocal</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; replayTtlValues(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; captured) &#123;</span><br><span class="line">    <span class="comment">// 创建副本backup</span></span><br><span class="line">    HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line">      <span class="comment">// 对当前线程的本地变量进行副本拷贝</span></span><br><span class="line">      backup.put(threadLocal, threadLocal.get());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若出现调用线程中不存在某个线程变量，而线程池中线程有，则删除线程池中对应的本地变量</span></span><br><span class="line">      <span class="keyword">if</span> (!captured.containsKey(threadLocal)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        threadLocal.superRemove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将捕获的TTL值打入线程池获取到的线程TTL中。</span></span><br><span class="line">    setTtlValuesTo(captured);</span><br><span class="line">    <span class="comment">// 是一个扩展点，调用TTL的beforeExecute方法。默认实现为空</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; replayThreadLocalValues(<span class="meta">@NonNull</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; captured) &#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; backup = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ThreadLocal&lt;Object&gt;, Object&gt; entry : captured.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      backup.put(threadLocal, threadLocal.get());</span><br><span class="line">      <span class="keyword">final</span> Object value = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (value == threadLocalClearMark) threadLocal.remove();</span><br><span class="line">      <span class="keyword">else</span> threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清除单线线程的所有TTL和TL，并返回清除之气的backup</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value = </span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;ThreadLocal&lt;Object&gt;,TtlCopier&lt;Object&gt;&gt;entry:threadLocalHolder.entrySet())&#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal2Value.put(threadLocal, threadLocalClearMark);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> replay(<span class="keyword">new</span> Snapshot(ttl2Value, threadLocal2Value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 还原</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="meta">@NonNull</span> Object backup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Snapshot backupSnapshot = (Snapshot) backup;</span><br><span class="line">    restoreTtlValues(backupSnapshot.ttl2Value);</span><br><span class="line">    restoreThreadLocalValues(backupSnapshot.threadLocal2Value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreTtlValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; backup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展点，调用TTL的afterExecute</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Iterator&lt;TransmittableThreadLocal&lt;Object&gt;&gt; iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = iterator.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!backup.containsKey(threadLocal)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        threadLocal.superRemove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本地变量恢复成备份版本</span></span><br><span class="line">    setTtlValuesTo(backup);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTtlValuesTo</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttlValues)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; entry : ttlValues.entrySet()) &#123;</span><br><span class="line">      TransmittableThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalValues</span><span class="params">(<span class="meta">@NonNull</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; backup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ThreadLocal&lt;Object&gt;, Object&gt; entry : backup.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> ThreadLocal&lt;Object&gt; threadLocal = entry.getKey();</span><br><span class="line">      threadLocal.set(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 快照类，保存TTL和TL</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Snapshot</span><span class="params">(HashMap&lt;TransmittableThreadLocal&lt;Object&gt;, Object&gt; ttl2Value,</span></span></span><br><span class="line"><span class="function"><span class="params">                     HashMap&lt;ThreadLocal&lt;Object&gt;, Object&gt; threadLocal2Value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ttl2Value = ttl2Value;</span><br><span class="line">      <span class="keyword">this</span>.threadLocal2Value = threadLocal2Value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入<code>TtlCallable#call()</code>方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object captured = capturedRef.get();</span><br><span class="line">  <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterCall &amp;&amp; </span><br><span class="line">      !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;TTL value reference is released after call!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用replay方法将捕获到的当前线程的本地变量，传递给线程池线程的本地变量，</span></span><br><span class="line">  <span class="comment">// 并且获取到线程池线程覆盖之前的本地变量副本。</span></span><br><span class="line">  Object backup = replay(captured);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 线程方法调用</span></span><br><span class="line">    <span class="keyword">return</span> callable.call();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 使用副本进行恢复。</span></span><br><span class="line">    restore(backup);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    到这基本上线程池方式传递本地变量的核心代码已经大概看完了。总的来说在创建<code>TtlCallable</code>对象是，调用<code>capture()</code>方法捕获调用方的本地线程变量，在<code>call()</code>执行时，将捕获到的线程变量，替换到线程池所对应获取到的线程的本地变量中，并且在执行完成之后，将其本地变量恢复到调用之前。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机类型不同导致异常</title>
    <url>/2021/04/14/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/mq%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="rabbitmq交换机类型不同导致异常"><a href="#rabbitmq交换机类型不同导致异常" class="headerlink" title="rabbitmq交换机类型不同导致异常"></a>rabbitmq交换机类型不同导致异常</h4><p>​    今天收到预生产环境测试人员的消息说项目启动失败，看了一下错误是<code>rabbitmq</code>的队列监听抛出找不到该队列，没有道理，逻辑上已经经过了测试环境的测试没有理由犯这么低级的错误。吓得我赶紧看去看了一下预生产环境的<code>apollo</code>配置信息(我们使用的<code>mq</code>厂商随环境的不同可能不同)，配置信息也是对的；赶紧再次核对一下错误日志，发启动时创建交换机还有另外的报错：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2021-04-14 16:58:23.014 [AMQP Connection 192.168.2.16:5672] ERROR o.s.a.r.c.CachingConnectionFactory-Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &#x27;type&#x27; for exchange &#x27;xxxxx&#x27; in vhost &#x27;/&#x27;: received &#x27;topic&#x27; but current is &#x27;fanout&#x27;, class-id=40, method-id=10)</span><br></pre></td></tr></table></figure>

<p>大概的意思是已经存在该名称为<code>fanout</code>类型交换机不允许改变为<code>topic</code>类型交换机。</p>
<span id="more"></span>

<p>为什么会导致这个问题？</p>
<p>由于数据之间的解耦传输是由两个团队处理，A团队负责发送消息，B团队负责接收消息。沟通中没有交流清楚细节导致。</p>
<blockquote>
<p>A团队创建<code>fanout</code>类型且名称为<code>PUSH_INFO_EXCHANGE</code>的交换机</p>
<p>B团队创建<code>topic</code>类型且名称为<code>PUSH_INFO_EXCHANGE</code>的交换机，<code>routeKey</code>为空串，队列名称为<code>RECEIVE_INFO_QUEUE</code>。</p>
</blockquote>
<p>这就导致，AB团队同时提测，如果先启动了B服务，则<code>rabbitmq</code>创建了一个名为<code>PUSH_INFO_EXCHANGE</code>类型为广播的交换机，并绑定在<code>RECEIVE_INFO_QUEUE</code>队列上；这时如果启动A服务，在<code>RabbitMq</code>中，一旦创建了交换机是不允许改变的，所以A服务的创建是不会成功，但有意思的是，A服务推送数据时，是可以找到这个交换机，且通过空串路由键B服务可以接收到相应的数据，这样也就是导致在测试环境中没有发现这个异常的原因。而在预生产环境中，严格按照先启动A服务后再启动B服务进行就抛出了开头的异常信息。</p>
<p>不要问为什么AB团队都创建了同名的交换机，如果这时A的业务场景有需要将某个队列绑定到这个交换机呢？</p>
]]></content>
      <categories>
        <category>超级大坑</category>
        <category>rabbitmq</category>
      </categories>
  </entry>
  <entry>
    <title>this调用导致注解未生效问题</title>
    <url>/2021/04/16/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E6%B3%A8%E8%A7%A3%E6%9C%AA%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<h4 id="动态代理导致注解未生效"><a href="#动态代理导致注解未生效" class="headerlink" title="动态代理导致注解未生效"></a>动态代理导致注解未生效</h4><p>​    今天在使用<code>mybatis-plus</code>作者苞米豆的另一个项目<code>lock4j</code>用于项目中的分布式锁，解决多实例情况下对接口进行上锁，使得业务上的共享资源在一个时间节点里只会被一个线程执行。</p>
<p>​    <code>lock4j</code>和<code>mybatis-plus</code>差不多，秉承着人性化使用的初衷，<code>lock4j</code>使用上还是非常简单的，只需要在需要上锁的接口方法上使用<code>@Lock4j</code>进行标记并设置一些简单的超时参数即可。</p>
<p>​    使用中发现有一个需要上锁的接口是一个私有方法(原本单机情况下，采用<code>ReentrantLock</code>)，所以改造时仅仅只是对改接口上添加<code>@Lock4j</code>注解。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveInfo</span><span class="params">(String userId)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 很多业务逻辑的处理 </span></span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">this</span>.finalSaveEffective(userId);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Lock4j(keys = &#123;&quot;#userId&quot;&#125;, expire = &quot;18000&quot;, acquireTimeout = &quot;10000&quot;,</span></span><br><span class="line"><span class="meta">        keyBuilder = DefaultKeyBuilder.class)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finalSaveEffective</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//reentrantLock.lock();</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    checkInfo(..);</span><br><span class="line">    mapper.insert(..);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    log.error(e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(e.getMessage());</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//reentrantLock.unlock();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    跑起来测试后发现根本没有进入到对<code>@Lock4j</code>处理的代理方法中，马上反应到这不是和常见<code>@Transaction</code>的坑一样，不能使用<code>this.xxx</code>的方式调用，修改代码后启动，果然正常上锁，那么为什么<code>this.xxx</code>会导致异常？</p>
<p>​    为了知其所以然，不再盲猜硬记，我决定结合<code>@Transaction</code>注解去了解底层的机制。</p>
<p>​    在<code>spring</code>中的<code>aop</code>说白了就是通过动态代理实现，而动态代理有两种实现方式(<code>jdk</code>动态代理和<code>cglib</code>动态代理)。这里简单模拟一下两种动态代理的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶层接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:30:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 10:28 下午</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">UserFacade</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getUserInfo();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入用户信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockAnnotation</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询图书信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:32:27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MockAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-jdk动态代理"><a href="#1-jdk动态代理" class="headerlink" title="1. jdk动态代理"></a>1. jdk动态代理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理的形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:33:07</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">                                      target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass()</span><br><span class="line">          	.getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">            .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeJdkProxy proxy = <span class="keyword">new</span> UserFacadeJdkProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade) proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeJdkProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure>

<h5 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2.cglib动态代理"></a>2.cglib动态代理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cglib方式代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/04/16 22:34:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFacadeCglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入调用方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Annotation annotation = target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes())</span><br><span class="line">                .getAnnotation(MockAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(ObjectUtils.isEmpty(annotation))&#123;</span><br><span class="line">            <span class="keyword">return</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">//return methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的前置处理&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invoke(target, args);</span><br><span class="line">        <span class="comment">//Object result = methodProxy.invokeSuper(o, args);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aop某方法的后置处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserFacadeCglibProxy proxy = <span class="keyword">new</span> UserFacadeCglibProxy();</span><br><span class="line">        UserFacade userFacade = (UserFacade)proxy.getProxy(<span class="keyword">new</span> UserService());</span><br><span class="line">        <span class="comment">//userFacade.getUserInfo();</span></span><br><span class="line">        userFacade.insertUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//&gt; Task :UserFacadeCglibProxy.main()</span></span><br><span class="line"><span class="comment">//进入调用方法</span></span><br><span class="line"><span class="comment">//查询图书信息</span></span><br><span class="line"><span class="comment">//插入用户信息</span></span><br></pre></td></tr></table></figure>

<p>由以上可得出结论：不论是通过哪一种动态代理实现<code>AOP</code>，使用<code>this.xxx</code>的写法都无法使得注解生效。且如果注解标记的方法为<code>final</code>或者是<code>private</code>方法也是不能进入代理方法，原因是<code>jdk</code>动态代理是基于接口代理、<code>cglib</code>动态代理是基于继承的方式，不论是那种方式的动态代理的代理对象其实都是无法进入<code>target</code>的私有方法和<code>final</code>方法。所以根据以上动态代理可以得出结论，通过<code>this.xxx</code>的方式调用本类接口是通过被代理对象直接调用本类接口，而不是通过代理对象，也就无法进入对应的<code>invoke</code>方法或者是<code>intercept</code>方法，从而无法解析到对应的注解，如果觉得将<code>this.xxx</code>修改为<code>A</code>类调用<code>B</code>类，代码需要被迫转移到其他类影响理解，在实际中可以通过<code>ApplicationContextUtil</code>的方式获取一次代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.getUserInfo(); 修改为一下写法</span></span><br><span class="line">UserFacade userFacade = ApplicationContextUtil.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userFacade.getUserInfo();</span><br></pre></td></tr></table></figure>

<p>但是，好玩的来了，注意看<code>UserFacadeCglibProxy</code>类中有两行注释，采用的是<code>methodProxy.invokeSuper(o, args);</code>的方式调用，运行之后可以发现通过<code>this.xxx</code>的方式竟然可以进入<code>invoice()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Task :UserFacadeCglibProxy.main()</span><br><span class="line">进入调用方法</span><br><span class="line">进入调用方法</span><br><span class="line">aop某方法的前置处理</span><br><span class="line">查询图书信息</span><br><span class="line">aop某方法的后置处理</span><br><span class="line">插入用户信息</span><br></pre></td></tr></table></figure>

<p>这边简单对这两个调用进行一个区别：</p>
<p><code>methodProxy.invoke(target, args)</code>的整个执行过程为：</p>
<ol>
<li>客户端调用了代理对象的<code>insertUserInfo()</code>方法</li>
<li>进入代理对象的<code>intercept</code>方法</li>
<li>通过<code>methodProxy.invoke(target, args)</code>执行被代理对象的<code>insertUserInfo()</code></li>
<li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是被代理对象，所以调用时不会触发<code>intercept</code>方法</li>
<li>调用结束</li>
</ol>
<p><code>methodProxy.invokeSuper(o, args)</code>的整个执行过程为：</p>
<ol>
<li>客户端调用了代理对象<code>insertUserInfo()</code>方法</li>
<li>进入代理对象的<code>intercept</code>方法</li>
<li>通过<code>methodProxy.invokeSuper(o, args)</code>进入被代理对象的<code>insertUserInfo()</code></li>
<li>这时的<code>this.getUserInfo()</code>中的<code>this</code>是代理对象，所以<code>getUserInfo()</code>会再次触发<code>intercept()</code></li>
<li>进入被代理对象的<code>getUserInfo()</code></li>
<li>调用结束</li>
</ol>
<p>所以最终作怪的是<code>this</code>，这个<code>this</code>代表的是代理对象(<code>proxy</code>)还是被代理对象(<code>target</code>)。</p>
]]></content>
      <categories>
        <category>超级大坑</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>扫包路径引发项目启动失败</title>
    <url>/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E6%89%AB%E5%8C%85%E8%B7%AF%E5%BE%84%E5%BC%95%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h5 id="指定扫包路径的坑"><a href="#指定扫包路径的坑" class="headerlink" title="指定扫包路径的坑"></a>指定扫包路径的坑</h5><p>​    由于项目包结构的修改对<code>feign</code>调用的类的编写修改了路径，原来的路径为<code>cn.com.projectname.feign</code>包下，新的<code>feign</code>需添加到<code>cn.com.projectname.common.feign</code>下。首次添加到该包下发现，新的<code>feign</code>类没有被加载到<code>spring</code>容器中，所以推测是扫包路径的问题，故通过<code>@EnableFeignClients(basePackages = &#123;&quot;cn.com.projectname.feign&quot;, &quot;cn.com.projectname.common.feign&quot;&#125;)</code>指定扫包路径，神奇的事情发生了，启动之后报错，内容为<code>cn.com.projectname.common.feign</code>下新增的那个<code>feign</code>类已经被加载到<code>spring</code>容器中，不允许二次加载！找了许久并没有找到什么问题。还尝试通过<code>@FeignClient(contextId = &quot;xxx&quot;)</code>的方式指定创建类名称，也还是失败了，最后发现玄机是在<code>@EnableFeignClients</code>的<code>basePackages</code>上，由于指定的两个包路径出现重叠部分，导致在扫包过程中重复添加某对象。</p>
]]></content>
      <categories>
        <category>超级大坑</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>用户token互串问题</title>
    <url>/2021/04/27/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%A8%E6%88%B7token%E4%BA%92%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="用户token互串问题"><a href="#用户token互串问题" class="headerlink" title="用户token互串问题"></a>用户token互串问题</h3><p><img src="https://i.loli.net/2021/04/27/4bWIrKcvBh2Go6Z.png"></p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>昨天要下班时遭测试反馈说某个业务日志表中的数据的基础字段(创建人、修改人)信息有问题，赶紧过去看了一眼，发现确实有问题，那张业务表主要是A角色的操作，而表中最后的数据记录的是B角色的信息。项目采用<code>Oauth2</code>的方式进行认证，很容易就想到是否是<code>token</code>互串导致，因为基础字段是直接通过<code>token</code>信息进行存储，便于后期排查问题而已？</p>
<span id="more"></span>

<h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>在简单查看代码之后，业务日志表的数据操作是在某个回调通知后触发，而这个回调类似于定时器触发或者是外部应用触发，这种情况下是没有<code>token</code>信息，也就是说在<code>ThreadLocal</code>中并不存在<code>token</code>信息。而导致这个问题的关键是容器的线程复用。</p>
<h4 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h4><p>1.简单搭建一个<code>springboot</code>工程，采用<code>undertow</code>容器。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.4.5&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    <span class="comment">// 排除tomcat</span></span><br><span class="line">    implementation.exclude <span class="attr">module:</span> <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    <span class="comment">// 添加undertow容器依赖</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-undertow&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testCompileOnly <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testAnnotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.4&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设置<code>undertow</code>容器线程池大小为1，仅设置一个线程来处理请求。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =============================</span></span><br><span class="line"><span class="comment">#        undertow配置</span></span><br><span class="line"><span class="comment"># =============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io线程数,主要执行非阻塞的任务</span></span><br><span class="line"><span class="comment"># server.undertow.threads.io=16</span></span><br><span class="line"><span class="comment"># 阻塞任务的线程池中线程个数</span></span><br><span class="line"><span class="meta">server.undertow.threads.worker</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 每块buffer的空间大小</span></span><br><span class="line"><span class="comment"># server.undertow.buffer-size=1024</span></span><br><span class="line"><span class="comment"># 是否分配直接内存(NIO直接分配的堆外内存)</span></span><br><span class="line"><span class="comment"># server.undertow.direct-buffers=true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Integer&gt; ageThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: xiaocainiaoya</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2021/04/27 22:15:21</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:  </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;getUserName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(<span class="meta">@RequestParam(required = false)</span>Integer age, <span class="meta">@RequestParam(required = true)</span>String requestId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ageThreadLocal.set(age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 模拟业务逻辑处理</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; get age value = &#123;&#125;&quot;</span>,requestId, ageThreadLocal.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.打开两个<code>postman</code>，一个请求携带<code>age</code>参数，一个请求不携带<code>age</code>参数，让携带<code>age</code>参数的请求先执行。结果是两个请求都打印了<code>age</code>值。由日志结果可知，使用的是同一个线程<code>XNIO-1 task-1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://127.0.0.1:8080/user/getUserName?requestId=A&amp;age=10</span></span><br><span class="line"><span class="comment">// http://127.0.0.1:8080/user/getUserName?requestId=B</span></span><br><span class="line"><span class="comment">// 控制台d打印信息</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">48.731</span>  INFO <span class="number">7334</span> --- [XNIO-<span class="number">1</span> task-<span class="number">1</span>] c.e.demo.controller.UserController: B get age value = <span class="number">10</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">20</span>:<span class="number">18</span>:<span class="number">53.738</span>  INFO <span class="number">7334</span> --- [XNIO-<span class="number">1</span> task-<span class="number">1</span>] c.e.demo.controller.UserController: A get age value = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    由于线程池的复用，在例子中第一个请求结束后将线程还给线程池，而下一次请求进来时从线程池中刚好获取了前一个请求的线程，而<code>ThreadLocal</code>本质就是一种空间换时间的并发做法，每个线程中开辟一块空间，使得其他线程无法访问，所以第二个请求获取到的线程变量有可能是未经过初始化产生的，而是第一个请求用剩下的。当然了，解决这个问题最简单的做法就是做一个拦截器，当请求进来时，不论是否有线程变量直接清空即可。<br>​    之前看了一篇文章写的是线程池中的线程异常问题，这里多说一嘴，例子中假如第一个请求将<code>age</code>保存到<code>ThreadLocal</code>中之后，由于<code>bug</code>导致产生了异常，这时第二个线程再请求是否能获取到<code>age</code>的值？答案是获取不到的，线程池中的线程出现异常后，工作线程(<code>worker</code>线程)会被销毁掉后重新创建线程，放置到线程池中，这时从线程池中获取的新线程的<code>ThreadLoal</code>不包含任何值。</p>
<hr>
<p>博客地址：<a href="https://xiaocainiaoya.github.io/">https://xiaocainiaoya.github.io/</a></p>
<p>联系方式：<a href="mailto:&#x78;&#105;&#x61;&#x6f;&#x63;&#97;&#105;&#110;&#x69;&#97;&#x6f;&#x79;&#97;&#x40;&#x66;&#111;&#x78;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#x78;&#105;&#x61;&#x6f;&#x63;&#97;&#105;&#110;&#x69;&#97;&#x6f;&#x79;&#97;&#x40;&#x66;&#111;&#x78;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a></p>
<p><img src="https://i.loli.net/2021/04/24/uiEBICyMHcYS4TA.png" alt="扫码"></p>
]]></content>
      <categories>
        <category>超级大坑</category>
      </categories>
  </entry>
  <entry>
    <title>由拆箱引发NPE</title>
    <url>/2021/04/13/%E8%B6%85%E7%BA%A7%E5%A4%A7%E5%9D%91/java/%E7%94%B1%E6%8B%86%E7%AE%B1%E5%BC%95%E5%8F%91bug/</url>
    <content><![CDATA[<h5 id="由拆箱引发bug"><a href="#由拆箱引发bug" class="headerlink" title="由拆箱引发bug"></a>由拆箱引发bug</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  Integer b = <span class="keyword">null</span>;</span><br><span class="line">  System.out.println(a == b); <span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>b</code>是包装类型，而<code>a</code>是基本数据类型，在比较时对<code>b</code>进行拆箱，所以会通过<code>((Integer)null).intValue()</code>进行拆箱，从而引发<code>NPE</code>。</p>
]]></content>
      <categories>
        <category>超级大坑</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>数据库索引字段过长</title>
    <url>/2021/04/13/%E9%97%AE%E9%A2%98%E5%92%8C%E6%96%B9%E6%A1%88/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E8%BF%87%E9%95%BF/</url>
    <content><![CDATA[<h5 id="数据库索引字段过长"><a href="#数据库索引字段过长" class="headerlink" title="数据库索引字段过长"></a>数据库索引字段过长</h5><p><strong>问题</strong>：在业务场景中，某些敏感数据需加密之后保存到数据库，而加密字段刚好又是频繁触发查询的字段。在一次插入数据时引发唯一索引异常。原因是索引长度小于数据库字段长度，在比对数据唯一性时截取了该字段的前面部分长度，导致匹配成功，抛出唯一索引异常。</p>
<p><strong>方案</strong>：这种情况下不能随意调整索引的长度，这涉及到全局的修改。故通过新增一个字段保存改加密字段<code>MD5</code>值，并将索引挂在这个新增字段上，这样既保证了索引的唯一性，又可以不用修改索引长度。</p>
]]></content>
      <categories>
        <category>问题和方案</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>问题和方案</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAop浅析（二）</title>
    <url>/2024/04/11/Spring/SpringAop%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="SpringAop浅析（二）"><a href="#SpringAop浅析（二）" class="headerlink" title="SpringAop浅析（二）"></a>SpringAop浅析（二）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    接两年前的旧文<a href="https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/" target="_blank">SpringAop浅析</a>，时隔两年再一次对<code>SpringAop</code>相关源码进行分析，只能说之前阅读的不够透彻，理解的不扎实，再加上工作上常年忙于业务的处理，现在已经少有看源码的时间，不过最近不知道是因为什么打了鸡血，还是想再沉淀沉淀。</p>
<span id="more"></span>

<h2 id="上篇回顾"><a href="#上篇回顾" class="headerlink" title="上篇回顾"></a>上篇回顾</h2><p>​    前面说到<code>SpringAop</code>的大致创建时机、创建流程和基本的调用流程。<code>SpringAop</code>是采用动态代理的方式实现，通过<code>@EnableAspectJAutoProxy</code>的方式开启，开启的原理为添加<code>AnnotationAwareAspectJAutoProxyCreator</code>后置处理器到<code>BeanDefinitionMap</code>中；在<code>Bean</code>对象实例化之前可以通过用户自定义的方式进行提前生成代理对象。或者是在<code>Bean</code>对象初始化之后，通过上述后置处理器的<code>postProcessAfterInitialization</code>方法，将<code>Bean</code>对象转为代理对象。</p>
<p>本篇想说明一个问题：被<code>SpringAop</code>代理之后的对象是什么对象？在调用被代理方法时，它具体的执行过程？</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>​    直接<code>debug</code>可以得知，被<code>SpringAop</code>代理之后的对象是<code>CglibAopProxy#DynamicAdvisedInterceptor</code>类的实现。（使用<code>cglib</code>代理的前提）</p>
<p>这个类是<code>CglibAopProxy</code>的内部类，它实现了<code>MethodInterceptor</code>接口，学过<code>cglib</code>动态代理的知道<code>MethodInterceptor</code>是它的代理类的增强，所以<code>DynamicAdvisedInterceptor</code>这个类就是为了<code>aop</code>来做增强的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// ...代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它定义了<code>AdvisedSupport</code>增强支持类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个类记录了被代理对象、被代理方法等等一系列的动态代理需要的参数等</span></span><br><span class="line">    <span class="comment">// 这个是一个重要的参数，它记录了这个被代理对象需要被执行增强的列表</span></span><br><span class="line">    <span class="comment">// 比如说你定义了一个方法，需要在这个方法上做</span></span><br><span class="line">    <span class="comment">// 1.打印访问时长的增强A，</span></span><br><span class="line">    <span class="comment">// 2.记录方法执行前后参数、返回值的增强B</span></span><br><span class="line">    <span class="comment">// 都会被记录在这个列表里</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以到这里可以知道，在项目中我们通过<code>SpringAop</code>得到的代理对象的增强是<code>DynamicAdvisedInterceptor</code>。故在执行被代理方法时，会直接进入到它的拦截方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 在被代理类初始化时，会根据一些匹配规则，将符合条件的增强放置在列表中，这里把这个列表里的增强取出</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">        <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建CglibMethodInvocation类，并执行processd()方法</span></span><br><span class="line">            <span class="comment">// CglibMethodInvocation类实际上是一个调用链对象，也就是说这里将目标类、代理对象、代理方法、调用参数、以及最关键的增强列表&lt;chain&gt;</span></span><br><span class="line">            <span class="comment">// 记录到这个对象中，还包含了当前索引下标等等信息。也就是调用它的process()方法之后，它就会遍历这个增强列表，执行每一个增强。</span></span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>process()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 到达链尾时进入被代理对象的目标方法中，至此递归结束</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历下标，取出对应的增强</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// 根据对应的信息进行匹配器的匹配，若匹配成功则执行增强的拦截方法</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 匹配失败，则进入到下一个链节点</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    以上便是<code>springAop</code>的大致过程，这里还要提到一个问题，如果对<code>aop</code>的这个执行过程进行过<code>debug</code>的会发现，假设我只设置了一个<code>aop</code>的注解拦截，对于上面提到的增强拦截链的<code>List&lt;Advisor&gt; advisors</code>实际上会有两个对象，如果设置了两个<code>aop</code>的注解拦截，那么这个列表中会有3个对象。</p>
<p>​    通过观察不难发现，是<code>springAop</code>在创建实例对象，如果需要被<code>aop</code>代理时，它会将<code>ExposeInvocationInterceptor</code>类，固定放置在这个列表的下标为0的位置。</p>
<p><code>AbstractAdvisorAutoProxyCreator</code>它实现了<code>spring</code>后置处理器接口，就是它在创建具体的代理对象时，将<code>ExposeInvocationInterceptor</code>放置在增强链的头部位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出满足这个将要创建的bean对象的增强，做法是从容器中首先找出所有Advisor.class的实现类</span></span><br><span class="line"><span class="comment">// 再根据一定的逻辑进行匹配，这里在获取之后会进行缓存，下次在获取Advisor.class的实现时直接</span></span><br><span class="line"><span class="comment">// 通过缓存就能获取到。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">   <span class="comment">// 最后会走到下面的那个方法中，在列表的头部加一个增强。</span></span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">makeAdvisorChainAspectJCapableIfNecessary</span><span class="params">(List&lt;Advisor&gt; advisors)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对获取到的增强列表进行遍历，这里来了一个二次核查，如果存在aop的增强，则在列表下标为0的位置，添加</span></span><br><span class="line">    <span class="comment">// ExposeInvocationInterceptor类。</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> foundAspectJAdvice = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// Be careful not to get the Advice without a guard, as this might eagerly</span></span><br><span class="line">            <span class="comment">// instantiate a non-singleton AspectJ aspect...</span></span><br><span class="line">            <span class="keyword">if</span> (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">                foundAspectJAdvice = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">            advisors.add(<span class="number">0</span>, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这个被加到增强列表头部的增强，有什么特殊的作用？</p>
<p>直接看它的拦截方法，他的拦截方法也比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 这里接收到的参数MethodInvocation实际上是aop代理类（链对象）</span></span><br><span class="line">    <span class="comment">// 重新来捋一下这个过程，在执行到对应aop的代理类之时：</span></span><br><span class="line">    <span class="comment">// 1.进入到了CglibAopProxy#intercept拦截方法</span></span><br><span class="line">    <span class="comment">// 2.用匹配的增强列表、代理类、被代理目标类（方法）的信息、具体方法、参数等创建CglibMethodInvocation</span></span><br><span class="line">    <span class="comment">//    注意这个类实现了MethodInvocation，然后调用了它的process()方法。</span></span><br><span class="line">    <span class="comment">// 3.这个process()拦截方法的实现上，主要是要遍历增强列表，进行增强的播放，当进入到首个增强时</span></span><br><span class="line">    <span class="comment">//    进入到ExposeInvocationInterceptor#invoke()方法中，来执行以下这段代码。</span></span><br><span class="line">    <span class="comment">// 4.这段代码的作用是将这个aop代理类对象放置到线程上下文中，以便于后续的增强获取。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从线程上下文中获取旧methodInvocation对象</span></span><br><span class="line">    MethodInvocation oldInvocation = invocation.get();</span><br><span class="line">    <span class="comment">// 将线程上下文替换为这个aop代理类对象，在后面的遍历增强类的过程中，</span></span><br><span class="line">    <span class="comment">// 通过线程上下文来获取这个aop代理类对象。</span></span><br><span class="line">    invocation.set(mi);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 还原现场</span></span><br><span class="line">        invocation.set(oldInvocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    <code>springAop</code>在初始化对象之后的代理类是<code>CglibAopProxy#DynamicAdvisedInterceptor</code>的实现（使用<code>cglib</code>代理的情况下），当执行到这个代理类进入到了<code>CglibAopProxy#intercept</code>拦截方法，这个方法中用匹配的增强列表、代理类、被代理目标类（方法）的信息、具体方法、参数等创建<code>CglibMethodInvocation</code>，注意这个类实现了<code>MethodInvocation</code>，然后调用了它的<code>process()</code>方法。这个<code>process()</code>拦截方法的实现上，主要是要遍历增强列表，进行增强的播放，当进入到首个增强时，进入到<code>ExposeInvocationInterceptor#invoke()</code>方法中，将这个<code>aop</code>代理类对象(<code>CglibAopProxy#DynamicAdvisedInterceptor</code>)放置到线程上下文中，以便于后续的增强获取。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Spring事务的aop浅析</title>
    <url>/2024/04/15/Spring/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84aop%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Spring事务的aop浅析"><a href="#Spring事务的aop浅析" class="headerlink" title="Spring事务的aop浅析"></a>Spring事务的aop浅析</h1><p>​    结合之前说到的<a href="https://xiaocainiaoya.github.io/2021/06/27/Spring/SpringAop%E6%B5%85%E6%9E%90/" target="_blank">SpringAop浅析（二）</a>本篇将从事务的角度，来看下<code>spring</code>或者说<code>springboot</code>是如何通过一些简单的配置就可以将一些方法进行事务的管理，并了解一些事务在管理过程中的一些简单<code>api</code>。</p>
<span id="more"></span>

<h2 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h2><p>​    在没有<code>spring</code>之前，或者说在不引入<code>spring</code>的时候，在获取数据库访问的时候，通常是通过<code>Connection</code>来进行。通过<code>Connection</code>类来进行<code>sql</code>的执行操作，然后在<code>sql</code>执行完毕之后调用<code>commit()</code>方法，将事务提交，当然了，在借助<code>spring</code>框架之后，在编码过程中，再也没有通过这种方式来进行事务的提交。但是大差不差，这些事情是一定要做的，既然我们在编码过程中没有做，那么这件事情就一定被<code>spring</code>做了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = getConnection();</span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//执行一系列的sql</span></span><br><span class="line">conn.commit();</span><br></pre></td></tr></table></figure>

<p>​    根据上篇文章<code>springAop</code>，不难猜测，<code>spring</code>肯定是借助于<code>aop</code>，对标记了<code>@Transactional</code>的方法进行拦截并进行事务的增强。那么它是怎么实现的呢？</p>
<p>在<code>spring</code>中开启事务需要通过<code>EnableTransactionManagement</code>注解，实际上就是通过它来进行一些开箱即用的处理。这个注解的实现上引入了<code>@Import</code>注解，这个注解的作用是为了将某些类引入到<code>Spring</code>容器中。这样做有一个好处是，在启用这个注解的情况下，才引入某些类到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到<code>TransactionManagementConfigurationSelector</code>类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableTransactionManagement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过selectImports方法将某些类加载到容器中，这个方法返回一个字符串数组</span></span><br><span class="line"><span class="comment">	 * 这个字符串是类的全限定类名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">						ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">			<span class="keyword">case</span> ASPECTJ:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来了，这里引入了两个类：</p>
<ol>
<li><code>AutoProxyRegistrar</code></li>
<li><code>ProxyTransactionManagementConfiguration</code></li>
</ol>
<h3 id="1-AutoProxyRegistar"><a href="#1-AutoProxyRegistar" class="headerlink" title="1.AutoProxyRegistar"></a>1.AutoProxyRegistar</h3><p>它实现了<code>ImportBeanDefinitionRegistrar</code>接口。所以它的主要作用是将<code>InfrastructureAdvisorAutoProxyCreator</code>这个后置处理器类注入到容器中，那么容器在进行每一个<code>bean</code>对象初始化时都会将这个后置处理作用在对应的<code>bean</code>上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 它的主要作用在AopConfigUtils.registerAutoProxyCreatorIfNecessary中，为了将org.springframework.aop.framework.autoproxy.InfrastructureAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment">	 * 类注册到spring中，这个类实现了spring的后置处理器，主要作用是在spring的bean初始化的过程中，对bean进行检查，如果符合一定的条件</span></span><br><span class="line"><span class="comment">	 * 则把这个bean的aop代理对象注入到spring容器中。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> candidateFound = <span class="keyword">false</span>;</span><br><span class="line">		Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes();</span><br><span class="line">		<span class="keyword">for</span> (String annType : annTypes) &#123;</span><br><span class="line">			AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">			<span class="keyword">if</span> (candidate == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Object mode = candidate.get(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">			Object proxyTargetClass = candidate.get(<span class="string">&quot;proxyTargetClass&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (mode != <span class="keyword">null</span> &amp;&amp; proxyTargetClass != <span class="keyword">null</span> &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp;</span><br><span class="line">					Boolean.class == proxyTargetClass.getClass()) &#123;</span><br><span class="line">				candidateFound = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (mode == AdviceMode.PROXY) &#123;</span><br><span class="line">					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">					<span class="keyword">if</span> ((Boolean) proxyTargetClass) &#123;</span><br><span class="line">						AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下<code>InfrastructureAdvisorAutoProxyCreator</code>类。它自己本身没有什么太多的实现，它继承与<code>AbstractAdvisorAutoProxyCreator</code>抽象类，这个抽象类实现了一些查询那些增强可以作用在目标<code>bean</code>对象上处理。本篇想聊的后置处理的实现是在它的父类<code>AbstractAutoProxyCreator</code>上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfrastructureAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AbstractAutoProxyCreator</code>中，实现了具体的后置处理的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这里获取到需要的增强链，这里会获取到刚刚最早提到的，通过@EnableTransactionManagement</span></span><br><span class="line">  <span class="comment">// 的import注解注入了两个类的第二个类，第二个配置类的作用是引入事务增强类。</span></span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-ProxyTransactionManagementConfiguration"><a href="#1-ProxyTransactionManagementConfiguration" class="headerlink" title="1.ProxyTransactionManagementConfiguration"></a>1.ProxyTransactionManagementConfiguration</h3><p>上面已经给出了结论，这个类的作用是引入了事务处理需要使用到的增强类。使得<code>springBean</code>对象在初始化时进入到后置处理器中，后置处理器再获取到这个类通过<code>@Bean</code>注解注入到容器中的增强类，从而实现将需要进行事务处理的类进行代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionManagementConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注入到容器中的事务增强类，它是Advisor接口的实现。它有两个参数，这两个参数也是通过容器来获取</span></span><br><span class="line"><span class="comment">	 * 也是在下方进行声明</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title">transactionAdvisor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			TransactionAttributeSource transactionAttributeSource,</span></span></span><br><span class="line"><span class="function"><span class="params">			TransactionInterceptor transactionInterceptor)</span> </span>&#123;</span><br><span class="line">		BeanFactoryTransactionAttributeSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryTransactionAttributeSourceAdvisor();</span><br><span class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">		advisor.setAdvice(transactionInterceptor);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.enableTx != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisor.setOrder(<span class="keyword">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 上面增强类的第一个参数，这个bean的作用主要是用来获取事务属性的；比如配置的传播机制，异常信息等等；</span></span><br><span class="line"><span class="comment">	 * 这个bean当中提供了一个方法来获取</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionAttributeSource <span class="title">transactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnnotationTransactionAttributeSource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 上面增强类的第二个参数，这个bean的作用主要是用来拦截，拦截目标方法之后进行事务的开启、提交、回滚等动作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TransactionInterceptor <span class="title">transactionInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			TransactionAttributeSource transactionAttributeSource)</span> </span>&#123;</span><br><span class="line">		TransactionInterceptor interceptor = <span class="keyword">new</span> TransactionInterceptor();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.txManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">			interceptor.setTransactionManager(<span class="keyword">this</span>.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> interceptor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看一下<code>BeanFactoryTransactionAttributeSourceAdvisor</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里定义了切点的查找规则，也就是说bean进入了前面提到的后置处理器之后，会取出容器中的所有增强通知，然后逐个进行匹配</span></span><br><span class="line">	<span class="comment">// 看遍历的到的通知是否需要作用到bean对象中，当遍历到这个增强时，就会通过TransactionAttributeSource类来进行匹配</span></span><br><span class="line">	<span class="comment">// 也就是导入的配置类ProxyTransactionManagementConfiguration中定义的第二个bean对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里具体的匹配规则在类<code>AnnotationTransactionAttributeSource</code>中。</p>
<p>具体的匹配规则在它的父类<code>AbstractFallbackTransactionAttributeSource#getTransactionAttribute()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">	TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">	<span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> cached;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 计算是否匹配</span></span><br><span class="line">		TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">		<span class="comment">// ...省略代码，主要是推入缓存</span></span><br><span class="line">		<span class="keyword">return</span> txAttr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ..省略代码，主要是前置校验，是不是已经是代理类等等的操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重点在这，通过这个方法获取到TransactionAttribute对象</span></span><br><span class="line">	<span class="comment">// 这个方法的实现由AnnotationTransactionAttributeSource自己实现</span></span><br><span class="line">	TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> txAttr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ..省略代码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到<code>AnnotationTransactionAttributeSource</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">findTransactionAttribute</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">		TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line">		<span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> attr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终走到SpringTransactionAnnotationParser中，通过这个方法获取被@Transactional标记的方法或者类的信息</span></span><br><span class="line"><span class="comment">// 将@Transactional中定制化配置的信息读取到AnnotationAttributes对象中。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">	AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">			element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <code>spring</code>事务的代理是通过<code>@EnableTransactionManagement</code>注解来开启，这个注解通过<code>@Import</code>注解来导入两个类，一个类是后置处理器，它的作用是在每个<code>bean</code>对象创建之后将第二个导入类中定义的增强作用在这个对象上，并形成代理对象。第二个导入类的作用是定义了一个增强，这个增强包含了如何确定切面、切点、连接点等信息，也包含了拦截的逻辑，也就是事务的开启、提交和回滚等处理。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>Type接口</title>
    <url>/2024/06/24/java/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>​    序列化是将数据对象转换为可传输格式的过程。是一种数据持久化的手段，一般广泛应用于网络传输、RPC、RMI等场景中。</p>
<span id="more"></span>

<p>常见的序列化框架：</p>
<table>
<thead>
<tr>
<th>java</th>
<th>jdk自带，使用方便，可序列化所有类，速度慢，占空间</th>
</tr>
</thead>
<tbody><tr>
<td>protobuf</td>
<td>速度快，但需要先进行静态编译</td>
</tr>
<tr>
<td>kryo</td>
<td>速度快，序列化后体积小；跨语言支持较复杂</td>
</tr>
</tbody></table>
<p>在<code>java</code>的序列化机制中，需要进行序列化的对象需要实现<code>Serializable</code>接口，这个接口没有方法或者字段，单纯是为了表示可序列化语义。自定义的类通过实现<code>Serializable</code>接口，进而在<code>IO</code>过程中实现序列化和反序列化。</p>
<p>在序列化过程中，会对将要序列化/方序列化的类进行检查，要求操作对象必须是字符串、枚举类、数组类型或者是实现了<code>Serializable</code>的类。</p>
<p>创建一个继承于<code>Serializable</code>接口的类，然后通过流处理将这个类写入到<code>1.txt</code>中，注意，这里写入之后，如果直接打开文件，会发现这是个乱码文件，这是因为序列化写入的是二进制文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend friend = <span class="keyword">new</span> Friend();</span><br><span class="line">        friend.setName(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">            objectOutputStream.writeObject(friend);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义序列化逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的序列化调用链：<code>objectOutputStream.writeObject()</code> &rarr;<code>writeObject0(obj, false);</code> &rarr; <code>writeOrdinaryObject(obj, desc, unshared);</code>(区分是<code>Serializable</code>还是<code>Externalizable</code>)&rarr;如果没有实现自定义的序列化策略则调用<code>defaultWriteFields(obj, slotDesc);</code>，如果实现了自定义序列化策略，则通过反射调用到自定义序列化策略<code>slotDesc.invokeWriteObject(obj, this);</code>。</p>
<p>但是需要注意，就算是自定义了序列化接口<code>writeObject()</code>，且不进行写入动作，最终的输出文件依然不会是空文件，为了反序列化，包含了一些格式信息，不单纯只有数据，比如有字段类型等信息。</p>
<p><b>Externalizable</b>的作用是什么？</p>
<p>它相比于<code>Serializable</code>更为灵活，比如一个类有一个父类，在序列化时，如果也想序列化父类中的属性，则这个父类也需要实现<code>Serializable</code>接口；另一种做法是是子类实现<code>Externalizable</code>接口，但是实现该接口需要重写<code>writeExternal()</code>和<code>readExternal()</code>方法，这种情况下就可以指定需要序列化的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeUTF(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        name = in.readUTF();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>serialVersionUID的作用？</b></p>
<p>一般一个类在继承<code>Serializable</code>接口后，都会定义一个字段<code>private static final long serialVersionUID = 1L;</code>，那么它的作用是什么？</p>
<p>它主要是用来校验是否允许进行反序列化的，当将某个类进行序列化后，比如是存储到文件中，会将这个值也序列化到文件中，当进行反序列化时，将这个<code>serialVerionUID</code>进行比对，如果不一致，则抛出<code>InvalidCastException</code>异常。</p>
<p>如果类发生了改变（比如新增字段、删除字段、改变字段类型等），这时如果进行反序列化，可能出现不匹配的情况，如果没有显示声明这个字段值，<code>java</code>会生成一个默认的<code>serialVersionUID</code>，这个值是基于类的结构生成的，当类的结构发生变化的时候，再次序列化时这个值也会发生变化，就会导致使用变更之前的数据进行反序列化会抛出异常。但是我们在使用时，通常为了确保即使类发生了变化，也要序列化成功，会显示的声明这个值。</p>
<p><b>数组的序列化</b></p>
<p>在序列化的过程中，如果被序列化对象自定义实现了<code>writeObject()</code>和<code>readObject()</code>方法，则会尝试使用自定义的方法进行序列化和方序列化。</p>
<p>在<code>ArrayList</code>中，它的存储是<code>transient Object[] elementData</code>，但是这个对象数组又被声明为<code>transient</code>，所以在默认的序列化策略中，并不会对它进行序列化，这是因为<code>ArrayList</code>是动态数组，每次在放满之后会进行动态的扩容，那么就会出现一个数组中有多个<code>null</code>元素，为了保证<code>null</code>元素不被序列化，所以将数组设置为<code>transient</code>后，通过自定义序列化策略进行序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span><span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// 写入固定格式</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入容器大小</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入元素值，只循环size次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span><span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// 也只读出size值的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s入门</title>
    <url>/2024/07/29/k8s/k8s%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="k8s入门"><a href="#k8s入门" class="headerlink" title="k8s入门"></a>k8s入门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><span id="more"></span>

<p><b>1.私有网络VPC</b></p>
<p>​    在集群内通过设置VPC来进行私有网络（专有网络）配置。</p>
<p><img src="https://s2.loli.net/2024/07/14/xGjEFrJ8U4Tb69K.png" alt="VPC.png"></p>
<p>集群内的机器通过私有IP进行访问，这样不需要走公网IP的流量，访问时也不会因为公网的带宽限制。一般云服务器都会默认分配对应的专有网络，也可以自己配置专有网络。</p>
<p>若自己配置专有网络，需要配置IP网段，这个网段标志着这个专有网络最多能容纳多少台服务器。</p>
<p>比如配置的网段是：192.168.0.1/16(192.168.0.0 ~ 192.168.255.255)其中头尾IP被占用，剩下的IP就可以分配给对应的服务器，之后就可以通过私有网络进行访问。</p>
<p>在一些云产商，在配置了专用VPC之后，还可以配置交换机。再一级的细分网段。</p>
<p>所以比如这时可以加两个交换机（192.168.0.1/24）（192.168.10.1/24）。</p>
<p><b>如果创建了多个VPC，VPC与VPC之间是相互隔离的，相互VPC之下的机器是无法互通。</b></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>Pod：是<code>K8s</code>调度的基本单位，一个<code>Pod</code>中支持多个容器，其中多个容器共享网络和文件系统，可以通过进程通信和文件共享这种简单高效的方式组合完成服务。每个<code>Pod</code>都有一个特殊的根容器<code>Pause</code>容器，以及一个或多个的业务容器组成。<code>Pause</code>容器作为根容器，以它的状态来代表这个<code>Pod</code>的运行状态，每个<code>Pod</code>都分配了一个唯一的<code>IP</code>地址（<code>Pod IP</code>)。<code>Pod</code>内的所有业务容器都共享根容器的<code>Ip</code>，以及共享根容器挂载的<code>Volume</code>。</li>
<li>Node：是<code>Pod</code>真正运行的主机，可以是物理机也可以是虚拟机，为了更好的管理<code>Pod</code>，在每个<code>Node</code>节点上至少要容器引擎（<code>docker</code>）、<code>kubelet</code>、<code>kubelet-proxy</code>服务。</li>
<li>Namespace：命名空间，是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或者用户组。</li>
<li>Label：是<code>k8s</code>对象的标签，以键值的方式附加到各种资源上，一个资源对象可以定义任意数量的<code>Label</code>，同一个<code>Label</code>也可以被添加到任意数量的资源上，<code>k8s</code>通过<code>Label Selector</code>（标签选择器）来查询和筛选某些<code>Label</code>资源对象。</li>
<li>Service：是一个服务的访问入口，通过标签选择器<code>Label Selector</code>与<code>Pod</code>副本集群之间进行对接，定义了一组的<code>Pod</code>访问策略（<code>iptable</code>），防止<code>Pod</code>失联。在创建<code>Service</code>时会自动为它分配一个虚拟的<code>IP</code>地址，即<code>Cluster IP</code>，服务发现就是通过<code>Service</code>的<code>Name</code>和<code>ClusterIP</code>地址做了一个<code>DNS</code>域名映射来解决。</li>
<li>RepllcaSet(RC)：用来确保预期的<code>Pod</code>副本数量，如果有过多的<code>Pod</code>副本运行，则会停止一些，反之则再启动一些。一般很少主动操作<code>RC</code>，都是通过<code>Deployment</code>这个更高层次的资源对象使用，从而形成一整套<code>Pod</code>创建、删除、更新的编排机制。</li>
<li>Deployment：用于部署无状态应用，只需要在<code>Deployment</code>上描述想要的目标状态，它就会将<code>Pod</code>和<code>RC</code>的实际状态改变到目标状态。</li>
</ul>
<h2 id="架构组件"><a href="#架构组件" class="headerlink" title="架构组件"></a>架构组件</h2><p><img src="https://s2.loli.net/2024/06/13/dZ17RHOM3BuYVFp.png" alt="k8s.png"></p>
<p><b>k8s主要由以下核心组件组成：</b>在<code>k8s</code>集群中分为<code>master</code>主节点和<code>node</code>工作节点。</p>
<p><b>在主节点中：（控制平面）</b></p>
<ul>
<li>kube-apiserver：提供了资源操作的唯一入口，各组件的协调者，以<code>Http Rest</code>方式提供接口服务，所有对象资源的增、删、改、查和监听都交给它处理后再提交到<code>etcd</code>中存储。</li>
<li>etcd：键值数据库，保存了整个集群的一些信息。比如<code>Pod</code>、<code>Service</code>等对象信息。</li>
<li>kube-scheduler：调度器，根据调度算法为新创建的<code>Pod</code>选择一个<code>node</code>工作节点，可以任意部署，可以部署在同一个工作节点上，也可以部署在不同的工作节点上。</li>
<li>kube-controller-manager：是所有资源对象的自动化控制中心，一个资源对应一个控制器，而它就是负责管理这些控制器。比如有：<ul>
<li>节点控制器</li>
<li>任务控制器</li>
<li>端点控制器</li>
<li>副本控制器</li>
<li>服务账户与令牌控制器</li>
</ul>
</li>
</ul>
<p><b>在工作节点中：</b></p>
<ul>
<li>kubelet：它是<code>master</code>主节点在<code>node</code>工作节点上的<code>agent</code>(代理），主节点通过它来管理当前工作节点的运行容器的生命周期，负责<code>Pod</code>对应容器的创建、启停等，实现集群管理的基本功能。</li>
<li>kube-proxy：在工作节点上实现<code>Pod</code>网络代理，实现<code>kubernets Service</code>的通信，维护网络规则和四层负责均衡工作。</li>
<li>docker engine：容器引擎，负责本机的容器创建和管理工作。</li>
</ul>
<h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><p><b>环境部署前遇到的一些问题</b></p>
<ul>
<li>由于需要使用到<code>yum</code>来下载一些包，但是<code>yum</code>需要访问镜像仓库，始终无法访问到<code> mirrorlist.centos.org</code>，所以需要更换为国内的的一些镜像源。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos7的镜像源文件的目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line"><span class="comment"># 将原本的CentOS-Base.repo备份后</span></span><br><span class="line"><span class="comment"># 使用阿里云镜像站，如果能使用wget，则直接下载，如果不能，可以先下载文件后贴进去</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用网易镜像站</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.<span class="built_in">help</span>/CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure>

<p>添加安装<code>docker</code>镜像源，这个命令执行之后，会在<code>/etc/yum.repos.d</code>目录下生成<code>docker-ce.repo</code>文件。是专门针对<code>docker</code>的软件包镜像源。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装<code>docker</code>，安装<code>docker</code>要注意需要和<code>k8s</code>版本匹配。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker是否安装成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置加速镜像源</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://gr4yxx0x.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p><b>接着就可以开始安装K8S</b></p>
<ul>
<li>设置<code>hostname</code>，每台服务器的主机名不可重复。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看主机名</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭交互区，一些安全配置</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 交换分区</span></span><br><span class="line">  free -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）  第一行是临时禁用，第二行是永久禁用</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap；第一行是临时禁用，第二行是永久禁用</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 iptables 检查桥接流量 （K8s 官方要求）</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让配置生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>

<ul>
<li>安装k8s三大件（<code>kubelet</code>、<code>kubeadm</code>、<code>kubectl</code>）版本使用<code>1.20.9</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置k8s的yum源</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装三大件</span></span><br><span class="line">yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动kubelet</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubelet 状态：一会停止 一会运行。 这个状态是对的，kubelet 等待 kubeadm 发号指令。</span></span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure>

<p>在<code>k8s</code>组件中，除了<code>kubelet</code>，其他组件都是通过容器的方式下载运行。</p>
<ul>
<li>安装其他组件的容器</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置镜像，生成 images.sh</span></span><br><span class="line"><span class="comment"># 逻辑上只需要在master节点上下载所有的容器镜像，在work节点上只需要下载kube-proxy</span></span><br><span class="line">sudo tee ./images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化主节点</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个要在每个节点上都配置对主节点的本地路由映射</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;10.211.55.15  cluster-endpoint&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主节点初始化 （只在 master 服务器执行， 其他 node 不用）</span></span><br><span class="line"><span class="comment"># --apiserver-advertise-address: master 的 IP</span></span><br><span class="line"><span class="comment"># --control-plane-endpoint: master 的域名</span></span><br><span class="line"><span class="comment"># --image-repository docker镜像仓库</span></span><br><span class="line"><span class="comment"># --service-cidr 和 --pod-network-cidr 是网络范围，建议不要改。要改的话 2 个cidr 和 vps（172.31.x.x） 的，3 个网络互相不能重叠；还要修改 calico.yaml的 IP（下图有写）。</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.211.55.15 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>如果使用的是云服务器要注意，至少要允许在<code>2c</code>的服务器上。</p>
<p>安装成功后会得到以下提示信息，需要根据以下信息进行操作。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and <span class="keyword">then</span> running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c </span><br></pre></td></tr></table></figure>

<ul>
<li>这时通过<code>kubectl get nodes</code>可以看到当前的节点状态，但是此时的主节点状态还是<code>NotReady</code>，是因为还需要下载一个网络组件。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用calico网络组件，在主节点下载 calico.yaml</span></span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">curl https://docs.projectcalico.org/v3.20/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>

<p>这里有一个问题：我使用的是阿里云的镜像加速器，但是好像一直无法下载<code>calico</code>镜像。所以只能通过一些非常规手段下载。创建<code>calico.sh</code>，之后<code>chmod +x calico.sh &amp;&amp; ./calico.sh</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/projectcalico/calico/releases/tag/v3.20.6 通过这个地址下载release-v3.20.6.tgz包，然后上传到服务器中。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后创建cailco.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf release-v3.20.6.tgz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> release-v3.20.6</span><br><span class="line"><span class="built_in">cd</span> images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环加载 image</span></span><br><span class="line">sudo tee load-images.sh &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">tars=(</span><br><span class="line">calico-kube-controllers.tar</span><br><span class="line">calico-node.tar</span><br><span class="line">calico-typha.tar</span><br><span class="line">calico-cni.tar</span><br><span class="line">calico-pod2daemon-flexvol.tar</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> tar <span class="keyword">in</span> <span class="variable">$&#123;tars[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">docker load &lt; <span class="variable">$tar</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod +x load-images.sh &amp;&amp; ./load-images.sh</span><br></pre></td></tr></table></figure>

<p>同时需要修改下载的<code>calico.yaml</code>中的镜像地址。(<b>注意：如果是通过这种方式，则工作节点也需要同样操作，因为工作节点也需要这个镜像。</b>)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原本 calico.yaml 中所规定的 image 资源都是长这样的 docker.io/calico/cni:v3.20.6， 由于这个 docker.io/ 前缀会导致 k8s 去 DockerHub 上找 image (前面已解释了走不了阿里加速器的原因)，而不是使用刚才我们导入进本地的 images。所以我们用 sed -i 来全局查找替换，去掉它们。</span></span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s/image: docker.io\//image: /g&#x27;</span> calico.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>工作节点运行命令，使得工作节点加入集群</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token xh1xft.8m76emhyhdjr7i0o \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:4985192332d76a8ebead16baed30db9c43d1efdd8c26d328691005da8649d31c</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果使用虚拟机部署，要注意服务器之间的防火墙有没有关闭，可能出现无法访问的情况。    </span></span><br></pre></td></tr></table></figure>

<p>加入集群的令牌的有效期是24小时，重新获取令牌。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新获取令牌</span></span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>

<p>在k8s中一般都是通过<code>.yaml</code>来进行一些操作。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml</span><br><span class="line">kubectl delete -f xxx.yaml</span><br></pre></td></tr></table></figure>

<p>我在测试时候使用的是云服务器，后面转到虚拟机上，部署了同样的环境。(不行，这个修改方式有问题，虽然乍一看修改之后是没有什么问题，通过<code>kubectl get nodes</code>查看的状态也是对的，但是我在创建<code>pod</code>的时候一直创建不起来，甚至连<code>pod</code>都没有去创建，也不知道是因为什么，通过<code>systemctl status kubelet</code>查看日志，其中有打印出还是通过旧的地址访问<code>serverapi</code>接口，说明哪里改漏了，没有改到，但是具体哪里就不知道了。)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 但是由于我部署的时候是和我后面用的时候不是同一个wifi网络环境，导致我在重启虚拟机之后ip变了。</span></span><br><span class="line"><span class="comment"># 重启虚拟机之后要先启动docker，再启动k8s</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/kubernetes/manifests</span><br><span class="line">vi etcd.yaml</span><br><span class="line">vi kube-apiserver.yaml</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 k8s 集群 所有节点</span></span><br><span class="line">kubectl get nodex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 k8s 集群 部署了 哪些应用运行的应用在 docker 中叫 container（容器），在 k8s 中叫 pod</span></span><br><span class="line">kubectl get pods -A对应 docker 中 的docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 默认命名空间（default）部署的应用</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 完整的信息，有 部署的 节点、节点IP 等。</span></span><br><span class="line">kubectl get pod -A -owide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 整个状态变化过程</span></span><br><span class="line">kubectl get pod -w</span><br></pre></td></tr></table></figure>

<h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 某个命名空间（kubernetes-dashboard）部署的应用</span></span><br><span class="line">kubectl get pod -n kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建命名空间 hello</span></span><br><span class="line">kubectl create ns hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除命名空间 hello</span></span><br><span class="line">kubectl delete ns hello</span><br></pre></td></tr></table></figure>

<h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建名为 mynginx-k8s 的 Pod （默认命名空间）</span></span><br><span class="line">kubectl run mynginx-k8s --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到 Pod 里面（和 docker exec -it 一样的）</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it Pod名字 -- /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod mynginx-k8s 的描述</span></span><br><span class="line">kubectl describe pod mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 在默认命名空间的 mynginx-k8s</span></span><br><span class="line">kubectl delete pod mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 在 xxx 命名空间的 mynginx-k8s</span></span><br><span class="line">kubectl delete pod mynginx-k8s -n xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod mynginx-k8s 的运行日志（默认的命名空间）</span></span><br><span class="line">kubectl logs mynginx-k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 运行日志（-n 就是 namespace 命名空间）</span></span><br><span class="line">kubectl logs -f -n xxx命名空间 xxxPodName</span><br></pre></td></tr></table></figure>

<h4 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用 Deployment 部署 Pod，deploy 名为 mytomcat，使用镜像 tomcat:8.5.68</span></span><br><span class="line">kubectl create deployment mytomcat --image=tomcat:8.5.68</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Deployment 创建的资源</span></span><br><span class="line">kubectl get deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Deployment 创建的资源，用 delete 是删不掉的</span></span><br><span class="line">kubectl delete deploy mytomcat</span><br><span class="line"></span><br><span class="line"><span class="comment"># --replicas=3，部署 3个 Pod my-dep</span></span><br><span class="line">kubectl create deployment my-dep --image=nginx --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Deployment my-dep 扩容 成 5 个 Pod</span></span><br><span class="line">kubectl scale deploy/my-dep --relicas=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Deployment my-dep 缩容 成 2 个 Pod</span></span><br><span class="line">kubectl scale deploy/my-dep --relicas=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前用的镜像（spec.container.image）</span></span><br><span class="line">kubectl get deploy/my-dep -oyaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看之前用的镜像</span></span><br><span class="line">kubectl get deploy/my-dep -oyaml | grep image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变 my-dep 中 nginx 版本（nginx 最新版 -&gt; 1.16.1）滚动更新</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/my-dep nginx=nginx:1.16.1 --recordkubectl rollout status deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史记录</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 my-dep 某个历史详情</span></span><br><span class="line">kubectl rollout histroy deployment/my-dep --revision=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># my-dep 回滚（回到上个版本）</span></span><br><span class="line">kubectl rollout undo deployment/my-dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># my-dep 回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment/my-dep --to-revision=2</span><br></pre></td></tr></table></figure>

<p>在<code>deployment</code>中还有一些细分：</p>
<ul>
<li>Deployment：无状态应用部署，比如微服务，提供多副本等功能。</li>
<li>StatefulSet：有状态应用部署，比如redis，提供稳定的存储、网络等功能</li>
<li>DeamonSet：守护型应用部署，比如日志收集组件，在每个机器都运行一份。</li>
<li>Job/CronJob:定时任务部署，比如垃圾清理组件，可以在指定时间运行。</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><code>Pod</code>的服务发现与负责均衡，将一组<code>Pods</code>公开为网络服务的抽象方法。如果访问是通过直接<code>IP</code>的方式，当其中的一个<code>Pod</code>或者是服务器宕了之后，就直接无法访问了，所以在<code>k8s</code>中，<code>Pod</code>的网络控制由<code>Service</code>管理，请求访问到<code>Service</code>上，由<code>Service</code>转到对应的<code>Pod</code>上，当然它也有负载均衡的能力。</p>
<p><b>Service有两种创建方式，或者说有两种创建类型</b></p>
<ul>
<li>ClusterIP：默认的访问方式（创建的时候不写就是使用这种方式），只能集群内访问。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl expose 暴露端口，只能在集群内部 ClusterIP 访问。--type=ClusterIP 不传默认就是ClusterP</span></span><br><span class="line"><span class="comment"># target-port 目标Pod的端口（源端口） </span></span><br><span class="line"><span class="comment"># port service的端口</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在集群内通过域名访问：服务名.命名空间.svc ; 比如 my-dep-02.default.svc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 service，里面有 CLUSTER-IP</span></span><br><span class="line"><span class="comment"># kubectl get service 或者 kubectl get svc</span></span><br><span class="line">kubectl get service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pod 标签</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">kubectl delete svc my-dep-02</span><br></pre></td></tr></table></figure>

<ul>
<li>NodePort：在公网上可以访问，但是这种方式暴露的端口是随机的。这种模式可以访问每一台服务器的暴露端口，比如创建之后生成的端口是30999，那么每一台服务器的IP:30999,都能访问到，且具备负责均衡。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只能集群内部访问（--type不写 默认 ClusterIP）</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80 --<span class="built_in">type</span>=ClusterIP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群外部也可以访问</span></span><br><span class="line">kubectl expose deploy my-dep-02 --port=8000 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>

<p><b>小Tip:</b>使用<code>ClusterIP</code>类型分配的IP地址，在初始化时其实配置了IP地址的范围。下方的<code>--service-cidr</code>。同样的下方的<code>--pod-network-cidr</code>是所有的<code>pod</code>的<code>IP</code>范围。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=172.31.0.2 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure>

<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>它是<code>Service</code>的统一网关入口，底层是<code>nginx</code>。所有的请求都是先到<code>ingress</code>，由<code>ingress</code>来打理这些请求，类似微服务中的网关层。</p>
<p><img src="https://s2.loli.net/2024/07/17/NS2nabyhVDUkWZF.png" alt="k8s.png"></p>
<p>安装<code>ingress</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改镜像</span></span><br><span class="line">vi deploy.yaml</span><br><span class="line"><span class="comment"># 将 image 的值改为如下值</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装资源</span></span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装的结果</span></span><br><span class="line">kubectl get pod,svc -n ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后别忘记把 svc 暴露的端口 在安全组放行</span></span><br></pre></td></tr></table></figure>

<p>删除<code>ingress</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl delete -f deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不知道为啥会删不干净</span></span><br><span class="line">kubectl get ns ingress-nginx -o json &gt; tmp.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启本地访问</span></span><br><span class="line">kubectl proxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再开一个窗口</span></span><br><span class="line">curl -k -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X PUT --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/ingress-nginx/finalize</span><br></pre></td></tr></table></figure>

<p>安装之后查看安装结果，可以看到<code>ingress-nginx-controller</code>通过<code>NodePort</code>方式暴露了两个端。</p>
<p><code>31276</code>这个是<code>http</code>的访问端口，<code>31267</code>这个是<code>https</code>的访问端口。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master home]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME                                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.96.2.61     &lt;none&gt;        80:31276/TCP,443:31267/TCP   2m44s</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.96.31.252   &lt;none&gt;        443/TCP                      2m44s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问<code>http://10.211.55.15:31067/</code>出现了<code>nginx</code>的404页面。</p>
<p>这里就简单的做个<code>ingress</code>的测试：如果访问的是<code>user.xiaocainiao.com</code>那么显示”Hello World!“。如果访问的是<code>pay.xiaocainiaoya.com</code>那么显示的是<code>nginx</code>的欢迎页面。</p>
<p>创建两个<code>Deployment</code>和两个<code>Service</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-demo</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在<code>k8s</code>中执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi test.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f test.yaml</span><br></pre></td></tr></table></figure>

<p>接着创建路由规则：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>  </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-host-bar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;user.xiaocainiao.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">hello-server</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span> <span class="comment"># hello-server （service） 的端口是 8000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;pay.xiaocainiaoya.com&quot;</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;/&quot;</span>  <span class="comment"># 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-demo</span>  <span class="comment">#java，比如使用路径重写，去掉前缀nginx</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>k8s</code>中执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi ingress-rule.yaml</span><br><span class="line"></span><br><span class="line">kubectl apply -f ingress-rule.yaml</span><br></pre></td></tr></table></figure>

<p>刚执行完命令，可能在<code>ADDRESS</code>一栏为空，稍微等一等之后会分配这个<code>ingress</code>的访问地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master home]<span class="comment"># kubectl get ingress -A</span></span><br><span class="line">NAMESPACE   NAME               CLASS   HOSTS                                        ADDRESS        PORTS   AGE</span><br><span class="line">default     ingress-host-bar   nginx   user.xiaocainiao.com,pay.xiaocainiaoya.com   10.211.55.16   80      12m</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我是用虚拟机做测试，需要进行本机的路由代理。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">10.211.55.16 user.xiaocainiao.com</span><br><span class="line">10.211.55.16 pay.xiaocainiaoya.com</span><br></pre></td></tr></table></figure>

<p>用这个访问地址+刚刚安装的<code>ingress-manager</code>暴露的端口进行访问。</p>
<p><img src="https://s2.loli.net/2024/07/24/e5HU4rxQOaPpsyS.png" alt="ingress.png"></p>
<h4 id="存储挂载"><a href="#存储挂载" class="headerlink" title="存储挂载"></a>存储挂载</h4><p>在<code>k8s</code>的场景中，<code>pod</code>在集群中部署的节点机是由<code>deployment</code>决定，假设说某一个<code>pod</code>挂了之后，可能<code>deployment</code>在识别到之后通过故障恢复，会将在其他机器上重新部署一个该<code>pod</code>。所以这时会存在一种情况，重新部署的<code>pod</code>理应能读取到之前<code>pod</code>故障之前写入到磁盘的一些持久性数据，所以在<code>k8s</code>体系中，引入了存储层框架。</p>
<p>在<code>k8s</code>中可以使用的一些存储层框架：Glusterfs、NFS、CephFS。</p>
<p>这里以NFS为例，需要在每一台节点机上安装<code>NFS</code>。每个机器上安装一个NFS存储层框架，然后相互之间进行数据同步，假设某一个<code>pod</code>故障之后，被转移到了其他的机器上，也能通过相同的挂载目录读取到之前持久化数据。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后在主节点上运行</span></span><br><span class="line"><span class="comment"># 只在 mster 机器执行：nfs主节点，rw 读写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure>

<p>到此就表示，在master机器上开放了<code>/nfs/data/</code>目录，用来做成存储空间。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查，下面的 IP 是master IP</span></span><br><span class="line">showmount -e 192.168.27.251</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器 执行，执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器执行，将远程 和本地的 文件夹 挂载</span></span><br><span class="line">mount -t nfs 192.168.27.251:/nfs/data /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 master 服务器，写入一个测试文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello nfs server&quot;</span> &gt; /nfs/data/test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器查看</span></span><br><span class="line"><span class="built_in">cd</span> /nfs/data</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p><b>原生方式 数据挂载</b></p>
<p>在 /nfs/data/nginx-pv 挂载，然后 修改， 里面 两个 Pod 也会 同步修改。</p>
<p>问题：①如果某个Pod不需要了，删掉Pod之后，文件还在，内容也在，②空间受机器空间管理，创建之后逻辑上是无限大的空间，除非达到机器上限，是没法管理大小的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pv-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 挂载目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="comment"># 和 volumeMounts.name 一样</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="comment"># master IP</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data/nginx-pv</span> <span class="comment"># 要提前创建好文件夹，否则挂载失败</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /nfs/data</span><br><span class="line">mkdir -p nginx-pv</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">vi deploy.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制上面配置</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f deploy.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pod -owide</span><br></pre></td></tr></table></figure>

<p><b>6.3 PV 和 PVC</b></p>
<p><strong>PV</strong>：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置</p>
<p><strong>PVC</strong>：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格</p>
<p>静态供应：在主节点上的<code>nfs/data/</code>目录下创建三个文件夹，并且通过yaml文件对其进行配置。</p>
<ul>
<li><code>01</code>：挂载名称为<code>pv01-10m</code>，且持久卷池的名称为<code>nfs</code>，空间为10M，多节点可读写</li>
<li><code>02</code>：挂载名称为<code>pv02-1gi</code>，且持久卷池的名称为<code>nfs</code>，空间为1G，多节点可读写</li>
<li><code>03</code>：挂载名称为<code>pv03-3gi</code>，且持久卷池的名称为<code>nfs</code>，空间为3G，多节点可读写</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 nfs主节点（master服务器） 执行</span></span><br><span class="line">mkdir -p /nfs/data/01</span><br><span class="line">mkdir -p /nfs/data/02</span><br><span class="line">mkdir -p /nfs/data/03</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv01-10m</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># 限制容量</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10M</span></span><br><span class="line">  <span class="comment"># 读写模式：可读可写</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span> <span class="comment"># 表示持久卷池子的名称</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="comment"># 挂载 上面创建过的文件夹</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/01</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># 这个name 要小写，如 Gi 大写就不行</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv02-1gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/02</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv03-3gi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs/data/03</span></span><br><span class="line">    <span class="comment"># nfs 主节点服务器的 IP</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.27</span><span class="number">.251</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制上面文件</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pv， kubectl get pv</span></span><br><span class="line">kubectl get persistentvolume</span><br></pre></td></tr></table></figure>

<p><b>创建、绑定 PCV</b></p>
<p>创建一个持久卷声明：从持久卷池子名为<code>nfs</code>的池子中申请一个至少有200M大小的空间。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="comment"># 需要 200M的 PV</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">200Mi</span></span><br><span class="line">  <span class="comment"># 上面 PV 写的什么 这里就写什么    </span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br></pre></td></tr></table></figure>

<p>绑定到<code>pod</code>上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy-pvc</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">          <span class="comment"># 之前是 nfs，这里用 pvc</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span> </span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">nginx-pvc</span> <span class="comment"># 绑定持久卷声明</span></span><br></pre></td></tr></table></figure>

<p>既然有静态供应那么也就会有动态供应，在静态供应商中，是创建好了一个个不同大小的PV,并把这些PV进行分组命名（池子名称），等需要使用时，通过这个分组名称（池子名称）去这个组里获取到最适合的空间大小的PV。这种方式比较麻烦的是，需要手动创建一个个PV,且空间大小上无法相对准确的预估，容易存在浪费。比如我只需要20M的空间，但是池子里的PV分别为1G，2G，3G，那么这时至少会给我1G的那个PV。</p>
<p>动态供应：就是可以动态的创建具体的PV，那么这种方式创建的PV的空间大小就会相对符合需要，不会造成过多的浪费。</p>
<h4 id="配置集ConfigMap"><a href="#配置集ConfigMap" class="headerlink" title="配置集ConfigMap"></a>配置集ConfigMap</h4><p>在<code>k8s</code>中部署<code>POD</code>，比如<code>redis</code>的启用，需要依赖于一些配置（配置一些服务器地址等），这时可以将这个配置内容添加到<code>k8s</code>的配置集中，那么所有的<code>pod</code>就可以都引用到这份配置文件，并且当需要修改配置时，只需要对这个配置集进行修改，<code>POD</code>中指定的配置文件也会相应的同步新的配置（一小段时间之后）。</p>
<p>假设我有配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置Redis监听的端口，默认为6379</span><br><span class="line">port 6379</span><br><span class="line"> </span><br><span class="line"># 设置Redis监听的网络接口的IP地址</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"> </span><br><span class="line"># 设置Redis是否以守护进程方式运行</span><br><span class="line">daemonize no</span><br><span class="line"> </span><br><span class="line"># 设置Redis的日志文件路径</span><br><span class="line">logfile &quot;&#x2F;var&#x2F;log&#x2F;redis&#x2F;redis-server.log&quot;</span><br><span class="line"> </span><br><span class="line"># 设置数据库的数量，默认16个数据库（0...15），可以通过select &lt;dbid&gt;命令选择数据库</span><br><span class="line">databases 16</span><br><span class="line"> </span><br><span class="line"># 设置密码认证</span><br><span class="line"># requirepass yourpassword</span><br><span class="line"> </span><br><span class="line"># 设置快照功能，即持久化</span><br><span class="line">#  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#  save 900 1</span><br><span class="line">#  save 300 10</span><br><span class="line">#  save 60 10000</span><br><span class="line"> </span><br><span class="line"># 设置持久化的文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"> </span><br><span class="line"># 设置当主服务器失效时，从服务器是否仍然可读</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"> </span><br><span class="line"># 设置是否在每个命令后进行日志记录</span><br><span class="line">appendonly no</span><br><span class="line"> </span><br><span class="line"># 设置更新日志的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"> </span><br><span class="line"># 设置更新日志写入策略</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"> </span><br><span class="line"># 设置Redis最大内存容量</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"> </span><br><span class="line"># 设置内存淘汰策略</span><br><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br><span class="line"><span class="comment"># 写</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置，redis保存到k8s的etcd；</span></span><br><span class="line">kubectl create cm redis-conf --from-file=redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">kubectl get cm</span><br><span class="line"></span><br><span class="line">rm -rf redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ConfigMap 的 yaml 配置咋写的</span></span><br><span class="line">kubectl get cm redis-conf -oyaml</span><br></pre></td></tr></table></figure>

<p>显示这个配置集的内容如下。（它是存储在<code>tecd</code>中）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="comment"># key为redis.conf 值为具体的redis启动配置值</span></span><br><span class="line">  <span class="attr">redis.conf:</span> <span class="string">&quot;# 设置Redis监听的端口，默认为6379\nport 6379\n \n# 设置Redis监听的网络接口的IP地址\n# bind 127.0.0.1\n</span></span><br><span class="line"><span class="string">    \n# 设置Redis是否以守护进程方式运行\ndaemonize no\n \n# 设置Redis的日志文件路径\nlogfile \&quot;/var/log/redis/redis-server.log\&quot;\n</span></span><br><span class="line"><span class="string">    \n# 设置数据库的数量，默认16个数据库（0...15），可以通过select &lt;dbid&gt;命令选择数据库\ndatabases 16\n \n# 设置密码认证\n#</span></span><br><span class="line"><span class="string">    requirepass yourpassword\n \n# 设置快照功能，即持久化\n#  save &lt;seconds&gt; &lt;changes&gt;\n#  save</span></span><br><span class="line"><span class="string">    900 1\n#  save 300 10\n#  save 60 10000\n \n# 设置持久化的文件\ndbfilename dump.rdb\ndir</span></span><br><span class="line"><span class="string">    /var/lib/redis\n \n# 设置当主服务器失效时，从服务器是否仍然可读\nslave-serve-stale-data yes\n \n# 设置是否在每个命令后进行日志记录\nappendonly</span></span><br><span class="line"><span class="string">    no\n \n# 设置更新日志的文件名\nappendfilename \&quot;appendonly.aof\&quot;\n \n# 设置更新日志写入策略\n# appendfsync</span></span><br><span class="line"><span class="string">    always\nappendfsync everysec\n# appendfsync no\n \n# 设置Redis最大内存容量\n# maxmemory</span></span><br><span class="line"><span class="string">    &lt;bytes&gt;\n \n# 设置内存淘汰策略\n# maxmemory-policy volatile-lru\n&quot;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2024-07-24T16:02:55Z&quot;</span></span><br><span class="line">  <span class="attr">managedFields:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">fieldsType:</span> <span class="string">FieldsV1</span></span><br><span class="line">    <span class="attr">fieldsV1:</span></span><br><span class="line">      <span class="attr">f:data:</span></span><br><span class="line">        <span class="string">.:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">f:redis.conf:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">manager:</span> <span class="string">kubectl-create</span></span><br><span class="line">    <span class="attr">operation:</span> <span class="string">Update</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">&quot;2024-07-24T16:02:55Z&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-conf</span> <span class="comment"># 创建了一个名为redis-conf的配置集</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;14777&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">a626dec1-6e28-4ed0-a5ce-0aaeafffe12f</span></span><br></pre></td></tr></table></figure>

<p>创建<code>pod</code>来引用这个配置集</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="comment"># 启动命令 如果是直接启动redis，一般写为 redis-server /path/to/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis-server</span></span><br><span class="line">      <span class="comment"># 指的是redis容器内部的位置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/redis-master/redis.conf&quot;</span>  </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span> <span class="comment"># 引用名称是叫dada的卷</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/redis-master</span> <span class="comment"># 这里表示挂载pod的这个位置</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 引用名称叫config的卷</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span> <span class="comment"># 创建一个名称叫data的卷</span></span><br><span class="line">      <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span> <span class="comment"># 创建一个名称叫config的卷</span></span><br><span class="line">      <span class="attr">configMap:</span> <span class="comment"># 它是一个configMap配置集类型</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">redis-conf</span> <span class="comment"># 找到配置集中的这个cm</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">redis.conf</span> <span class="comment"># 获取到key为redis.conf的配置</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">redis.conf</span> <span class="comment"># 把key为redis.conf的配置的值写入到这个地址</span></span><br></pre></td></tr></table></figure>

<p>注：配置集是具备了热更新的能力，修改了配置集中的配置值的内容，它会同步到<code>pod</code>中配置的制定文件上，但是如果<code>pod</code>中的应用想要获取到配置热更新之后的值，应用本身得拥有热更新的能力。（所以这时可能需要重启<code>pod</code>来读取最新的配置值）</p>
<h4 id="密钥集Secret"><a href="#密钥集Secret" class="headerlink" title="密钥集Secret"></a>密钥集Secret</h4><p>用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 Pod的定义或者容器镜像中来说更加安全和灵活。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##命令格式</span></span><br><span class="line">kubectl create secret docker-registry regcred \</span><br><span class="line">  --docker-server=&lt;你的镜像仓库服务器&gt; \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; \</span><br><span class="line">  --docker-email=&lt;你的邮箱地址&gt;</span><br><span class="line">  </span><br><span class="line">kubectl create secret docker-registry cgxin-docker-secret \</span><br><span class="line">--docker-username=leifengyang \</span><br><span class="line">--docker-password=Lfy123456 \</span><br><span class="line">--docker-email=534096094@qq.com</span><br></pre></td></tr></table></figure>



<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">private-cgxin-docker</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">private-cgxin-docker</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cgxin/cgxin_docker:1.0</span></span><br><span class="line">  <span class="comment"># 加上 Secret  </span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cgxin-docker-secret</span> <span class="comment"># 使用密钥集Secret</span></span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>spring日志系统</title>
    <url>/2024/05/22/Spring/spring%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="spring日志系统"><a href="#spring日志系统" class="headerlink" title="spring日志系统"></a>spring日志系统</h1><p>​    <code>spring</code>通过门面模式来应对项目中依赖不同的组件时，各组件使用不同的日志框架，有<code>log4j</code>、<code>log4j2</code>、<code>lockback</code>等，门面有<code>sl4j</code>和<code>commons-logging</code>。</p>
<span id="more"></span>

<p><img src="https://s2.loli.net/2024/05/22/KxUy7luX86DkjCB.png" alt=".png"></p>
<p>在开发的过程中，经常需要使用到日志框架来打印一些信息，来帮助开发者定位产生的相关问题等，在使用时只需要通过<code>log.info()</code>等方式就可以打印出一条日志信息，但是这条日志是如何打印出来，理清日志框架的工作过程及原理，能有效帮助开发者扩展日志功能以及优雅的进行日志打印等级切换等等。</p>
<h2 id="springboot日志框架"><a href="#springboot日志框架" class="headerlink" title="springboot日志框架"></a>springboot日志框架</h2><p><code>springboot</code>的默认日志框架是<code>logback</code>。具官网介绍<code>logback</code>的性能高于<code>log4j</code>，而<code>log4j2</code>是在<code>logback</code>之后诞生的，性能高于<code>logback</code>。<code>springboot</code>中默认引入的是<code>logback</code>日志框架，如果需要在<code>springboot</code>项目中使用<code>sl4j2</code>作为日志框架，需要将原生框架中的<code>logback</code>依赖排除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--排除lockback的依赖--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入log4j2依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    然后就可以在<code>resource</code>下创建<code>sl4j2.xml</code>配置文件，配置一些打印相关操作，比如指定多个打印器，指定打印路径，指定打印格式、打印等级等等。当然，也可以不创建这个配置文件，在<code>springboot</code>有兜底配置。</p>
<p>​    接着一步步来了解一下，以及<code>springboot</code>是如果设计，达到可以自由切换日志框架的目的。以及<code>sl4j2</code>的一些工作原理。</p>
<p>​    如果项目中结合了<code>lombok</code>可以发现，在实体上标记了<code>@Slf4j</code>之后，就可以通过<code>log</code>对象来打印日志，而这个打印日志的<code>log</code>对象就是<code>org.slf4j.Logger</code>类对象，它仅仅是定义了一系列的日志打印接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object arg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String format, Object... arguments)</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String msg, Throwable t)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果工程是使用<code>sl4j2</code>，那么此时就会进入到<code>org.apache.logging.slf4j.Log4jLogger</code>，它是<code>org.slf4j.Logger</code>门面接口的实现，它是在依赖<code>org.apache.logging.log4j:log4j-slf4j-impl</code>中。</p>
<p>如果工程是使用<code>logback</code>，那么此时就会进入到<code>ch.qos.logback.classic.Logger</code>，它也是<code>org.slf4j.Logger</code>门面对象的实现，他是在依赖<code>ch.qos.logback:logback-classis</code>中，这里要注意，<code>loback</code>对门面接口类的实现的类的名称也是叫<code>Logger</code>。</p>
<h2 id="log4j2的简单工作原理"><a href="#log4j2的简单工作原理" class="headerlink" title="log4j2的简单工作原理"></a>log4j2的简单工作原理</h2><p>从上述可以知道，其实打印日志都是获取<code>Logger</code>对象，通过它来进行日志打印操作。在<code>log4j2</code>中的<code>Logger</code>对象有两个属性<code>PrivateConfig</code>和<code>LoggerContext</code>。</p>
<ul>
<li><code>PrivateConfig</code>中包含了通过<code>log4j2.xml</code>文件解析出来的<code>appender</code>和具体的<code>logger</code>。</li>
<li><code>LoggerContext</code>是根据配置规则，缓存了每个类打印时需要使用到的<code>logger</code>和<code>appender</code>的关系。</li>
</ul>
<p><img src="https://s2.loli.net/2024/06/03/sJRqwL2lvr1TkGO.png" alt="logger.png"></p>
<p>在配置文件中的&lt;Appenders&gt;标签下每增加一项，解析得到的<code>Configuration</code>中的<code>Appenders</code>就多一个<code>Appender</code>。在&lt;Loggers&gt;标签下每增加一项，解析得到的<code>Configuration</code>中的<code>loggerConfigs</code>就多一项。</p>
<p>在<code>LoggerConfig</code>中持有所有<code>Appender</code>的引用，而解析后的<code>Configuration</code>中的<code>loggerConfigs</code>表示的是某一个<code>logger</code>持有的<code>Appender</code>引用。</p>
<p>如果需要使用到打印，都会先到<code>LoggerContext</code>的注册器<code>LoggerRegistry</code>中获取，如果没有，则会创建出一个<code>Logger</code>并注册到<code>LoggerRegistry</code>中。</p>
<p><img src="https://s2.loli.net/2024/06/03/f7j52o8GTA6bdFM.png" alt="loggerRegistry.png"></p>
<p>比方说我这个工程中的这个类<code>cn.com.xiaocainiaoya.common.CustomizeConfiguration</code>，如果需要打印就会从这个注册器中获取到这个<code>Logger</code>，然后通过这个<code>Logger</code>的日志等级配置以及<code>Appender</code>等等进行打印操作。</p>
<h2 id="Springboot日志启动机制"><a href="#Springboot日志启动机制" class="headerlink" title="Springboot日志启动机制"></a>Springboot日志启动机制</h2><p><code>Springboot</code>的日志启动依赖于<code>springboot</code>的事件监听机制，在<code>spring</code>的启动过程中，需要进行一系列的准备、加载等动作，所以<code>Spring</code>在对容器最终加载完成的整个生命周期中，设置了很多监听事件，比如刚刚启动容器、<code>Enviroment</code>准备完成、<code>ApplicatonContext</code>准备完成等等。日志启动是依赖于<code>LoggingApplicationListener</code>类，它实现了<code>ApplicationListener</code>的封装类<code>GenericApplicationListener</code>，所以它能接收到多种消息事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在启动SpringApplicatioin之后就发布了事件，先于Environment和ApplicationContext可用之前发布</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationStartingEvent) &#123;</span><br><span class="line">        onApplicationStartingEvent((ApplicationStartingEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Environment加载完成之后立即发布</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">        onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ApplicationContext准备好后但是刷新容器之前发布</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">        onApplicationPreparedEvent((ApplicationPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent</span><br><span class="line">            &amp;&amp; ((ContextClosedEvent) event).getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onContextClosedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationFailedEvent) &#123;</span><br><span class="line">        onApplicationFailedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>1.监听到<code>ApplicationStartingEvent</code>事件</b></p>
<p>在<code>Springboot</code>中操作日志最关键的一个对象就是<code>LoggingSystem</code>，这个对象在整个生命周期中掌握着日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationStartingEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem.beforeInitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在接收到这个事件通知之后，就到系统属性中去读取<code>LoggingSystem</code>具体的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; systems = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    systems.put(<span class="string">&quot;ch.qos.logback.core.Appender&quot;</span>, <span class="string">&quot;org.springframework.boot.logging.logback.LogbackLoggingSystem&quot;</span>);</span><br><span class="line">    systems.put(<span class="string">&quot;org.apache.logging.log4j.core.impl.Log4jContextFactory&quot;</span>,</span><br><span class="line">            <span class="string">&quot;org.springframework.boot.logging.log4j2.Log4J2LoggingSystem&quot;</span>);</span><br><span class="line">    systems.put(<span class="string">&quot;java.util.logging.LogManager&quot;</span>, <span class="string">&quot;org.springframework.boot.logging.java.JavaLoggingSystem&quot;</span>);</span><br><span class="line">    SYSTEMS = Collections.unmodifiableMap(systems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次加载的时候会从以上的SYSTEMS的map中去找，通过类加载器，逐个查找，看哪一个类是在类路径中，就启用哪一个LoggingSystem。我这里使用的是Log4j日志框架，那么这里就会找到并加载Log4J2LoggingSystem。如果使用的是logback，那么加载的就是LogbackLoggingSystem。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggingSystem <span class="title">get</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String loggingSystem = System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(loggingSystem)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NONE.equals(loggingSystem)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NoOpLoggingSystem();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(classLoader, loggingSystem);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 通过类加载器来找有没有引入对应的类，第一个匹配到谁就是谁</span></span><br><span class="line">    <span class="keyword">return</span> SYSTEMS.entrySet().stream().filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))</span><br><span class="line">            .map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No suitable logging system located&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到<code>LogginSystem</code>之后，就会调用它的<code>beforeInitialize()</code>，这个方法的主要作用就是进行一些事前初始化动作，这里添加了一个日志过滤器，但实际上是一个阻断器，这个阻断器拒绝了所有的日志打印。所以到达这一步，仍然是无法打印出日志的，就算日志框架接收到需要打印日志的请求，也会被阻断器拒绝。这样的设计是为了防止日志系统在完成初始化之前打印出不可控的日志信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.beforeInitialize();</span><br><span class="line">    loggerContext.getConfiguration().addFilter(FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><b>2.监听到<code>ApplicationEnvironmentPreparedEvent</code>事件</b></p>
<p>当<code>Environment</code>准备完成之后，继续进行日志框架的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggingSystem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用enviroment中配置的信息对日志框架进行初始化</span></span><br><span class="line">    initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableEnvironment environment, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把在enviroment中的配置信息读取出来，并设置到system中，比如有打印文件的路径</span></span><br><span class="line">    <span class="comment">// 文件大小、打印格式等等</span></span><br><span class="line">    <span class="keyword">new</span> LoggingSystemProperties(environment).apply();</span><br><span class="line">    <span class="keyword">this</span>.logFile = LogFile.get(environment);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logFile.applyToSystemProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将预制的web和sql日志打印初始化LoggerGroups</span></span><br><span class="line">    <span class="keyword">this</span>.loggerGroups = <span class="keyword">new</span> LoggerGroups(DEFAULT_GROUP_LOGGERS);</span><br><span class="line">    <span class="comment">// 读取系统级别的debug或者trace是否设置为true</span></span><br><span class="line">    <span class="comment">// 哪个类型为true就将springbootLogging的级别设置为那个</span></span><br><span class="line">    <span class="comment">// trace的优先级高于debug</span></span><br><span class="line">    initializeEarlyLoggingLevel(environment);</span><br><span class="line">    <span class="comment">// 执行loggingSystem.initialize()初始化方法</span></span><br><span class="line">    initializeSystem(environment, <span class="keyword">this</span>.loggingSystem, <span class="keyword">this</span>.logFile);</span><br><span class="line">    <span class="comment">// 完成日志打印组和日志打印器的级别的设置</span></span><br><span class="line">    initializeFinalLoggingLevels(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">    registerShutdownHookIfNecessary(environment, <span class="keyword">this</span>.loggingSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来看下<code>LoggingSystem</code>的初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeSystem</span><span class="params">(ConfigurableEnvironment environment, LoggingSystem system, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    LoggingInitializationContext initializationContext = <span class="keyword">new</span> LoggingInitializationContext(environment);</span><br><span class="line">    <span class="comment">// 从系统变量中获取logging.config</span></span><br><span class="line">    String logConfig = environment.getProperty(CONFIG_PROPERTY);</span><br><span class="line">    <span class="comment">// 如果没有就根据规则从类路径中找</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreLogConfig(logConfig)) &#123;</span><br><span class="line">        system.initialize(initializationContext, <span class="keyword">null</span>, logFile);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果有，就直接加载指定的文件。所以如果通过yaml直接配置，或者通过jar启动命令指定</span></span><br><span class="line">        <span class="comment">// 就直接走到这里</span></span><br><span class="line">        <span class="comment">// ... 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达Log4J2LoggingSystem的初始化方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    LoggerContext loggerContext = getLoggerContext();</span><br><span class="line">    <span class="keyword">if</span> (isAlreadyInitialized(loggerContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里移除了前面设置的日志阻断器</span></span><br><span class="line">    loggerContext.getConfiguration().removeFilter(FILTER);</span><br><span class="line">    <span class="comment">// 调用父类方法找到log4j2的配置文件，并进行初始化</span></span><br><span class="line">    <span class="keyword">super</span>.initialize(initializationContext, configLocation, logFile);</span><br><span class="line">    <span class="comment">// 标记初始化完成</span></span><br><span class="line">    markAsInitialized(loggerContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类方法最终会走到这里，按类路径查找，</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithConventions</span><span class="params">(LoggingInitializationContext initializationContext, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑上是要找到一个 classpath:xxxx的地址</span></span><br><span class="line">    String config = getSelfInitializationConfig();</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; logFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把这个配置文件中的东西解析出来为Configuration</span></span><br><span class="line">        reinitialize(initializationContext);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">        config = getSpringInitializationConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadConfiguration(initializationContext, config, logFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadDefaults(initializationContext, logFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就会将日志打印器<code>logger</code>进行分组。这样做的好处是便于管理，分组之后，如果需要对某个组改日志级别，只需要将这个组的日志级别进行修改，就不需要逐个去找打印器并进行修改。</p>
<p><img src="https://s2.loli.net/2024/06/03/M6NR7afJlAHk5Xn.png" alt="loggerGroups.png"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 可以通过yaml进行设置</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">common:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line">    <span class="attr">common:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cn.com.xiaocainiaoya.common</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">com.lee.xiaocainiaoya.user</span></span><br></pre></td></tr></table></figure>

<p>如果设置了<code>trace=true</code>或者是<code>bebud=true</code>，那么<code>springboot</code>会将自己的某些类的打印开启。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeFinalLoggingLevels</span><span class="params">(ConfigurableEnvironment environment, LoggingSystem system)</span> </span>&#123;</span><br><span class="line">    bindLoggerGroups(environment);</span><br><span class="line">    <span class="comment">// 只要trace=true 或者是 debug=true就开启springbootlogging</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.springBootLogging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        initializeLogLevel(system, <span class="keyword">this</span>.springBootLogging);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置用户自定义的打印器的日志级别</span></span><br><span class="line">    setLogLevels(system, environment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeLogLevel</span><span class="params">(LoggingSystem system, LogLevel springBootLogging)</span> </span>&#123;</span><br><span class="line">    initializeSpringBootLogging(system, springBootLogging);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeSpringBootLogging</span><span class="params">(LoggingSystem system, LogLevel springBootLogging)</span> </span>&#123;</span><br><span class="line">    BiConsumer&lt;String, LogLevel&gt; configurer = getLogLevelConfigurer(system);</span><br><span class="line">    SPRING_BOOT_LOGGING_LOGGERS.getOrDefault(springBootLogging, Collections.emptyList())</span><br><span class="line">            .forEach((name) -&gt; configureLogLevel(name, springBootLogging, configurer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    MultiValueMap&lt;LogLevel, String&gt; loggers = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 如果是debug就开这些</span></span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;sql&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;web&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.DEBUG, <span class="string">&quot;org.springframework.boot&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果是trace 就开这些</span></span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.springframework&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.apache.tomcat&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.apache.catalina&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.eclipse.jetty&quot;</span>);</span><br><span class="line">    loggers.add(LogLevel.TRACE, <span class="string">&quot;org.hibernate.tool.hbm2ddl&quot;</span>);</span><br><span class="line">    SPRING_BOOT_LOGGING_LOGGERS = Collections.unmodifiableMap(loggers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能按组设置就按组设置，不能按组设置就单独设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureLogLevel</span><span class="params">(String name, LogLevel level, BiConsumer&lt;String, LogLevel&gt; configurer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.loggerGroups != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LoggerGroup group = <span class="keyword">this</span>.loggerGroups.get(name);</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.hasMembers()) &#123;</span><br><span class="line">            group.configureLogLevel(level, configurer);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    configurer.accept(name, level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><b>3.监听到<code>ApplicationPreparedEvent</code>事件</b></p>
<h3 id="日志级别热更新"><a href="#日志级别热更新" class="headerlink" title="日志级别热更新"></a>日志级别热更新</h3><p>其实对应的日志框架都已经提供了对应的日志级别更新方法，只需要获取到<code>LoggingSystem</code>类，并调用<code>setLogLevel</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loggingSystem.setLogLevel(<span class="string">&quot;cn.com.xiaocainiaoya.BootStrap&quot;</span>, LogLevel.DEBUG);</span><br></pre></td></tr></table></figure>

<p>这里简单分析一下过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogLevel</span><span class="params">(String loggerName, LogLevel logLevel)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 转换为log4j对应的日志级别枚举类</span></span><br><span class="line">	Level level = LEVELS.convertSystemToNative(logLevel);</span><br><span class="line">	<span class="comment">// 到Configuration中去找这个loggerName的LoggerConfig(初始化之后所有的LoggerConfig都在这里)</span></span><br><span class="line">	LoggerConfig loggerConfig = getLoggerConfig(loggerName);</span><br><span class="line">	<span class="comment">// 如果不存在，则需要创建这个LoggerConfig，并添加到Configuration的ConcurrentMap&lt;String, LoggerConfig&gt; loggerConfigs中。</span></span><br><span class="line">	<span class="keyword">if</span> (loggerConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">		loggerConfig = <span class="keyword">new</span> LoggerConfig(loggerName, level, <span class="keyword">true</span>);</span><br><span class="line">		getLoggerContext().getConfiguration().addLogger(loggerName, loggerConfig);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果存在，则直接更新这个loggerConfig的日志级别</span></span><br><span class="line">		loggerConfig.setLevel(level);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ⭐️逐个更新loagger</span></span><br><span class="line">	getLoggerContext().updateLoggers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateLoggers</span><span class="params">(<span class="keyword">final</span> Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Configuration old = <span class="keyword">this</span>.configuration;</span><br><span class="line">    <span class="comment">// 逐个更新loagger</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Logger logger : loggerRegistry.getLoggers()) &#123;</span><br><span class="line">        logger.updateConfiguration(config);</span><br><span class="line">    &#125;</span><br><span class="line">    firePropertyChangeEvent(<span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>, PROPERTY_CONFIG, old, config));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateConfiguration</span><span class="params">(<span class="keyword">final</span> Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.privateConfig = <span class="keyword">new</span> PrivateConfig(newConfig, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我刚看到这个地方时候，我是有点困惑的，在我标记⭐️的地方。在更新完<code>loggerConfig</code>的的日志级别之后，尽然需要将所有的<code>loggerRegistry</code>都取出来进行重新创建<code>PrivateConfig</code>。难道不是<code>loggerConfig</code>的日志级别修改了之后持有这个对象的引用获取到信息也是更新之后的值。但是其实这里是有可能获取不到<code>loggerConfig</code>，那么就需要创建一个新的<code>loggerConfig</code>到<code>Configuration</code>池子里。根据日志名称匹配规则，新增了一个<code>loggerConfig</code>那么其实对缓存中的所有信息有所影响，比如某个类的全限定类名是<code>cn.com.xiaocainiao.FeignUtil</code>，原本它是使用名称为<code>root</code>的打印器，但是我调用<code>setLogLevel(&quot;cn.com.xiaocainiao&quot;, &quot;DEBUG&quot;)</code>那么这时会创建一个新的打印器器，也就导致了<code>cn.com.xiaocainiao.FeignUtil</code>应该使用新创建的这个打印器，而不是根打印器，所以这里的将所有的<code>logger</code>进行了更新。</p>
]]></content>
      <categories>
        <category>srping</category>
      </categories>
  </entry>
  <entry>
    <title>KubeSphere入门</title>
    <url>/2024/07/29/k8s/KubeSphere%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="KubeSphere入门"><a href="#KubeSphere入门" class="headerlink" title="KubeSphere入门"></a>KubeSphere入门</h1><p>全栈的 Kubernetes 容器云 PaaS 解决方案：<a href="https://kubesphere.io/zh/">https://kubesphere.io/zh/</a></p>
<p>KubeSphere 是在 Kubernetes 之上构建的以应用为中心的多租户容器平台，提供全栈的 IT 自动化运维的能力，简化企业的 DevOps 工作流。KubeSphere 提供了运维友好的向导式操作界面，帮助企业快速构建一个强大和功能丰富的容器云平台。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>KubeSphere有两种安装模式：</p>
<ul>
<li>在已有的<code>k8s</code>环境中安装</li>
<li>在<code>linux</code>环境中安装</li>
</ul>
<p>其实<code>KubeSphere</code>的安装已经做的很简便了，不管是使用那种方式进行安装，都是开箱即用，通过简单的几个命令就可以安装成功。</p>
<h3 id="在已有的k8s环境中安装"><a href="#在已有的k8s环境中安装" class="headerlink" title="在已有的k8s环境中安装"></a>在已有的k8s环境中安装</h3><p>前置环境：<a href="https://kubesphere.io/zh/docs/v3.4/quick-start/minimal-kubesphere-on-k8s/">https://kubesphere.io/zh/docs/v3.4/quick-start/minimal-kubesphere-on-k8s/</a></p>
<ul>
<li>在安装之前，需要配置 Kubernetes 集群中的<strong>默认</strong>存储类型。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有机器执行</span></span><br><span class="line">yum install -y nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在 mster 机器执行：nfs主节点，rw 读写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot;</span> &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind --now</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置生效</span></span><br><span class="line">exportfs -r</span><br></pre></td></tr></table></figure>

<p>从节点配置加入到这个存储NFS中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查，下面的 IP 是master IP</span></span><br><span class="line">showmount -e 192.168.27.251</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器 执行，执行以下命令挂载 nfs 服务器上的共享目录到本机路径 /root/nfsmount</span></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2 个从服务器执行，将远程 和本地的 文件夹 挂载</span></span><br><span class="line">mount -t nfs 192.168.27.251:/nfs/data /nfs/data</span><br></pre></td></tr></table></figure>

<p>配置默认存储，使其支持动态供应能力。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建了一个存储类</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-storage</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">storageclass.kubernetes.io/is-default-class:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">archiveOnDelete:</span> <span class="string">&quot;true&quot;</span>  <span class="comment">## 删除pv的时候，pv的内容是否要备份</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/nfs-subdir-external-provisioner:v4.0.2</span></span><br><span class="line">          <span class="comment"># resources:</span></span><br><span class="line">          <span class="comment">#    limits:</span></span><br><span class="line">          <span class="comment">#      cpu: 10m</span></span><br><span class="line">          <span class="comment">#    requests:</span></span><br><span class="line">          <span class="comment">#      cpu: 10m</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/persistentvolumes</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PROVISIONER_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">k8s-sigs.io/nfs-subdir-external-provisioner</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_SERVER</span></span><br><span class="line">              <span class="attr">value:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span> <span class="comment">## 指定自己nfs服务器地址</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NFS_PATH</span>  </span><br><span class="line">              <span class="attr">value:</span> <span class="string">/nfs/data</span>  <span class="comment">## nfs服务器共享的目录</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-client-root</span></span><br><span class="line">          <span class="attr">nfs:</span></span><br><span class="line">            <span class="attr">server:</span> <span class="number">172.31</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/nfs/data</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;persistentvolumeclaims&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;storage.k8s.io&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;storageclasses&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;events&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">run-nfs-client-provisioner</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-client-provisioner-runner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;endpoints&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nfs-client-provisioner</span></span><br><span class="line">    <span class="comment"># replace with namespace where provisioner is deployed</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">leader-locking-nfs-client-provisioner</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>集群监控组件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-admin:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-edit:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">rbac.authorization.k8s.io/aggregate-to-view:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:aggregated-metrics-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes/stats</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server-auth-reader</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">extension-apiserver-authentication-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server:system:auth-delegator</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:auth-delegator</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:metrics-server</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--cert-dir=/tmp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-insecure-tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--secure-port=4443</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--kubelet-use-node-status-port</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/metrics-server:v0.4.3</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/livez</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">https</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">4443</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/readyz</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">https</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">tmp-dir</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">metrics-server</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">name:</span> <span class="string">tmp-dir</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">metrics-server</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">v1beta1.metrics.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">metrics.k8s.io</span></span><br><span class="line">  <span class="attr">groupPriorityMinimum:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">insecureSkipTLSVerify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">metrics-server</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line">  <span class="attr">versionPriority:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>确保您的机器满足安装的前提条件之后，可以按照以下步骤安装 KubeSphere。</p>
<ol>
<li><p>执行以下命令开始安装：(可以先把这两个文件通过wget下载下来，然后在通过kubectl执行)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.4.1/kubesphere-installer.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置文件可以控制开启一些可插拔的功能 </span></span><br><span class="line"><span class="comment"># https://kubesphere.io/zh/docs/v3.4/pluggable-components/</span></span><br><span class="line">kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.4.1/cluster-configuration.yaml</span><br></pre></td></tr></table></figure></li>
<li><p>检查安装日志：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>kubectl get pod --all-namespaces</code> 查看所有 Pod 是否在 KubeSphere 的相关命名空间中正常运行。如果是，请通过以下命令检查控制台的端口（默认为 <code>30880</code>）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl get svc/ks-console -n kubesphere-system</span><br></pre></td></tr></table></figure></li>
<li><p>确保在安全组中打开了端口 <code>30880</code>，并通过 NodePort <code>(IP:30880)</code> 使用默认帐户和密码 <code>(admin/P@88w0rd)</code> 访问 Web 控制台。</p>
</li>
<li><p>登录控制台后，您可以在<strong>系统组件</strong>中检查不同组件的状态。如果要使用相关服务，可能需要等待某些组件启动并运行。</p>
</li>
</ol>
<p><b>解决etcd监控证书找不到问题</b></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl -n kubesphere-monitoring-system create secret generic kube-etcd-client-certs  --from-file=etcd-client-ca.crt=/etc/kubernetes/pki/etcd/ca.crt  --from-file=etcd-client.crt=/etc/kubernetes/pki/apiserver-etcd-client.crt  --from-file=etcd-client.key=/etc/kubernetes/pki/apiserver-etcd-client.key</span><br></pre></td></tr></table></figure>

<h3 id="在linux环境中安装"><a href="#在linux环境中安装" class="headerlink" title="在linux环境中安装"></a>在linux环境中安装</h3><h4 id="设置服务器名"><a href="#设置服务器名" class="headerlink" title="设置服务器名"></a>设置服务器名</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@kubeshpere-master ~]<span class="comment"># hostnamectl set-hostname master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@kubeshpere-node ~]<span class="comment"># hostnamectl set-hostname node</span></span><br></pre></td></tr></table></figure>

<h4 id="下载KubeKey"><a href="#下载KubeKey" class="headerlink" title="下载KubeKey"></a>下载KubeKey</h4><p>只需要在<code>master</code>节点执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KKZONE=cn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v1.1.1 sh -</span><br><span class="line"></span><br><span class="line">chmod +x kk</span><br></pre></td></tr></table></figure>

<h4 id="创建集群配置文件"><a href="#创建集群配置文件" class="headerlink" title="创建集群配置文件"></a>创建集群配置文件</h4><p>使用<code>kk</code>工具创建集群的配置文件，执行之后会生成一个<code>config-sample.yaml</code>配置文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ./kk create config --with-kubernetes v1.20.4 --with-kubesphere v3.1.1</span></span><br><span class="line">[root@master ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg  config-sample.yaml  kk  kubekey-v1.1.1-linux-amd64.tar.gz  original-ks.cfg  README.md  README_zh-CN.md</span><br></pre></td></tr></table></figure>

<p>修改配置文件中的集群信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubekey.kubesphere.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="comment"># 集群的相关信息</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">master</span>, <span class="attr">address:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.17</span>, <span class="attr">internalAddress:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.17</span>, <span class="attr">user:</span> <span class="string">root</span>, <span class="attr">password:</span> <span class="string">jjm7560808</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">node</span>, <span class="attr">address:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.18</span>, <span class="attr">internalAddress:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.18</span>, <span class="attr">user:</span> <span class="string">root</span>, <span class="attr">password:</span> <span class="string">jjm7560808</span>&#125;</span><br><span class="line">  <span class="attr">roleGroups:</span></span><br><span class="line">    <span class="attr">etcd:</span> <span class="comment"># etcd放在那台机器上</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">master:</span> <span class="comment"># 主节点是那台机器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">worker:</span> <span class="comment"># 工作节点是那台机器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># 主节点也作为工作节点</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node</span></span><br><span class="line">  <span class="attr">controlPlaneEndpoint:</span></span><br><span class="line">    <span class="attr">domain:</span> <span class="string">lb.kubesphere.local</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6443</span></span><br><span class="line">  <span class="attr">kubernetes:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.20.4</span></span><br><span class="line">    <span class="attr">imageRepo:</span> <span class="string">kubesphere</span></span><br><span class="line">    <span class="attr">clusterName:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">network:</span></span><br><span class="line">    <span class="attr">plugin:</span> <span class="string">calico</span></span><br><span class="line">    <span class="attr">kubePodsCIDR:</span> <span class="number">10.233</span><span class="number">.64</span><span class="number">.0</span><span class="string">/18</span></span><br><span class="line">    <span class="attr">kubeServiceCIDR:</span> <span class="number">10.233</span><span class="number">.0</span><span class="number">.0</span><span class="string">/18</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">registryMirrors:</span> []</span><br><span class="line">    <span class="attr">insecureRegistries:</span> []</span><br><span class="line">  <span class="attr">addons:</span> []</span><br></pre></td></tr></table></figure>

<h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ./kk create cluster -f config-sample.yaml</span></span><br><span class="line">+--------+------+------+---------+----------+-------+-------+-----------+--------+------------+-------------+------------------+--------------+</span><br><span class="line">| name   | sudo | curl | openssl | ebtables | socat | ipset | conntrack | docker | nfs client | ceph client | glusterfs client | time         |</span><br><span class="line">+--------+------+------+---------+----------+-------+-------+-----------+--------+------------+-------------+------------------+--------------+</span><br><span class="line">| node   | y    | y    | y       | y        |       | y     |           |        |            |             |                  | CST 22:52:17 |</span><br><span class="line">| master | y    | y    | y       | y        |       | y     |           |        | y          |             | y                | CST 20:07:22 |</span><br><span class="line">+--------+------+------+---------+----------+-------+-------+-----------+--------+------------+-------------+------------------+--------------+</span><br><span class="line">node: conntrack is required. </span><br><span class="line">master: conntrack is required. </span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行之后它会检查每个机器上是否有一些必须安装的项没有安装</span></span><br><span class="line">[root@master ~]<span class="comment"># yum install -y conntrack</span></span><br></pre></td></tr></table></figure>

<p><b>我在安装的时候出现的问题：</b></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Please, check the contents of the <span class="variable">$HOME</span>/.kube/config file.</span><br><span class="line">ERRO[20:36:11 CST] Failed to add worker to cluster: Failed to <span class="built_in">exec</span> <span class="built_in">command</span>: sudo env PATH=<span class="variable">$PATH</span> /bin/sh -c <span class="string">&quot;/usr/local/bin/kubeadm join  lb.kubesphere.local:6443 --token cizh27.yysycm95alsr418r     --discovery-token-ca-cert-hash sha256:babe3bc05ea57c183e800628d06c42587cc6425822eea5db652b3c28312f944b&quot;</span> </span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING FileExisting-socat]: socat not found <span class="keyword">in</span> system path</span><br><span class="line">        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 26.1.4. Latest validated version: 19.03</span><br><span class="line">error execution phase preflight: couldn<span class="string">&#x27;t validate the identity of the API Server: Get &quot;https://lb.kubesphere.local:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s&quot;: x509: certificate has expired or is not yet valid: current time 2024-08-06T23:23:26+08:00 is before 2024-08-07T12:20:40Z</span></span><br><span class="line"><span class="string">To see the stack trace of this error execute with --v=5 or higher: Process exited with status 1  node=10.211.55.18</span></span><br><span class="line"><span class="string">WARN[20:36:11 CST] Task failed ...                              </span></span><br><span class="line"><span class="string">WARN[20:36:11 CST] error: interrupted by error                  </span></span><br><span class="line"><span class="string">Error: Failed to join node: interrupted by error</span></span><br></pre></td></tr></table></figure>

<p>找了很多资料都没有找到怎么解决，根据之前逐个安装的经验，感觉是因为<code>calico</code>安装的问题。但是我没有去尝试机器中先安装<code>calico</code>再安装一次，而是跟换了版本，我直接升级到最高版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除旧版</span></span><br><span class="line">./kk create cluster -f config-sample.yaml</span><br><span class="line"></span><br><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.13 sh -</span><br><span class="line"></span><br><span class="line">./kk create config --with-kubesphere v3.4.1 --with-kubernetes v1.22.12</span><br><span class="line"></span><br><span class="line">./kk create cluster -f config-sample.yaml</span><br></pre></td></tr></table></figure>

<p>尝试最新版之后本以为会一切顺利，没想到在安装后卡在：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Please <span class="built_in">wait</span> <span class="keyword">for</span> the installation to complete:     &lt;---&lt;&lt; </span><br></pre></td></tr></table></figure>

<p>退出进程后，查看集群Pod的状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master docker]<span class="comment"># kubectl get pods -A</span></span><br><span class="line">NAMESPACE                      NAME                                             READY   STATUS              RESTARTS        AGE</span><br><span class="line">kube-system                    calico-kube-controllers-5d5bbb5dc-5qpg5          1/1     Running             0               78m</span><br><span class="line">kube-system                    calico-node-b28p6                                1/1     Running             0               78m</span><br><span class="line">kube-system                    calico-node-kslgp                                1/1     Running             2 (6m11s ago)   78m</span><br><span class="line">kube-system                    coredns-5495dd7c88-czhp4                         1/1     Running             0               78m</span><br><span class="line">kube-system                    coredns-5495dd7c88-jdk5j                         1/1     Running             0               78m</span><br><span class="line">kube-system                    kube-apiserver-master                            1/1     Running             2 (6m1s ago)    78m</span><br><span class="line">kube-system                    kube-controller-manager-master                   1/1     Running             7 (6m11s ago)   78m</span><br><span class="line">kube-system                    kube-proxy-2zgvn                                 1/1     Running             2 (6m11s ago)   78m</span><br><span class="line">kube-system                    kube-proxy-jhdpm                                 1/1     Running             0               78m</span><br><span class="line">kube-system                    kube-scheduler-master                            1/1     Running             7 (6m11s ago)   78m</span><br><span class="line">kube-system                    nodelocaldns-2h8bc                               1/1     Running             0               78m</span><br><span class="line">kube-system                    nodelocaldns-bwkwf                               1/1     Running             2 (6m10s ago)   78m</span><br><span class="line">kube-system                    openebs-localpv-provisioner-58d9ff469c-j94fg     1/1     Running             6 (6m ago)      78m</span><br><span class="line">kube-system                    snapshot-controller-0                            0/1     ErrImagePull        0               76m</span><br><span class="line">kubesphere-controls-system     default-http-backend-5bf68ff9b8-l4qwm            0/1     ErrImagePull        0               74m</span><br><span class="line">kubesphere-monitoring-system   kube-state-metrics-554c8c5d65-bthnt              0/3     ErrImagePull        0               68m</span><br><span class="line">kubesphere-monitoring-system   node-exporter-l8245                              0/2     ErrImagePull        0               68m</span><br><span class="line">kubesphere-monitoring-system   node-exporter-vxcqg                              0/2     ContainerCreating   0               68m</span><br><span class="line">kubesphere-monitoring-system   notification-manager-operator-8694799c76-l6zkf   0/2     ContainerCreating   0               63m</span><br><span class="line">kubesphere-monitoring-system   prometheus-operator-8955bbd98-84fml              0/2     ErrImagePull        0               68m</span><br><span class="line">kubesphere-system              ks-apiserver-7fd66f7885-dfsrm                    0/1     ContainerCreating   0               74m</span><br><span class="line">kubesphere-system              ks-console-85c97b6d7d-d4g7w                      0/1     ErrImagePull        0               74m</span><br><span class="line">kubesphere-system              ks-controller-manager-798444f496-gqk2w           0/1     ImagePullBackOff    0               74m</span><br><span class="line">kubesphere-system              ks-installer-5594ffc86d-kl8g6                    1/1     Running             0               78m</span><br></pre></td></tr></table></figure>

<p>发现好多的容器状态不对，通过<code>describe</code>命令查看状态：看状态像是容器拉取失败，所以尝试修改了对<code>docker</code>配置文件进行修改，添加阿里云的镜像加速。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master docker]<span class="comment"># kubectl describe pod -n kubesphere-monitoring-system node-exporter-vxcqg</span></span><br><span class="line"></span><br><span class="line">  Warning  Failed          26m                kubelet            Failed to pull image <span class="string">&quot;kubesphere/kube-rbac-proxy:v0.11.0&quot;</span>: rpc error: code = Unknown desc = error pulling image configuration: download failed after attempts=6: dial tcp 111.243.214.169:443: i/o timeout</span><br><span class="line">  Warning  Failed          26m (x3 over 62m)  kubelet            Error: ErrImagePull</span><br><span class="line">  Normal   Pulling         26m (x4 over 69m)  kubelet            Pulling image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span></span><br><span class="line">  Warning  Failed          17m (x4 over 66m)  kubelet            Error: ErrImagePull</span><br><span class="line">  Warning  Failed          17m (x2 over 56m)  kubelet            Failed to pull image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span>: rpc error: code = Unknown desc = context canceled</span><br><span class="line">  Normal   Pulling         17m (x4 over 66m)  kubelet            Pulling image <span class="string">&quot;kubesphere/kube-rbac-proxy:v0.11.0&quot;</span></span><br><span class="line">  Normal   SandboxChanged  11m                kubelet            Pod sandbox changed, it will be killed and re-created.</span><br><span class="line">  Normal   Pulling         11m                kubelet            Pulling image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span></span><br><span class="line">  Warning  Failed          8m55s              kubelet            Failed to pull image <span class="string">&quot;prom/node-exporter:v1.3.1&quot;</span>: rpc error: code = Unknown desc = error pulling image configuration: download failed after attempts=6: dial tcp 128.121.243.228:443: i/o timeout</span><br><span class="line">  Warning  Failed          8m55s              kubelet            Error: ErrImagePull</span><br><span class="line">  Normal   Pulling         8m55s              kubelet            Pulling image <span class="string">&quot;kubesphere/kube-rbac-proxy:v0.11.0&quot;</span></span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo的Spi机制</title>
    <url>/2024/09/21/Springboot/dubbo%E7%9A%84spi%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="dubbo的Spi机制"><a href="#dubbo的Spi机制" class="headerlink" title="dubbo的Spi机制"></a>dubbo的Spi机制</h1><p>结合之前说到的<a href="https://xiaocainiaoya.github.io/2023/04/10/Springboot/springboot%E7%9A%84Spi%E6%9C%BA%E5%88%B6/" target="_blank">springboot的Spi机制</a>本篇将简单介绍一下<code>Doubbo</code>的SPI机制，<code>Dobbo</code>没有使用<code>jdk</code>的这套<code>SPI</code>机制，而是自己实现了一套，提供了一些更灵活、更易于使用的方式。</p>
<span id="more"></span>

<p>​    简单回顾下，SPI全称（Service Provider Interface）是一种服务发现机制，本质上是将接口的实现类的全限定类名写在配置文件中，并由类加载器读取配置文件，这样可以在运行时，动态为接口替换实现类，所以一般用这种方式来为服务提供扩展能力。</p>
<h2 id="JDK的服务发现spi机制"><a href="#JDK的服务发现spi机制" class="headerlink" title="JDK的服务发现spi机制"></a>JDK的服务发现spi机制</h2><p>JDK 的 SPI 规范规定：</p>
<ul>
<li><code>接口名</code>：可随意定义</li>
<li><code>实现类名</code>：可随意定义</li>
<li><code>提供者配置文件路径</code>： 其查找的目录为 META-INF/services</li>
<li><code>提供者配置文件名称</code>：接口的全限定性类名，没有扩展名。</li>
<li><code>提供者配置文件内容</code>：该接口的所有实现类的全限类性类名写入到该文件中，一个类名占一行</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建配置文件（META-INF/services/cn.com.xiaocainiaoya.spi.jdk.CarService），然后在配置文件中配置接口的实现类的全限定类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cn.com.xiaocainiaoya.spi.jdk.ElectricCarServiceImpl</span><br><span class="line">cn.com.xiaocainiaoya.spi.jdk.TankCarServiceImpl</span><br></pre></td></tr></table></figure>

<p>模拟客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ServiceLoader.load()方法获取到配置文件中的实现类</span></span><br><span class="line">        ServiceLoader&lt;CarService&gt; loader = ServiceLoader.load(CarService.class);</span><br><span class="line">        Iterator&lt;CarService&gt; it = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            CarService service = it.next();</span><br><span class="line">            service.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElectricCarServiceImpl run</span><br><span class="line">TankCarServiceImpl run</span><br></pre></td></tr></table></figure>

<p>这种方式有几个问题：</p>
<ul>
<li>获取实现类的方式不够灵活，只能通过<code>loader.iterator()</code>迭代器的方式来获取实现类，然后遍历判定当前要使用的实现类，假设说可以以键值对的方式来获取实现类，那么可以增加一定的便利。</li>
<li>不能按需加载，比如某个接口在配置文件中配置的实现类有很多，但是实际在运行过程中只需要其中的小几个，虽然ServiceLoader做了延迟载入，但是获取实现类的手段只能通过遍历来获取，基本上实现类都得加载并实例化。</li>
<li>ServiceLoader类的实例是线程不安全。</li>
</ul>
<h2 id="Dubbo的服务发现机制SPI"><a href="#Dubbo的服务发现机制SPI" class="headerlink" title="Dubbo的服务发现机制SPI"></a>Dubbo的服务发现机制SPI</h2><p>Dobbo没有使用<code>Java</code>的这套SPI机制，而是自己实现了一套功能更加强大的SPI机制，Dubbo的SPI是通过<code>ExtensionLoader</code>类来进行实现类加载。</p>
<p>先来简单理解一下Dubbo这套SPI机制中的一些概念：</p>
<p><b>接口名：</b>可以随意定义，但接口必须被<code>@SPI 注解修饰</code></p>
<p><b>实现类名：</b> 在接口名前添加一个用于表示自身功能的“标识前辍”字符串</p>
<p><b>提供者配置文件路径：</b>在依次查找的目录为</p>
<ul>
<li>META-INF/dubbo/internal</li>
<li>META-INF/dubbo</li>
<li>META-INF/services</li>
</ul>
<p><b>提供者配置文件名称：</b>接口的全限定性类名，无需扩展名</p>
<p><b>提供者配置文件内容：</b> 文件的内容为 <code>key=value 形式</code>， value 为该接口的实现类的全限类性类名， key 可以随意，但一般为该实现类的“标识前辍”（首字母小写）。一个类名占一行。</p>
<p><b>提供者加载： </b>ExtensionLoader 类相当于 JDK SPI 中的 ServiceLoader 类，用于加载提供者配置文件中所有的实现类，并创建相应的实例。</p>
<p>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接使用 setter() 方法注入其他扩展点 ，也可 以对扩展点使用 Wrapper 类进行功能增强。</p>
<p><b>一些名词解释：</b></p>
<ul>
<li>普通扩展类：就是接口的具体的实现类（对应JDK的SPI中的具体的实现类）</li>
<li>Adaptive类：自适应扩展类，就是类似于在普通扩展类上再包一层，客户端获取到这个自适应扩展类，通过这个扩展类调用定义的扩展接口，它会根据一定的规则（自适应扩展类的接口的参数需要有com.alibaba.dubbo.common.URL）来路由到对应的实现类中。</li>
<li>Wrapper类：包装类，对普通扩展类的包装机制，可以对扩展类的SPI接口方法进行增强，一个SPI可以包含多个Wrapper。</li>
<li>Activate类：激活类，激活扩展类，可以通过指定的条件来一下子把需要的扩展类激活（因为Dubbo这套机制是按需加载，也就使用到时再进行加载，但是有些场景，可能一下子就要把某一些规则「比如做了分组，要把某个组的类一下子都加载」的类进行加载）</li>
</ul>
<h3 id="普通扩展类"><a href="#普通扩展类" class="headerlink" title="普通扩展类"></a>普通扩展类</h3><p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;car&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>META-INF/services/cn.com.xiaocainiaoya.spi.dubbo.CarService</code>文件，并添加配置:</p>
<p><b>注：</b>这里与<code>JDK</code>的SPI稍有不同，这是是自定为每个接口实现定义了一个key。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">electric</span>=<span class="string">cn.com.xiaocainiaoya.spi.dubbo.ElectricCarServiceImpl</span></span><br><span class="line"><span class="attr">tank</span>=<span class="string">cn.com.xiaocainiaoya.spi.dubbo.TankCarServiceImpl</span></span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到用于加载Order类型扩展类实例的extensionLoader实例</span></span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        <span class="comment">// 这里只会获取到electric这个key指向的实例，它也只会加载这个实例，达到了按需加载的效果</span></span><br><span class="line">        CarService car = loader.getExtension(<span class="string">&quot;electric&quot;</span>);</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自适应扩展类Adaptive"><a href="#自适应扩展类Adaptive" class="headerlink" title="自适应扩展类Adaptive"></a>自适应扩展类Adaptive</h3><p>自适应扩展<code>@Adaptive</code>注解可以标记在类上，也可以标记在方法上。</p>
<h4 id="1-标记在类上"><a href="#1-标记在类上" class="headerlink" title="1.标记在类上"></a>1.标记在类上</h4><p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记在类上</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String defaultName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定要加载扩展类的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">(String defaultName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = defaultName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        CarService carService;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(defaultName)) &#123;</span><br><span class="line">            <span class="comment">// 加载SPI默认名称的扩展类</span></span><br><span class="line">            carService = loader.getDefaultExtension();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加载指定名称的扩展类</span></span><br><span class="line">            carService = loader.getExtension(defaultName);</span><br><span class="line">        &#125;</span><br><span class="line">        carService.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<p>注意一个<code>@SPI</code>接口只能有一个标记<code>@Adaptive</code>在类上的实现，所以在有这个要求的情况下，这个类的在下面配置文件中的<code>key</code>就显得无关紧要，这里是叫<code>adaptive</code>，你可以叫其他名字。</p>
<p>那么假设某个接口有两个标记了<code>@Adaptive</code>类，并且两个类都写在了下方的配置文件中会怎么样？</p>
<p>在<code>ExtensionLoader#loadFile()</code>方法中逐行扫描这些配置文件时，会发现某个<code>@SPI</code>接口有两个<code>@Adaptive</code>的实现类，后一个扫描到时会中断，之后它的做法是把异常信息保存在<code>Map&lt;String, IllegalStateException&gt; exceptions</code>，并不会使得程序都中断。也就是说假设有两个<code>@Apdative</code>的情况下，最终加载的是靠前的那个实现。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">electric</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.ElectricCarServiceImpl</span><br><span class="line"><span class="attr">tank</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.TankCarServiceImpl</span><br><span class="line"><span class="attr">adaptive</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.AdaptiveCarServiceImpl</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        CarService carService = loader.getAdaptiveExtension();</span><br><span class="line">        ((AdaptiveCarServiceImpl)carService).setDefaultName(<span class="string">&quot;tank&quot;</span>);</span><br><span class="line">        carService.display();</span><br><span class="line">        <span class="comment">// 这里要注意，自适应扩展类不属于直接扩展类!!!!</span></span><br><span class="line">        Set&lt;String&gt; supportedExtensions = loader.getSupportedExtensions();</span><br><span class="line">        System.out.println(supportedExtensions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">TankCarServiceImpl display</span><br><span class="line">[electric, tank]</span><br></pre></td></tr></table></figure>

<h4 id="2-标记在方法上"><a href="#2-标记在方法上" class="headerlink" title="2.标记在方法上"></a>2.标记在方法上</h4><p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>@Adaptive</code>标记在方法上时，会通过<code>javassist</code>为该接口生成一个动态类<code>CarService$Adaptive</code>，这个自动生成的代理类的主要作用是根据<code>URL</code>这个类来传入路由规则，使得此类可以根据这个路由规则，找到具体的实现类。(这个类是动态生成的，这就导致了不能通过IDE打断点之类的方式进行调试)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.com.xiaocainiaoya.spi.dubbo.adaptive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarService</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">cn</span>.<span class="title">com</span>.<span class="title">xiaocainiaoya</span>.<span class="title">spi</span>.<span class="title">dubbo</span>.<span class="title">adaptive</span>.<span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;method public abstract void cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.CarService.display() of interface cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService is not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;car.service&quot;</span>, <span class="string">&quot;electric&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension(cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;.CarService) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([car.service])&quot;</span>);</span><br><span class="line">        cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService extension = (cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService) </span><br><span class="line">                ExtensionLoader.getExtensionLoader(cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService.class).getExtension(extName);</span><br><span class="line">        extension.run(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到用于加载Order类型扩展类实例的extensionLoader实例</span></span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        <span class="comment">// 获取自适应扩展类，它是一个代理类</span></span><br><span class="line">        CarService car = loader.getAdaptiveExtension();</span><br><span class="line">        <span class="comment">// 不传参数，它会去查找@SPI(&quot;car&quot;) 注解，获取默认值</span></span><br><span class="line">        URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        car.run(url);</span><br><span class="line">        <span class="comment">// 传参，注意这里的参数名要和@SPI的接口名把驼峰转换为点号分隔作为参数名</span></span><br><span class="line">        URL url2 = URL.valueOf(<span class="string">&quot;xxx?car.service=tank&quot;</span>);</span><br><span class="line">        car.run(url2);</span><br><span class="line">        <span class="comment">// 这里是不能调用display方法，它不是自适应扩展类的方法，根据动态生成的类CarService$Adaptive可以看出来，</span></span><br><span class="line">        <span class="comment">// display方法的实现里直接抛出了UnsupportedOperationException异常</span></span><br><span class="line">        car.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">ElectricCarServiceImpl run</span><br><span class="line">TankCarServiceImpl run</span><br></pre></td></tr></table></figure>

<h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h4><p>​    对比两种对于<code>@Adaptive</code>标记的位置的不同，可以发现，其实标记在类上，就是需要自己去实现路由规则，由自己来控制怎么找到自己需要的实现类；标记在接口上，是<code>Dubbo</code>通过做了一层高度抽象，配合<code>URL</code>类和根据<code>javassist</code>动态生成自适应扩展类，来路由到具体需要使用到的实现类。</p>
<h3 id="包装机制Wrapper"><a href="#包装机制Wrapper" class="headerlink" title="包装机制Wrapper"></a>包装机制Wrapper</h3><p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarServiceWrapper</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarService carService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarServiceWrapper</span><span class="params">(CarService carService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carService = carService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper display before&quot;</span>);</span><br><span class="line">        carService.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper display after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper run before&quot;</span>);</span><br><span class="line">        carService.run(url);</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper run after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarServiceWrapper2</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CarService carService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarServiceWrapper2</span><span class="params">(CarService carService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carService = carService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 display before&quot;</span>);</span><br><span class="line">        carService.display();</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 display after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 run before&quot;</span>);</span><br><span class="line">        carService.run(url);</span><br><span class="line">        System.out.println(<span class="string">&quot;CarServiceWrapper2 run after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">electric</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.ElectricCarServiceImpl</span><br><span class="line"><span class="attr">tank</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.TankCarServiceImpl</span><br><span class="line"><span class="attr">wrapper</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarServiceWrapper</span><br><span class="line"><span class="attr">wrapper2</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarServiceWrapper2</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到用于加载Order类型扩展类实例的extensionLoader实例</span></span><br><span class="line">        ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">        <span class="comment">// 获取自适应扩展类，它是一个代理类</span></span><br><span class="line">        CarService car = loader.getAdaptiveExtension();</span><br><span class="line">        <span class="comment">// 不传参数，它会去查找@SPI(&quot;car&quot;) 注解，获取默认值</span></span><br><span class="line">        URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        car.run(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">CarServiceWrapper2 run before</span><br><span class="line">CarServiceWrapper run before</span><br><span class="line">ElectricCarServiceImpl run</span><br><span class="line">CarServiceWrapper run after</span><br><span class="line">CarServiceWrapper2 run after</span><br></pre></td></tr></table></figure>

<h3 id="激活机制Activate"><a href="#激活机制Activate" class="headerlink" title="激活机制Activate"></a>激活机制Activate</h3><p>用于直接激活扩展类，通过一定的规则（分组）等方式，一下子激活符合条件的扩展类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Activate &#123;</span><br><span class="line"></span><br><span class="line">    String[] group() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] before() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] after() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>before()</code>和<code>after()</code>已经过时。</p>
<ul>
<li>group：分组名称，根据组名称来激活一些类（是一个大范围，指定到一个集体）</li>
<li>value：指定一个名称，可以不根据分组，直接根据名称来激活（一个小范围，直接指定到个体）</li>
<li>order：排序号，序号越小，优先级越高，默认值为0。</li>
</ul>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;electric&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<p>3个具体实现类，其中<code>HybridCarServiceImpl</code>既属于<code>tankGroup</code>，也属于<code>electricGroup</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &quot;electricGroup&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ElectricCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate(group = &#123;&quot;tankGroup&quot;, &quot;electricGroup&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HybridCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HybridCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HybridCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Activate(group = &quot;tankGroup&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">CarService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TankCarServiceImpl run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">electric</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.ElectricCarServiceImpl</span><br><span class="line"><span class="attr">tank</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.TankCarServiceImpl</span><br><span class="line"><span class="attr">hybrid</span>=cn.com.xiaocainiaoya.spi.dubbo.adaptive.HybridCarServiceImpl</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">    URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活整个组，返回整个组的实现类列表</span></span><br><span class="line">    List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活整个组，但是只会返回第二个参数指定的实现类</span></span><br><span class="line">    List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;tank&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 激活整个组，但是只会返回URL对象中的参数key的实现类</span></span><br><span class="line">    URL url = URL.valueOf(<span class="string">&quot;xxx?tank=true&quot;</span>);</span><br><span class="line">    List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 综上：其实不论是为了获取那些实现类，实际上都是激活了（加载了）整个组的实现类 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (CarService carService : tankServices) &#123;</span><br><span class="line">        carService.run(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">TankCarServiceImpl run</span><br><span class="line">HybridCarServiceImpl run</span><br></pre></td></tr></table></figure>

<p><b>注：</b>我在<code>@Activate</code>中只有指定了<code>group</code>值，并没有指定<code>value</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经过我的测试，如果我的@Activate是这样声明：</span></span><br><span class="line"><span class="meta">@Activate(group = &quot;tankGroup&quot;, value = &quot;tank&quot;)</span></span><br><span class="line"><span class="meta">@Activate(group = &#123;&quot;tankGroup&quot;, &quot;electricGroup&quot;&#125;, value = &quot;hybrid&quot;)</span></span><br><span class="line"><span class="meta">@Activate(group = &quot;electricGroup&quot; , value = &quot;electric&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行后输出的结果是空的，是一个实现类都获取不到的，我看有些博客是说这个语句的后两个参数是或的关系</span></span><br><span class="line"><span class="comment">// 经过我的测试，并不是这样。我的dobbo版本是2.6.0。</span></span><br><span class="line">List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这种方式获取tankGroup中value值为tank的实现类</span></span><br><span class="line">URL url = URL.valueOf(<span class="string">&quot;xxx?service.car=tank&quot;</span>);</span><br><span class="line">List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;service.car&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h2><p>根据前面提到的特性，我们需要通过一个类，来自动查找具体实现类，这个类就是<code>ExtensionLoader</code>（在<code>jdk</code>中是通过<code>ServiceLoader</code>）。</p>
<p>这是一个静态方法，通过这个方法获取<code>ExtensionLoader</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExtensionLoader&lt;Car&gt; loader = ExtensionLoader.getExtensionLoader(Car.class);</span><br></pre></td></tr></table></figure>

<p>先从缓存中获取，如果获取不到，则创建一个新的<code>ExtensionLoader</code>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EXTENSION_LOADERS中获取，如果获取不到则创建一个</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下这个类的构建函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前加载类的类型</span></span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="comment">// 判断当前需要创建的类是不是ExtensionFactory类型，ExtensionFactory是dubbo内置的一个@SPI接口</span></span><br><span class="line">    <span class="comment">// 它的具体实现类有SpiExtensionFactory和SpringExtensionFactory，它的自适应扩展类是AdaptiveExtensionFactory（@Adaptive标记在类上）</span></span><br><span class="line">    <span class="comment">// 看下这个语句，如果type不是ExtensionFactory，那么ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</span></span><br><span class="line">    <span class="comment">// 也就是，除了它自己，其他类型的ExtensionLoader实例的objectFactory(对象创建工厂)都是ExtensionFactory这个类的自适应扩展类</span></span><br><span class="line">    objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ExtensionFactory</code>的两个实现：从以下可以看出，这是为了兼容<code>spring</code>，加载具体实现类可以从<code>spring</code>上下文中获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; contexts = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从spring容器中获取bean</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(name)) &#123;</span><br><span class="line">                Object bean = context.getBean(name);</span><br><span class="line">                <span class="keyword">if</span> (type.isInstance(bean)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) bean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到<code>ExtensionLoader</code>实例之后，就可以执行上文中介绍的一些特性功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接获取对应key指向的实现类</span></span><br><span class="line">CarService car = loader.getExtension(<span class="string">&quot;electric&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自适应扩展类，通过自适应扩展类来路由到具体实现类的具体方法</span></span><br><span class="line">CarService car = loader.getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接激活所有符合条件的扩展类</span></span><br><span class="line">loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>具体实现类的获取过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="comment">// 这个实际不用管，其实就是直接读默认的实现</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检测锁用来防止并发冲突，在ExtensionLoader中大量使用</span></span><br><span class="line">    Object instance = holder.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建实现类</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getExtensionClasses()主要的作用是从配置中获取到@SPI标记的那个接口的实现类，并将相关信息(全限定类名)进行缓存</span></span><br><span class="line">    <span class="comment">// 将需要使用到的类进行加载并返回到这里</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在，则加入缓存中</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对这个实现进行注入</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 获取到包装类的缓存</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; wrapperClasses.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 对这个实现进行包装，获取到包装类以当前类型为参数的构造函数，然后调用newInstance创建实例（包装类必须为@SPI接口的实现）</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终就返回了一个经过注入和经过包装的具体实现类的代理类（如果没有包装，就不是代理类）</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Extension instance(name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;)  could not be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载扩展类"><a href="#加载扩展类" class="headerlink" title="加载扩展类"></a>加载扩展类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">    <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String value = defaultAnnotation.value();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; (value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">            <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;more than 1 default extension name on extension &quot;</span> + type.getName()</span><br><span class="line">                        + <span class="string">&quot;: &quot;</span> + Arrays.toString(names));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// 加载对应路径下的文件内容：META-INF/dubbo/internal、META-INF/dubbo、META-INF/services</span></span><br><span class="line">    loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">    loadFile(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">    loadFile(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">    <span class="comment">// loadFile()方法就不贴了，主要做的事情就是：</span></span><br><span class="line">    <span class="comment">// 1. 是按key=value的方式逐行读取文件内容</span></span><br><span class="line">    <span class="comment">// 2. 如果读取的类标记了@Adaptive，则表示是自适应扩展类，赋值到 cachedAdaptiveClass，并且一个@SPI只能有一个@Adaptive扩展类</span></span><br><span class="line">    <span class="comment">// 3. 如果读取的类标记了@Activate，则表示需要进行自动激活，则加入到 Map&lt;String, Activate&gt; cachedActivates</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展类注入"><a href="#扩展类注入" class="headerlink" title="扩展类注入"></a>扩展类注入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对象工厂不为空，这里在构造函数中创建了ExtensionFactory的自适应扩展类</span></span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="comment">// 1. 方法名需要时set开头 2. 方法需要是public方法 3. 方法参数只有1个参数</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">&quot;set&quot;</span>) &amp;&amp; method.getParameterTypes().length == <span class="number">1</span> &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="comment">// 通过对象工厂获取对象，这里自适应扩展类会使得SpiExtensionFactory和SpringExtensionFactory都执行</span></span><br><span class="line">                        <span class="comment">// 也就是说这里会从spring容器中获取，如果是从SpiExtensionFactory，拿到的是pt的自适应扩展类</span></span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;fail to inject via method &quot;</span> + method.getName()</span><br><span class="line">                                + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自适应扩展类"><a href="#自适应扩展类" class="headerlink" title="自适应扩展类"></a>自适应扩展类</h3><p>首先来看看自适应扩展类的相关源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双重检测锁</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建自适应扩展类</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建自适应扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先获取到自适应扩展类的实例，再为自适应扩展类注入需要的对象</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Can not create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到自适应扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 这个方法其实前面已经介绍过了，如果 cachedClasses 里没有，则会去加载指定目录（META-INF/XXX）</span></span><br><span class="line">    <span class="comment">// 下的配置文件，并将对应的类加载</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 如果 cachedAdaptiveClass 不为空，则表示这个ExtensionLoader实例的自适应扩展类已经加载过了</span></span><br><span class="line">    <span class="comment">// 什么情况到这里会加载过呢？</span></span><br><span class="line">    <span class="comment">// 就是为这个@SPI标记的接口，指定了一个类级的@Adaptive，也就是说将@Adaptive标记在类上</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里就是标记方法级的@Adaptive，这里需要进行动态生成代码并编译</span></span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 创建动态生成的文件字符串，其实就是通过StringBuilder然后各种判断后拼接字符串，创建出一个xxx$Adaptive类的字符串</span></span><br><span class="line">    String code = createAdaptiveExtensionClassCode();</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    <span class="comment">// 使用编译器编译这个类的字符串</span></span><br><span class="line">    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这边测试的时候动态生成的一个自适应扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.com.xiaocainiaoya.spi.dubbo.adaptive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarService</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">cn</span>.<span class="title">com</span>.<span class="title">xiaocainiaoya</span>.<span class="title">spi</span>.<span class="title">dubbo</span>.<span class="title">adaptive</span>.<span class="title">CarService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有标记@Adaptive注解的方法是不允许通过自适应扩展类访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;method public abstract void cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.CarService.display() of interface cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService is not &quot;</span> +</span><br><span class="line">                <span class="string">&quot;adaptive method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被标记@Adaptive注解的方法，通过URL设置了一些参数规则，根据这个参数规则，获取到对应的参数来路由到对应的实现类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;car.service&quot;</span>, <span class="string">&quot;electric&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Fail to get extension(cn.com.xiaocainiaoya.spi.dubbo.adaptive&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;.CarService) name from url(&quot;</span> + url.toString() + <span class="string">&quot;) use keys([car.service])&quot;</span>);</span><br><span class="line">        cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService extension = (cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService) </span><br><span class="line">                ExtensionLoader.getExtensionLoader(cn.com.xiaocainiaoya.spi.dubbo.adaptive.CarService.class).getExtension(extName);</span><br><span class="line">        extension.run(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动激活机制"><a href="#自动激活机制" class="headerlink" title="自动激活机制"></a>自动激活机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExtensionLoader&lt;CarService&gt; loader = ExtensionLoader.getExtensionLoader(CarService.class);</span><br><span class="line">URL url = URL.valueOf(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;CarService&gt; tankServices = loader.getActivateExtension(url, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tankGroup&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (CarService carService : tankServices) &#123;</span><br><span class="line">  carService.run(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取需要自动激活的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String key, String group)</span> </span>&#123;</span><br><span class="line">  String value = url.getParameter(key);</span><br><span class="line">  <span class="keyword">return</span> getActivateExtension(url, value == <span class="keyword">null</span> || value.length() == <span class="number">0</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(value), group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取自动激活的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getActivateExtension</span><span class="params">(URL url, String[] values, String group)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; exts = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    List&lt;String&gt; names = values == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">0</span>) : Arrays.asList(values);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class="line">        <span class="comment">// 加载这个@SPI接口对应的相关信息「去加载META-INF文件夹下的文件」</span></span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">            String name = entry.getKey();</span><br><span class="line">            Activate activate = entry.getValue();</span><br><span class="line">            <span class="comment">// 组是否对应</span></span><br><span class="line">            <span class="keyword">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class="line">                <span class="comment">// 获取对应的扩展类，到这一步其实就已经在加载名为name的这个类了</span></span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                <span class="comment">// 1. 如果当前循环的这个name不落在names中时（因为names是直接指定，优先级比较低，是在下方的那个for循环中加入到exts结果列表中）</span></span><br><span class="line">                <span class="comment">// 2. 如果names中不包含“-name”时（这个目前不太清楚是干嘛用的，可能是有一些特殊的操作判断）</span></span><br><span class="line">                <span class="comment">// 3. isActive()是否符合激活规则（url参数中指定的规则）</span></span><br><span class="line">                <span class="keyword">if</span> (!names.contains(name) &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name) &amp;&amp; isActive(activate, url)) &#123;</span><br><span class="line">                    exts.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; usrs = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="comment">// 用户直接指定的实现，比如这种写法 loader.getActivateExtension(url, new String[]&#123;&quot;tank&quot;, &quot;electric&quot;&#125;); </span></span><br><span class="line">    <span class="comment">// 就是直接激活@Activate中value=tank和value=electric的扩展类</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">        String name = names.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    exts.addAll(<span class="number">0</span>, usrs);</span><br><span class="line">                    usrs.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T ext = getExtension(name);</span><br><span class="line">                usrs.add(ext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (usrs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        exts.addAll(usrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前按我理解：自动激活机制的意思是，会将整个组都激活（加载），但是接口会根据相应的规则来获取对应的扩展类。（比如groupA下有V1，V2，V3，groupB下有W1，W2，W3，如果是加载groupA，那么V1，V2，V3都会激活，但是会根据一些规则判断，返回其中的某个或者某些，比如只返回V1，或者返回V1,V2）</p>
]]></content>
      <categories>
        <category>doubbo</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spi</tag>
      </tags>
  </entry>
  <entry>
    <title>shardingsphere初识</title>
    <url>/2025/09/02/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/shardingsphere/</url>
    <content><![CDATA[<h1 id="shardingsphere"><a href="#shardingsphere" class="headerlink" title="shardingsphere"></a>shardingsphere</h1><p>[TOC]</p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><blockquote>
<p>Springboot 3.2.5+ mybatis-flex 1.9.4 + jdk21+ shardingsphere-jdbc-core-spring-boot-starter(5.2.1)</p>
</blockquote>
<h2 id="2-引入maven依赖"><a href="#2-引入maven依赖" class="headerlink" title="2. 引入maven依赖"></a>2. 引入maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-设置分片配置"><a href="#3-设置分片配置" class="headerlink" title="3. 设置分片配置"></a>3. 设置分片配置</h2><ul>
<li><p>application-dev.yml：引入application-sharding.yml配置文件，并屏蔽mybatis-flex的数据源设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span> <span class="string">classpath:application-sharding.yml</span>  <span class="comment"># 引入ShardingSphere分片配置</span></span><br></pre></td></tr></table></figure></li>
<li><p>application-sharding.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds1</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://192.168.8.1:10086/ruoyi-flex?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8&amp;autoReconnect=true&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">          <span class="attr">minimum-idle:</span> <span class="string">$&#123;spring.datasource.hikari.minimum-idle&#125;</span></span><br><span class="line">          <span class="attr">maximum-pool-size:</span> <span class="string">$&#123;spring.datasource.hikari.maximum-pool-size&#125;</span></span><br><span class="line">          <span class="attr">connection-timeout:</span> <span class="string">$&#123;spring.datasource.hikari.connectionTimeout&#125;</span></span><br><span class="line">          <span class="attr">idle-timeout:</span> <span class="string">$&#123;spring.datasource.hikari.idleTimeout&#125;</span></span><br><span class="line">          <span class="attr">max-lifetime:</span> <span class="string">$&#123;spring.datasource.hikari.maxLifetime&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分片规则配置</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">sharding:</span></span><br><span class="line">        <span class="comment"># 分片表配置</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">version_code_change_record:</span></span><br><span class="line">            <span class="comment"># 实际数据节点 - 3张分片表：00、01、02</span></span><br><span class="line">            <span class="attr">actual-data-nodes:</span> <span class="string">ds1.version_code_change_record0$-&gt;&#123;0..2&#125;</span></span><br><span class="line">            <span class="comment"># 分表策略</span></span><br><span class="line">            <span class="attr">table-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">version_id</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">version-id-mod-algorithm</span></span><br><span class="line">            <span class="comment"># 主键生成策略</span></span><br><span class="line">            <span class="attr">key-generate-strategy:</span></span><br><span class="line">              <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">              <span class="attr">key-generator-name:</span> <span class="string">snowflake</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分片算法配置</span></span><br><span class="line">        <span class="attr">sharding-algorithms:</span></span><br><span class="line">          <span class="attr">version-id-mod-algorithm:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">MOD</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">sharding-count:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主键生成算法配置</span></span><br><span class="line">        <span class="attr">key-generators:</span></span><br><span class="line">          <span class="attr">snowflake:</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="attr">worker-id:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 属性配置</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="comment"># 是否开启SQL显示，建议开发环境开启，生产环境关闭</span></span><br><span class="line">      <span class="attr">sql-show:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">sql-simple:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 是否检查表元数据，生产环境建议关闭以提升启动性能</span></span><br><span class="line">      <span class="attr">check-table-metadata-enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 是否检查重复表，开发阶段开启</span></span><br><span class="line">      <span class="attr">check-duplicate-table-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-自定义分片算法"><a href="#4-自定义分片算法" class="headerlink" title="4.自定义分片算法"></a>4.自定义分片算法</h2><p>一般采用基因法对分片键进行一定的”潜规则“设置，使得某一类型的数据能到达统一固定分片上，比如如果用订单表的用户id做分片键，对用户id做基因法操作，使得这个用户的所有订单都到达同一个分片。</p>
<p>再通过分片查询逻辑实现<code>ComplexKeysShardingAlgorithm</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenComplexTableAlgorithm</span> <span class="keyword">implements</span> <span class="title">ComplexKeysShardingAlgorithm</span>&lt;<span class="title">Comparable</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String VERSION_ID = <span class="string">&quot;version_id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String VERSION_FLOW_NUM = <span class="string">&quot;version_flow_num&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> shardingCount = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ComplexKeysShardingValue&lt;Comparable&lt;?&gt;&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Collection&lt;Comparable&lt;?&gt;&gt;&gt; columnNameAndShardingValuesMap = shardingValue.getColumnNameAndShardingValuesMap();</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(availableTargetNames.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(MapUtils.isNotEmpty(columnNameAndShardingValuesMap))&#123;</span><br><span class="line">            <span class="comment">// 获取用户ID</span></span><br><span class="line">            Collection&lt;Comparable&lt;?&gt;&gt; versionIdCollection = columnNameAndShardingValuesMap.get(VERSION_ID);</span><br><span class="line">            <span class="comment">//用户分片</span></span><br><span class="line">            <span class="keyword">if</span>(CollectionUtils.isNotEmpty(versionIdCollection))&#123;</span><br><span class="line">                versionIdCollection.stream().findFirst().ifPresent(comparable -&gt; &#123;</span><br><span class="line">                    <span class="keyword">long</span> tableNameSuffix = (Long) comparable % shardingCount;</span><br><span class="line">                    result.add(shardingValue.getLogicTableName() + <span class="string">&quot;_&quot;</span> + tableNameSuffix);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Collection&lt;Comparable&lt;?&gt;&gt; orderSnCollection = columnNameAndShardingValuesMap.get(VERSION_FLOW_NUM);</span><br><span class="line">                orderSnCollection.stream().findFirst().ifPresent(comparable -&gt; &#123;</span><br><span class="line">                    String orderSn = String.valueOf(comparable);</span><br><span class="line">                    <span class="comment">//获取用户基因</span></span><br><span class="line">                    String substring = orderSn.substring(Math.max(<span class="number">0</span>, orderSn.length() - <span class="number">6</span>));</span><br><span class="line">                    <span class="keyword">long</span> tableNameSuffix = Long.parseLong(substring) % shardingCount;</span><br><span class="line">                    result.add(shardingValue.getLogicTableName() + <span class="string">&quot;_&quot;</span> + tableNameSuffix);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.props = props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><ul>
<li><p>所有 ShardingSphere 配置都嵌套在该节点下，包含三大核心模块：datasources（数据源）、rules（功能规则）、props（全局属性）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">  	<span class="attr">datasource:</span></span><br><span class="line">  	<span class="attr">rules:</span></span><br><span class="line">		<span class="attr">props:</span></span><br></pre></td></tr></table></figure></li>
<li><p>rules：功能规则</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">  	<span class="attr">rules:</span> <span class="comment"># 功能规则</span></span><br><span class="line">			<span class="attr">sharding:</span></span><br><span class="line">        <span class="comment"># 分片表配置</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">        	<span class="attr">version_code_change_record:</span> <span class="comment"># 要分片的表名</span></span><br><span class="line">        		<span class="attr">actual-data-node:</span> <span class="string">ds1.version_code_change_record0$-&gt;&#123;0..2&#125;</span> <span class="comment"># 实际的数据节点</span></span><br><span class="line">        		<span class="attr">database-strategy:</span> <span class="comment"># 分库策略</span></span><br><span class="line">        		</span><br><span class="line">        		<span class="attr">table-strategy:</span> <span class="comment"># 分表策略</span></span><br><span class="line">        			</span><br></pre></td></tr></table></figure>

<ul>
<li><p>标准策略：<code>standard</code>：基于单一字段（分片键）进行分片，是最常用的策略。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tables:</span></span><br><span class="line">  <span class="attr">t_order:</span></span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">ds0.t_order_$&#123;0..1&#125;,</span> <span class="string">ds1.t_order_$&#123;0..1&#125;</span>  <span class="comment"># 物理表分布</span></span><br><span class="line">    <span class="attr">table-strategy:</span></span><br><span class="line">      <span class="attr">standard:</span>  <span class="comment"># 标准策略</span></span><br><span class="line">        <span class="attr">sharding-column:</span> <span class="string">order_id</span>  <span class="comment"># 分片键：订单ID</span></span><br><span class="line">        <span class="attr">sharding-algorithm-name:</span> <span class="string">order_table_inline</span>  <span class="comment"># 关联算法</span></span><br><span class="line"><span class="attr">sharding-algorithms:</span></span><br><span class="line">  <span class="attr">order_table_inline:</span>  <span class="comment"># 算法定义</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">INLINE</span>  <span class="comment"># 内联表达式算法</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">algorithm-expression:</span> <span class="string">t_order_$&#123;order_id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span>  <span class="comment"># 计算逻辑：order_id取模2</span></span><br></pre></td></tr></table></figure></li>
<li><p>复合策略：<code>complex</code>：基于<strong>多个字段联合分片</strong>（如同时按 <code>user_id</code> 和 <code>order_id</code> 分片），适合复杂业务场景。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tables:</span></span><br><span class="line">  <span class="attr">t_order:</span></span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">ds0.t_order_$&#123;0..3&#125;,</span> <span class="string">ds1.t_order_$&#123;0..3&#125;</span>  <span class="comment"># 4个物理表</span></span><br><span class="line">    <span class="attr">table-strategy:</span></span><br><span class="line">      <span class="attr">complex:</span>  <span class="comment"># 复合策略</span></span><br><span class="line">        <span class="attr">sharding-columns:</span> <span class="string">user_id,order_id</span>  <span class="comment"># 多个分片键</span></span><br><span class="line">        <span class="attr">sharding-algorithm-name:</span> <span class="string">order_table_complex</span>  <span class="comment"># 关联复合算法</span></span><br><span class="line"><span class="attr">sharding-algorithms:</span></span><br><span class="line">  <span class="attr">order_table_complex:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">CLASS_BASED</span>  <span class="comment"># 基于自定义类的算法</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">strategy:</span> <span class="string">STANDARD</span></span><br><span class="line">      <span class="attr">algorithm-class-name:</span> <span class="string">com.example.sharding.OrderTableComplexAlgorithm</span>  <span class="comment"># 自定义算法类</span></span><br></pre></td></tr></table></figure></li>
<li><p>hint策略：<code>hint</code>：不依赖 SQL 中的字段，而是通过<strong>代码手动指定分片值</strong>（如强制路由到某个物理表）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tables:</span></span><br><span class="line">  <span class="attr">t_order:</span></span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">ds0.t_order_$&#123;0..1&#125;</span></span><br><span class="line">    <span class="attr">table-strategy:</span></span><br><span class="line">      <span class="attr">hint:</span>  <span class="comment"># Hint策略</span></span><br><span class="line">        <span class="attr">sharding-algorithm-name:</span> <span class="string">order_table_hint</span>  <span class="comment"># 关联Hint算法</span></span><br><span class="line"><span class="attr">sharding-algorithms:</span></span><br><span class="line">  <span class="attr">order_table_hint:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">HINT_INLINE</span>  <span class="comment"># Hint内联算法</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">algorithm-expression:</span> <span class="string">t_order_$&#123;value&#125;</span>  <span class="comment"># value由代码传入</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动指定分片值为0，路由到t_order_0</span></span><br><span class="line">HintManager hintManager = HintManager.getInstance();</span><br><span class="line">hintManager.addTableShardingValue(<span class="string">&quot;t_order&quot;</span>, <span class="number">0</span>);  <span class="comment">// 指定逻辑表和分片值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行SQL时，ShardingSphere会根据Hint值路由</span></span><br><span class="line">Order order = orderMapper.selectById(<span class="number">1001L</span>);</span><br><span class="line">hintManager.close();  <span class="comment">// 用完关闭</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>内联策略：<code>inline</code></p>
</li>
<li><p>不分片策略：<code>none</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="5-遇到的问题"><a href="#5-遇到的问题" class="headerlink" title="5. 遇到的问题"></a>5. 遇到的问题</h2><ol>
<li><p>如果工程中没有使用<code>@MapperScan</code>，若使用<code>@MapperScan</code>需制定到具体的<code>mapper</code>实现(<code>com.ruoyi.**.mapper</code>)，否则会出现某个类被多次扫描，多次生成bean实例。</p>
</li>
<li><p><code>snakeyaml</code>版本不兼容问题</p>
</li>
</ol>
<p><code>shardingsphere-jdbc-core-spring-boot-starter 5.2.1</code>版本与<code>snakeyaml 3.2</code>不兼容，需要使用<code>snakeyaml 1.33</code>，但<code>snakeyaml 1.33</code>与<code>springboot 3.2.5</code>不兼容。</p>
<p>所以，强行使用<code>snakeyaml 1.33</code>，并覆盖<code>TagInspector</code>、<code>UnTrustedTagInspector</code>、<code>LoaderOptions</code>三个类。</p>
]]></content>
      <categories>
        <category>shardingsphere</category>
      </categories>
      <tags>
        <tag>shardingsphere</tag>
        <tag>分表</tag>
      </tags>
  </entry>
</search>
